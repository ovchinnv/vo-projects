      module parser
!
      use cmd
      use prm
      __CHARMM_ONLY __DEP_KINDS
!
      __IMPNONE
      private
!     read, parse & store input file; 
!
      int, parameter, public :: contextnamelen=200
!
!     the current implementation (11/2012) does not allow for nested contexting
!
      type contexts ! for storing multiple parameter sets ('contexts') per single execution
       character(len=contextnamelen), pointer :: context_name(:)
       type (params), pointer :: context_params(:)
       type (commands), pointer :: context_commands(:)
       int :: length=0
       int :: last=0
       int :: current=0
      end type contexts
!
      character(len=26), parameter  :: lower='abcdefghijklmnopqrstuvwxyz'
      character(len=26), parameter  :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
      character(len=10), parameter  :: digits='0123456789'
      int :: i
      character, parameter :: lower2(26)=(/ (lower(i:i),i=1,26)/)
      character, parameter :: upper2(26)=(/ (upper(i:i),i=1,26)/)
      character, parameter, public :: letters(52)=(/ (lower2(i), i=1,26), (upper2(i), i=1,26) /)
      character, parameter, public :: digits2(10)=(/ (digits(i:i),i=1,10)/)
      character, parameter :: tilde='~'
      character, parameter :: decimal='.'
      character, parameter :: underscore='_'
      character, parameter, public :: hyphen='-'
      character, parameter :: slash='/'
      character, parameter :: colon=':'
      character, parameter, public :: tab=char(9)
      character, parameter, public :: space(4) = (/' ', tab, ',',';'/)
      character, parameter :: comment(4) = (/'*','!','#','%'/)
      character, parameter :: nextline(1)=(/hyphen/)
      character, parameter :: equals(1) = (/'='/)
      character, parameter :: vector_open(2)=(/'(','['/)
      character, parameter :: vector_close(2)=(/')',']'/)
      character, parameter :: context_open(1)=(/'{'/)
      character, parameter :: context_close(1)=(/'}'/)
      character, parameter :: string_open(1)=(/'"'/)
      character, parameter :: string_close(1)=(/'"'/) ! do not have to be the same -- see code below
      character(len=200), parameter :: allowed=upper//lower//digits//decimal//underscore//hyphen//slash//tilde//colon
#ifdef __STRING_SERIAL
      character(len=2), parameter :: exec_start=':'
#else
      character(len=5), parameter :: exec_start='exec:'
#endif
      character(len=18), parameter :: exec_msg='Execution stack +='
      character(len=4), parameter, public :: maincontext_name='MAIN'
      __STRING_PARAM(bigline,======================>)
      int, parameter :: maincontext_namelen=4
!
      int, parameter, private :: context_incr=1  ! expand increment for contexts
!
      bool, save :: parser_initialized=.false. ! set to true after parse_file is called successfully; private
!
      type (contexts), save :: context              ! contexts
      type (params), save, pointer :: parameters    ! pointer to a single parameter set (e.g. main parameter set)
      type (commands), save, pointer :: executables ! pointer to a single command set   (e.g. main command set)
!
      public bigline
!
      public atoi     	! convert string to int 
      public atof	! convert string to double
      public atol	! convert string to bool
      public atoiv     	! convert string to a vector of ints 
      public atofv	! convert string to a vector of double
!      public atolv	! convert string to a vector of bool (not yet)
      private params_getval
      private params_getval_nocase
      public getval	        ! return tag value
      public getval_nocase	! return tag value (case insensitive version)
      public getval_nocase_upper! return tag value in uppercase (case insensitive version)
      public existtag	! return tag value
      public existtag_nocase	! return tag value (case insensitive version)
      public get_next_command	! return command
      public noexec             ! returns true if context specified in the atgument has no executable statements or is not present
      public parse_file ! read input file and store all parameters
      public parser_done
      public list_params ! list parameters
      public list_commands ! list commands
      public adjustleft
      public adjustleft_1, adjustleft_2
      public numword
      public parser_clear_context
! CHARMM-compatibility routines
      public pop_string
      public find_tag
      public remove_tag
      public get_remove_parameter
      public toupper
      public ftoupper
      public tolower
      public itoa
      public ftoa
      public ltoa
!
      interface adjustleft
       module procedure adjustleft_1, adjustleft_2, adjustleft_3
      end interface adjustleft
!
      interface pop_string
       module procedure pop_string_default
       module procedure pop_string_custom
       module procedure pop_string_custom2
      end interface pop_string
!
      interface itoa
       module procedure itoa4, itoa8
      end interface itoa
!
      interface atoi
       module procedure atoi4, atoi8, atoi_
      end interface atoi
!
      interface atofv
       module procedure atofv4, atofv8
      end interface atofv
!
      contains
!********************************************************************************************
       subroutine parser_init()
!    initialize contexts
       call parser_done()
!
       allocate(context%context_params(context_incr))
       allocate(context%context_commands(context_incr))
       allocate(context%context_name(context_incr))
       context%length=context_incr
       context%last=1
       context%current=1
       context%context_name(1)=maincontext_name
!    initialize main context
       parameters=>context%context_params(1)
       executables=>context%context_commands(1)
       call params_init(parameters)
       call commands_init(executables)
!
       parser_initialized=.true.
       end subroutine parser_init
!********************************************************************************************
       subroutine parser_done()
       int :: i
!
       if (parser_initialized) then
!    destroy contexts
       if (context%last.gt.0) then
        if (associated(context%context_params)) then
         do i=1,context%last ; call params_done(context%context_params(i)) ; enddo
         deallocate(context%context_params)
        endif
!
        if (associated(context%context_commands)) then
         do i=1,context%last ; call commands_done(context%context_commands(i)) ; enddo
         deallocate(context%context_commands)
        endif
!
        if (associated(context%context_name)) then
         deallocate(context%context_name)
        endif
       endif
!
       context%last=0 ; context%length=0
!
       nullify(parameters)
       nullify(executables)
       parser_initialized=.false.
!
       endif ! initialized
!
       end subroutine parser_done
!********************************************************************************************
       subroutine parser_context_expand()
!    increase the size of contexts array
       int :: newlength
       type (params), pointer :: newparams(:)
       type (commands), pointer :: newcommands(:)
       character(len=contextnamelen), pointer :: newnames(:)
!
       if ( .not. parser_initialized ) call parser_init()
       newlength=context%length+context_incr
       allocate(newparams(newlength), newcommands(newlength), newnames(newlength))
       newparams(1:context%length)=context%context_params ! copy members of context_params (incl. pointers)
       newcommands(1:context%length)=context%context_commands
       newnames(1:context%length)=context%context_name
       deallocate(context%context_params, context%context_commands, context%context_name)
       context%context_params=>newparams ; context%context_commands=>newcommands ; context%context_name=>newnames ! point to new arrays
       context%length=newlength
       nullify(newparams, newcommands, newnames)
!
       end subroutine parser_context_expand
!********************************************************************************************
       subroutine parser_clear_context(cname)
!    erase all statements and parameters from context (but keep the context defined)
!    note that this is a cheating "quick" clear, which simply sets the length to zero
       character(len=*), intent(in) :: cname
       int :: ictx
       ictx=parser_find_context(cname)
       if (ictx.gt.0) then
        context%context_params(ictx)%last=0
        context%context_commands(ictx)%last=0
       endif
       end subroutine parser_clear_context
!********************************************************************************************
       function parser_find_context(cname)
!    find the array index of a context specified by cname
       character(len=*), intent(in) :: cname
       character(len=len(cname)) :: copyname
       int :: parser_find_context, j
!
       parser_find_context=-1
       copyname=cname; call toupper(copyname)
       call adjustleft(copyname)
       if (.not.parser_initialized) call parser_init() 
!    check current context for a match
       if (context%context_name(context%current).eq.copyname) then
        parser_find_context=context%current
       else
        do j=1,context%last
         if (context%context_name(j).eq.copyname) then
!    found element
          parser_find_context=j
         endif
        enddo
       endif
!
       end function parser_find_context
!********************************************************************************************
       function parser_context(cname)
!    find the array index of a context specified by cname; if the context does exist, create it
       character(len=*), intent(in) :: cname
       character(len=len(cname)) :: copyname
       int :: parser_context, j
!
       parser_context=parser_find_context(cname)
       if (parser_context.le.0) then
        copyname=cname; call toupper(copyname)
        if (context%last.eq.context%length) call parser_context_expand()
        j=context%last+1
        context%context_name(j)=copyname
        context%last=j
        parser_context=j
       endif
!
       context%current=parser_context
!
       end function parser_context
!********************************************************************************************
       function params_getval( v,atag )
       type (params) :: v
       character(len=vartaglen) :: params_getval
       character(len=*) :: atag
       int :: j
!
       if (.not.parser_initialized) call parser_init()
       params_getval=''
       if (.not.v%initialized) then 
!
       else
        do j=1,v%last
         if (v%tag(j).eq.atag) then
!       found element
          params_getval=v%val(j)(1:v%vlen(j))
          return
         endif
        enddo
       endif
!
       end function params_getval
!********************************************************************************************
       function params_getval_nocase( v,atag )
       type (params) :: v
       character(len=vartaglen) :: params_getval_nocase, tag1, tag2
       character(len=*) :: atag
       int :: j
!
       if (.not.parser_initialized) call parser_init()
       params_getval_nocase=''
       if (.not.v%initialized) then 
! nothing
       else
        tag2=atag; call toupper(tag2)
        do j=1,v%last
         tag1=v%tag(j);
         call toupper(tag1)
         if (tag1.eq.tag2) then
!       found element
          params_getval_nocase=v%val(j)(1:v%vlen(j))
          return
         endif
        enddo
       endif
!
       end function params_getval_nocase
!********************************************************************************************
       character(len=vartaglen) function getval(atag,ctx)
       __DEP_OUTPUT
       character(len=vartaglen) :: value
       character(len=*), intent(in) :: atag
       character(len=*), intent(in), optional :: ctx
       int :: ictx
       __IAM(GETVAL)
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx))
       value=params_getval(context%context_params(ictx),atag)
       if (len_trim(value).eq.0) __WRN3(whoami,'Parameter "'//trim(atag)//'" not found in context "'//trim(context%context_name(ictx))//'"',-1)
       getval=value
!
       end function getval
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       character(len=vartaglen) function getval_nocase(atag,ctx)
       __DEP_OUTPUT
       character(len=vartaglen) :: value
       character(len=*), intent(in) :: atag
       character(len=*), intent(in), optional :: ctx ; int :: ictx
       __IAM(GETVAL_NOCASE)
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx))
       value=params_getval_nocase(context%context_params(ictx),atag)
       if (len_trim(value).eq.0) __WRN3(whoami,'Parameter "'//trim(atag)//'" not found in context "'//trim(context%context_name(ictx))//'"',-1)
       getval_nocase=value
!
       end function getval_nocase
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       character(len=vartaglen) function getval_nocasev(atag,ctx)
       __DEP_OUTPUT
       character(len=vartaglen) :: value
       character(len=*), intent(in) :: atag
       character(len=*), intent(in), optional :: ctx(:) 
       int :: ictx, i, j
       bool :: found
       __IAM(GETVAL_NOCASEV)
       found=.false.
       ictx=1 ;
       if (present(ctx)) then
        j=size(ctx);
        do i=1, j
         ictx=parser_find_context(ctx(i))
         if (ictx.gt.0) then
          if (i.gt.1) __MESSAGE3(whoami, 'Checking for parameter "'//trim(atag)//'" in context "'//trim(context%context_name(ictx))//'"',0)
          value=params_getval_nocase(context%context_params(ictx),atag)
          if (len_trim(value).eq.0) then ! issue a warning; if i=j, wrnlev=-1 (should be fatal)
           __WRN3(whoami,'Parameter "'//trim(atag)//'" not found in context "'//trim(context%context_name(ictx))//'"', min(1,j-i)-1)
          else  ! value
           exit
          endif ! value
         else ! (ictx==0)
          __WRN3(whoami,'Skipping nonexistent context "'//trim(ctx(i))//'"',min(1,j-i)-1)
         endif ! ictx
        enddo ! loop over contexts
       else ! present(ctx) : default to main context
        value=params_getval_nocase(context%context_params(ictx),atag)
        if (len_trim(value).eq.0) __WRN3(whoami,'Parameter "'//trim(atag)//'" not found in context "'//trim(context%context_name(ictx))//'"',-1)
       endif ! present(ctx)
!
       getval_nocasev=value
       end function getval_nocasev
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       character(len=vartaglen) function getval_nocase_upper(atag,ctx)
       __DEP_OUTPUT
       character(len=vartaglen) :: value
       character(len=*), intent(in) :: atag
       character(len=*), intent(in), optional :: ctx ; int :: ictx
       __IAM(GETVAL_NOCASE_UPPER)
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx))
       value=params_getval_nocase(context%context_params(ictx),atag)
       if (len_trim(value).eq.0) __WRN3(whoami,'Parameter "'//trim(atag)//'" not found in context "'//trim(context%context_name(ictx))//'"',-1)
       call toupper(value)
       getval_nocase_upper=value
!
       end function getval_nocase_upper
!********************************************************************************************
       function get_next_command(ctx) ! returning command as an array of characters
       __DEP_OUTPUT
       character(len=maxlinelen), pointer :: get_next_command
! some advanced Fortran 2003 commented out
!       character(len=:), pointer :: get_next_command
       character(len=*), intent(in), optional :: ctx
       type (commands), pointer :: c
       int :: ictx, i
       __IAM(GET_NEXT_COMMAND)
!
       nullify(get_next_command)
!
       if (.not.parser_initialized) call parser_init()
       ictx=1 ; if (present(ctx)) ictx=parser_find_context(ctx)
!
       if (ictx.gt.0) then
!
        c=>context%context_commands(ictx)
        if (.not.c%initialized) then 
!
        elseif (c%current.le.c%last) then
         i=c%clen(c%current)
!         allocate(character(i) :: get_next_command)
         allocate(get_next_command)
         get_next_command=c%command(c%current)(1:i)
#ifdef __DEBUG
        __MESSAGE3(whoami,' CURRENT COMMAND IS: "'//trim(get_next_command)//'".',__DBGLEV)
#endif
         c%current=c%current+1
        endif ! c%initialized
       else
        __WRN3(whoami,'Context "'//trim(ctx)//'" not found.',-1)
       endif ! ictx > 0
!
       end function get_next_command
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       bool function noexec(ctx)
       character(len=*), intent(in), optional :: ctx
       type (commands), pointer :: c
       int :: ictx
       __IAM(NOEXEC)
       noexec=.true.
       if (.not.parser_initialized) call parser_init()
       ictx=1 ; if (present(ctx)) ictx=parser_find_context(ctx)
       if (ictx.gt.0) then
        c=>context%context_commands(ictx)
        if (c%initialized) then
         if (c%current.le.c%last) noexec=.false.
        endif !c%initialized
       endif ! ictx
!
#ifdef __DEBUG
       if (noexec) then
         __MESSAGE3(whoami,'CONTEXT IS EMPTY',__DBGLEV);
       else
         __MESSAGE3(whoami,'CONTEXT INDEX :'//itoa(ictx), __DBGLEV );
         __MESSAGE3(whoami,'CONTEXT IS NOT EMPTY',__DBGLEV);
       endif
#endif
       end function noexec
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function existtag(atag,ctx)
       __DEP_OUTPUT
       bool :: existtag
       character(len=vartaglen) :: value
       character(len=*), intent(in) :: atag
       character(len=*), intent(in), optional :: ctx ; int :: ictx
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx))
!
       existtag=.false.
       if (.not.parser_initialized) call parser_init()
       value=params_getval(context%context_params(ictx),atag)
       if (len_trim(value).gt.0) existtag=.true.
!
       end function existtag
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function existtag_nocase(atag,ctx)
       bool :: existtag_nocase
       character(len=vartaglen) :: value
       character(len=*), intent(in) :: atag
       character(len=*), intent(in), optional :: ctx ; int :: ictx
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx))
!
       existtag_nocase=.false.
       if (.not.parser_initialized) call parser_init()
       value=params_getval_nocase(context%context_params(ictx),atag)
       if (len_trim(value).gt.0) existtag_nocase=.true.
!
       end function existtag_nocase
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
       subroutine parse_file(fid &
#ifdef __PARALLEL
     &  ,communicator,me__       &
#endif
     & ,quiet_                    )
       __DEP_OUTPUT
!
#ifdef __PARALLEL
       __DEP_MPI
#endif
       __IMPNONE
!
#ifdef __PARALLEL
       int4mpi :: communicator, me
       int4mpi, optional :: me__
       int :: msglev
       int4mpi :: ierr
#endif
!
#ifdef __CHARMM
#include "mpitype.def"
#endif
!
       int, intent(in) :: fid ! input file handle
       bool, optional, intent(in) :: quiet_ ! last resort for shutting up messages
       int :: i, j
       bool :: qloud
       __IAM(PARSE_FILE)
!
       int :: allowed_len
       character :: allowed2(200),c,cc
       bool :: qtag, qeq, qval, qexec, qerror ! active : tag, equals, value, executable line, error flag
       bool :: qvector ! flag that is active when we are reading a vector (certain default behavior is overridden)
       bool :: qstring ! flag that is active when we are reading a character string (anything is allowed inside)
       bool :: qcontext ! flag that is active when any context other than the main context is active
       bool :: qcontinue ! flag that is set when a line continuation symbol is found, which forces read of a new line w/o change of state
!
       integer :: ioerr
       int :: l=0, ltag=0, lval=0, lexec=0
       character(len=2*maxlinelen) :: cmdline
       character(len=vartaglen) :: tag, val, exec
       character(len=contextnamelen), pointer :: contextname
!
       allowed_len=len_trim(allowed)
       do i=1,allowed_len
        allowed2(i)=allowed(i:i)
       enddo 
!
#ifdef __PARALLEL
       if (present(me__)) then ; me=me__ 
       elseif (communicator.ne.MPI_COMM_NULL) then
        call mpi_comm_rank(communicator,me,ierr) 
       else
        me=0
       endif
#ifndef __CHARMM
       msglev=get_minmessagelev() ; qprint=(me.eq.0)
#endif
#endif
!     do work
       if (present(quiet_)) then;qloud=.not.quiet_;else;qloud=.true.;endif
!
       qcontext=.false.
       qvector=.false.
       qerror=.false.
       qexec=.false.
       qstring=.false.
       qcontinue=.false.
       if (.not. parser_initialized) call parser_init()
       if(qloud) __MESSAGE(whoami, 'Reading input file.')
 lines:do while (.true.)
#ifdef __PARALLEL
        if (me.le.0) read(fid,'(A)',IOSTAT=ioerr) cmdline ! if running in parallel, then only the root node is passed a valid handle
        if (communicator.ne.MPI_COMM_NULL) call MPI_BCAST(ioerr,1,mpiint,0,communicator,ierr)
#else
        read(fid,'(A)',IOSTAT=ioerr) cmdline ! if running in parallel, then only the root node is passed a valid handle
#endif
!
        if (ioerr.eq.0) then
#ifdef __PARALLEL
         if (communicator.ne.MPI_COMM_NULL) call MPI_BCAST(cmdline,len(cmdline),MPI_BYTE,0,communicator,ierr) ! broadcast to all CPUs
#endif
!   write(0,*) cmdline
! read from the line
         call adjustleft(cmdline)
         l=len_trim(cmdline)
!   write(0,*) cmdline(1:l)
! add comment character to know when to stop below
         if (l.lt.2*maxlinelen) l=l+1
         cmdline(l:l)='*'   ! note the difference between lowercase "L" (here) and "one" (below)
         if (any(comment.eq.cmdline(1:1))) l=1 ! skip lines that are comments
!
         i=0
         if (qcontinue) then ! continued line
          qcontinue=.false.
         else ! normal line
          qtag=.true. ; ltag=0 ! each line is required to begin with a tag
          qval=.false.; lval=0
          qeq=.false.
          qvector=.false.      ! this implies that a vector entry currently cannot span multiple lines
          qexec=.false.        ! this implies that an executable command currently cannot span multiple lines
          qstring=.false.      ! string cannot span multiple lines
         endif
!
 chars:  do while (l.ge.1)
           i=i+1
           c=cmdline(i:i)
!          continuation :
           if (any(nextline.eq.c) .and. .not. qstring) then ! continuation found
!           quickly scan remainder of line to make sure nothing but comments remain
            do j=i+1, l
             cc=cmdline(j:j)
             if (any(space.eq.cc)) cycle
             if (any(comment.eq.cc)) then
              qcontinue=.true.
              cycle lines
             endif
             exit ! if we are here then a command character was encountered, in which case continuation is disallowed
            enddo
           endif
!          EOL : 
           if ( (any(comment.eq.c).and..not.qstring).or.(i.eq.l)) then ! end of command line
            if ((qtag.and.i.gt.1).or.qeq) then
             __WRN3(whoami,'Unexpected end of line',0)
             qerror=.true.; exit 
            elseif (qval) then
             if (lval.eq.0) then
              __WRN3(whoami, 'Missing value for parameter "'//tag(1:ltag)//'". Skipping line',0)
              qerror=.true.; exit 
             elseif (qvector) then
              __WRN3(whoami, 'Missing closing bracket for vector parameter "'//tag(1:ltag)//'". Skipping line',0)
              qerror=.true.; exit 
             elseif (qstring) then
              __WRN3(whoami, 'Missing termination character for string parameter "'//tag(1:ltag)//'". Skipping line',0)
              qerror=.true.; exit 
             else ! store tag and val
              if(qloud) __MESSAGE(whoami, tag(1:ltag)//' <= '//val(1:lval))
              j=params_uadd(parameters,tag,val,ltag,lval)
              ltag=0; lval=0
              qtag=.true. ! no need because we are at the eol, but included here for clarity
              exit
             endif
            elseif (qexec) then
             if (lexec.eq.0) then
              contextname=>context%context_name(context%current)
              __WRN3(whoami, 'Empty command line in context "'//contextname(1:len_trim(contextname))//'". Skipping line',0)
              qerror=.true.; exit 
             else ! store command
! remove trailing space
              lexec=len_trim(exec(1:lexec))
              if(qloud) __MESSAGE(whoami, exec_msg//' "'//exec(1:lexec)//'"')
              j=commands_add(executables, exec, lexec)
              qexec=.false.; qtag=.true.
              lexec=0
              exit
             endif
!
            else ! qtag
             exit
            endif ! qtag
!
           elseif ( any(comment.eq.c).and.qstring ) then ! comments are ok as long as they are part of a string
            __INC(lval) ; val(lval:lval)=c;
!=============================================================================================================
           elseif (any(string_open.eq.c).or.any(string_close.eq.c)) then ! beginning/finishing string parameter
!
!write(0,*) cmdline(i:l), qtag, qval, qstring ! aa
!
            if ((qtag.and.ltag.gt.0).or.qeq) then
             __WRN3(whoami, 'Unexpected string character while processing parameter "'//tag(1:ltag)//'".  Skipping line',0)
             qerror=.true. ; exit
!
            elseif (qtag.and.(ltag.eq.0)) then
             __WRN3(whoami, 'Missing parameter name. Skipping line',0)
             qerror=.true. ; exit
!
            elseif (qexec) then ! this is a valid command character
             lexec=lexec+1; exec(lexec:lexec)=c
!
            elseif (qvector) then
             __WRN3(whoami, 'Unexpected string character while processing vector parameter "'//tag(1:ltag)//'"  Skipping line',0)
             qerror=.true. ; exit
!
            elseif (qval) then ! the only acceptable occurrence
             if (qstring) then
              if (any(string_close.eq.c)) then !  already reading a string so terminate and attempt to store
               qstring=.false. ! the only legitimate occurrence
!     peek ahead to make sure we have a spacer, if not, issue a warning and skip line
!     (the convention is that a vector value must be separated from a subsequent tag)
               c=cmdline(i+1:i+1)
               if ( (i.lt.l) .and. (all(space.ne.c)) .and. (all(comment.ne.c))) then 
                __WRN3(whoami, 'Error reading string value for parameter "'//tag(1:ltag)//'". Skipping line.',0)
                qerror=.true.; exit 
!     otherwise, attempt to add tag/value pair
               else
!                if (lval.eq.0) then ! this is unnecessary in view of what is below
!                 __WRN3(whoami, 'Missing string value for parameter "'//tag(1:ltag)//'". Skipping line.',0)
!                 qerror=.true.; exit 
!                endif
                call adjustleft(val(1:lval)); lval=len_trim(val(1:lval));
                if (lval.eq.0) then
                 __WRN3(whoami, 'Missing string value for parameter "'//tag(1:ltag)//'". Skipping line.',0)
                 qerror=.true.; exit 
                else ! add pair
                 call adjustleft(val(1:lval)); lval=len_trim(val(1:lval));
                 if(qloud) __MESSAGE(whoami, tag(1:ltag)//'[STRING] <= "'//val(1:lval)//'"')
                 j=params_uadd(parameters,tag,val,ltag,lval)
                 ltag=0; lval=0
                 cmdline=cmdline(i+1:l) ! remove tag/val pair from string
                 call adjustleft(cmdline) ! remove tag/val pair from string
                 l=len_trim(cmdline)
                 i=0
                endif ! lval
                qtag=.true. ; ltag=0
                qval=.false.
               endif ! (i.lt.l)
              else ! c=string_open
               __WRN3(whoami, 'Unexpected string opening character while processing string parameter "'//tag(1:ltag)//'"  Skipping line',0)
              endif ! c=string_close
             else ! not qstring, so start reading a new string
              if (any(string_open.eq.c)) then
               qstring=.true. ! reading a string now
              else ! not qstring
               __WRN3(whoami, 'Unexpected string termination character while processing parameter "'//tag(1:ltag)//'"  Skipping line',0)
              endif
             endif ! qstring
            else ! should not be here !
             __WRN3(whoami, 'Unexpected character encountered (please report this internal error). Abort.',-1)
             qerror=.true. ; exit
            endif
!=================================================================================
           elseif (any(space.eq.c)) then ! completed a tag or value (since lines cannot begin with blanks -- see above)
!
            if (qtag) then
             qtag=.false.
             qeq=.true.
            elseif (qeq) then
!      nothing
            elseif (qval) then 
             if (qvector.or.qstring) then ! if we are in the process of reading a vector/string, then the separator (space) tags do not apply;
!                                      otherwise, a tag/value pair has been completed, so attempt to add pair and reinitialize for new tag
              __INC(lval); val(lval:lval)=' ' ! substitute a space for all separators
             else
!
              qval=.false.
              qtag=.true.
              if (lval.eq.0) then
               __WRN3(whoami, 'Missing value for parameter "'//tag(1:ltag)//'". Skipping line',0)
               qerror=.true.; exit 
              else ! store tag and val
               if(qloud) __MESSAGE(whoami, tag(1:ltag)//' <= '//val(1:lval))
               j=params_uadd(parameters,tag,val,ltag,lval)
               ltag=0; lval=0
               cmdline=cmdline(i:l) ! remove tag/val pair from string
               call adjustleft(cmdline)
               l=len_trim(cmdline)
               i=0
              endif ! lval
              ltag=0
             endif ! qvector
            elseif (qexec) then ! space is a valid exec character
             lexec=lexec+1; exec(lexec:lexec)=' '
            endif ! qtag
!==============================================================================================
           elseif (any(equals.eq.c)) then ! "=" encountered : assume we have completed a tag
! write(0,*) qtag, qeq, qval, "tag: ", tag(1:ltag)
! write(0,*) "CMD:", cmdline(i+1:l)
            if (qtag) then
             qtag=.false.
             if (ltag.eq.0) then
              __WRN3(whoami, 'Missing parameter name. Skipping line',0)
              qerror=.true.; exit 
             endif
!
             qval=.true. ; lval=0   ! expecting a value next
             cmdline=cmdline(i+1:l) ! remove 'tag=' and leading spaces pair from string
             call adjustleft(cmdline) 
             l=len_trim(cmdline)
             i=0
!
             qeq=.false.
            elseif (qeq) then ! in case tag was followed by space; expect a value next
             qeq=.false.
             qval=.true. ; lval=0
             cmdline=cmdline(i+1:l) ! remove 'tag=' and leading spaces pair from string
             call adjustleft(cmdline) 
             l=len_trim(cmdline)
             i=0
            elseif (qval) then ! found '=' while reading parameter value
             if (qstring) then ! '=' is legitimate inside strings
              __INC(lval); val(lval:lval)='='
!write(0,*) '= inside string ; tag= ',tag(1:ltag), '; val(so far)= ', val(1:lval)
             elseif (lval.eq.0) then
              __WRN3(whoami, 'Missing value for parameter "'//tag(1:ltag)//'". Skipping line',0)
              qerror=.true.; exit 
             elseif (qvector) then
              __WRN3(whoami, 'Missing closing bracket for vector parameter "'//tag(1:ltag)//'". Skipping line',0)
              qerror=.true.; exit 
             else ! store tag and val (despite the misplaced '=' sign ; leave that for next cycle)
              call adjustleft(val(1:lval)); lval=len_trim(val(1:lval));
              if(qloud) __MESSAGE(whoami, tag(1:ltag)//' <= '//val(1:lval))
              j=params_uadd(parameters,tag,val,ltag,lval)
              ltag=0; lval=0
              cmdline=cmdline(i:l) ! remove tag/val pair from string (looks like keeping '=' in cmdline) 
              call adjustleft(cmdline) ! remove tag/val pair from string
              l=len_trim(cmdline)
              i=0
              qtag=.true. ; ltag=0
              qval=.false.
             endif ! qstring
!
            elseif (qexec) then ! this is a valid command character
             lexec=lexec+1; exec(lexec:lexec)=c
            endif ! qtag
!
!************************************** CONTEXTS **************************************
           elseif (any(context_open.eq.c)) then ! encountered a context opening bracket
            if (qstring) then ! allowed
             __INC(lval) ; val(lval:lval)=c;
!    check if already inside a context (currently nesting is not supported)
            elseif (qcontext) then
             __WRN3(whoami, 'Unexpected open brace while processing parameter "'//tag(1:ltag)//'".',0)
             __WRN(whoami, 'Nested contexts are not allowed. Skipping line.')
             qerror=.true.; exit
!
            elseif (qtag.or.qeq) then
             if (ltag.gt.0) then
              call toupper(tag)
! check to make sure the new context name is not the default name
              if (tag(1:ltag).ne.maincontext_name(1:maincontext_namelen)) then
               if(qloud) __MESSAGE(whoami, bigline//' Switching to context "'//tag(1:ltag)//'".')
!     note : cannot simply do this:
!               parameters =>context%context_params  (parser_context(tag(1:ltag)))
!     because context_params might need to be reallocated _during the call_; in the meantime, parameters points to the wrong thing
               j=parser_context(tag(1:ltag))
               parameters=>context%context_params(j)
               executables=>context%context_commands(j)
!
               qcontext=.true.
               qtag=.true.
               qeq=.false.
               ltag=0
               cmdline=cmdline(i+1:l) ! remove open brace from string
               call adjustleft(cmdline)
               l=len_trim(cmdline)
               i=0
              else ! context name not allowed
               __WRN3(whoami, 'Context name "'//tag(1:ltag)//'" is not allowed. Skipping line.',0)
               qerror=.true.; exit 
              endif ! tag .ne. maincontext_name
             else
              __WRN3(whoami, 'Missing context name. Skipping line.',0)
              qerror=.true.; exit 
             endif ! ltag
!
            else
             __WRN3(whoami, 'Unexpected open brace while processing parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit
            endif ! qcontext
!===========================================================================================
           elseif (any(context_close.eq.c)) then ! encountered a context closing bracket
            if (qstring) then ! allowed
             __INC(lval) ; val(lval:lval)=c;
            elseif (.not. qcontext) then ! make sure that there was an open brace
             __WRN3(whoami, 'Encountered a close brace without a matching open brace. Skipping line.',0)
             qerror=.true.; exit
            elseif (qtag.and.ltag.eq.0) then   ! if expecting a new tag
             if(qloud) __MESSAGE(whoami, bigline//' Returning to main context.')
!
             j=parser_context(maincontext_name) ! default context
             parameters =>context%context_params(j)
             executables=>context%context_commands(j)
!
             qcontext=.false.
             cmdline=cmdline(i+1:l) ! remove close bracket
             call adjustleft(cmdline) 
             l=len_trim(cmdline)
             i=0
            elseif (qval.and..not.qvector.and.lval.gt.0) then ! finished reading a parameter value
!    first, store tag/value pair
             qval=.false.
             qtag=.true.
             if(qloud) __MESSAGE(whoami, tag(1:ltag)//' <= '//val(1:lval))
             j=params_uadd(parameters,tag,val,ltag,lval)
             ltag=0; lval=0
             cmdline=cmdline(i+1:l) ! remove tag/val pair from string and also the close bracket
             call adjustleft(cmdline)
             l=len_trim(cmdline)
             i=0
!    now return to then main context
             if(qloud) __MESSAGE(whoami, 'Returning to main context.')
!
             j=parser_context(maincontext_name) ! default context
             parameters =>context%context_params(j)
             executables=>context%context_commands(j)
!
             qcontext=.false.
            elseif (qexec) then
             if (lexec.le.0) then
              contextname=>context%context_name(context%current)
              __WRN3(whoami, 'Unexpected close brace while reading command in context "'//contextname(1:len_trim(contextname))//'". Skipping line',0)
              qerror=.true.; exit 
             else ! store command
! remove trailing space
              lexec=len_trim(exec(1:lexec))
              if(qloud) __MESSAGE(whoami, exec_msg//' "'//exec(1:lexec)//'"')
              j=commands_add(executables, exec, lexec)
              lexec=0
              qexec=.false.
              qtag=.true.
              cmdline=cmdline(i+1:l) ! remove command from string and also the close bracket
              call adjustleft(cmdline)
              l=len_trim(cmdline)
              i=0
              if(qloud) __MESSAGE(whoami, 'Returning to main context.')
              j=parser_context(maincontext_name) ! default context
              parameters =>context%context_params(j)
              executables=>context%context_commands(j)
              qcontext=.false.
             endif
!
            else
             __WRN3(whoami, 'Unexpected close brace while processing parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit
            endif ! qcontext
!************************************** VECTOR DATA *****************************************
           elseif (any(vector_open.eq.c)) then ! encountered an opening vector bracket
            if (qstring) then ! allowed
             __INC(lval) ; val(lval:lval)=c;
            elseif (qtag) then ! opening bracket not allowed
             __WRN3(whoami, 'Unexpected opening bracket when processing parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit
            elseif (qeq) then
             __WRN3(whoami, 'Unexpected opening bracket when processing parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit 
            elseif (qval) then
             if (qvector) then ! already read one bracket 
              __WRN3(whoami,'Unexpected opening bracket when processing vector parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit
             else
              qvector=.true. ! the only legitimate occurrence
             endif
!
            elseif (qexec) then ! this is a valid command character
             lexec=lexec+1; exec(lexec:lexec)=c
!
            endif
!========================================================================================
           elseif (any(vector_close.eq.c)) then ! encountered a closing vector bracket
            if (qstring) then ! allowed
             __INC(lval) ; val(lval:lval)=c;
!      write(0,*) '**', qtag, qeq, qval, qvector, tag, ltag, val, lval; !aa
            elseif (qtag) then ! closing bracket not allowed
             __WRN3(whoami, 'Unexpected closing bracket when processing parameter "'//tag(1:ltag)//'". Skipping line.',0)
!              write(0,*) cmdline(i:l) ! aa
             qerror=.true.; exit
            elseif (qeq) then
             __WRN3(whoami, 'Unexpected closing bracket when processing parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit 
            elseif (qval) then
             qvector=.false. ! the only legitimate occurrence
!     peek ahead to make sure we have a spacer, if not, issue a warning and skip line
!     (the convention is that a vector value must be separated from a subsequent tag)
             c=cmdline(i+1:i+1)
             if ( (i.lt.l) .and. (all(space.ne.c)) .and. (all(comment.ne.c))) then 
              __WRN3(whoami, 'Error reading vector value for parameter "'//tag(1:ltag)//'". Skipping line.',0)
              qerror=.true.; exit 
!     otherwise, attempt to add tag/value pair
             else
              if (lval.eq.0) then
               __WRN3(whoami, 'Missing vector value for parameter "'//tag(1:ltag)//'". Skipping line.',0)
               qerror=.true.; exit 
              endif
              call adjustleft(val(1:lval)); lval=len_trim(val(1:lval));
              if (lval.eq.0) then
               __WRN3(whoami, 'Missing vector value for parameter "'//tag(1:ltag)//'". Skipping line.',0)
               qerror=.true.; exit 
              else ! add pair
               call adjustleft(val(1:lval)); lval=len_trim(val(1:lval));
               if(qloud) __MESSAGE(whoami, tag(1:ltag)//'[VECTOR] <= ('//val(1:lval)//')')
               j=params_uadd(parameters,tag,val,ltag,lval)
               ltag=0; lval=0
               cmdline=cmdline(i+1:l) ! remove tag/val pair from string
               call adjustleft(cmdline) ! remove tag/val pair from string
               l=len_trim(cmdline)
               i=0
              endif ! lval
              qtag=.true. ; ltag=0
              qval=.false.
             endif ! (i.lt.l)
!
            elseif (qexec) then ! this is a valid command character
             lexec=lexec+1; exec(lexec:lexec)=c
!
            else ! no input mode (qtag/qeq/qval/qexec) : this should never happen
             __WRN3(whoami, 'Misplaced closing bracket in input. Skipping line.',0)
             qerror=.true.; exit
            endif 
!=============================================================================================
           elseif (any(allowed2(1:allowed_len).eq.c)) then ! check that the characters are allowed
!
            if (qtag) then ! reading a tag
             if (ltag.eq.0) then
! test for executable line; if executable tag found, switch off qtag, switch on qexec
              j=len_trim(exec_start)
!              write(0,*) cmdline(i:l)
              if ( i + j - 1 .lt. l) then ! recall that cmdline(l:l) is a comment
               qexec=cmdline(i : i + j - 1).eq.exec_start(1:j)
               if (qexec) then
                cmdline=cmdline(i+j:l)
                call adjustleft(cmdline) 
                l=len_trim(cmdline)
                i=0
                qtag=.false.
                lexec=0
                cycle !    <==== will bail if starting a command line
               endif ! qexec
              endif ! i+j-1 < l
             endif ! ltag
            endif ! qtag
! try again
            if (qtag) then ! reading a tag
             if (all(lower2(1:26).ne.c).and.all(upper2(1:26).ne.c)) then
              if (ltag.eq.0) then 
               __WRN3(whoami, 'Parameter names must start with a letter. Skipping line.',0)
               qerror=.true.; exit
              elseif (all(digits2(1:10).ne.c).and.underscore.ne.c) then
               __WRN3(whoami, 'Illegal character in parameter name. Skipping line.',0)
               qerror=.true.; exit
              endif
             endif
             ltag=ltag+1; tag(ltag:ltag)=c
!
            elseif (qeq) then
             __WRN3(whoami, 'Missing value for parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit 
!
            elseif (qval) then
             __INC(lval); val(lval:lval)=c
!
            elseif (qexec) then ! append to command
             __INC(lexec); exec(lexec:lexec)=c
!
            else
             __WRN3(whoami, 'Internal input error (please report). Skipping line',-1)
             qerror=.true.; exit 
            endif
!
           elseif (qstring) then ! character is not allowed except in a string, where we currently allow anything
             __INC(lval); val(lval:lval)=c
           else
             __WRN3(whoami, 'Unrecognized character "'//c//'". Skipping line.',0)
             exit 
           endif ! character loop
          enddo chars ! while l.gt.1
        else ! end of file
         exit
        endif
       enddo lines ! over all lines in the file
!
!    check to make sure that the file did not end while a context was being read
       if (qcontext) then 
        __WRN3(whoami, 'File ended while inside a context. Your input may be incomplete.',0)
        qerror=.true.
        if(qloud) __MESSAGE(whoami, 'Returning to main context.') ; 
        j=parser_context(maincontext_name)
        parameters =>context%context_params(j)
        executables=>context%context_commands(j)
       endif
!
#ifdef __PARALLEL
       if (communicator.ne.MPI_COMM_NULL) call MPI_BCAST(qerror,1,mpibool,0,communicator,ioerr)
#endif
       if (qerror) then
         __WRN3(whoami, 'Error(s) found in input.',0)
       else
         if(qloud) __MESSAGE(whoami, 'Input file read.')
       endif
!
#ifdef __PARALLEL
#ifndef __CHARMM
       if (me.gt.0) call set_minmessagelev(msglev) ! restore
#endif
#endif
!
       end subroutine parse_file
!============================================================================================
       subroutine list_params(ctx &
#ifdef __PARALLEL
       & , me &
#endif
       & )
! 
       __DEP_OUTPUT
!
       character(len=*), intent(in), optional :: ctx ; int :: ictx
!
       __IAM(LIST_PARAMS)
       int :: i
#ifdef __PARALLEL
       int4mpi :: me
#endif
!
       if (.not.parser_initialized) call parser_init()
!
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx)) ; parameters=>context%context_params(ictx)
!
#ifdef __PARALLEL
       if (me.le.0) then
#endif
        __MESSAGE(whoami,'THE FOLLOWING PARAMETERS ARE DEFINED IN CONTEXT "'//context%context_name(ictx)(1:len_trim(context%context_name(ictx)))//'":')
        __MESSAGE(whoami,'========================================================')
        do i=1,parameters%last
         __MESSAGE(whoami,tab//parameters%tag(i)(1:parameters%tlen(i))//' = "'//parameters%val(i)(1:parameters%vlen(i))//'"')
        enddo
        __MESSAGE(whoami,'========================================================')
#ifdef __PARALLEL
       endif
#endif
       end subroutine list_params
!============================================================================================
       subroutine list_commands(ctx &
#ifdef __PARALLEL
       & , me &
#endif
       & )
! 
       __DEP_OUTPUT
!
       character(len=*), intent(in), optional :: ctx ; int :: ictx
!
       __IAM(LIST_COMMANDS)
       int :: i
#ifdef __PARALLEL
       int4mpi :: me
#endif
!
       if (.not.parser_initialized) call parser_init()
!
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx)) ; executables=>context%context_commands(ictx)
!
#ifdef __PARALLEL
       if (me.le.0) then
#endif
        __MESSAGE(whoami,'THE FOLLOWING COMMANDS ARE DEFINED IN CONTEXT "'//context%context_name(ictx)(1:len_trim(context%context_name(ictx)))//'":')
        __MESSAGE(whoami,'========================================================')
        do i=1,executables%last
         __MESSAGE(whoami,tab//'"'//executables%command(i)(1:executables%clen(i))//'"')
        enddo
        __MESSAGE(whoami,'========================================================')
#ifdef __PARALLEL
       endif
#endif
       end subroutine list_commands
!============================================================================================
! auxiliary functions (they need not be part of this module)
       function atoi4(a, invalid)
! NOTE: no overflow check yet
       __DEP_OUTPUT
       integer*4, intent(in) :: invalid
       int :: atoi4, i, l, j, k, sgn, base, missing
       character(len=*), intent(in) :: a
       character(len=len(a)) :: b
       __IAM(ATOI)
       int :: flag(10)
! convert string to int
       missing=INT(invalid)
       i=0
!
       b=a
       call adjustleft(b)
       l=len_trim(b)
       if (l.ge.1) then
        if (b(1:1).eq.hyphen) then
         sgn=-1
         b(1:l-1)=b(2:l); l=l-1; 
         if (l.eq.0) i = -missing ; ! only a hyphen present : will multiply by -1 and quit
        else
         sgn=1
        endif
       else
        i=missing; sgn=1
       endif ! l.ge.1
!
       base=1
       do j=l,1,-1
        where(digits2.eq.b(j:j)); flag=1 ; elsewhere; flag=0 ; endwhere; k=sum(maxloc(flag))-1
        if (all(flag.eq.0)) then 
         __WRN3(whoami, 'ERROR CONVERTING STRING "'//b(1:l)//'" TO INTEGER.',0)
         i=missing; sgn=1;
         exit
        else
         i=i+base*k
         base=base*10
        endif
       enddo
       atoi4=i*sgn
       end function atoi4
       function atoi8(a, invalid)
! NOTE: no overflow check yet
       __DEP_OUTPUT
       integer*8, intent(in) :: invalid
       int :: atoi8, i, l, j, k, sgn, base, missing
       character(len=*), intent(in) :: a
       character(len=len(a)) :: b
       __IAM(ATOI)
       int :: flag(10)
! convert string to int
       missing=INT(invalid)
       i=0
!
       b=a
       call adjustleft(b)
       l=len_trim(b)
       if (l.ge.1) then
        if (b(1:1).eq.hyphen) then
         sgn=-1
         b(1:l-1)=b(2:l); l=l-1; 
         if (l.eq.0) i = -missing ; ! only a hyphen present : will multiply by -1 and quit
        else
         sgn=1
        endif
       else
        i=missing; sgn=1
       endif ! l.ge.1
!
       base=1
       do j=l,1,-1
        where(digits2.eq.b(j:j)); flag=1 ; elsewhere; flag=0 ; endwhere; k=sum(maxloc(flag))-1
        if (all(flag.eq.0)) then 
         __WRN3(whoami, 'ERROR CONVERTING STRING "'//b(1:l)//'" TO INTEGER.',0)
         i=missing; sgn=1;
         exit
        else
         i=i+base*k
         base=base*10
        endif
       enddo
       atoi8=i*sgn
       end function atoi8
       function atoi_(a)
! NOTE: no overflow check yet
       __DEP_OUTPUT
       int :: atoi_, i, l, j, k, sgn, base, missing
       character(len=*), intent(in) :: a
       character(len=len(a)) :: b
       __IAM(ATOI)
       int :: flag(10)
! convert string to int
       missing=-999
       i=0
!
       b=a
       call adjustleft(b)
       l=len_trim(b)
       if (l.ge.1) then
        if (b(1:1).eq.hyphen) then
         sgn=-1
         b(1:l-1)=b(2:l); l=l-1; 
         if (l.eq.0) i = -missing ; ! only a hyphen present : will multiply by -1 and quit
        else
         sgn=1
        endif
       else
        i=missing; sgn=1
       endif ! l.ge.1
!
       base=1
       do j=l,1,-1
        where(digits2.eq.b(j:j)); flag=1 ; elsewhere; flag=0 ; endwhere; k=sum(maxloc(flag))-1
        if (all(flag.eq.0)) then 
         __WRN3(whoami, 'ERROR CONVERTING STRING "'//b(1:l)//'" TO INTEGER.',0)
         i=missing; sgn=1;
         exit
        else
         i=i+base*k
         base=base*10
        endif
       enddo
       atoi_=i*sgn
       end function atoi_
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function atoiv(a,n)
       __DEP_OUTPUT
       __DEP_NUMBER
       character(len=*) :: a
       character(len=maxlinelen), allocatable :: b(:)
       __IAM(ATOIV)
       int :: n, i, j
       int, dimension(n) :: atoiv
!
       i=numword(a)
       if (n.le.0) then
        __WRN3(whoami,' Vector has nonpositive dimension',-1)
        return
       elseif (i.ne.n) then 
        __WRN3(whoami,' Vector dimension mismatch',-1)
       endif
       i=min(i,n)
       atoiv=__INAN
       allocate(b(i))
       read(a,*) b
       do j=1,i
        atoiv(j)=atoi(b(j))
       enddo
       deallocate(b)
!
       end function atoiv
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function atof(a,invalid)
       __DEP_OUTPUT
       float, optional, intent(in) :: invalid
       float :: atof, missing
       float :: f 
       int :: l, j, k, sgn, base
       character(len=*) :: a
       character(len=len(a)) :: b
       __IAM(ATOF)
       bool :: fraction
       int :: flag(10)
! convert string to floating point number
       if (present(invalid)) then ; missing=invalid ; else ; missing=-99999. ; endif
       f=0;
       fraction=.false.
!
       b=a
       call adjustleft(b)
       l=len_trim(b)
       if (l.ge.1) then
        if (b(1:1).eq.hyphen) then
         sgn=-1
         b(1:l-1)=b(2:l); l=l-1; 
         if (l.eq.0) f = -missing ; ! only a hyphen present : will multiply by -1 and quit
        else
         sgn=1
        endif
       else
        f=missing; sgn=1
       endif ! l.ge.1
!
       base=0
       do j=l,1,-1
        if (b(j:j).eq.decimal) then
         if (fraction) then ! two decimal points are invalid
          __WRN3(whoami, 'ERROR CONVERTING STRING "'//b(1:l)//'" TO REAL.',0)
          f=missing; sgn=1;
          exit
         else
          fraction=.true.
          do while (base.gt.0) 
           f=f/10.
           base=base-1
          enddo
         endif
        else
         where(digits2.eq.b(j:j)); flag=1 ; elsewhere; flag=0 ; endwhere; k=sum(maxloc(flag))-1
         if (all(flag.eq.0)) then 
          __WRN3(whoami, 'ERROR CONVERTING STRING "'//b(1:l)//'" TO REAL.',0)
          f=missing; sgn=1;
          exit
         else
          f=f+1.0d0*(10.0d0**base)*k
          base=base+1
         endif
        endif
       enddo
       atof=f*sgn
       end function atof
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function atofv4(a,n)
       __DEP_OUTPUT
       __DEP_NUMBER
       character(len=*) :: a
       character(len=maxlinelen), allocatable :: b(:)
       __IAM(ATOFV)
       integer*4 :: n
       int :: i, j
       float, dimension(n) :: atofv4
!
       i=numword(a)
       if (n.le.0) then
        __WRN3(whoami,' Vector has nonpositive dimension',-1)
        return
       elseif (i.ne.n) then 
        __WRN3(whoami,' Vector dimension mismatch',-1)
       endif
       i=INT(min(i,n))
       atofv4=__NAN
       allocate(b(i))
       read(a,*) b
       do j=1,i
        atofv4(j)=atof(b(j))
       enddo
       deallocate(b)
!
       end function atofv4
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function atofv8(a,n)
       __DEP_OUTPUT
       __DEP_NUMBER
       character(len=*) :: a
       character(len=maxlinelen), allocatable :: b(:)
       __IAM(ATOFV)
       integer*8 :: n
       int :: i, j
       float, dimension(n) :: atofv8
!
       i=numword(a)
       if (n.le.0) then
        __WRN3(whoami,' Vector has nonpositive dimension',-1)
        return
       elseif (i.ne.n) then 
        __WRN3(whoami,' Vector dimension mismatch',-1)
       endif
       i=INT(min(i,n))
       atofv8=__NAN
       allocate(b(i))
       read(a,*) b
       do j=1,i
        atofv8(j)=atof(b(j))
       enddo
       deallocate(b)
!
       end function atofv8
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function atol(a)
       __DEP_OUTPUT
       bool :: atol
       character(len=*) :: a
       character(len=maxlinelen) :: b
       __IAM(ATOL)
       int :: l
!
       b=a
       call adjustleft(b)
       l=len_trim(b)
       select case(a)
!
        case('true', '.true.', '.TRUE.', 'TRUE', 'YES', 'ON', 'yes', 'on', 'y', 'Y', 'T', 't');
         atol=.true.
        case('false', '.false.', '.FALSE.', 'FALSE', 'NO', 'OFF', 'no', 'off', 'n', 'N', 'F', 'f');
         atol=.false.
        case default
         __ERR3(whoami, 'ERROR CONVERTING STRING "'//b(1:l)//'" TO BOOLEAN.',0)
        atol=.false.
       end select
!
       end function atol
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   function itoa4(i)
   __DEP_NUMBER, only: one
   integer*4 :: i
   integer*4, parameter :: ione=1, itwo=2
!   character(len=((ceiling(log10(one*abs(i)+1.)))+1)) :: itoa
!   character(len=((ceiling(log10(one*abs(i)+1.)))+count((/i.lt.0/)) )) :: itoa4 ! sexy way to cast bool to int ? does not work with Pathscale
   character(len=max(((ceiling(log10(one*abs(i)+1.)))+ (ione-sign(ione,i))/itwo ),1)) :: itoa4
   character(len=80) :: b 
   write(b,*) i
   itoa4=adjustl(b)
   end function itoa4
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   function itoa8(i)
   __DEP_NUMBER, only: one
   integer*8 :: i
   integer*8, parameter :: ione=1, itwo=2
!   character(len=((ceiling(log10(one*abs(i)+1.)))+1)) :: itoa
!   character(len=((ceiling(log10(one*abs(i)+1.)))+count((/i.lt.0/)) )) :: itoa8 ! sexy way to cast bool to int ?
   character(len=max(((ceiling(log10(one*abs(i)+1.)))+ (ione-sign(ione,i))/itwo ),1)) :: itoa8
   character(len=80) :: b 
   write(b,*) i
   itoa8=adjustl(b)
   end function itoa8
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   function ftoa(f)
   float :: f
   character(len=17) :: ftoa
   write(ftoa,'(G17.10)') f
   end function ftoa
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   function ltoa(l)
   bool :: l
   character(len=3) :: ltoa
   if (l) then ; ltoa='YES' ; else ; ltoa='NO ' ; endif
   end function ltoa
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       subroutine toupper(a)
       character(len=*), intent(inout) :: a
       int :: i,j
!
       do j=1, len_trim(a)
        do i=1,26; if (lower2(i).eq.a(j:j)) then; a(j:j)=upper2(i); exit; endif; enddo
       enddo
!
       end subroutine toupper
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function ftoupper(a)
       character(len=*), intent(in) :: a
       character(len=len(a)) :: ftoupper
       int :: i,j
       ftoupper=a
!
       do j=1, len_trim(a)
        do i=1,26; if (lower2(i).eq.a(j:j)) then; ftoupper(j:j)=upper2(i); exit; endif; enddo
       enddo
!
       end function ftoupper
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       subroutine tolower(a)
       character(len=*), intent(inout) :: a
       int :: i,j
!
       do j=1, len_trim(a)
        do i=1,26; if (upper2(i).eq.a(j:j)) then; a(j:j)=lower2(i); exit; endif; enddo
       enddo
!
       end subroutine tolower
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! this subroutine uses a custom definition of white space
       subroutine adjustleft_1(a, space, invert_)
        character(len=*) :: a
        character, intent(in) :: space(:)
        bool, optional, intent(in) :: invert_ ! when true "space" becomes "not space" i.e. everything but "space" is considered whitespace
        bool :: invert
        int :: l, i, j
        if (present(invert_)) then ; invert = invert_  ; else ; invert=.false. ; endif
!
        if (len(space).gt.0) then
         l=len(a)
         if (l.gt.0) then
          i=1
!
          if (invert) then
           do while (i.le.l)
            if (any(space.eq.a(i:i))) exit
            i=i+1
           enddo
          else ! invert
           do while (i.le.l)
            if (all(space.ne.a(i:i))) exit
            i=i+1
           enddo
          endif ! invert

!    move string left
          j=1
          do while (j.le.l-i+1)
           a(j:j)=a(i+j-1:i+j-1)
           j=j+1
          enddo
!    pad with blanks
          do while (j.le.l)
           a(j:j)=' '
           j=j+1
          enddo
         endif
        endif
!
       end subroutine adjustleft_1
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! this subroutine uses the definition of white space found in the module
       subroutine adjustleft_2(a)
        character(len=*) :: a
        int :: l, i, j
        l=len(a)
        if (l.gt.0) then
         i=1
         do while (i.le.l)
          if (all(space.ne.a(i:i))) exit
          i=i+1
         enddo
!    move string left
         j=1
         do while (j.le.l-i+1)
          a(j:j)=a(i+j-1:i+j-1)
          j=j+1
         enddo
!    pad with blanks
         do while (j.le.l)
          a(j:j)=' '
          j=j+1
         enddo
        endif
!
       end subroutine adjustleft_2
!====================================================================
       subroutine adjustleft_3(a,l) ! length passed in
        character(len=*) :: a
        int, intent(inout) :: l
        int :: i, j
        if (l.gt.0) then
         i=1
         do while (i.le.l)
          if (all(space.ne.a(i:i))) exit
          i=i+1
         enddo
!    move string left
         j=1
         do while (j.le.l-i+1)
          a(j:j)=a(i+j-1:i+j-1)
          j=j+1
         enddo
!    pad with blanks
         do while (j.le.l)
          a(j:j)=' '
          j=j+1
         enddo
         l=l-i+1; ! new string length
        endif
!
       end subroutine adjustleft_3
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  function numword(a) ! returns the number of blank-separated words in a string
   character(len=*) :: a
   character, parameter :: tab=char(9)
   character(len=2), parameter :: space = ' '//tab
   character, parameter :: space2(2) = (/' ',tab/)
   int :: n, numword,i,j,l
!
   l=len_trim(a);
   n=0
   if (l.eq.0.or.any(a(1:l).eq.space2)) then ; numword=n; return ; endif ! this is string comparison: any applies to space2
   j=1
   i=1
   do while (j.gt.0)
    j=scan(a(i:l),space)
!    write(0,*) i,j,n
!    pause
    if (j.gt.1) then
     n=n+1
    endif
    i=i+j
   enddo
   if (i.le.l) then
    if (all(a(i:l).ne.space2)) n=n+1
   endif
   numword=n
  end function numword
!===============================================================================
  function pop_string_default(a,n) result(b) ! returns the next white-space-delimited word in a string, and removes it from the string
   character(len=*) :: a
   character(len=len(a)) :: b
   character, parameter :: tab=char(9)
   character(len=2), parameter :: space = ' '//tab
   character, parameter :: space2(2) = (/' ',tab/)
   int, optional, intent(inout) :: n
   int :: j,l

   if (present(n)) a(max(0,n)+1:)='' ! erase string beyond length n
!
   call adjustleft(a,space2)
   l=len_trim(a);
   j=scan(a(1:l),space)
   if (j.eq.0) j=l+1 ! there must be only one word
   b=a(1:j-1)
   a=a(j:l)
   if (present(n)) n=l-j+1
  end function pop_string_default
!===============================================================================
  function pop_string_custom(a,n,space,invert_) result(b) ! same as pop_string except custom white space is passed in
   character(len=*) :: a
   character(len=len(a)) :: b
   character(len=*), intent(in) :: space
   bool, optional, intent(in) :: invert_ ! when true "space" becomes "not space" i.e. everything but "space" is considered whitespace
   bool :: invert
   character :: space2(len(space))
   int, intent(inout) :: n
   int :: j,k,l
   if (present(invert_)) then ; invert = invert_  ; else ; invert=.false. ; endif
!
   l=len(space); do j=1,l ; space2(j)=space(j:j) ; enddo
!
   a(max(0,n)+1:)='' ! erase string beyond length n
!
   call adjustleft(a,space2,invert)
   l=len_trim(a);
   if (invert) then
    j=0; do k=1,l ; if ( all(space2.ne.a(k:k)) ) then ; j=k ; exit ; endif ; enddo
   else
    j=scan(a(1:l),space)
   endif
   if (j.eq.0) j=l+1 ! there must be only one word
   b=a(1:j-1)
   a=a(j:l)
   n=l-j+1
  end function pop_string_custom
!===============================================================================
  function pop_string_custom2(a,n,space2, invert_) result(b) ! same as pop_string except custom white space is passed in
   character(len=*) :: a
   character(len=len(a)) :: b
   character, intent(in) :: space2(:)
   bool, optional, intent(in) :: invert_ ! when true "space" becomes "not space" i.e. everything but "space" is considered whitespace
   bool :: invert
   character(len=size(space2)) :: space
   int, intent(inout) :: n
   int :: j,k,l
   if (present(invert_)) then ; invert = invert_  ; else ; invert=.false. ; endif
!
   l=size(space2); do j=1,l ; space(j:j)=space2(j) ; enddo
!
   a(max(0,n)+1:)='' ! erase string beyond length n
!
   call adjustleft(a,space2, invert)
   l=len_trim(a);
   if (invert) then
    j=0; do k=1,l ; if ( all(space2.ne.a(k:k)) ) then ; j=k ; exit ; endif ; enddo
   else
    j=scan(a(1:l),space)
   endif
   if (j.eq.0) j=l+1 ! there must be only one word
   b=a(1:j-1)
   a=a(j:l)
   n=l-j+1
  end function pop_string_custom2
!===============================================================================
  function find_tag(a,tag,n_,qnocase_)
  character(len=*), intent(in) :: a
  character(len=*) :: tag
  int, optional, intent(in) :: n_ ! search up to this length
  bool, optional, intent(in) :: qnocase_
  bool :: qnocase
  int :: ltag, i, j, k, find_tag, n, ntrim
  character(len=len(tag)) :: tcopy
  character(len=len(a)) :: acopy
!
  character(len=2), parameter :: space = ' '//tab
  character, parameter :: space2(2) = (/' ',tab/)
!
  n=len_trim(a)
  if (present(n_)) then; n=min(max(0, n_), n) ! if length n_ is passed in, use instead trimmed length n when n<n_
  else; n=len_trim(a); endif
!
  tcopy=tag; call adjustleft(tcopy,space2); ltag=len_trim(tcopy)
  acopy=a(1:n);  call adjustleft(acopy,space2); ntrim=len_trim(acopy) ! ntrim <= n
!
  if (present(qnocase_)) then; qnocase=qnocase_; else; qnocase=.false.; endif; if (qnocase) then; call toupper(acopy); call toupper(tcopy); endif
!
  j=0 ! not found flag
  if (ltag.gt.0.and.ntrim.ge.ltag) then ! proceed only if tag nontrivial and could fit inside string 
! note: we are only looking for matches that correspond to a new word (not mid-word)
   if (acopy(1:ltag).eq.tcopy(1:ltag)) then ! string begins with tag
    j=1 + n - ntrim ! offset due to adjustleft (since the index will be into the ORIGINAL a, not acopy)
   else ! tag might be somewhere in the middle
    do i=1,size(space2)
     k=index(acopy(1:ntrim), space(i:i)//tcopy(1:ltag) ); ! pre-pend an instance of white space to tag
     if (k.gt.0) then
      j=k + 1 + n - ntrim ! take the first occurrence (in terms of whitespace separator) 
      exit                ! and recall that we added a space to tag copy, and used adjustleft
     endif
    enddo
   endif
  endif
!write(0,*) j, '"'//a(1:n)//'"'
!write(0,*) '"'//acopy(1:ntrim)//'"'
!
  find_tag=j
  end function find_tag
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  function remove_tag(a,tag,n_,qnocase_) result(j)
  character(len=*) :: a
  character(len=*) :: tag
  int, optional, intent(inout) :: n_
  bool, optional, intent(in) :: qnocase_
  bool :: qnocase
  int :: ltag, i, j, k, n, ntrim
  character(len=len(a)) :: right, acopy
  character(len=len(tag)) :: tcopy
!
  character(len=2), parameter :: space = ' '//tab
  character, parameter :: space2(2) = (/' ',tab/)
!
  n=len_trim(a)
  if (present(n_)) then; n=min(max(0, n_), n) ! if length n_ is passed in, use instead trimmed length n when n<n_
  else; n=len_trim(a); endif

  tcopy=tag; call adjustleft(tcopy,space2); ltag=len_trim(tcopy)
  acopy=a(1:n);  call adjustleft(acopy,space2); ntrim=len_trim(acopy) ! ntrim <= n
!
  if (present(qnocase_)) then; qnocase=qnocase_; else; qnocase=.false.; endif; if (qnocase) then; call toupper(acopy); call toupper(tcopy); endif
!
  j=0
  if (ltag.gt.0.and.ntrim.ge.ltag) then ! proceed only if tag nontrivial and could fit inside string 
! note: we are only looking for matches that correspond to a new word (not mid-word)
   if (acopy(1:ltag).eq.tcopy(1:ltag)) then ! string begins with tag
    j=1 + n - ntrim
   else ! tag might be somewhere in the middle
    do i=1,size(space2)
     k=index(acopy(1:ntrim), space(i:i)//tcopy(1:ltag) ); ! pre-pend an instance of white space to tag
     if (k.gt.0) then 
      j=k + 1 + n - ntrim  ! take the first occurrence (in terms of whitespace separator) and recall that we added a space to tag copy, and used adjustleft
      exit
     endif
    enddo
   endif
! remove tag from string, if tag found
   if (j.gt.0) then
    right=a(j:n)             ! string beginning with the tag and up to (trimmed) length n ; trimmed length of right is n-j+1
    tcopy=pop_string(right)  ! remove the tag
    ntrim=len_trim(right)    ! new trimmed length
    a(j:n)=right(1:ntrim)
    if (present(n_)) then ;  __INCR(n_,ntrim - ( n - j + 1 ) ) ; endif
   endif
  endif
!
  end function remove_tag
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  function get_remove_parameter(a,tag,n_,qnocase_) result(b)
  character(len=*) :: a
  character(len=*) :: tag
  int, optional, intent(inout) :: n_
  bool, optional, intent(in) :: qnocase_
  bool :: qnocase
  int :: ltag, i, j, k, n, ntrim
  character(len=len(a)) :: right, acopy, b
  character(len=len(tag)) :: tcopy
!
  character(len=2), parameter :: space = ' '//tab
  character, parameter :: space2(2) = (/' ',tab/)
!
  b='' ; ! initialize
!
  n=len_trim(a)
  if (present(n_)) then; n=min(max(0, n_), n) ! if length n_ is passed in, use instead trimmed length n when n<n_
  else; n=len_trim(a); endif

  tcopy=tag; call adjustleft(tcopy,space2); ltag=len_trim(tcopy)
  acopy=a(1:n);  call adjustleft(acopy,space2); ntrim=len_trim(acopy) ! ntrim <= n
!
  if (present(qnocase_)) then; qnocase=qnocase_; else; qnocase=.false.; endif; if (qnocase) then; call toupper(acopy); call toupper(tcopy); endif
!
  j=0
  if (ltag.gt.0.and.ntrim.ge.ltag) then ! proceed only if tag nontrivial and could fit inside string 
! note: we are only looking for matches that correspond to a new word (not mid-word)
   if (acopy(1:ltag).eq.tcopy(1:ltag)) then ! string begins with tag
    j=1 + n - ntrim
   else ! tag might be somewhere in the middle
    do i=1,size(space2)
     k=index(acopy(1:ntrim), space(i:i)//tcopy(1:ltag) ); ! pre-pend an instance of white space to tag
     if (k.gt.0) then 
      j=k + 1 + n - ntrim  ! take the first occurrence (in terms of whitespace separator) and recall that we added a space to tag copy, and used adjustleft
      exit
     endif
    enddo
   endif
! remove tag from string, if tag found
   if (j.gt.0) then
    right=a(j:n)             ! string beginning with the tag and up to (trimmed) length n ; trimmed length of right is n-j+1
    b=pop_string(right)      ! remove the tag
    b=pop_string(right)      ! remove the patameter
    ntrim=len_trim(right)    ! new trimmed length
    a(j:n)=right(1:ntrim)
    if (present(n_)) then ;  __INCR(n_,ntrim - ( n - j + 1 ) ) ; endif
   endif
  endif
  end function get_remove_parameter
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      end module parser
