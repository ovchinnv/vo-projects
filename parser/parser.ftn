      module parser
!
      use cmd
      use prm
!
      __IMPNONE
      private
!     read, parse & store input file; 
!
      int, parameter, public :: contextnamelen=200
!
!     the current implementation (11/2012) does not allow for nested contexting
!
      type contexts ! for storing multiple parameter sets ('contexts') per single execution
       character(len=contextnamelen), pointer :: context_name(:)
       type (params), pointer :: context_params(:)
       type (commands), pointer :: context_commands(:)
       int :: length=0
       int :: last=0
       int :: current=0
      end type contexts
!
      character(len=26), parameter  :: lower='abcdefghijklmnopqrstuvwxyz'
      character(len=26), parameter  :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
      character(len=10), parameter  :: digits='0123456789'
      int :: i
      character, parameter :: lower2(26)=(/ (lower(i:i),i=1,26)/)
      character, parameter :: upper2(26)=(/ (upper(i:i),i=1,26)/)
      character, parameter, public :: digits2(10)=(/ (digits(i:i),i=1,10)/)
      character, parameter :: tilde='~'
      character, parameter :: decimal='.'
      character, parameter :: underscore='_'
      character, parameter, public :: hyphen='-'
      character, parameter :: slash='/'
      character, parameter, public :: tab=char(9)
      character, parameter, public :: space(4) = (/' ', tab, ',',';'/)
      character, parameter :: comment(4) = (/'*','!','#','%'/)
      character, parameter :: equals(1) = (/'='/)
      character, parameter :: vector_open(2)=(/'(','['/)
      character, parameter :: vector_close(2)=(/')',']'/)
      character, parameter :: context_open(1)=(/'{'/)
      character, parameter :: context_close(1)=(/'}'/)
      character(len=200), parameter :: allowed=upper//lower//digits//decimal//underscore//hyphen//slash//tilde
      character(len=5), parameter :: exec_start='exec:'
      character(len=18), parameter :: exec_msg='Execution stack +='
      character(len=4), parameter :: maincontext_name='MAIN'
      int, parameter :: maincontext_namelen=4
!
      int, parameter, private :: context_incr=1  ! expand increment for contexts
!
      bool, save :: parser_initialized=.false. ! set to true after parse_file is called successfully; private
!
      type (contexts), save :: context              ! contexts
      type (params), save, pointer :: parameters    ! pointer to a single parameter set (e.g. main parameter set)
      type (commands), save, pointer :: executables ! pointer to a single command set   (e.g. main command set)
!
      public atoi     	! convert string to int 
      public atof	! convert string to double
      public atol	! convert string to bool
      public atoiv     	! convert string to a vector of ints 
      public atofv	! convert string to a vector of double
!      public atolv	! convert string to a vector of bool (not yet)
      private params_getval
      private params_getval_nocase
      public getval	        ! return tag value
      public getval_nocase	! return tag value (case insensitive version)
      public getval_nocase_upper! return tag value in uppercase (case insensitive version)
      public existtag	! return tag value
      public existtag_nocase	! return tag value (case insensitive version)
      public get_next_command	! return command
      public noexec             ! returns true if context specified in the atgument has no executable statements or is not present
      public parse_file ! read input file and store all parameters
      public parser_done
      public list_params ! list parameters
      public list_commands ! list commands
      public adjustleft
      public adjustleft_1, adjustleft_2
      public numword
! CHARMM-compatibility routines
      public pop_string
      public find_tag
      public remove_tag
      public get_remove_parameter
      public toupper
      public tolower
      public itoa
      public ftoa
      public ltoa
!
      interface adjustleft
       module procedure adjustleft_1, adjustleft_2
      end interface adjustleft
!
      interface itoa
       module procedure itoa4, itoa8
      end interface itoa
!
      interface atoi
       module procedure atoi4, atoi8, atoi_
      end interface atoi
!
      interface atofv
       module procedure atofv4, atofv8
      end interface atofv
!
      contains
!********************************************************************************************
       subroutine parser_init()
!    initialize contexts
       call parser_done()
!
       allocate(context%context_params(context_incr))
       allocate(context%context_commands(context_incr))
       allocate(context%context_name(context_incr))
       context%length=context_incr
       context%last=1
       context%current=1
       context%context_name(1)=maincontext_name
!    initialize main context
       parameters=>context%context_params(1)
       executables=>context%context_commands(1)
       call params_init(parameters)
       call commands_init(executables)
!
       parser_initialized=.true.
       end subroutine parser_init
!********************************************************************************************
       subroutine parser_done()
       int :: i
!    destroy contexts
       if (context%last.gt.0) then
        if (associated(context%context_params)) then
         do i=1,context%last ; call params_done(context%context_params(i)) ; enddo
         deallocate(context%context_params)
        endif
!
        if (associated(context%context_commands)) then
         do i=1,context%last ; call commands_done(context%context_commands(i)) ; enddo
         deallocate(context%context_commands)
        endif
!
        if (associated(context%context_name)) deallocate(context%context_name)
       endif
!
       context%last=0 ; context%length=0
!
       nullify(parameters)
       nullify(executables)
       parser_initialized=.false.
!
       end subroutine parser_done
!********************************************************************************************
       subroutine parser_context_expand()
!    increase the size of contexts array
       int :: newlength
       type (params), pointer :: newparams(:)
       type (commands), pointer :: newcommands(:)
       character(len=contextnamelen), pointer :: newnames(:)
!
       if ( .not. parser_initialized ) call parser_init()
       newlength=context%length+context_incr
       allocate(newparams(newlength), newcommands(newlength), newnames(newlength))
       newparams(1:context%length)=context%context_params ! copy members of context_params (incl. pointers)
       newcommands(1:context%length)=context%context_commands
       newnames(1:context%length)=context%context_name
       deallocate(context%context_params, context%context_commands, context%context_name)
       context%context_params=>newparams ; context%context_commands=>newcommands ; context%context_name=>newnames ! point to new arrays
       context%length=newlength
       nullify(newparams, newcommands, newnames)
!
       end subroutine parser_context_expand
!********************************************************************************************
       function parser_find_context(cname)
!    find the array index of a context specified by cname
       character(len=*), intent(in) :: cname
       character(len=len(cname)) :: copyname
       int :: parser_find_context, j
!
       parser_find_context=-1
       copyname=cname; call toupper(copyname)
       call adjustleft(copyname)
       if (.not.parser_initialized) call parser_init() 
!    check current context for a match
       if (context%context_name(context%current).eq.copyname) then
        parser_find_context=context%current
       else
        do j=1,context%last
         if (context%context_name(j).eq.copyname) then
!    found element
          parser_find_context=j
         endif
        enddo
       endif
!
       end function parser_find_context
!********************************************************************************************
       function parser_context(cname)
!    find the array index of a context specified by cname; if the context does exist, create it
       character(len=*), intent(in) :: cname
       character(len=len(cname)) :: copyname
       int :: parser_context, j
!
       parser_context=parser_find_context(cname)
       if (parser_context.le.0) then
        copyname=cname; call toupper(copyname)
        if (context%last.eq.context%length) call parser_context_expand()
        j=context%last+1
        context%context_name(j)=copyname
        context%last=j
        parser_context=j
       endif
!
       context%current=parser_context
!
       end function parser_context
!********************************************************************************************
       function params_getval( v,atag )
       type (params) :: v
       character(len=vartaglen) :: params_getval
       character(len=*) :: atag
       int :: j
!
       if (.not.parser_initialized) call parser_init()
       params_getval=''
       if (.not.v%initialized) then 
!
       else
        do j=1,v%last
         if (v%tag(j).eq.atag) then
!       found element
          params_getval=v%val(j)(1:v%vlen(j))
          return
         endif
        enddo
       endif
!
       end function params_getval
!********************************************************************************************
       function params_getval_nocase( v,atag )
       type (params) :: v
       character(len=vartaglen) :: params_getval_nocase, tag1, tag2
       character(len=*) :: atag
       int :: j
!
       if (.not.parser_initialized) call parser_init()
       params_getval_nocase=''
       if (.not.v%initialized) then 
! nothing
       else
        tag2=atag; call toupper(tag2)
        do j=1,v%last
         tag1=v%tag(j);
         call toupper(tag1)
         if (tag1.eq.tag2) then
!       found element
          params_getval_nocase=v%val(j)(1:v%vlen(j))
          return
         endif
        enddo
       endif
!
       end function params_getval_nocase
!********************************************************************************************
       character(len=vartaglen) function getval(atag,ctx)
       use output, only: warning
       character(len=vartaglen) :: value
       character(len=*), intent(in) :: atag
       character(len=*), intent(in), optional :: ctx
       int :: ictx
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx))
!
       value=params_getval(context%context_params(ictx),atag)
       if (len_trim(value).eq.0) call warning('GETVAL','Parameter "'//trim(atag)//'" not found.',-1)
       getval=value
!
       end function getval
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       character(len=vartaglen) function getval_nocase(atag,ctx)
       use output, only: warning
       character(len=vartaglen) :: value
       character(len=*), intent(in) :: atag
       character(len=*), intent(in), optional :: ctx ; int :: ictx
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx))
!
       value=params_getval_nocase(context%context_params(ictx),atag)
       if (len_trim(value).eq.0) call warning('GETVAL_NOCASE','Parameter "'//trim(atag)//'" not found.',-1)
       getval_nocase=value
!
       end function getval_nocase
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       character(len=vartaglen) function getval_nocase_upper(atag,ctx)
       use output, only: warning
       character(len=vartaglen) :: value
       character(len=*), intent(in) :: atag
       character(len=*), intent(in), optional :: ctx ; int :: ictx
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx))
!
       value=params_getval_nocase(context%context_params(ictx),atag)
       if (len_trim(value).eq.0) call warning('GETVAL_NOCASE_UPPER','Parameter "'//trim(atag)//'" not found.',-1)
       call toupper(value)
       getval_nocase_upper=value
!
       end function getval_nocase_upper
!********************************************************************************************
       function get_next_command(ctx) ! returning command as an array of characters
       use output, only: warning
       character(len=maxlinelen), pointer :: get_next_command
! some advanced Fortran 2003 commented out
!       character(len=:), pointer :: get_next_command
       character(len=*), intent(in), optional :: ctx
       type (commands), pointer :: c
       int :: ictx, i
!
       nullify(get_next_command)
!
       if (.not.parser_initialized) call parser_init()
       ictx=1 ; if (present(ctx)) ictx=parser_find_context(ctx)
!
       if (ictx.gt.0) then
!
        c=>context%context_commands(ictx)
        if (.not.c%initialized) then 
!
        elseif (c%current.le.c%last) then
         i=c%clen(c%current)
!         allocate(character(i) :: get_next_command)
         allocate(get_next_command)
         get_next_command=c%command(c%current)(1:i)
         c%current=c%current+1
        endif ! c%initialized
       else
        call warning('GET_NEXT_COMMAND','Context "'//trim(ctx)//'" not found.',-1)
       endif ! ictx > 0
!
       end function get_next_command
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       bool function noexec(ctx)
       character(len=*), intent(in), optional :: ctx
       type (commands), pointer :: c
       int :: ictx
       noexec=.true.
       if (.not.parser_initialized) call parser_init()
       ictx=1 ; if (present(ctx)) ictx=parser_find_context(ctx)
       if (ictx.gt.0) then
        c=>context%context_commands(ictx)
        if (c%initialized) then
         if (c%current.le.c%last) noexec=.false.
        endif !c%initialized
       endif ! ictx
       end function noexec
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function existtag(atag,ctx)
       use output, only: error
       bool :: existtag
       character(len=vartaglen) :: value
       character(len=*), intent(in) :: atag
       character(len=*), intent(in), optional :: ctx ; int :: ictx
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx))
!
       existtag=.false.
       if (.not.parser_initialized) call parser_init()
       value=params_getval(context%context_params(ictx),atag)
       if (len_trim(value).gt.0) existtag=.true.
!
       end function existtag
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function existtag_nocase(atag,ctx)
       bool :: existtag_nocase
       character(len=vartaglen) :: value
       character(len=*), intent(in) :: atag
       character(len=*), intent(in), optional :: ctx ; int :: ictx
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx))
!
       existtag_nocase=.false.
       if (.not.parser_initialized) call parser_init()
       value=params_getval_nocase(context%context_params(ictx),atag)
       if (len_trim(value).gt.0) existtag_nocase=.true.
!
       end function existtag_nocase
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
       subroutine parse_file(fid &
#ifdef __PARALLEL
     &  ,communicator,me__       &
#endif
     &                           )
       use output
!
#ifdef __PARALLEL
       __DEP_MPI
#endif
       __IMPNONE
!
#ifdef __PARALLEL
       int4mpi :: communicator, me
       int4mpi, optional :: me__
       int :: msglev
#endif
!
       int :: fid ! input file handle
       int :: i, j
       character(len=10), parameter :: whoami = 'PARSE_FILE'
!
       int :: allowed_len, lower_len, upper_len, digits_len
       character :: allowed2(200),c
       bool :: qtag, qeq, qval, qexec, qerror ! active : tag, equals, value, executable line, error flag
       bool :: qvector ! flag that is active when we are reading a vector (certain default behavior is overridden)
       bool :: qcontext ! flag that is active when any context other than the main context is active
!
       integer :: ioerr
       int4mpi :: ierr
       int :: l=0, ltag=0, lval=0, lexec=0
       character(len=400) :: cmdline
       character(len=vartaglen) :: tag, val, exec
       character(len=contextnamelen), pointer :: contextname
!
       allowed_len=len_trim(allowed)
       do i=1,allowed_len
        allowed2(i)=allowed(i:i)
       enddo 
!
#ifdef __PARALLEL
       if (present(me__)) then ; me=me__ ; else ; call mpi_comm_rank(communicator,me,ierr) ; endif
       msglev=get_minmessagelev() ; qprint=(me.eq.0)
#endif
!     do work
!
       qcontext=.false.
       qvector=.false.
       qerror=.false.
       qexec=.false.
       if (.not. parser_initialized) call parser_init()
       call message(whoami, 'Reading input file.')
       do while (.true.)
#ifdef __PARALLEL
        if (me.le.0) read(fid,'(A)',IOSTAT=ioerr) cmdline ! if running in parallel, then only the root node is passed a valid handle
        if (communicator.ne.MPI_COMM_NULL) call MPI_BCAST(ioerr,1,mpiint,0,communicator,ierr)
#else
        read(fid,'(A)',IOSTAT=ioerr) cmdline ! if running in parallel, then only the root node is passed a valid handle
#endif
!
        if (ioerr.eq.0) then
#ifdef __PARALLEL
         if (communicator.ne.MPI_COMM_NULL) call MPI_BCAST(cmdline,len(cmdline),MPI_BYTE,0,communicator,ierr) ! broadcast to all CPUs
#endif
!   write(0,*) cmdline
! read from the line
         call adjustleft(cmdline)
         l=len_trim(cmdline)
!   write(0,*) cmdline(1:l)
! add comment character to know when to stop below
         if (l.lt.maxlinelen) l=l+1
         cmdline(l:l)='*'
         if (any(comment.eq.cmdline(1:1))) l=1 ! skip lines that are comments
!
         i=0
         qtag=.true. ; ltag=0 ! each line is required to begin with a tag
         qval=.false.; lval=0
         qeq=.false.
         qvector=.false.      ! this implies that a vector entry currently cannot span multiple lines
         qexec=.false.        ! this implies that an executable command currently cannot span multiple lines
!
         do while (l.gt.1)
           i=i+1
           c=cmdline(i:i)
!     write(0,*) tag(1:ltag), val(1:lval),i
           if (any(comment.eq.c.or.i.eq.l)) then ! end of command line
            if ((qtag.and.i.gt.1).or.qeq) then
             call warning(whoami,'Unexpected end of line',0)
             qerror=.true.; exit 
            elseif (qval) then
             if (lval.eq.0) then
              call warning(whoami, 'Missing value for parameter "'//tag(1:ltag)//'". Skipping line',0)
              qerror=.true.; exit 
             elseif (qvector) then
              call warning(whoami, 'Missing closing bracket for vector parameter "'//tag(1:ltag)//'". Skipping line',0)
              qerror=.true.; exit 
             else ! store tag and val
              call message(whoami, tag(1:ltag)//' <= '//val(1:lval))
              j=params_uadd(parameters,tag,val,ltag,lval)
              ltag=0; lval=0
              qtag=.true. ! no need because we are at the eol, but included here for clarity
              exit
             endif
            elseif (qexec) then
             if (lexec.eq.0) then
              contextname=>context%context_name(context%current)
              call warning(whoami, 'Empty command line in context "'//contextname(1:len_trim(contextname))//'". Skipping line',0)
              qerror=.true.; exit 
             else ! store command
! remove trailing space
              lexec=len_trim(exec(1:lexec))
              call message(whoami, exec_msg//' '//exec(1:lexec)//'"')
              j=commands_add(executables, exec, lexec)
              qexec=.false.; qtag=.true.
              lexec=0
              exit
             endif
!
            else ! qtag
             exit
            endif ! qtag
!
           elseif (any(space.eq.c)) then ! completed a tag or value (since lines cannot begin with blanks -- see above)
!
            if (qtag) then
             qtag=.false.
             qeq=.true.
            elseif (qeq) then
!      nothing
            elseif (qval) then 
             if (qvector) then ! if we are in the process of reading a vector, then the separator (space) tags do not apply;
!                                      otherwise, a tag/value pair has been completed, so attempt to add pair and reinitialize for new tag
              lval=lval+1; val(lval:lval)=' ' ! substitute a space for all separators
             else
!
              qval=.false.
              qtag=.true.
              if (lval.eq.0) then
               call warning(whoami, 'Missing value for parameter "'//tag(1:ltag)//'". Skipping line',0)
               qerror=.true.; exit 
              else ! store tag and val
               call message(whoami, tag(1:ltag)//' <= '//val(1:lval))
               j=params_uadd(parameters,tag,val,ltag,lval)
               ltag=0; lval=0
               cmdline=cmdline(i:l) ! remove tag/val pair from string
               call adjustleft(cmdline)
               l=len_trim(cmdline)
               i=0
              endif ! lval
              ltag=0
             endif ! qvector
            elseif (qexec) then ! space is a valid exec character
             lexec=lexec+1; exec(lexec:lexec)=' '
            endif ! qtag
!
           elseif (any(equals.eq.c)) then ! completed a tag
!
            if (qtag) then
             qtag=.false.
             if (ltag.eq.0) then
              call warning(whoami, 'Missing parameter name. Skipping line',0)
              qerror=.true.; exit 
             endif
!
             qval=.true. ; lval=0   ! expecting a value next
             cmdline=cmdline(i+1:l) ! remove 'tag=' and leading spaces pair from string
             call adjustleft(cmdline) 
             l=len_trim(cmdline)
             i=0
!
             qeq=.false.
            elseif (qeq) then ! in case tag was followed by space; expect a value next
             qeq=.false.
             qval=.true. ; lval=0
             cmdline=cmdline(i+1:l) ! remove 'tag=' and leading spaces pair from string
             call adjustleft(cmdline) 
             l=len_trim(cmdline)
             i=0
            elseif (qval) then ! expected a value but found '='
             if (lval.eq.0) then
              call warning(whoami, 'Missing value for parameter "'//tag(1:ltag)//'". Skipping line',0)
              qerror=.true.; exit 
             elseif (qvector) then
              call warning(whoami, 'Missing closing bracket for vector parameter "'//tag(1:ltag)//'". Skipping line',0)
              qerror=.true.; exit 
             else ! store tag and val (despite the misplaced '=' sign ; leave that for next cycle)
              call adjustleft(val(1:lval)); lval=len_trim(val(1:lval));
              call message(whoami, tag(1:ltag)//' <= '//val(1:lval))
              j=params_uadd(parameters,tag,val,ltag,lval)
              ltag=0; lval=0
              cmdline=cmdline(i:l) ! remove tag/val pair from string (looks like keeping '=' in cmdline) 
              call adjustleft(cmdline) ! remove tag/val pair from string
              l=len_trim(cmdline)
              i=0
             endif ! lval
             qtag=.true. ; ltag=0
             qval=.false.
!
            elseif (qexec) then ! this is a valid command character
             lexec=lexec+1; exec(lexec:lexec)=c
            endif ! qtag
!
!************************************** CONTEXTS **************************************
           elseif (any(context_open.eq.c)) then ! encountered a context opening bracket
!    check if already inside a context (currently nesting is not supported)
            if (qcontext) then
             call warning(whoami, 'Unexpected open brace while processing parameter "'//tag(1:ltag),0)
             call message(whoami, 'Nested contexts are not allowed. Skipping line.')
             qerror=.true.; exit
!
            elseif (qtag.or.qeq) then
             if (ltag.gt.0) then
              call toupper(tag)
! check to make sure the new context name is not the default name
              if (tag(1:ltag).ne.maincontext_name(1:maincontext_namelen)) then
               call message(whoami, 'Switching to context "'//tag(1:ltag)//'".')
!     note : cannot simply do this:
!               parameters =>context%context_params  (parser_context(tag(1:ltag)))
!     because context_params might need to be reallocated _during the call_; in the meantime, parameters points to the wrong thing
               j=parser_context(tag(1:ltag))
               parameters=>context%context_params(j)
               executables=>context%context_commands(j)
!
               qcontext=.true.
               qtag=.true.
               qeq=.false.
               ltag=0
               cmdline=cmdline(i+1:l) ! remove open brace from string
               call adjustleft(cmdline)
               l=len_trim(cmdline)
               i=0
              else ! context name not allowed
               call warning(whoami, 'Context name "'//tag(1:ltag)//'" is not allowed. Skipping line.',0)
               qerror=.true.; exit 
              endif ! tag .ne. maincontext_name
             else
              call warning(whoami, 'Missing context name. Skipping line.',0)
              qerror=.true.; exit 
             endif ! ltag
!
            else
             call warning(whoami, 'Unexpected open brace while processing parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit
            endif ! qcontext
!
           elseif (any(context_close.eq.c)) then ! encountered a context closing bracket
            if (.not. qcontext) then ! make sure that there was an open brace
             call warning(whoami, 'Encountered a close brace without a matching open brace. Skipping line.',0)
             qerror=.true.; exit
            elseif (qtag.and.ltag.eq.0) then   ! if expecting a new tag
             call message(whoami, 'Returning to main context.')
!
             j=parser_context(maincontext_name) ! default context
             parameters =>context%context_params(j)
             executables=>context%context_commands(j)
!
             qcontext=.false.
             cmdline=cmdline(i+1:l) ! remove close bracket
             call adjustleft(cmdline) 
             l=len_trim(cmdline)
             i=0
            elseif (qval.and..not.qvector.and.lval.gt.0) then ! finished reading a parameter value
!    first, store tag/value pair
             qval=.false.
             qtag=.true.
             call message(whoami, tag(1:ltag)//' <= '//val(1:lval))
             j=params_uadd(parameters,tag,val,ltag,lval)
             ltag=0; lval=0
             cmdline=cmdline(i+1:l) ! remove tag/val pair from string and also the close bracket
             call adjustleft(cmdline)
             l=len_trim(cmdline)
             i=0
!    now return to then main context
             call message(whoami, 'Returning to main context.')
!
             j=parser_context(maincontext_name) ! default context
             parameters =>context%context_params(j)
             executables=>context%context_commands(j)
!
             qcontext=.false.
            elseif (qexec) then
             if (lexec.le.0) then
              contextname=>context%context_name(context%current)
              call warning(whoami, 'Unexpected close brace while reading command in context "'//contextname(1:len_trim(contextname))//'". Skipping line',0)
              qerror=.true.; exit 
             else ! store command
! remove trailing space
              lexec=len_trim(exec(1:lexec))
              call message(whoami, exec_msg//' "'//exec(1:lexec)//'"')
              j=commands_add(executables, exec, lexec)
              lexec=0
              qexec=.false.
              qtag=.true.
              cmdline=cmdline(i+1:l) ! remove command from string and also the close bracket
              call adjustleft(cmdline)
              l=len_trim(cmdline)
              i=0
              call message(whoami, 'Returning to main context.')
              j=parser_context(maincontext_name) ! default context
              parameters =>context%context_params(j)
              executables=>context%context_commands(j)
             endif
!
            else
             call warning(whoami, 'Unexpected close brace while processing parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit
            endif ! qcontext
!************************************** VECTOR DATA *****************************************
           elseif (any(vector_open.eq.c)) then ! encountered an opening vector bracket
            if (qtag) then ! opening bracket not allowed
             call warning(whoami, 'Unexpected opening bracket when processing parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit
            elseif (qeq) then
             call warning(whoami, 'Unexpected opening bracket when processing parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit 
            elseif (qval) then
             if (qvector) then ! already read one bracket 
              call warning(whoami, & 
&                          'Unexpected opening bracket when processing vector parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit
             else
              qvector=.true. ! the only legitimate occurrence
             endif
!
            elseif (qexec) then ! this is a valid command character
             lexec=lexec+1; exec(lexec:lexec)=c
!
            endif
!
           elseif (any(vector_close.eq.c)) then ! encountered a closing vector bracket
!      write(0,*) '**', qtag, qeq, qval, qvector, tag, ltag, val, lval; !aa
            if (qtag) then ! closing bracket not allowed
             call warning(whoami, 'Unexpected closing bracket when processing parameter "'//tag(1:ltag)//'". Skipping line.',0)
!              write(0,*) cmdline(i:l) ! aa
             qerror=.true.; exit
            elseif (qeq) then
             call warning(whoami, 'Unexpected closing bracket when processing parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit 
            elseif (qval) then
             qvector=.false. ! the only legitimate occurrence
!     peek ahead to make sure we have a spacer, if not, issue a warning and skip line
!     (the convention is that a vector value must be separated from a subsequent tag)
             c=cmdline(i+1:i+1)
             if ( (i.lt.l) .and. (all(space.ne.c)) .and. (all(comment.ne.c))) then 
              call warning(whoami, 'Error reading vector value for parameter "'//tag(1:ltag)//'". Skipping line.',0)
              qerror=.true.; exit 
!     otherwise, attempt to add tag/value pair
             else
              if (lval.eq.0) then
               call warning(whoami, 'Missing vector value for parameter "'//tag(1:ltag)//'". Skipping line.',0)
               qerror=.true.; exit 
              endif
              call adjustleft(val(1:lval)); lval=len_trim(val(1:lval));
              if (lval.eq.0) then
               call warning(whoami, 'Missing vector value for parameter "'//tag(1:ltag)//'". Skipping line.',0)
               qerror=.true.; exit 
              else ! add pair
               call adjustleft(val(1:lval)); lval=len_trim(val(1:lval));
               call message(whoami, tag(1:ltag)//'[VECTOR] <= ('//val(1:lval)//')')
               j=params_uadd(parameters,tag,val,ltag,lval)
               ltag=0; lval=0
               cmdline=cmdline(i+1:l) ! remove tag/val pair from string
               call adjustleft(cmdline) ! remove tag/val pair from string
               l=len_trim(cmdline)
               i=0
              endif ! lval
              qtag=.true. ; ltag=0
              qval=.false.
             endif ! (i.lt.l)
!
            elseif (qexec) then ! this is a valid command character
             lexec=lexec+1; exec(lexec:lexec)=c
!
            else ! no input mode (qtag/qeq/qval/qexec) : this should never happen
             call warning(whoami, 'Misplaced closing bracket in input. Skipping line.',0)
             qerror=.true.; exit
            endif 
!
           elseif (any(allowed2(1:allowed_len).eq.c)) then ! check that the characters are allowed
!
            if (qtag) then ! reading a tag
             if (ltag.eq.0) then 
! test for executable line; if executable tag found, switch off qtag, switch on qexec
              j=len_trim(exec_start)
!              write(0,*) cmdline(i:l)
              if ( i + j - 1 .lt. l) then ! recall that cmdline(l:l) is a comment
               qexec=cmdline(i : i + j - 1).eq.exec_start(1:j)
               if (qexec) then
                cmdline=cmdline(i+j:l)
                call adjustleft(cmdline) 
                l=len_trim(cmdline)
                i=0
                qtag=.false.
                lexec=0
                cycle !    <==== will bail if starting a command line
               endif ! qexec
              endif ! i+j-1 < l
             endif ! ltag
            endif ! qtag
! try again
            if (qtag) then ! reading a tag
             if (all(lower2(1:26).ne.c).and.all(upper2(1:26).ne.c)) then
              if (ltag.eq.0) then 
               call warning(whoami, 'Parameter names must start with a letter. Skipping line.',0)
               qerror=.true.; exit
              elseif (all(digits2(1:10).ne.c).and.underscore.ne.c) then
               call warning(whoami, 'Illegal character in parameter name. Skipping line.',0)
               qerror=.true.; exit
              endif
             endif
             ltag=ltag+1; tag(ltag:ltag)=c
!
            elseif (qeq) then
             call warning(whoami, 'Missing value for parameter "'//tag(1:ltag)//'". Skipping line.',0)
             qerror=.true.; exit 
!
            elseif (qval) then
             lval=lval+1; val(lval:lval)=c
!
            elseif (qexec) then ! append to command
             lexec=lexec+1; exec(lexec:lexec)=c
!
            else
             call warning(whoami, 'Internal input error. Skipping line',0)
             qerror=.true.; exit 
            endif
!
           else
             call warning(whoami, 'Unrecognized character "'//c//'". Skipping line.',0)
             exit 
           endif ! character loop
         enddo ! while l.gt.1
        else ! end of file
         exit
        endif
       enddo ! over all lines in the file
!
!    check to make sure that the file did not end while a context was being read
       if (qcontext) then 
        call warning(whoami, 'File ended while inside a context. Your input may be incomplete.',0)
        qerror=.true.
        call message(whoami, 'Returning to main context.') ; 
        j=parser_context(maincontext_name)
        parameters =>context%context_params(j)
        executables=>context%context_commands(j)
       endif
!
#ifdef __PARALLEL
       call MPI_BCAST(qerror,1,mpibool,0,communicator,ioerr)
#endif
       if (qerror) then
         call warning(whoami, 'Error(s) found in input.',0)
       else
         call message(whoami, 'Input file read.')
       endif
!
#ifdef __PARALLEL
       if (me.gt.0) call set_minmessagelev(msglev) ! restore
#endif
!
       end subroutine parse_file
!============================================================================================
       subroutine list_params(ctx &
#ifdef __PARALLEL
       & , me &
#endif
       & )
! 
       use output
!
       character(len=*), intent(in), optional :: ctx ; int :: ictx
!
       character(len=11), parameter :: whoami = 'LIST_PARAMS'
       int :: i
#ifdef __PARALLEL
       int4mpi :: me
#endif
!
       if (.not.parser_initialized) call parser_init()
!
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx)) ; parameters=>context%context_params(ictx)
!
#ifdef __PARALLEL
       if (me.le.0) then
#endif
        call message(whoami,'THE FOLLOWING PARAMETERS ARE DEFINED IN CONTEXT "'//context%context_name(ictx)(1:len_trim(context%context_name(ictx)))//'":')
        call message(whoami,'========================================================')
        do i=1,parameters%last
         call message(whoami,tab//parameters%tag(i)(1:parameters%tlen(i))//' = "'//parameters%val(i)(1:parameters%vlen(i))//'"')
        enddo
        call message(whoami,'========================================================')
#ifdef __PARALLEL
       endif
#endif
       end subroutine list_params
!============================================================================================
       subroutine list_commands(ctx &
#ifdef __PARALLEL
       & , me &
#endif
       & )
! 
       use output
!
       character(len=*), intent(in), optional :: ctx ; int :: ictx
!
       character(len=13), parameter :: whoami = 'LIST_COMMANDS'
       int :: i
#ifdef __PARALLEL
       int4mpi :: me
#endif
!
       if (.not.parser_initialized) call parser_init()
!
       ictx=1 ; if (present(ctx)) ictx=max(1,parser_find_context(ctx)) ; executables=>context%context_commands(ictx)
!
#ifdef __PARALLEL
       if (me.le.0) then
#endif
        call message(whoami,'THE FOLLOWING COMMANDS ARE DEFINED IN CONTEXT "'//context%context_name(ictx)(1:len_trim(context%context_name(ictx)))//'":')
        call message(whoami,'========================================================')
        do i=1,executables%last
         call message(whoami,tab//'"'//executables%command(i)(1:executables%clen(i))//'"')
        enddo
        call message(whoami,'========================================================')
#ifdef __PARALLEL
       endif
#endif
       end subroutine list_commands
!============================================================================================
! auxiliary functions (they need not be part of this module)
       function atoi4(a, invalid)
! NOTE: no overflow check yet
       use output, only: warning
       integer*4, intent(in) :: invalid
       int :: atoi4, i, l, j, k, sgn, base, missing
       character(len=*), intent(in) :: a
       character(len=len(a)) :: b
       character(len=4), parameter :: whoami = 'ATOI'
       int :: flag(10)
! convert string to int
       missing=invalid
       i=0
!
       b=a
       call adjustleft(b)
       l=len_trim(b)
       if (l.ge.1) then
        if (b(1:1).eq.hyphen) then
         sgn=-1
         b(1:l-1)=b(2:l); l=l-1; 
         if (l.eq.0) i = -missing ; ! only a hyphen present : will multiply by -1 and quit
        else
         sgn=1
        endif
       else
        i=missing; sgn=1
       endif ! l.ge.1
!
       base=1
       do j=l,1,-1
        where(digits2.eq.b(j:j)); flag=1 ; elsewhere; flag=0 ; endwhere; k=sum(maxloc(flag))-1
        if (all(flag.eq.0)) then 
         call warning(whoami, 'ERROR CONVERTING STRING "'//b(1:l)//'" TO INTEGER.',-1)
         i=missing; sgn=1;
         exit
        else
         i=i+base*k
         base=base*10
        endif
       enddo
       atoi4=i*sgn
       end function atoi4
       function atoi8(a, invalid)
! NOTE: no overflow check yet
       use output, only: warning
       integer*8, intent(in) :: invalid
       int :: atoi8, i, l, j, k, sgn, base, missing
       character(len=*), intent(in) :: a
       character(len=len(a)) :: b
       character(len=4), parameter :: whoami = 'ATOI'
       int :: flag(10)
! convert string to int
       missing=invalid
       i=0
!
       b=a
       call adjustleft(b)
       l=len_trim(b)
       if (l.ge.1) then
        if (b(1:1).eq.hyphen) then
         sgn=-1
         b(1:l-1)=b(2:l); l=l-1; 
         if (l.eq.0) i = -missing ; ! only a hyphen present : will multiply by -1 and quit
        else
         sgn=1
        endif
       else
        i=missing; sgn=1
       endif ! l.ge.1
!
       base=1
       do j=l,1,-1
        where(digits2.eq.b(j:j)); flag=1 ; elsewhere; flag=0 ; endwhere; k=sum(maxloc(flag))-1
        if (all(flag.eq.0)) then 
         call warning(whoami, 'ERROR CONVERTING STRING "'//b(1:l)//'" TO INTEGER.',-1)
         i=missing; sgn=1;
         exit
        else
         i=i+base*k
         base=base*10
        endif
       enddo
       atoi8=i*sgn
       end function atoi8
       function atoi_(a)
! NOTE: no overflow check yet
       use output, only: warning
       int :: atoi_, i, l, j, k, sgn, base, missing
       character(len=*), intent(in) :: a
       character(len=len(a)) :: b
       character(len=4), parameter :: whoami = 'ATOI'
       int :: flag(10)
! convert string to int
       missing=-999
       i=0
!
       b=a
       call adjustleft(b)
       l=len_trim(b)
       if (l.ge.1) then
        if (b(1:1).eq.hyphen) then
         sgn=-1
         b(1:l-1)=b(2:l); l=l-1; 
         if (l.eq.0) i = -missing ; ! only a hyphen present : will multiply by -1 and quit
        else
         sgn=1
        endif
       else
        i=missing; sgn=1
       endif ! l.ge.1
!
       base=1
       do j=l,1,-1
        where(digits2.eq.b(j:j)); flag=1 ; elsewhere; flag=0 ; endwhere; k=sum(maxloc(flag))-1
        if (all(flag.eq.0)) then 
         call warning(whoami, 'ERROR CONVERTING STRING "'//b(1:l)//'" TO INTEGER.',-1)
         i=missing; sgn=1;
         exit
        else
         i=i+base*k
         base=base*10
        endif
       enddo
       atoi_=i*sgn
       end function atoi_
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function atoiv(a,n)
       use output, only: warning
       __DEP_NUMBER, only: unknowni
       character(len=*) :: a
       character(len=maxlinelen), allocatable :: b(:)
       character(len=5), parameter :: whoami = 'ATOIV'
       int :: n, i, j
       int, dimension(n) :: atoiv
!
       i=numword(a)
       if (n.le.0) then
        call warning(whoami,' Vector has nonpositive dimension',-1)
        return
       elseif (i.ne.n) then 
        call warning(whoami,' Vector dimension mismatch',-1)
       endif
       i=min(i,n)
       atoiv=unknowni
       allocate(b(i))
       read(a,*) b
       do j=1,i
        atoiv(j)=atoi(b(j))
       enddo
       deallocate(b)
!
       end function atoiv
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function atof(a,invalid)
       use output, only: warning
       float, optional, intent(in) :: invalid
       float :: atof, missing
       float :: f 
       int :: i, l, j, k, sgn, base
       character(len=*) :: a
       character(len=len(a)) :: b
       character(len=4), parameter :: whoami = 'ATOF'
       bool :: fraction
       int :: flag(10)
! convert string to floating point number
       if (present(invalid)) then ; missing=invalid ; else ; missing=-99999. ; endif
       f=0;
       fraction=.false.
!
       b=a
       call adjustleft(b)
       l=len_trim(b)
       if (l.ge.1) then
        if (b(1:1).eq.hyphen) then
         sgn=-1
         b(1:l-1)=b(2:l); l=l-1; 
         if (l.eq.0) f = -missing ; ! only a hyphen present : will multiply by -1 and quit
        else
         sgn=1
        endif
       else
        f=missing; sgn=1
       endif ! l.ge.1
!       
       base=0
       do j=l,1,-1
        if (b(j:j).eq.decimal) then
         if (fraction) then ! two decimal points are invalid
          call warning(whoami, 'ERROR CONVERTING STRING "'//b(1:l)//'" TO REAL.',-1)
          f=missing; sgn=1;
          exit
         else
          fraction=.true.
          do while (base.gt.0) 
           f=f/10.
           base=base-1
          enddo
         endif
        else
         where(digits2.eq.b(j:j)); flag=1 ; elsewhere; flag=0 ; endwhere; k=sum(maxloc(flag))-1
         if (all(flag.eq.0)) then 
          call warning(whoami, 'ERROR CONVERTING STRING "'//b(1:l)//'" TO REAL.',-1)
          f=missing; sgn=1;
          exit
         else
          f=f+1.0d0*(10.0d0**base)*k
          base=base+1
         endif
        endif
       enddo
       atof=f*sgn
       end function atof
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function atofv4(a,n)
       use output, only: warning
       __DEP_NUMBER, only: unknownf
       character(len=*) :: a
       character(len=maxlinelen), allocatable :: b(:)
       character(len=5), parameter :: whoami = 'ATOFV'
       integer*4 :: n
       int :: i, j
       float, dimension(n) :: atofv4
!
       i=numword(a)
       if (n.le.0) then
        call warning(whoami,' Vector has nonpositive dimension',-1)
        return
       elseif (i.ne.n) then 
        call warning(whoami,' Vector dimension mismatch',-1)
       endif
       i=min(i,n)
       atofv4=unknownf
       allocate(b(i))
       read(a,*) b
       do j=1,i
        atofv4(j)=atof(b(j))
       enddo
       deallocate(b)
!
       end function atofv4
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function atofv8(a,n)
       use output, only: warning
       __DEP_NUMBER, only: unknownf
       character(len=*) :: a
       character(len=maxlinelen), allocatable :: b(:)
       character(len=5), parameter :: whoami = 'ATOFV'
       integer*8 :: n
       int :: i, j
       float, dimension(n) :: atofv8
!
       i=numword(a)
       if (n.le.0) then
        call warning(whoami,' Vector has nonpositive dimension',-1)
        return
       elseif (i.ne.n) then 
        call warning(whoami,' Vector dimension mismatch',-1)
       endif
       i=min(i,n)
       atofv8=unknownf
       allocate(b(i))
       read(a,*) b
       do j=1,i
        atofv8(j)=atof(b(j))
       enddo
       deallocate(b)
!
       end function atofv8
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       function atol(a)
       use output, only: error
       bool :: atol
       character(len=*) :: a
       character(len=maxlinelen) :: b
       character(len=4), parameter :: whoami = 'ATOL'
       int :: l
!
       b=a
       call adjustleft(b)
       l=len_trim(b)
       select case(a)
!
        case('true', '.true.', '.TRUE.', 'TRUE', 'YES', 'ON', 'yes', 'on', 'y', 'Y');
         atol=.true.
        case('false', '.false.', '.FALSE.', 'FALSE', 'NO', 'OFF', 'no', 'off', 'n', 'N');
         atol=.false.
        case default
         call error(whoami, 'ERROR CONVERTING STRING "'//b(1:l)//'" TO BOOLEAN.',-1)
        atol=.false.
       end select
!
       end function atol
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   function itoa4(i)
   __DEP_NUMBER, only : one
   integer*4 :: i
   integer*4, parameter :: ione=1, itwo=2
!   character(len=((ceiling(log10(one*abs(i)+1.)))+1)) :: itoa
!   character(len=((ceiling(log10(one*abs(i)+1.)))+count((/i.lt.0/)) )) :: itoa4 ! sexy way to cast bool to int ? does not work with Pathscale
   character(len=max(((ceiling(log10(one*abs(i)+1.)))+ (ione-sign(ione,i))/itwo ),1)) :: itoa4
   character(len=80) :: b 
   write(b,*) i
   itoa4=adjustl(b)
   end function itoa4
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   function itoa8(i)
   __DEP_NUMBER, only : one
   integer*8 :: i
   integer*8, parameter :: ione=1, itwo=2
!   character(len=((ceiling(log10(one*abs(i)+1.)))+1)) :: itoa
!   character(len=((ceiling(log10(one*abs(i)+1.)))+count((/i.lt.0/)) )) :: itoa8 ! sexy way to cast bool to int ?
   character(len=max(((ceiling(log10(one*abs(i)+1.)))+ (ione-sign(ione,i))/itwo ),1)) :: itoa8
   character(len=80) :: b 
   write(b,*) i
   itoa8=adjustl(b)
   end function itoa8
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   function ftoa(f)
   float :: f
   character(len=15) :: ftoa
   write(ftoa,'(G15.10)') f
   end function ftoa
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   function ltoa(l)
   bool :: l
   character(len=3) :: ltoa
   if (l) then ; ltoa='YES' ; else ; ltoa='NO ' ; endif
   end function ltoa
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       subroutine toupper(a)
       character(len=*) :: a
       int :: i,j
!
       do j=1, len_trim(a)
        do i=1,26; if (lower2(i).eq.a(j:j)) then; a(j:j)=upper2(i); exit; endif; enddo
       enddo
!
       end subroutine toupper
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       subroutine tolower(a)
       character(len=*) :: a
       int :: i,j
!
       do j=1, len_trim(a)
        do i=1,26; if (upper2(i).eq.a(j:j)) then; a(j:j)=lower2(i); exit; endif; enddo
       enddo
!
       end subroutine tolower
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! this subroutine uses a custom definition of white space
       subroutine adjustleft_1(a, space)
        character(len=*) :: a
        character :: space(:)
        int :: l, i, j
        l=len(a)
        if (l.gt.0) then
         i=1
         do while (i.le.l)
          if (all(space.ne.a(i:i))) exit
          i=i+1
         enddo
!    move string left
         j=1
         do while (j.le.l-i+1)
          a(j:j)=a(i+j-1:i+j-1)
          j=j+1
         enddo
!    pad with blanks
         do while (j.le.l)
          a(j:j)=' '
          j=j+1
         enddo
        endif
!
       end subroutine adjustleft_1
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! this subroutine uses the definition of white space found in the module
       subroutine adjustleft_2(a)
        character(len=*) :: a
        int :: l, i, j
        l=len(a)
        if (l.gt.0) then
         i=1
         do while (i.le.l)
          if (all(space.ne.a(i:i))) exit
          i=i+1
         enddo
!    move string left
         j=1
         do while (j.le.l-i+1)
          a(j:j)=a(i+j-1:i+j-1)
          j=j+1
         enddo
!    pad with blanks
         do while (j.le.l)
          a(j:j)=' '
          j=j+1
         enddo
        endif
!
       end subroutine adjustleft_2
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  function numword(a) ! returns the number of blank-separated words in a string
   character(len=*) :: a
   character, parameter :: tab=char(9)
   character(len=2), parameter :: space = ' '//tab
   character, parameter :: space2(2) = (/' ',tab/)
   int :: n, numword,i,j,l
!
   l=len_trim(a);
   n=0
   if (l.eq.0.or.any(a(1:l).eq.space2)) return ! this is string comparison: any applies to space2
   j=1
   i=1
   do while (j.gt.0)
    j=scan(a(i:l),space)
!    write(0,*) i,j,n
!    pause
    if (j.gt.1) then
     n=n+1
    endif
    i=i+j
   enddo
   if (i.le.l) then
    if (all(a(i:l).ne.space2)) n=n+1
   endif
   numword=n
  end function numword
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  function pop_string(a,n) result(b) ! returns the next white-space-delimited word in a string, and removes it from the string
   character(len=*) :: a
   character(len=len(a)) :: b
   character, parameter :: tab=char(9)
   character(len=2), parameter :: space = ' '//tab
   character, parameter :: space2(2) = (/' ',tab/)
   int, optional, intent(inout) :: n
   int :: j,l

   if (present(n)) a(max(0,n)+1:)='' ! erase string beyond length n
!
   call adjustleft(a,space2)
   l=len_trim(a);
   j=scan(a(1:l),space)
   if (j.eq.0) j=l+1 ! there must be only one word
   b=a(1:j-1)
   a=a(j:l)
   if (present(n)) n=l-j+1
  end function pop_string
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  function find_tag(a,tag,n)
  character(len=*), intent(inout) :: a ! because we might be removing white space
  character(len=*) :: tag
  int, optional, intent(inout) :: n
  int :: ltag, i, j, k, find_tag
  character(len=len(tag)) :: copy
!
  character(len=2), parameter :: space = ' '//tab
  character, parameter :: space2(2) = (/' ',tab/)
!
  copy=tag; call adjustleft(copy,space2); ltag=len_trim(copy)
  if (present(n)) a(max(0,n)+1:)=''        ! erase string beyond length n
  call adjustleft(a,space2); n=len_trim(a);
  if (ltag.gt.0.and.n.ge.ltag) then ! proceed only if tag nontrivial and could fit inside string 
! note: we are only looking for matches that correspond to a new word (not mid-word)
   if (a(1:ltag).eq.copy(1:ltag)) then ! string begins with tag
    j=1
   else ! tag might be somewhere in the middle
    j=-1
    do i=1,size(space2)
     k=index(a(1:n), space(i:i)//copy(1:ltag) ); ! pre-pend an instance of white space to tag
     if (k.gt.0) j=min(j,k) ! take the first occurrence
    enddo
    j=j+1
   endif
  else
   j=0
  endif
!
  find_tag=j
  end function find_tag
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  function remove_tag(a,tag,n) result(j)
  character(len=*) :: a
  character(len=*) :: tag
  int, optional, intent(inout) :: n
  int :: ltag, i, j, k, l
  character(len=len(a)) :: right
  character(len=len(tag)) :: copy
!
  character(len=2), parameter :: space = ' '//tab
  character, parameter :: space2(2) = (/' ',tab/)
!
  copy=tag; call adjustleft(copy,space2); ltag=len_trim(copy)
  if (present(n)) a(max(0,n)+1:)=''        ! erase string beyond length n
  call adjustleft(a,space2); l=len_trim(a);
  if (ltag.gt.0.and.l.ge.ltag) then ! proceed only if tag nontrivial and could fit inside string 
! note: we are only looking for matches that correspond to a new word (not mid-word)
   if (a(1:ltag).eq.copy(1:ltag)) then ! string begins with tag
    j=1
   else ! tag might be somewhere in the middle
    j=-1
    do i=1,size(space2)
     k=index(a(1:l), space(i:i)//copy(1:ltag) ); ! pre-pend an instance of white space to tag
     if (k.gt.0) j=min(j,k) ! take the first occurrence
    enddo
    j=j+1
   endif
! remove tag and parameter from string, if tag found
   if (j.gt.0) then
    right=a(j+ltag:)
    a(j:)=right
    if (present(n)) n=len_trim(a)
   endif
  endif
!
  end function remove_tag
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  function get_remove_parameter(a,tag,n) result(b)
  character(len=*) :: a
  character(len=*) :: tag
  int, optional, intent(inout) :: n
  int :: ltag, i, j, k, l
  character(len=len(a)) :: b, right
  character(len=len(tag)) :: copy
!
  character(len=2), parameter :: space = ' '//tab
  character, parameter :: space2(2) = (/' ',tab/)
!
  b=''
  copy=tag; call adjustleft(copy,space2); ltag=len_trim(copy)
  if (present(n)) a(max(0,n)+1:)=''        ! erase string beyond length n
  call adjustleft(a,space2); l=len_trim(a);
  if (ltag.gt.0.and.l.ge.ltag) then ! proceed only if tag nontrivial and could fit inside string 
! note: we are only looking for matches that correspond to a new word (not mid-word)
   if (a(1:ltag).eq.copy(1:ltag)) then ! string begins with tag
    j=1
   else ! tag might be somewhere in the middle
    j=-1
    do i=1,size(space2)
     k=index(a(1:l), space(i:i)//copy(1:ltag) ); ! pre-pend an instance of white space to tag
     if (k.gt.0) j=min(j,k) ! take the first occurrence
    enddo
    j=j+1
   endif
! remove tag and parameter from string, if tag found
   if (j.gt.0) then
    right=a(j+ltag:)
    b=pop_string(right)
    a(j:)=right
    if (present(n)) n=len_trim(a)
   endif
  endif
!
  end function get_remove_parameter
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      end module parser
