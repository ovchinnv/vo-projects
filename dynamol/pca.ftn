#define __CTX __STRING(__PCACTX)
#define __THISCOMM __PCACOMM
#include "multicom_def.src"
module pca
! functioniality to perform principal component analysis (PCA) 
! and related calculations
!=============================================================
 __DEP_PARSER
 __DEP_OUTPUT
 __DEP_MULTICOM
 __DEP_CONST
 use system
 use psf
 use files
 use bestfit
 use parselist
 use ivector

 __IMPNONE

 private

 public pca_initialize
 public pca_done
 public pca_compute
 public pca_exec

 bool, save :: pca_initialized=.false.
 int :: msglev = 1
!
 character(len=vartaglen) :: trajectory_file, trajectory_type, covmat_file, covmat_type, avg_file, avg_type,&
    & evec_file, evec_type, evec_inds_str, eval_file, sbfit, sfirst_frame, slast_frame
 bool :: qentropy, qmass, qbfit, qbfit_iter
 type (int_vector) :: evec_inds
 int :: stride_frame, first_frame, last_frame
 int :: natoms=-1
 float :: temperature ! quasiharmonic temperature
! data arrays
 float, pointer :: ravg(:,:), rcov(:,:), eval(:), evec(:,:), wgt(:)
!
 contains
!====================================================================================
 subroutine pca_initialize()
 character(len=vartaglen) :: keyword
 int :: l
 float :: totmass=zero
 __IAM(PCA_INIT)
!
 if (.not. system_initialized) then 
  call warning(whoami, ' System not initialized. Cannot proceed.', -1)
 endif
 if (fatal_warning(__COMM)) return
!
#define __CONTEXT __CTX
!
#define __CHAR
#define __WARNIFMISSING
!
#define __VAR	trajectory_file
#define __TAG	trajectory_file
#define __NAME	trajectory file name
#include "parser/parser_macro1.src"
!
#undef __WARNIFMISSING
#define __DEFAULT
#define __VAR	trajectory_type
#define __TAG	trajectory_type
#define __NAME	trajectory file format
#define __DEFAULT_VAL 'DCD'
#include "parser/parser_macro1.src"
!
#define __VAR	covmat_file
#define __TAG	covmat_output
#define __NAME	covariance matrix file name
#define __DEFAULT_VAL 'NONE'
#include "parser/parser_macro1.src"
!
#define __VAR	covmat_type
#define __TAG	covmat_type
#define __NAME	covariance matrix file format
#define __DEFAULT_VAL 'BINARY'
#include "parser/parser_macro1.src"
!
#define __VAR	avg_file
#define __TAG	average_output
#define __NAME	average coordinates file name
#define __DEFAULT_VAL 'NONE'
#include "parser/parser_macro1.src"
!
#define __VAR	avg_type
#define __TAG	average_type
#define __NAME	average coordinates file format
#define __DEFAULT_VAL 'CHARMM'
#include "parser/parser_macro1.src"
!
#define __VAR	evec_file
#define __TAG	evec_output
#define __NAME	eigenvectors file name
#define __DEFAULT_VAL 'NONE'
#include "parser/parser_macro1.src"
!
#define __VAR	evec_type
#define __TAG	evec_type
#define __NAME	eigenvectors file format
#define __DEFAULT_VAL 'BINARY'
#include "parser/parser_macro1.src"
!
#define __VAR	evec_inds_str
#define __TAG	evec_inds
#define __NAME	indices of eigenvectors for output
#define __DEFAULT_VAL '1 THRU 10'
#include "parser/parser_macro1.src"
!
#define __VAR	eval_file
#define __TAG	eval_output
#define __NAME	eigenvalues file name
#define __DEFAULT_VAL 'NONE'
#include "parser/parser_macro1.src"
!
#define __VAR	sbfit
#define __TAG	bestfit
#define __NAME	use best-fitting 
#define __DEFAULT_VAL 'YES'
#include "parser/parser_macro1.src"
!
#define __VAR	sfirst_frame
#define __TAG	first_frame
#define __NAME	first frame
#define __DEFAULT_VAL 'FIRST'
#include "parser/parser_macro1.src"
!
#define __VAR	slast_frame
#define __TAG	last_frame
#define __NAME	last frame
#define __DEFAULT_VAL 'LAST'
#include "parser/parser_macro1.src"
!
#undef __CHAR
#define __INT
#define __LEZEROERR
#define __VAR	stride_frame
#define __TAG	stride_frame
#define __NAME	frame stride
#define __DEFAULT_VAL 1
#include "parser/parser_macro1.src"
!
#undef __LEZEROERR
#undef __INT
#define __BOOL
#define __VAR	qmass
#define __TAG	mass
#define __NAME	use mass weighting
#define __DEFAULT_VAL .true.
#include "parser/parser_macro1.src"
!
#define __VAR	qentropy
#define __TAG	entropy
#define __NAME	compute quasiharmonic entropy
#define __DEFAULT_VAL .true.
#include "parser/parser_macro1.src"
!
#undef __BOOL
#define __VAR	temperature
#define __TAG	quasi_temp
#define __NAME	temprature (Kelvin) for entropy calculation
#define __DEFAULT_VAL 300.0d0
#include "parser/parser_macro1.src"
!
! process bestfit
 call toupper(sbfit);
 select case(sbfit)
  case ('ITER','ITERATIVE') ; qbfit=.true. ; qbfit_iter=.true.
  case default
   qbfit_iter=.false. ; qbfit=atol(sbfit);
 end select
! process eigenvector list
 call toupper(evec_inds_str)
 call ilist_parse(evec_inds, evec_inds_str) ! extract evector indices
!
! interpret frame request
 call toupper(sfirst_frame)
 select case(sfirst_frame)
  case('FIRST','BEG') ; first_frame=1 ! duh
  case default 
   first_frame=atoi(sfirst_frame)
 end select
 call toupper(slast_frame)
 select case(slast_frame)
  case('FIRST','BEG') ; last_frame=1 ! duh
  case('LAST','END','FINAL') ; last_frame = -1 ! speecial code for last frame
  case default 
   last_frame=atoi(slast_frame)
 end select
! check fram limits
 if ( ( (first_frame+stride_frame>last_frame).and.(last_frame.ne.-1) ).or.&
    & (first_frame.le.-1).or.(last_frame.lt.-1)) then
  call warning(whoami, 'Invalid frame range specified: '//trim(sfirst_frame)//' : '//itoa(stride_frame)//&
    &                  ' : '//trim(slast_frame)//'. Abort.',-1)
  return
 endif
!
! allocate variables
 natoms=atoms%last
!
 allocate(wgt(natom))                        ! weights
 if (qmass) then ; wgt=m; else ; wgt=one ; endif
 totmass=abs(sum(wgt)); if (totmass.gt.__ERRTOL) then ; totmass=one/totmass; else ; totmass=one ; endif ; wgt=wgt*totmass
!
 allocate(ravg(3,natom)) ; ravg=zero;        ! average structure
 allocate(rcov(3*natom,3*natom)) ; rcov=zero ! covariance matrix
!
 if (.not.fatal_warning(__COMM)) pca_initialized=.true.
!
end subroutine pca_initialize
!============================
subroutine pca_done()
 pca_initialized=.false.
! deallocate trajectory data
 __FREE(wgt)
end subroutine pca_done
!============================
subroutine pca_compute()
 use charmmio
__IAM(PCA_COMPUTE)
#include "files/fopen.def"
 int :: fid, ioerr, iframe, nframes, i, fido
 float, pointer :: r(:,:), rref(:,:)
 int, pointer :: freeatoms(:)
 real*8, pointer :: unitcell(:)
 float :: t, u(3,3)=Id3;
 bool :: readheader = .true.
 character(len=10) :: tmpdcd='__dmol.tmp'

 if (.not. pca_initialized) then
  call warning (whoami, 'PCA module not initialized. Cannot proceed.',-1)
  return
 endif

 call toupper(trajectory_type)
 select case(trajectory_type)
  case('DCD', 'CHARMM', 'XPLOR','NAMD');
 __FOPEN(trajectory_file,'UNFORMATTED','READ',fid)

  call message(whoami, 'Computing average structure using frames in the range: '//&
  & trim(sfirst_frame)//' : '//itoa(stride_frame)//' : '//trim(slast_frame)//'.')
  if (qbfit) then ; call message(whoami, 'Will use best-fitting');
   if (qmass) call message(whoami, 'Will use mass-weighting');
  endif
!
! skip first_frame-1 frames, return number of frames read in iframe
  nframes=0
  ioerr=dcd_read_frame(fid, ravg, readheader, freeatoms, unitcell, first_frame, iframe);
!write(0,*) first_frame, iframe, last_frame, associated(freeatoms), associated(unitcell), fid, ioerr
  if (ioerr.ne.0) then
   call warning(whoami, 'Error reading first frame (#'//itoa(first_frame)//'). Abort.',-1); return
  else
   allocate(rref(3,natoms), r(3,natoms))
   rref=ravg; __INC(nframes);
! open new trajectory file that will contain only the requested frames and th requested atoms
   call message(whoami,'Opening temporary trajectory file')
__FOPEN(tmpdcd,'UNFORMATTED','WRITE',fido)
   ioerr=dcd_write_frame(fido, r, readheader, freeatoms, unitcell); readheader=.false. ;
   if (ioerr.ne.0) call warning(whoami, 'Trajectory write failed with IOSTAT='//itoa(ioerr)//'. Abort.',-1)
   if (fatal_warning(__COMM)) return
!
   do while (( iframe+stride_frame<=last_frame ) .or. last_frame<0) ! read until frame range exceeded, or EOF.
    ioerr=dcd_read_frame(fid, r, readheader, freeatoms, unitcell, stride_frame, i); iframe=iframe+i ! keep track of the number of frames
!write(0,*) iframe, stride_frame, ioerr
    if (ioerr.eq.0) then ! process frame 
     if (qbfit) call RMSBestFit(r,rref,wgt,u, QDIMSWAP_=.true.);
     __INC(nframes)
     t=one / (nframes)
     r=matmul(u,r) ! rotate to overlap with rref
     ravg=(one-t)*ravg + t*r
    else ! ioerr>0
     if (last_frame>0) then
      call message(whoami, 'Not enough frames in trajectory ('//itoa(iframe)//'). Abort.', -1);
      __FREE(rref);__FREE(r); return
     else
      last_frame=iframe;
      exit
     endif ! last frame<0
    endif ! ioerr
   enddo ! while
   call message(whoami,'Read '//itoa(nframes)//' trajectory frames.')

 call files_close(fid) 
 call files_close(fido)

  endif ! ioerr.ne.0 (first frame)
!
  case default
   call warning(whoami, 'Trajectory type "'//trim(trajectory_type)//'" is not supported.', -1)
   return
 end select

!================= clean up
 __FREE(freeatoms)
 __FREE(unitcell)
 __FREE(r)
 __FREE(rref)
!
end subroutine pca_compute
!=================================================================================
!
#ifdef __CONTEXT
#undef __CONTEXT
#endif
#define __CONTEXT __PCACTX
#define _IFS1 'INIT','INITIALIZE'
#define _DOS1 initialize
#define _IFS2 'SOLVE','RUN','EXEC', 'COMPUTE'
#define _DOS2 compute
#define _IFS4 'DONE','STOP','END'
#define _DOS4 done
#include "exec.def"
!=================================================================================
end module pca
