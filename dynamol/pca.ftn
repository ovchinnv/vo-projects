#define __CTX __STRING(__PCACTX)
#define __THISCOMM __PCACOMM
#include "multicom_def.src"
module pca
! functioniality to perform principal component analysis (PCA) 
! and related calculations
! TO DO :  prallelization
!=============================================================
 __DEP_PARSER
 __DEP_OUTPUT
 __DEP_MULTICOM
 __DEP_CONST
 use system
 use psf
 use files
 use bestfit
 use parselist
 use ivector
 use mol_formats

 __IMPNONE

 private

 public pca_initialize
 public pca_done
 public pca_compute
 public pca_exec

 bool, save :: pca_initialized=.false.
 int :: msglev = 1
!
 character(len=vartaglen) :: trajectory_file, trajectory_type, covmat_file, covmat_type, avg_file, avg_type,&
    & evec_file, evec_type, evec_inds_str, eval_file, sbfit, sfirst_frame, slast_frame, atom_selection
 bool :: qentropy, qmass, qbfit, qbfit_iter
 type (int_vector) :: evec_inds
 int :: stride_frame, first_frame, last_frame
 int :: natoms=-1
 float :: temperature ! quasiharmonic temperature
 float :: bfit_tol ! tolerance for iterative bestfit
! data arrays
 float, pointer :: ravg(:,:)=>NULL(), rcov(:,:,:,:)=>NULL(), eval(:)=>NULL(), evec(:,:)=>NULL(), wgt(:)=>NULL(), wgtn(:)=>NULL()
 int, pointer :: iatom_selection(:)=>NULL()
!
 contains
!====================================================================================
 subroutine pca_initialize()
 character(len=vartaglen) :: keyword
 int :: l
 float :: totmass
 __IAM(PCA_INIT)
!
 if (.not. system_initialized) then 
  call warning(whoami, ' System not initialized. Cannot proceed.', -1)
 endif
 if (fatal_warning(__COMM)) return
!
#define __CONTEXT __CTX
!
#define __CHAR
#define __WARNIFMISSING
!
#define __VAR	trajectory_file
#define __TAG	trajectory_file
#define __NAME	trajectory file name
#include "parser/parser_macro1.src"
!
#undef __WARNIFMISSING
#define __DEFAULT
#define __VAR	trajectory_type
#define __TAG	trajectory_type
#define __NAME	trajectory file format
#define __DEFAULT_VAL 'DCD'
#include "parser/parser_macro1.src"
!
#define __VAR	covmat_file
#define __TAG	covmat_output
#define __NAME	covariance matrix file name
#define __DEFAULT_VAL 'NONE'
#include "parser/parser_macro1.src"
!
#define __VAR	covmat_type
#define __TAG	covmat_type
#define __NAME	covariance matrix file format
#define __DEFAULT_VAL 'BINARY'
#include "parser/parser_macro1.src"
!
#define __VAR	avg_file
#define __TAG	average_output
#define __NAME	average coordinates file name
#define __DEFAULT_VAL 'NONE'
#include "parser/parser_macro1.src"
!
#define __VAR	avg_type
#define __TAG	average_type
#define __NAME	average coordinates file format
#define __DEFAULT_VAL 'CHARMM'
#include "parser/parser_macro1.src"
!
#define __VAR	evec_file
#define __TAG	evec_output
#define __NAME	eigenvectors file name
#define __DEFAULT_VAL 'NONE'
#include "parser/parser_macro1.src"
!
#define __VAR	evec_type
#define __TAG	evec_type
#define __NAME	eigenvectors file format
#define __DEFAULT_VAL 'BINARY'
#include "parser/parser_macro1.src"
!
#define __VAR	evec_inds_str
#define __TAG	evec_inds
#define __NAME	indices of eigenvectors for output
#define __DEFAULT_VAL '1 THRU 10'
#include "parser/parser_macro1.src"
!
#define __VAR	eval_file
#define __TAG	eval_output
#define __NAME	eigenvalues file name
#define __DEFAULT_VAL 'NONE'
#include "parser/parser_macro1.src"
!
#define __VAR	sbfit
#define __TAG	bestfit
#define __NAME	use best-fitting 
#define __DEFAULT_VAL 'YES'
#include "parser/parser_macro1.src"
!
#define __VAR	sfirst_frame
#define __TAG	first_frame
#define __NAME	first frame
#define __DEFAULT_VAL 'FIRST'
#include "parser/parser_macro1.src"
!
#define __VAR	slast_frame
#define __TAG	last_frame
#define __NAME	last frame
#define __DEFAULT_VAL 'LAST'
#include "parser/parser_macro1.src"
!
#define __VAR	atom_selection
#define __TAG	atom_selection
#define __NAME	atom selection
#define __DEFAULT_VAL 'ALL'
#include "parser/parser_macro1.src"
!
#undef __CHAR
#define __INT
#define __LEZEROERR
#define __VAR	stride_frame
#define __TAG	stride_frame
#define __NAME	frame stride
#define __DEFAULT_VAL 1
#include "parser/parser_macro1.src"
!
#undef __LEZEROERR
#undef __INT
#define __BOOL
#define __VAR	qmass
#define __TAG	mass
#define __NAME	use mass weighting in best-fitting
#define __DEFAULT_VAL .true.
#include "parser/parser_macro1.src"
!
#define __VAR	qentropy
#define __TAG	entropy
#define __NAME	compute quasiharmonic entropy
#define __DEFAULT_VAL .true.
#include "parser/parser_macro1.src"
!
#undef __BOOL
#define __VAR	temperature
#define __TAG	quasi_temp
#define __NAME	temprature (Kelvin) for entropy calculation
#define __DEFAULT_VAL 300.0d0
#include "parser/parser_macro1.src"
!
#define __VAR	bfit_tol
#define __TAG	bestfit_tol
#define __NAME	Tolerance for iterative bestfit calculation
#define __DEFAULT_VAL __ERRTOL*100d0
#include "parser/parser_macro1.src"
! process bestfit
 call toupper(sbfit);
 select case(sbfit)
  case ('ITER','ITERATIVE') ; qbfit=.true. ; qbfit_iter=.true.
  case default
   qbfit_iter=.false. ; qbfit=atol(sbfit);
 end select
! process eigenvector list
 call toupper(evec_inds_str)
 call ilist_parse(evec_inds, evec_inds_str) ! extract evector indices
!
! interpret frame request
 call toupper(sfirst_frame)
 select case(sfirst_frame)
  case('FIRST','BEG') ; first_frame=1 ! duh
  case default 
   first_frame=atoi(sfirst_frame)
 end select
 call toupper(slast_frame)
 select case(slast_frame)
  case('FIRST','BEG') ; last_frame=1 ! duh
  case('LAST','END','FINAL') ; last_frame = -1 ! speecial code for last frame
  case default 
   last_frame=atoi(slast_frame)
 end select
! check frame limits
 if ( ( (first_frame+stride_frame>last_frame).and.(last_frame.ne.-1) ).or.&
    & (first_frame.le.-1).or.(last_frame.lt.-1)) then
  call warning(whoami, 'Invalid frame range specified: '//trim(sfirst_frame)//' : '//itoa(stride_frame)//&
    &                  ' : '//trim(slast_frame)//'. Abort.',-1)
  return
 endif
! interpret output options
! 1) average structure
 if (avg_file.ne.'NONE') then
  call toupper(avg_type)
  if (all(mol_format_name.ne.avg_type)) &
   call warning(whoami, 'Coordinate format "'//trim(avg_type)//'" for is  not supported. Abort.',-1)
 endif
! 2) average structure
 if (covmat_file.ne.'NONE') then
  call toupper(covmat_type)
  select case(covmat_type)
   case ('BINARY','BIN','UNFORMATTED','ASCII','TEXT','TXT'); ! nothing
   case default
    call message(whoami, 'File format "'//trim(covmat_type)//'" is not supported. Abort.',-1); return
  end select
 endif
!
! interpret atom selection
 iatom_selection=>system_getind(atom_selection)
 if (.not.associated(iatom_selection)) then
  call warning(whoami, 'Error processing atom selection. Abort.',-1) ;  return
 endif
!
! allocate variables
 natoms=atoms%last
!
 allocate(wgt(natoms)) ! weights for covariance matrix
 wgt=m ! masses
 if (qbfit) then
  allocate(wgtn(natoms))
  if (qmass) then ; wgtn=m; totmass=abs(sum(wgtn)) ; else ; wgtn=one ; totmass=natoms ; endif
  if (totmass.gt.__ERRTOL) then ; totmass=one/totmass; else ; totmass=one ; endif ; wgtn=wgtn*totmass
 endif
!
 allocate(ravg(3,natom)) ; ravg=zero;        ! average structure
 allocate(rcov(3,natom,3,natom)) ; rcov=zero ! covariance matrix
!
 if (.not.fatal_warning(__COMM)) pca_initialized=.true.
!
end subroutine pca_initialize
!============================
subroutine pca_done()
 pca_initialized=.false.
! deallocate trajectory data
 __FREE(wgt)
 __FREE(wgtn)
 __FREE(ravg)
 __FREE(rcov)
 __FREE(eval)
 __FREE(evec)
 __FREE(iatom_selection)
end subroutine pca_done
!============================
subroutine pca_compute()
 use charmmio
 use corio
 use fieldio
 __DEP_CONST
__IAM(PCA_COMPUTE)
 int :: fid, ioerr, iframe, nframes, i, fido
 int :: j, k, a, b ! indices
 float, pointer :: r(:,:)=>NULL(), rref(:,:)=>NULL()
 int, pointer :: freeatoms(:)=>NULL()
 real*8, pointer :: unitcell(:)=>NULL()
 float :: t, u(3,3)=Id3, rr
 float :: rmsdavg ! rmsd between successive average structures (for iterative bestfit)
 bool :: readheader = .true., ok
 character(len=10) :: tmpdcd='__dmol.tmp'

 if (.not. pca_initialized) then
  call warning (whoami, 'PCA module not initialized. Cannot proceed.',-1)
  return
 endif

 call toupper(trajectory_type)
 select case(trajectory_type)
  case('DCD', 'CHARMM', 'XPLOR','NAMD');
 __FOPEN(trajectory_file,'UNFORMATTED','READ',fid)

  call message(whoami, 'Computing average structure using frames in the range: '//&
  & trim(sfirst_frame)//' : '//itoa(stride_frame)//' : '//trim(slast_frame)//'.')
  if (qbfit) then ; call message(whoami, 'Will use best-fitting');
   if (qmass) call message(whoami, 'Will use mass-weighting');
  endif
!
! skip first_frame-1 frames, return number of frames read in iframe
  nframes=0
  ioerr=dcd_read_frame(fid, ravg, readheader, freeatoms, unitcell, first_frame, iframe);
!write(0,*) first_frame, iframe, last_frame, associated(freeatoms), associated(unitcell), fid, ioerr
  if (ioerr.ne.0) then
   call warning(whoami, 'Error reading first frame (#'//itoa(first_frame)//'). Abort.',-1); goto 999
  endif
!
  allocate(rref(3,natoms), r(3,natoms))
  rref=ravg; __INC(nframes);
!========================== open new trajectory file that will contain only the requested frames (and the requested atoms)
   call message(whoami,'Opening temporary trajectory file')
__FOPEN(tmpdcd,'UNFORMATTED','WRITE',fido)
  ioerr=dcd_write_frame(fido, r, readheader, freeatoms); readheader=.false. ;
  if (ioerr.ne.0) call warning(whoami, 'Trajectory write failed with IOSTAT='//itoa(ioerr)//'. Abort.',-1)
!write(0,*) ioerr, fatal_warning(__COMM)
  if (fatal_warning(__COMM)) goto 999
!
  do while (( iframe+stride_frame<=last_frame ) .or. last_frame<0) ! read until frame range exceeded, or EOF.
    ioerr=dcd_read_frame(fid, r, readheader, freeatoms, unitcell, stride_frame, i); iframe=iframe+i ! keep track of the number of frames
!write(0,*) iframe, stride_frame, ioerr
    if (ioerr.eq.0) then ! process frame 
     if (qbfit) call RMSBestFit(r,rref,wgtn,u, QDIMSWAP_=.true.);
     __INC(nframes)
     t=one / (nframes)
! write frame to output dcd file (before rotation to avoid precision loss)
     ioerr=dcd_write_frame(fido, r, readheader, freeatoms);
     if (ioerr.ne.0) then ; call warning(whoami, 'Trajectory write failed with IOSTAT='//itoa(ioerr)//'. Abort.',-1); goto 999 ; endif
!
     r=matmul(u,r) ! rotate to overlap with rref
     ravg=(one-t)*ravg + t*r
    else ! ioerr>0
     if (last_frame>0) then
      call message(whoami, 'Not enough frames in trajectory ('//itoa(iframe)//'). Abort.', -1); goto 999
     else
      last_frame=iframe;
      exit
     endif ! last frame<0
    endif ! ioerr
  enddo ! while
  call message(whoami,'Read '//itoa(nframes)//' trajectory frames.')
  call files_close(fid)
  call files_close(fido)
!================================= perform bestfit iteratively, if requested
  if (qbfit.and.qbfit_iter) then
   call message(whoami, 'Performing iterative bestfit to compute optimal average structure.');
   rmsdavg=rmsd(ravg, rref, wgtn, qdimswap_=.true.)
   call message(whoami, ' ===> Log10(RMSD) between successive average structures: '//&
     &ftoa(log10(max(__ERRTOL, rmsdavg))))
!
   do while (rmsdavg.gt.bfit_tol)
    __FOPEN(tmpdcd,'UNFORMATTED','READ',fid)
    readheader=.true.
    do i=1,nframes
     ioerr=dcd_read_frame(fid, r, readheader, freeatoms, unitcell); readheader=.false.
     if (ioerr.ne.0) then 
      call warning(whoami, 'Reading temporary trajectory failed with IOSTAT='//itoa(ioerr)//'. Abort.',-1); goto 999 ;
     endif
     call RMSBestFit(r,ravg,wgtn,u, QDIMSWAP_=.true.);
     t=one / i
     rref=(one-t)*rref + t*matmul(u,r)
    enddo
    call files_close(fid)
    rmsdavg=rmsd(ravg, rref, wgtn, qdimswap_=.true.)
    ravg=rref;
!
    call message(whoami, ' ===> Log10(RMSD) between successive average structures: '//&
     &ftoa(log10(max(__ERRTOL, rmsdavg))))
   enddo
  endif ! qbfit
!================================= write average structure, if requested
  if (avg_file.ne.'NONE') then
   ok=corio_write(avg_file, avg_type, ravg, B=wgt)
   if (.not.ok) call warning(whoami, 'Could not write average structure.',0);
  endif ! avg_file
!================================= compute covariance matrix
  call message(whoami, 'Computing covariance matrix.');
! iterate over trajectory one more time 
  __FOPEN(tmpdcd,'UNFORMATTED','READ',fid)
  readheader=.true.
!
  do i=1,nframes
   ioerr=dcd_read_frame(fid, r, readheader, freeatoms, unitcell); readheader=.false.
   if (ioerr.ne.0) then 
    call warning(whoami, 'Reading temporary trajectory failed with IOSTAT='//itoa(ioerr)//'. Abort.',-1); goto 999 ;
   else
    call message(whoami, 'Processing frame '//itoa(i));
   endif
   call RMSBestFit(r,ravg,wgtn,u, QDIMSWAP_=.true.);
   r=matmul(u,r)-ravg
!   t=one / i
   do k=1,natoms ! do not know how to make this faster
    do b=1,3
     rr=r(b,k);
     do j=1, k-1
      do a=1,3
!       rcov(a, j, b, k) = rcov(a, j, b, k) + t * ( r(a,j)*rr - rcov(a, j, b, k) ) ; ! NOTE: this is not a running variance -- correct only at the end 
       rcov(a, j, b, k) = rcov(a, j, b, k) + r(a,j)*rr ! simplest method
!
      enddo
     enddo
! j=k case: (block diagonal)
     j=k
     do a=1,b ! lower limits
!      rcov(a, j, b, k) = rcov(a, j, b, k) + t * ( r(a,j)*rr - rcov(a, j, b, k) )
      rcov(a, j, b, k) = rcov(a, j, b, k) + r(a,j)*rr
     enddo
    enddo ! b
   enddo ! k
  enddo ! frames
!
! normalization and mass-weighting
  wgt=sqrt(wgt/natoms)
  do k=1,natoms ! do not know how to make this faster
   do b=1,3
    do j=1, k-1
     do a=1,3 ; rcov(a,j,b,k) = rcov(a,j,b,k) * wgt(j) * wgt(k) ; rcov(b,k,a,j) = rcov(a,j,b,k) ;  enddo
    enddo ! j
    do a=1,b ; rcov(a,k,b,k) = rcov(a,k,b,k) * wgt(k)**2; rcov(b,k,a,k) = rcov(a,k,b,k) ; enddo
   enddo ! b
  enddo ! k
!================================= write covariance matrix, if requested
  if (covmat_file.ne.'NONE') then
   call message(whoami, 'Writing mass-weighted covariance matrix.');
   ok=fieldio_write_scalar3D(covmat_file, 'CHEST', covmat_type, rcov, 3*natoms, 3*natoms, 1)
   if (.not.ok) call warning(whoami, 'Could not write covariance matrix.',0);
  endif ! covmat_file
!================================== diagonalize covariance matrix



!
  case default
   call warning(whoami, 'Trajectory type "'//trim(trajectory_type)//'" is not supported.', -1); goto 999
 end select

 999 continue
!================= clean up
 call files_close(fid, 1) ! keep quiet if not open
 call files_close(fido,1)
 __FREE(freeatoms)
 __FREE(unitcell)
 __FREE(r)
 __FREE(rref)
!
end subroutine pca_compute
!=======================================================================
!
#ifdef __CONTEXT
#undef __CONTEXT
#endif
#define __CONTEXT __PCACTX
#define _IFS1 'INIT','INITIALIZE'
#define _DOS1 initialize
#define _IFS2 'SOLVE','RUN','EXEC', 'COMPUTE'
#define _DOS2 compute
#define _IFS4 'DONE','STOP','END'
#define _DOS4 done
#include "exec.def"
!=================================================================================
end module pca
