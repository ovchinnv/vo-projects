! to "regularize" variation of applied forces with the contour value, 
! use a rough approximation to the inverse of the filter CDF;
! for efficiency, use a logistic function matched to the Gaussian filter
!
! to avoid divide iverflow, define minimum density as the smallest float in single precision
#define  __RHO_MIN FERRTOL()
#define  __RHO(_X) ( one/(one+exp(-_X/logistic_constant)) )
#define  __RHO_INVERSE(_L) ( - logistic_constant * log ( one/(max(_L,__RHO_MIN)) - one) )
!
#define __CTX __WATERSHELLCTX
#define __RESTARTCTX __CONCAT(__WATERSHELLCTX,_RESTART)
#//define __CHKUPDATE(_WHAT)   ( (mod(iteration, _WHAT) .eq. ione) .or. _WHAT.eq.ione )
#define __CHKUPDATE(_WHAT)   (mod(iteration, _WHAT) .eq. izero)

module _N

 use system, only : r, rcomp, fr, radius, natom, system_PDB_initialized, system_PDB_init, system_done, system_getind, &
&                   system_init_mol_scalar_nocase
 __DEP_OUTPUT
 __DEP_PARSER
 __DEP_CONST
 __DEP_FILES
 __DEP_MPI
 __IMPNONE

 private

 public __NM(initialize)
 public __NM(main)
 public __NM(done)
 private __NM(write_restart_file)
!
! hack to make variables from system visible from plugin
 public natom
 public r
 public fr

 bool, public :: __NM(initialized)=.false.
 bool, private:: radii_initialized=.false.

! macro for parameters with defaults
#define __PAR(_PAR,_TYPE,_DEF) _TYPE, save :: _PAR ; _TYPE, parameter :: __CONCAT(default_,_PAR)=_DEF;
!
! surface computation parameters :
! __PAR(surface_contour_value, float, -one) ! value of density isosurface which is defines the surface ; negative means to compute from structure
 __PAR(surface_distance, float, zero)! approximate distance from surface ; obtained by inverting logistic function of density (as an approximation)
 __PAR(cutoff_surf_stdev,float,5d0)  ! grid smoothing cutoff normalized by standard deviation of gaussian (surface)
 __PAR(surf_padding,float,0d0)       ! ( units of radius ) padding values to radii which might account for e.g. solvent layer(s)
 __PAR(surf_stdev,float,2d0)         ! standard deviation of smoothing filter
!
 float :: cutoff_surf, cutoff_surf2, oo_surf_stdev, logistic_constant
 float :: surface_contour_value ! value of density isosurface which is defines the surface ; negative means to compute from structure
!
 __PAR(iteration,int,izero)   ! iteration
! surface evolution and output parameters
 __PAR(distance_update_freq, int, ione)          ! frequency of updating distance value
 __PAR(distance_update_step, float, 0.001d0)     ! constant for update
 __PAR(structure_update_freq, int, ione)         ! frequency of updating coordinats from which the surface is generated
 __PAR(structure_update_memory, float, 0.999d0)  ! memory constant for exponential update
 __PAR(output_file_freq, int, 1000)              ! frequency of writing output file
 __PAR(restart_file, character(len=vartaglen), 'NONE') ! restart file name
 __PAR(structure_file, character(len=vartaglen),'NONE') ! coordinate file (e.g. PDB) with system information, such as atomic radii
 __PAR(output_file, character(len=vartaglen), 'watershell.restart.txt') ! output file name
 __PAR(surface_force_constant, float, one)      ! surface restraint force constant
 __PAR(target_surface_energy, float, 0.001d0) ! target average energy of surface potential / par area ( units of pressure or normal stress )
!
!  atom selections
 __PAR(surface_atom_selection, character(len=vartaglen), 'ANAME=CA')  ! protein CA trace
 __PAR(solvent_atom_selection, character(len=vartaglen), 'ANAME=OH2') ! TIP3 oxygens atoms
 int, pointer, public :: isurface_atoms(:)=>NULL()
 int, pointer, public :: isolvent_atoms(:)=>NULL()
!
 float, pointer :: r_surf(:,:), & ! reference atom coordinates
&                  rad_surf(:), & ! reference atom radii
&                  r_solv(:,:), & ! solvent atom coordinates
&                  rho_solv(:), & ! density value at solvent coordinate
&                  drho_solv(:,:) ! density gradient at solvent coordinate (inward surface normal)
 int, public :: nsurface=-1, nsolvent=-1
 float :: oonsolvent
!
 int :: fid
 bool :: qrestart=.false. ! whether we are restarting from a restart file
!
 float, private, parameter :: osq2=one/sqrt2
 float, private, parameter :: osq2pi=one/sqrt(twopi)
!
!= subroutines
 contains
!========
 __SUB(initialize) ()
 character(len=vartaglen) :: keyword, context
 int :: l, ierr
 character(len=maxlinelen) :: line
 float, pointer :: farray(:) => NULL()
 __IAM(__NM(INITIALIZE))
!
#define __CONTEXT __STRING(__CTX)
 context=__CONTEXT ;
#define __DEFAULT
! first, check for restart file
! if present, read it and skip initialization options
! read restart file
#define __CHAR
#define __VAR	restart_file
#define __TAG	restart_file
#define __NAME	restart file
#include "parser/parser_macro2.src"
#undef __CHAR
!
 qrestart = ( existtag_nocase('restart_file', context) .and. trim(ftoupper(restart_file)).ne.'NONE')
!
 if (qrestart) then
  __MESSAGE(whoami,' WILL READ SURFACE DEFINITION PARAMETERS FROM RESTART FILE.')
! read and parse restart file
  fid=-1
  call files_open(fid, restart_file, 'FORMATTED', 'READ')
  call parse_file(fid, &
#ifdef __PARALLEL
 &  MPI_COMM_NULL, &
#endif
 &  quiet_=.false.)
  call files_close(fid)
! now comes a trick : change context name temporarily to process the restart file using the same calls
  context= __STRING(__RESTARTCTX)
!
 endif ! have restart file
!
#define __MINUSERR
! density padding
#define __VAR	surf_padding
#define __TAG __VAR
#define __NAME	Density padding
#include "parser/parser_macro2.src"
!
#undef __MINUSERR
! value for density isosurface
! abandoning this in favor of distance
!#define __VAR	surface_contour_value
!#define __TAG __VAR
!#define __NAME	Value for density isosurface
!#define __DOIFOK if (__VAR.le.zero) __MESSAGE(whoami, ' DENSITY ISOSURFACE VALUE WILL BE COMPUTED FROM COORDINATES.')
!#include "parser/parser_macro2.src"
! value for distance of the surface from protein (approximate)
#define __VAR	surface_distance
#define __TAG __VAR
#define __NAME	Distance of solvent surface from protein
#define __DOIFOK if (__VAR.lt.__ERRTOL) then ; \
                  __MESSAGE(whoami, ' LOCATION OF SOLVENT SURFACE WILL BE SET FROM SOLVENT COORDINATES.') ; \
                 else ;\
                  __VAR=-(abs(__VAR)) ; \
                  surface_contour_value=__RHO(surface_distance) ;\
                 endif ! make sure to set a negative value
!
#include "parser/parser_macro2.src"
!
#define __VAR surface_force_constant
#define __TAG __VAR
#define __NAME force constant for surface potential
#define __DOIFOK if (__VAR.lt.__ERRTOL) __WRN(whoami, ' SURFACE FORCE IS OFF.')
#include "parser/parser_macro2.src"
!
#define __LEZEROERR
! cutoff for density
#define __VAR	cutoff_surf_stdev
#define __TAG __VAR
#define __NAME	Cutoff for density smoothing
#include "parser/parser_macro2.src"

! GAUSSIAN standard deviations for smoothing
#define __VAR	surf_stdev
#define __TAG __VAR
#define __NAME	Standard deviation of Gaussian filter for density smoothing
#include "parser/parser_macro2.src"

#undef __LEZEROERR
#define __MINUSERR

! ====== done with (possible) restart file data
 context=__CONTEXT ! reset context if changed
! other parameters
#define __INT
#define __DEFAULT
#define __WARNIFMISSING
#define __INT
#define __VAR	iteration
#define __TAG	__VAR
#define __NAME	starting iteration
!
#include "parser/parser_macro2.src"
#define __VAR	distance_update_freq
#define __TAG	__VAR
#define __NAME	frequency of updating target distance from surface
#define __DOIFOK if (__VAR.eq.izero) __MESSAGE(whoami, ' UPDATE OF SURFACE DISTANCE VALUE IS OFF.')
#include "parser/parser_macro2.src"
!
#define __VAR	structure_update_freq
#define __TAG	__VAR
#define __NAME	frequency of updating reference structure
#define __DOIFOK if (__VAR.eq.izero) __MESSAGE(whoami, ' SURFACE UPDATE IS OFF.')
#include "parser/parser_macro2.src"
!
#define __VAR	output_file_freq
#define __TAG	__VAR
#define __NAME	frequency for writing output/restart file
#define __DOIFOK if (__VAR.le.izero) __WRN(whoami, ' RESTART FILE WILL BE WRITTEN AT THE END ONLY')
#include "parser/parser_macro2.src"
#undef __INT
!
! output file
#define __CHAR
! read structure file
#define __VAR	structure_file
#define __TAG	__VAR
#define __NAME	structure file
#include "parser/parser_macro2.src"
! read atom selections
! atoms to define surface
#define __CHAR
#define __WARNIFMISSING
#define __VAR	surface_atom_selection
#define __TAG	surface_atoms
#define __NAME	surface atoms
#include "parser/parser_macro2.src"
! (solvent) atoms to which surface forces are applied
#define __VAR	solvent_atom_selection
#define __TAG	solvent_atoms
#define __NAME	solvent atoms
#include "parser/parser_macro2.src"
!
#undef __WARNIFMISSING
#define __VAR	output_file
#define __TAG	__VAR
#define __NAME	watershell output file
#include "parser/parser_macro2.src"
#undef __CHAR
!
#undef __MINUSERR
#define __LEZEROERR
!
#define __VAR distance_update_step
#define __TAG __VAR
#define __NAME memory constant for surface contour update
#define __DOIFOK if (__VAR.le.zero) __WRN(whoami, ' UPDATE OF SURFACE CONTOUR REFERENCE VALUE IS OFF.')
#include "parser/parser_macro2.src"
!
#define __VAR structure_update_memory
#define __TAG __VAR
#define __NAME memory constant for reference structure update
#define __DOIFOK if (__VAR.le.zero) then ; __WRN(whoami, ' SURFACE UPDATE IS OFF.') ; \
 elseif (__VAR .gt. one ) then ; __WRN(whoami, ftoupper(__STRING(__NAME))//' SHOULD _NOT_ BE GRETER THAN ONE !') ; endif
#include "parser/parser_macro2.src"
!
#define __VAR target_surface_energy
#define __TAG __VAR
#define __NAME target surface energy per area
#define __DOIFOK if (__VAR.lt.__ERRTOL) __WRN(whoami, ' TARGET SURFACE ENERGY IS ALMOST ZERO.')
#include "parser/parser_macro2.src"
!
! read structure file
!
 __MESSAGE(whoami, 'READING STRUCTURE FROM FILE "'//trim(structure_file)//'"');
 call system_PDB_init(structure_file, 'PDB');
 if (.not. fatal_warning()) system_PDB_initialized=.true.
! save coordinates in rcomp, just in case we need them later ?
 if (associated(rcomp) .and. associated(r)) rcomp=r
! initialize radii using a system function

#define __GET_RAD(_TAG)  if (existtag_nocase(__STRING(_TAG),context)) then;\
                            farray=>system_init_mol_scalar_nocase(__STRING(_TAG), context);\
                            radius=farray;\
                            deallocate(farray);\
                            radii_initialized=.true.;
 __GET_RAD(radii)
 else __GET_RAD(radius) ! other tags here
 endif
!
 if (.not.radii_initialized) __WRN(whoami, ' COULD NOT INITIALIZE ATOMIC RADII');
!
! copy coordinates
!
 isurface_atoms=>system_getind(surface_atom_selection)
 if (associated(isurface_atoms)) then
  nsurface=size(isurface_atoms)
  __ALLOC(r_surf(3,nsurface))
  __ALLOC(rad_surf(nsurface))
 else
  __WRN(whoami, ' COULD NOT ALLOCATE MEMORY FOR SURFACE ATOM INDICES.')
 endif
! repeat for solvent atoms
 isolvent_atoms=>system_getind(solvent_atom_selection)
 if (associated(isolvent_atoms)) then
  nsolvent=size(isolvent_atoms) ; oonsolvent=one/nsolvent ;
  __ALLOC(r_solv(3,nsolvent))
  __ALLOC(rho_solv(nsolvent))
  __ALLOC(drho_solv(3,nsolvent))
 else
  __WRN(whoami, ' COULD NOT ALLOCATE MEMORY FOR SOLVENT ATOM INDICES.')
 endif
!
 if  (qrestart) then
! read surface atom coordinates from restart file (context __RESTARTCTX)
  do l=1, nsurface
   line=getval_nocase('rsurf_'//trim(itoa(l)),__STRING(__RESTARTCTX))
   if (len_trim(line).gt.0) then
    read(line,*,iostat=ierr) r_surf(:,l)
    if (ierr.ne.0) then
     __WRN(whoami, 'ERROR READING COORDINATE FROM LINE "'//trim(line)//'"')
     cycle
    endif
   else
    __WRN(whoami, 'ERROR READING COORDINATE FROM LINE "'//trim(line)//'"')
   endif ! line ok
  enddo ! over surface atoms
 else ! qrestart
! take surface atom coordinates from structure (PDB) file
  r_surf=r(:,isurface_atoms)
 endif ! qrestart
!
 rad_surf=radius(isurface_atoms)
!
 oo_surf_stdev=one/surf_stdev
 cutoff_surf  =cutoff_surf_stdev*surf_stdev
 cutoff_surf2 =cutoff_surf**2
! compute constant (=1/a)  for logistic distribution that matches the stdev
! the distribution is a * exp (-xa) / ( 1 + exp (-xa ) )^2
! the corresponding cdf is 1 / ( 1 + exp (-xa) )
 logistic_constant = sqrt3 * opi * surf_stdev ;
!
 if (.not.fatal_warning()) __NM(initialized)=.true.
!
 end __SUB(initialize)
!======================================
 __SUB(write_restart_file) ()
! = adapted from tempering
 __IAM(__NM(WRITE_RESTART_FILE))
 int :: ifile, i
 ifile=-1 ! make sure files_open determines the handle automatically
 call files_open(ifile, output_file, 'FORMATTED','WRITE')
!
#define _W write(ifile,*)
 _W '#WATERSHELL RESTART FILE'
 _W __STRING(__RESTARTCTX)//' {'
 _W 'iteration=',iteration
! _W 'surface_contour_value=',surface_contour_value, ' # value for which density isosurface is computed'
 _W 'surface_distance=',surface_distance, ' # distance of solvent surface from solute'
 _W 'surface_force_constant=',surface_force_constant, ' # surface force constant'
 _W 'surf_stdev=',surf_stdev, ' # standard deviation of Gaussian filter'
 _W 'cutoff_surf_stdev=',cutoff_surf_stdev, ' # distance from center beyond which it set to zero (units of stdandard deviation)'
 _W 'surf_padding=',surf_padding, ' # scalar padding added to each atom radius'
!
! write the current reference atoms :
 _W '# rsurf_i : reference coordinate triple for atom #i used to define surface'
 do i=1, nsurface
  _W 'rsurf_'//trim(itoa(i)),'=(',r_surf(:,i),')'
 enddo ! surface atoms
 _W '}'
! close file
 call files_close(ifile)
!
 end __SUB(write_restart_file)
!================================================================
 __SUB(done)
 __IAM(__NM(done))
 if (__NM(initialized)) then
  __MESSAGE(whoami, ' WRITING RESTART FILE.')
  call __NM(write_restart_file)()
 endif
!
 call system_done()
 call parser_done()
 __FREE(r_surf)
 __FREE(r_solv)
 __FREE(rad_surf)
 __FREE(rho_solv)
 __FREE(drho_solv)
 __FREE(isurface_atoms)
 __FREE(isolvent_atoms)
!
 __NM(initialized)=.false. ; radii_initialized=.false.
!
 end __SUB(done)
!================================================================
 __SUB(main)(r,fr,energy)
 float, intent(in) :: r(:,:)   ! coordinate array
 float, intent(out) :: fr(:,:) ! force array
 float, intent(out) :: energy
! int :: ibeg, iend ! atom indices for looping
 float :: distance_from_solute, distance_from_solute2, pre, d0
 float :: surface_energy, surface_force, density_beyond_contour
 int :: i
 __IAM(__NM(main))
!
!================================================================
 if (.not. __NM(initialized)) then
  __WRN(whoami, ftoupper(__STRING(_N))//' NOT INITIALIZED. NOTHING DONE.');
  return
 endif
!
__INC(iteration)

!============================================= update reference coordinates
 if (structure_update_freq.gt.izero) then
  if __CHKUPDATE(structure_update_freq) then
   r_surf = structure_update_memory * r_surf + (one - structure_update_memory) * r(:,isurface_atoms)
  endif
 endif

!============================================= compute contour value and gradient at solvent coordinates
! compute forces, average density at contour value
! this is the time-consuming part ; it could benefit from GPU acceleration and/or nonbonded lists
! moving down below
! call __NM(compute_density_grad)
!
 surface_energy=zero
 distance_from_solute=zero
 distance_from_solute2=zero ! for computing second moment
!
!========================== compute contour value if needed
! if reference contour value is negative, estimate a reasonable value from density distribution
 if (surface_distance .lt. __ERRTOL) then
  call __NM(compute_density_grad)(.false.) ! need entire sum
  do i=1, nsolvent
! convert to distance
   d0 = __RHO_INVERSE(rho_solv(i))
   __INCR(distance_from_solute, d0)
   __INCR(distance_from_solute2, d0**2)
  enddo
! set contour value to average value + (a) x stdev ; a set empirically
#define _a 2d0
  __SCALE(distance_from_solute,oonsolvent);
  __SCALE(distance_from_solute2,oonsolvent);
  surface_distance = distance_from_solute - & ! average
&                         _a * sqrt( max(zero,distance_from_solute2 - distance_from_solute**2) ) ! analytically positive, but, just in case, protect from roundoff
  surface_contour_value = __RHO(surface_distance)
 else
  call __NM(compute_density_grad)(.true.) ! truncate if value exceeds
 endif
!========================== compute contour value ^
!========================== compute forces :
! calculate density integral using only atoms beyond contour (to estimate surface area)
 density_beyond_contour=zero
!
 do i=1, nsolvent
  if ( rho_solv(i) .lt. surface_contour_value) then
   __INCR(density_beyond_contour, rho_solv(i))
   pre = ( __RHO_INVERSE ( rho_solv(i) ) - surface_distance ) ;
!
! add atomic force
   fr(:,isolvent_atoms(i)) = - surface_force_constant * pre * drho_solv(:,i)
! sum "energy"
   __INCR(surface_force, pre) ! x k, below
   __INCR(surface_energy, pre**2) ! x k/2, below
  endif
 enddo
!
 __SCALE(surface_force, surface_force_constant)
 __SCALE(surface_energy, half*surface_force_constant)
 energy=surface_energy
!
!=========================== evolve/update contour value using surface energy
!
 if (distance_update_freq.gt.izero) then
  if __CHKUPDATE(distance_update_freq) then
! for now, a very simple update strategy
! in the future will add estimation of pressure and surface tension

    d0 = ( target_surface_energy - oonsolvent * surface_energy );
    __INCR(surface_distance, distance_update_step * d0)
    surface_contour_value = __RHO(surface_distance)

  endif
 endif
!============================================= output restart file
 if (output_file_freq.gt.izero) then
  if __CHKUPDATE(output_file_freq) then
!
   __MESSAGE(whoami, ' WRITING OUTPUT/RESTART FILE TO ("'//trim(output_file)//'")')
   call __NM(write_restart_file)
!
  endif
 endif
!
 end __SUB(main)
!================================================================
 __SUB(compute_density_grad)(qtruncate_sum)
 bool :: qtruncate_sum ! whether we can stop computation for each atom once the density reaches a threshold value
 int :: i, j
 float :: rp(3), rw(3), dr(3), dr2, a, b, expa, expb, ooc
 float :: rmaxsurf, rsurf, rsurfn
 __IAM(__NM(compute_density_grad))
! naive algorithm to compute density at each solvent coordinate
! adapted from molecule.ftn in continua
!
! error function definition
#ifndef __erf
#define __erf erf
#endif
#define __SMOOTH_GAUSS(__A,__B,__C)  half * ( __erf (__A) - __erf (__B) ) + osq2pi*( exp(-__A**2) - exp(-__B**2 ) ) /__C

!
 do i=1, nsolvent ! outer loop over solvent atoms
   rho_solv(i)=zero
   drho_solv(:,i)=zero
   rw=r_solv(:,i);
   do j=1, nsurface ! inner loop over solute atoms
! determine if atoms are too far away :
    rp=r_surf(:,j)
!
    rsurf    = ( rad_surf(j) + surf_padding )
    rmaxsurf = ( cutoff_surf  + rsurf  )
!
    dr = rp-rw ;
    if (any(dr .gt. rmaxsurf)) cycle
    dr=dr**2 ; dr2=sum(dr);
    if (dr2 .gt. rmaxsurf**2) cycle
! proceed with calculation
    rsurfn=rsurf * oo_surf_stdev
    dr2 = sqrt(dr2) * oo_surf_stdev
! a and b
    a = osq2 * (dr2 + rsurfn)
    b = osq2 * (dr2 - rsurfn)
    ooc = one / dr2
!
    expa = exp ( - a**2 )
    expb = exp ( - b**2 )
! update density
    __INCR(rho_solv(i), half * ( __erf(a) - __erf(b) ) + osq2pi * ooc * ( expa - expb )   )
    if (qtruncate_sum.and. &
&      (__RHO_INVERSE(rho_solv(i)).gt.surface_contour_value) ) exit ! density threshold exceeded ; will not apply force to this atom
! otherwise, compute gradient contribution : (note that I am flipping the direction of dr (in the notes it is r0-r)
    __SCALE(dr, osq2pi * (ooc*oo_surf_stdev)**2 * ( (expa + expb) * rsurfn + half * (expa - expb) * ooc) )
! add gradient contribution
    __INCR(drho_solv(:,i),dr)
   enddo ! nsurface
 enddo ! nsolvent
!
 end __SUB(compute_density_grad)
!================================================================
end module _N

