! to "regularize" variation of applied forces with the contour value,
! use a rough approximation to the inverse of the filter CDF;
! for efficiency, use a logistic function matched to the Gaussian filter
!
! to avoid divide overflow, define minimum density
#// single precision small number :
!#define  __RHO_MIN FERRTOL()
#// double precision small number :
#define  __RHO_MIN ERRTOL()
#// because the logistic is centered on zero, arguments > 0 map to > 0.5, which puts them inside the shell ; in other words, we truncate densities to at most 0.5 :
#define  __RHO_MAX half
#define  __RHO(_X) ( one/(one+exp(-_X/logistic_constant)) )
#define  __RHOSAFE(_X) (min(__RHO_MAX, __RHO(_X)))
#define  __OORHO(_R) ( one/_R )
#//define  __OORHOSAFE(_R) ( one/(max(_R,__RHO_MIN)))
#// incorporate maximum density into above :
#define  __OORHOSAFE(_R) ( one/(min(__RHO_MAX,max(_R,__RHO_MIN))))
#define  __RHO_INVERSE(_L) ( - logistic_constant * log ( __OORHO(_L) - one) )
#define  __RHO_INVSAFE(_L) ( - logistic_constant * log ( __OORHOSAFE(_L) - one) )
#// if already have 1/rho
#define  __RHO_INVERSE2(_OL) ( - logistic_constant * log ( _OL - one) )
#// with __RHO_MIN specified, we also have the largest possible shell that can be defined ; note the (-) sign convention
#// this value should be considered when evolving the shell distance
#define  __MINSURFDIST __RHO_INVERSE(__RHO_MIN)
!
#define __CTX __WATERSHELLCTX
#define __RESTARTCTX __CONCAT(__WATERSHELLCTX,_RESTART)
#//define __CHKUPDATE(_WHAT)   ( (mod(iteration, _WHAT) .eq. ione) .or. _WHAT.eq.ione )
#define __CHKUPDATE(_WHAT)   (mod(iteration, _WHAT) .eq. izero)

! for openmm local thread variables
#ifdef __OMP
#define _U _
#else
#define _U
#endif
#define __U(_WHAT) __CONCAT(_WHAT,_U)

#if defined(__SORT_LIST ) && defined(__NEIGHBOR_LIST)
! neighbor list length
#// to check a subset of surface atom list
#define __NEIGHBOR_LIST_LENGTH_MINDIST max(1,min(nsurface, INT(solute_neighbor_mind(i) * neighbor_list_factor) ))
#//define __NEIGHBOR_LIST_LENGTH_DENSITY __NEIGHBOR_LIST_LENGTH_MINDIST
#define __NEIGHBOR_LIST_LENGTH_DENSITY max(1,min(nsurface, INT (half * solute_neighbor_mind(i) * neighbor_list_factor) ))
#endif

#ifdef __UNWRAP_PBC
#// note that I assume that _PER is positive, no checks are done
#define __PBCDIST(_DIST,_PER) _DIST=modulo(_DIST, _PER);if(_DIST .gt. half*(_PER)) __DECR(_DIST,_PER)
#define __PBC_DIST(_DIST,_PER) __PBCDIST(_DIST,_PER)
#define __DISTPBC(_DIST,_PER) __PBCDIST(_DIST,_PER)
#define __DIST_PBC(_DIST,_PER) __PBCDIST(_DIST,_PER)
#endif

module _N

 use system, only : r, rcomp, fr, radius, natom, system_PDB_initialized, system_PDB_init, system_done, system_getind, &
#ifdef __DASYSTAT
&                   dasystat_masses=>occupancy, & ! use occupancy to store masses used in density control
#endif
&                   system_init_mol_scalar_nocase
 __DEP_OUTPUT
 __DEP_PARSER
 __DEP_CONST
 __DEP_FILES
 __DEP_MPI
#ifdef __PERTURB_GRID
 __DEP_RANDOM
#define random_channel 50
#endif
 use ugrid
 use unitcell
#ifdef __OMP
 use omp_lib
#endif
 __IMPNONE
 private

 public __NM(initialize)
 public __NM(main)
 public __NM(done)
!
! hack to make variables from system visible from plugin
 public natom
 public iteration
 public structure_update_freq
 public r
 public fr

 bool, public :: __NM(initialized)=.false.
 bool, private:: radii_initialized=.false.
#ifdef __DASYSTAT
 bool, private:: dmasses_initialized=.false. ! for dasystat ; not necessarily atomic, i.e. possibly molecular masses !
#endif
 bool, private :: qper_parser_override=.false. ! to turn off (override) periodicity in parser

! macro for parameters with defaults
#define __PAR(_PAR,_TYPE,_DEF) _TYPE, save :: _PAR ; _TYPE, parameter :: __CONCAT(default_,_PAR)=_DEF;
!
! surface computation parameters :
! __PAR(surface_contour_value, float, -one) ! value of density isosurface which is defines the surface ; negative means to compute from structure
 __PAR(surface_distance, float, zero) ! in the original density method, obtained by inverting logistic function of density (as an approximation)
#ifdef __DASYSTAT
 __PAR(bulk_boundary_distance, float, zero) ! distance to the bulk solvent boundary (should obviously be smaller than the shell surface distance)
#endif
 __PAR(cutoff_surf_stdev,float,5d0)  ! smoothing cutoff normalized by standard deviation of gaussian (surface)
 __PAR(surf_padding,float,0d0)       ! ( units of radius ) padding values to radii which might account for e.g. solvent layer(s)
 __PAR(surf_stdev,float,2d0)         ! standard deviation of smoothing filter
!
 float :: cutoff_surf, cutoff_surf2, oo_surf_stdev, logistic_constant
 float :: surface_contour_value ! value of density which defines the surface ; negative means to compute from structure
#ifdef __DASYSTAT
 float :: bulk_boundary_contour_value ! value of density which defines bulk boundary (will be greater than surface_contour_value)
#endif
!
 __PAR(iteration,INTEGER*8,izero)   ! iteration
!
! surface evolution and output parameters
 __PAR(structure_update_freq, int, ione)         ! frequency of updating coordinates from which the surface is generated
 __PAR(structure_update_memory, float, 0.999d0)  ! memory constant for exponential update
 __PAR(output_freq, int, 1000)                   ! frequency of writing output file
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
 __PAR(full_sum_freq, int, 75)                   ! frequency of force calculation without density truncation
                                                 ! doing the full calculation allows all atoms to be sorted
 __PAR(sort_neighbor_list_freq, int, 10000)      ! frequency of completely sorting the neighbor list
#endif
 __PAR(restart_file, character(len=vartaglen), 'NONE') ! restart file name
 __PAR(structure_file, character(len=vartaglen),'NONE') ! coordinate file (e.g. PDB) with system information, such as atomic radii
 __PAR(output_file, character(len=vartaglen), 'watershell.restart.txt') ! output file name
 __PAR(surface_force_constant, float, one)      ! surface restraint force constant
! __PAR(target_surface_energy, float, 5d0) ! target average energy of surface potential / par area ( units of pressure or normal stress )
#ifdef __RMFT
 __PAR(remove_net_torque, bool, .false.) ! whether to remove net torque on the solvent atom
 __PAR(remove_net_force, bool, .true.)   ! whether to remove net force ( ONLY ACTIVE IF removing net torque )
#endif
 __PAR(qminimum_distance, bool, .false.) ! use the (cheaper) minimum distance method, rather than density method
!
#ifdef __BAROSTAT
! === v barostat parameters v ====
 __PAR(barostat, bool, .false.) ! optional, but if barostat=off then pressure control turned off
 __PAR(pressure_target, float, one) ! units of atm
 float :: oopressure_target
 float, parameter :: akma_per_pa = avogadro * 1d-30 * joule
 float, parameter :: pa_per_akma = 1d0/akma_per_pa 
 float, parameter :: atm_per_akma = atm_per_pa * pa_per_akma ! conversion from akma to atom (~ 14)
 float, parameter :: akma_per_atm = 1d0/atm_per_akma
 __PAR(pressure_num_long_samples, int, 0)    ! number of inst. pressure samples that make up long-time average
 __PAR(pressure_max_long_samples, int, 10000) ! max number of inst. samples to keep in long-time average
 __PAR(pressure_num_samples, int, 0)    ! number of inst. pressure samples that make up long-time average
 __PAR(pressure_max_samples, int, 1000) ! max number of inst. samples to keep in average
 __PAR(pressure_update_freq, int, 10)   ! how often pressure is updated from force and area
#endif
! === ^ barostat parameters ^ ====
#ifdef __DASYSTAT
! === v dasystat parameters v ====
 __PAR(dasystat, bool, .false.) ! optional, but if dasystat=off then density control turned off
 __PAR(density_target, float, 0.997) ! units of g/ml for pure water
 float, parameter :: g_per_amu = 1d0/avogadro
 float, parameter :: ml_per_angstrom3 = 1d-24
 float, parameter :: gml_per_akma = g_per_amu / ml_per_angstrom3 ! density conversion factor ; note that it is dimensional
 __PAR(density_num_samples, int, 0)    ! number of inst. density samples that make up average
 __PAR(density_max_samples, int, 100) ! max number of inst. samples to keep in average
 __PAR(density_update_freq, int, 100)   ! how often density is updated from volume and mass
#ifdef __OMP
 integer*1, allocatable, dimension(:,:,:,:), target :: inrho_all_threads ! density array for computing nonbulk solvent volume
#else
 integer*1, allocatable, dimension(:,:,:), target :: inrho
#endif
! === ^ dasystat parameters ^ ====
#endif
! variables common to barostat and dasystat
#if defined(__BAROSTAT) || defined(__DASYSTAT)
! distance update :
 __PAR(distance_update_freq, int, 10)          ! frequency of updating distance value
 __PAR(distance_update_step, float, 0.001d0)   ! constant for update
! surface area computation parameters (hopefully, adjusting from defaults should be unnecessary)
 __PAR(surface_area_grid_spacing, float, one)
 float :: oo_surface_area_grid_spacing
 __PAR(surface_area_grid_buffer, float, three)
 __PAR(surface_area_compute_freq, int, 10) ! surface area (or volume) gets recomputed every pressure_freq times this
 __PAR(surface_area_grid_check_freq, int, 1) ! if no pbc, sa grid gets checked/updated this times sa_compute_freq x pressure_freq
 __PAR(surface_area_grid_recompute_change, float, three) ! domain size increase/decrease required to trigger grid recomputation
 float :: r_com_sa(3)=(/zero, zero, zero/) ! center of protein for gridding in SA computation
 float :: r_surf_minmax(2,3)=reshape((/zero, zero, zero, zero, zero, zero/),(/2,3/))
 bool :: r_surf_changed=.true. ! for convenience, use flag that keeps track of whether surface atoms have been updated
 bool :: surf_dist_changed=.true. ! simlarly, use flag that keeps track of whether surface distance has changed
 type (grid) :: sagrid
#ifdef __OMP
 integer*1, allocatable, dimension(:,:,:,:), target :: sarho_all_threads ! density array for surface are computation
 real*4, allocatable, dimension(:,:,:,:), target :: sarhof_all_threads   ! density array for surface are computation
#else
 integer*1, allocatable, dimension(:,:,:), target :: sarho
 real*4, allocatable, dimension(:,:,:), target :: sarhof
#endif
#endif
!
!
!  atom selections
 __PAR(surface_atom_selection, character(len=vartaglen), 'ANAME=CA')  ! protein CA trace
 __PAR(solvent_atom_selection, character(len=vartaglen), 'ANAME=OH2') ! TIP3 oxygens atoms
 int, pointer, public :: isurface_atoms(:)=>NULL()
 int, pointer, public :: isolvent_atoms(:)=>NULL()
!
 float, pointer :: r_surf(:,:), & ! reference atom coordinates
&                  rad_surf(:), & ! reference atom radii
&                  r_solv(:,:), & ! solvent atom coordinates
#ifdef __DASYSTAT
&                  mass_solv(:), & ! solvent atom/molecular mass
#endif
&                  rho_solv(:), & ! density value at solvent coordinate
&                  drho_solv(:,:),& ! density gradient at solvent coordinate (inward surface normal)
&                  dist_solv(:), &! minimum distance to solute
&                  ddist_solv(:,:) ! distance gradient at solvent coordinate (inward surface normal)
 bool, pointer :: qforced_solv(:) ! flags that indicate whether a force is to be applied on the atom
#ifdef __SORT_LIST
 int, pointer :: solute_neighbor_list(:,:) ! for each solvent atom, the solute atoms are sorted in terms of proximity
#ifdef __NEIGHBOR_LIST
 __PAR(qneighbor_list, bool, .true.) ! whether to use a neighbor list to shorten loops over surface atoms
 float :: neighbor_list_factor ! coefficient used to relate sorting frequency and limit index to loop length
 int, pointer :: solute_neighbor_mind(:) ! for each solvent atom, index of closest solute atom in the mindist algorithm
 bool :: qneighbor_list_sorted ! flag to ensure initial sorting of neighbor list
!
 float, parameter :: neighbor_list_factor_grow = 0.1d0
 float, parameter :: neighbor_list_factor_shrink = - neighbor_list_factor_grow / 500d0
!                                        ! also, the largest index of an atom within the cutoff distance for original algorithm
! note : should implement a real test of the neighbor list algorithm, e.g. scanning the entire array and comparing with the
! short array result
#endif
#endif
!
 int, public :: nsurface=-1, nsolvent=-1
 int :: nsolvent_outside
#ifdef __DASYSTAT
 float :: solvent_mass         ! total mass of solvent atoms (constant throughout simulation)
 float :: solvent_mass_outside ! mass of solvent atoms that are outside the shell surface
 float :: solvent_mass_nonbulk ! solvent mass that excludes solvent atoms that are too close to solute to be considered bulk, i.e. inside the inner surface
! float :: solvent_mass_bulk    ! mass of solvent in the bulk shell
#endif
 float :: oonsurface, oonsolvent, oonsolvent_outside
 float :: current_surface_distance
#ifdef __RMFT
 float :: r_com(3) =(/zero, zero, zero/); ! center of mass (geometry) for torque computation
#ifdef __SIMPLE_NET_FORCE_SURFACE
 float :: r_com_inst(3) =(/zero, zero, zero/); ! inst. center of mass (geometry) for torque computation
#if defined (__OMP) && defined (__PBC_UNWRAP)
 float :: __U(r_com_inst)(3)=(/zero, zero, zero/) ! thread locals
#endif
#endif
#ifdef __UNWRAP_PBC
 float :: r_pbc_reference(3)=(/zero, zero, zero/) ! to unwrap water coordinates for torque correction
#endif
 float :: net_force(3) = (/zero, zero, zero/);
 float :: net_force_ave(3) = (/zero, zero, zero/); ! running average of net force
 __PAR(net_force_ave_update_memo, float, 0d0); ! memory governing the evolution of net force average ; 0 -- instant force correction
 float :: max_force(3) = (/zero, zero, zero/);
 float :: net_torque(3) = (/zero, zero, zero/);
#endif
! pressure variables
#if defined(__BAROSTAT) || defined(__DASYSTAT)
 float :: surface_area=-1d0
#ifdef __BAROSTAT
 float :: pressure, pressure_ave, pressure_long_ave ! will store in atm
#endif
#ifdef __DASYSTAT
 float :: volume_bulk=-1d0
 float :: density, density_ave ! mg/mL
#endif
#endif
!
#if defined(__BAROSTAT) || defined(__DASYSTAT) || defined(__UNWRAP_PBC)
 type (cell) :: ucell
#endif
!
 int :: fid
 bool :: qrestart=.false. ! whether we are restarting from a restart file
!
 float, private, parameter :: osq2=one/sqrt2
 float, private, parameter :: osq2pi=one/sqrt(twopi)
!
!= subroutines
 contains
!========
 __SUB(initialize) (atoms, forced_atoms, qper, mdcell)
 __DEP_VECTORS
 type (int_vector) :: atoms, forced_atoms
 bool, intent(in) :: qper
 type (cell), intent(in), optional :: mdcell

 character(len=vartaglen) :: keyword, context, contexts(2) ! all_context currently holds the input context and the restart file context
 int :: ictx ! ugly variables for context searching in macro : (ictx: context # ; qctx, whether tag present in context)
 bool :: qctx
 int, parameter :: main_context=2, restart_context=1 ! the order serves to provide desired override behavior ; DO NO CHANGE UNLESS YOU KNOW WHAT YOU ARE DOING
 int :: l, ierr
 character(len=maxlinelen) :: line
 float, pointer :: farray(:) => NULL()
 __IAM(__NM(initialize))
!
 contexts(main_context)=__STRING(__CTX)
 contexts(restart_context)=__STRING(__RESTARTCTX)
!
 context=contexts(main_context)
! first, check if we have the watershell context present
 if (parser_find_context(__STRING(__CTX)).le.0) then
  __MESSAGE(whoami, trim(ftoupper(__STRING(_N)))//' CONFIGURATION OPTIONS NOT PROVIDED. WILL NOT INITIALIZE.');
   return
 endif
!
! next, check for restart file
! if present, read it and skip initialization options
! read restart file
#define __DEFAULT
#define __CHAR
#define __VAR	restart_file
#define __TAG	__VAR
#define __NAME	restart file
#include "parser/parser_macro2.src"
#undef __CHAR
!
 qrestart = ( existtag_nocase('restart_file', context) .and. trim(ftoupper(restart_file)).ne.'NONE')
!
 if (qrestart) then
  __MESSAGE(whoami,'WILL READ SURFACE DEFINITION PARAMETERS FROM RESTART FILE.')
! read and parse restart file
  fid=-1
  call files_open(fid, restart_file, 'FORMATTED', 'READ')
  call parse_file(fid, &
#ifdef __PARALLEL
 &  MPI_COMM_NULL, &
#endif
 &  quiet_=.false.)
  call files_close(fid)
! now comes a trick : change context name temporarily to process the restart file using the same calls
  context=contexts(restart_context)
!
 endif ! have restart file
!
#define __BOOL
#define __TAG minimum_distance
#define __VAR __CONCAT(q,__TAG)
#define __NAME flag to use the (faster) minimum distance to solute method
#include "parser/parser_macro2.src"
!
#if defined(__SORT_LIST) & defined(__NEIGHBOR_LIST)
#define __TAG neighbor_list
#define __VAR __CONCAT(q,__TAG)
#define __NAME flag to use a neighbor list for solvent forces (default=yes)
#define __DOALWAYS if (__VAR) then ;\
                    __MESSAGE(whoami, 'WILL USE A NEIGHBOR LIST FOR SOLVENT FORCES.');\
                   else ; \ 
                    __MESSAGE(whoami, 'WILL NOT USE A NEIGHBOR LIST FOR SOLVENT FORCES.');\
                   endif
#include "parser/parser_macro2.src"
#endif
#undef __BOOL
!
#define __WARNIFMISSING
#//define __MINUSERR
! density padding
#define __VAR	surf_padding
#define __TAG __VAR
#define __NAME	Density padding
#include "parser/parser_macro2.src"
!
#//undef __MINUSERR
! value for density isosurface
! abandoning this in favor of distance
!#define __VAR	surface_contour_value
!#define __TAG __VAR
!#define __NAME	Value for density isosurface
!#define __DOIFOK if (__VAR.le.zero) __MESSAGE(whoami, ' DENSITY ISOSURFACE VALUE WILL BE COMPUTED FROM COORDINATES.')
!#include "parser/parser_macro2.src"
!
#define __VAR surface_force_constant
#define __TAG __VAR
#define __NAME force constant for surface potential
#define __DOIFOK if (__VAR.lt.__ERRTOL) __WRN(whoami, 'SURFACE FORCE IS OFF.')
#include "parser/parser_macro2.src"
!
#define __LEZEROERR
! cutoff for density
#define __VAR	cutoff_surf_stdev
#define __TAG __VAR
#define __NAME	Cutoff for density smoothing
#define __DOIFOK if (qminimum_distance) then ;\
                  __WARN(whoami,'PARAMETER "'//__STRING(__TAG)//'" HAS NO EFFECT WHEN THE MINIMUM DISTANCE METHOD IS USED.');\
                 endif;
#include "parser/parser_macro2.src"

! GAUSSIAN standard deviations for smoothing (irrelevant for mindist method)
#define __VAR	surf_stdev
#define __TAG __VAR
#define __NAME	Standard deviation of Gaussian filter for density smoothing
#define __DOIFOK if (qminimum_distance) then;\
                  __WARN(whoami,'PARAMETER "'//__STRING(__TAG)//'" HAS NO EFFECT WHEN THE MINIMUM DISTANCE METHOD IS USED.');\
                 endif
#include "parser/parser_macro2.src"
! compute constant (=1/a)  for logistic distribution that matches the stdev
! the distribution is a * exp (-xa) / ( 1 + exp (-xa ) )^2
! the corresponding cdf is 1 / ( 1 + exp (-xa) )
 logistic_constant = sqrt3 * opi * surf_stdev ; ! need this for __RHO below
!
#undef __LEZEROERR
!
! value for distance of the surface from protein (approximate for density method)
#define __VAR	surface_distance
#define __TAG __VAR
#define __NAME	Distance of solvent surface from protein
#define __DOALWAYS if (abs(__VAR).lt.__ERRTOL) then ; \
                  __MESSAGE(whoami, 'LOCATION OF SOLVENT SURFACE WILL BE SET FROM SOLVENT COORDINATES.') ; \
                 else ;\
                  __VAR=-(abs(__VAR)) ; \
                  surface_contour_value=__RHOSAFE(__VAR) ;\
                 endif ! make sure to set to a negative value
!
#include "parser/parser_macro2.src"
#define __MINUSERR
!
! other parameters
#define __INT
#define __VAR	iteration
#define __TAG	__VAR
#define __NAME	starting iteration
#include "parser/parser_macro2.src"
!
#ifdef __BAROSTAT
! number of samples in barostat (we may not need it because the barostat is specified in the input file)
#define __VAR	pressure_num_samples
#define __TAG	__VAR
#define __NAME	current number of instantaneous pressure samples
#include "parser/parser_macro2.src"
!
! number of long samples
!
#undef __WARNIFMISSING
#define __VAR	pressure_num_long_samples
#define __TAG	__VAR
#define __NAME	current number of instantaneous pressure samples in long-time average
#include "parser/parser_macro2.src"
#define __WARNIFMISSING
#endif
!
#ifdef __DASYSTAT
#undef __WARNIFMISSING
! number of samples in dasystat (we may not need it because the barostat is specified in the input file)
#define __VAR	density_num_samples
#define __TAG	__VAR
#define __NAME	current number of instantaneous density samples
#include "parser/parser_macro2.src"
#define __WARNIFMISSING
#endif
!
! ====== done with (possible) restart file data
 context=contexts(main_context) ! reset context if changed
!
#ifdef __BAROSTAT
! barostat flag :
#undef __INT
#define __BOOL
#define __VAR	barostat
#define __TAG	__VAR
#define __NAME	flag to turn barostat on/off
#define __DOIFOK if (.not.__VAR) __MESSAGE(whoami, 'BAROSTAT IS OFF. (WILL IGNORE BAROSTAT-RELATED SETTINGS).')
#include "parser/parser_macro2.src"
#undef __BOOL
#endif
!
#ifdef __DASYSTAT
! dasystat flag :
#undef __INT
#define __BOOL
#define __VAR	dasystat
#define __TAG	__VAR
#define __NAME	flag to turn dasystat on/off
#ifdef __BAROSTAT
#define __DOALWAYS if (__VAR.and.barostat) then ;\
                    __WRN(whoami, 'CANNOT USE BOTH A BAROSTAT AND A DASYSTAT. ABORT.') ;\
                    barostat=.false. ;\
                    dasystat=.false. ;\
                    return ;\
                   elseif (.not.__VAR) then ;\
                     __MESSAGE(whoami, 'DASYSTAT IS OFF. (WILL IGNORE DASYSTAT-RELATED SETTINGS).') ; \
                   endif
#else
#define __DOIFOK if (.not.__VAR) then ; __MESSAGE(whoami, 'DASYSTAT IS OFF. (WILL IGNORE DASYSTAT-RELATED SETTINGS).') ; endif
#endif
#include "parser/parser_macro2.src"
#undef __BOOL
#endif

#define __INT
#if defined(__BAROSTAT) || defined(__DASYSTAT) || defined(__UNWRAP_PBC)
!
 if ( &
#ifdef __BAROSTAT
 & barostat .or. &
#endif
#ifdef __DASYSTAT
 & dasystat .or. &
#endif
#ifdef __UNWRAP_PBC
 & .true. .or. &
#endif
 & .false.)  then
!
! check for periodicity override from parser :
  __GET_OPT_PAR_B(pbc, qper_parser_override, qper, __STRING(__WATERSHELLCTX)); ! if not present use qper that is passed in
  if (qper_parser_override) then
   if (present(mdcell)) then
    ucell=mdcell
   else
    __WARN(whoami, 'PBC OVERRIDE IN USE BUT UNIT CELL NOT PROVIDED. WILL NOT USE PBC.')
    qper_parser_override=.false.
   endif ! present mdcell
  endif
 endif ! barostat or dasystat
#endif
!
! barostat only :
!===================================================================================================
#ifdef __BAROSTAT
 if (barostat) then
!
#define __VAR	pressure_update_freq
#define __TAG	__VAR
#define __NAME	frequency of computing instantaneous shell pressure
#define __DOIFOK if (__VAR.eq.izero) then; \
                  __MESSAGE(whoami, 'PRESSURE UPDATE IS OFF. TURNING BAROSTAT OFF.'); \
                  barostat=.false. ; \
                 endif ! it does not make any sense to run barostat without a pressure calculation !
#include "parser/parser_macro2.src"
 endif ! barostat
!
 if (barostat) then ! repeat if because barostat may have been turned off
#define __VAR	surface_area_compute_freq
#define __TAG	__VAR
#define __NAME	frequency of computing instantaneous shell surface area
#define __DOIFOK if (__VAR.eq.izero) then; \ 
                  __MESSAGE(whoami, 'SURFACE AREA COMPUTATION IS OFF. TURNING BAROSTAT OFF.'); \
                  barostat=.false. ; \
                 endif ! it does not make any sense to run barostat without a surface area calculation !
#include "parser/parser_macro2.src"
 endif ! barostat
!
 if (barostat) then
#define __VAR	surface_area_grid_check_freq
#define __TAG	__VAR
#define __NAME	frequency of checking grid limits for computing shell surface area
#define __DOIFOK if (qper_parser_override) then ;\
                  __WRN(whoami, '"'//__STRING(__TAG)//'" HAS NO EFFECT WHEN PBC ARE USED.');\
                 elseif (__VAR.eq.izero) then; \
                  __WRN(whoami, 'WILL NOT UPDATE SURFACE AREA GRID DURING DYNAMICS (THIS IS PROBABLY NOT A GREAT IDEA).'); \
                 endif
!
#include "parser/parser_macro2.src"
#define __LEZEROERR
#define __VAR	pressure_max_samples
#define __TAG	pressure_relax_time
#define __NAME	barostat relaxation time (in simulation steps)
#include "parser/parser_macro2.src"
!
#undef __WARNIFMISSING
#define __VAR	pressure_max_long_samples
#define __TAG	__VAR
#define __NAME	maximum number of samples in long-time pressure average
#include "parser/parser_macro2.src"
#define __WARNIFMISSING
!
#undef __INT // default is float
!
#define __VAR	surface_area_grid_recompute_change
#define __TAG	__VAR
#define __NAME	domain size difference required to trigger reinitialization of surface area grid
#define __DOIFOK if (qper_parser_override) then ;\
                  __WRN(whoami, '"'//__STRING(__TAG)//'" HAS NO EFFECT WHEN PBC ARE USED.');\
                 endif
#include "parser/parser_macro2.src"
!
#undef __LEZEROERR
#define __VAR	pressure_target
#define __TAG	__VAR
#define __NAME	target pressure in atm
#define __DOALWAYS oopressure_target=one/max(__ERRTOL,(__VAR))
#include "parser/parser_macro2.src"
!
! surface area computation parameters (hopefully, adjusting from defaults should be unnecessary)
#define __LEZEROERR
#define __VAR	surface_area_grid_spacing
#define __TAG	__VAR
#define __NAME	grid spacing for surface area computation
#define __DOALWAYS oo_surface_area_grid_spacing=one/surface_area_grid_spacing
#include "parser/parser_macro2.src"
!
! NOTE : should consider the possibility of periodicity
#define __VAR	surface_area_grid_buffer
#define __TAG	__VAR
#define __NAME	grid buffer for surface area computation
#define __DOIFOK if (qper_parser_override) then ;\
                  __WRN(whoami, '"'//__STRING(__TAG)//'" HAS NO EFFECT WHEN PBC ARE USED.');\
                 elseif (__VAR.lt. __CONCAT(default_,__VAR) ) then ; \
                      __WRN(whoami, 'SETTING A LOW VALUE FOR SURFACE AREA GRID BUFFER MAY CAUSE INACCURACIES.');\
                 endif
#include "parser/parser_macro2.src"
!
 endif
#define __INT
#endif
!
! dasystat only (similar to barostat, and using same variables with different tags):
!===================================================================================================
#undef __LEZEROERR
#ifdef __DASYSTAT
 if (dasystat) then
!
#define __VAR	density_update_freq
#define __TAG	__VAR
#define __NAME	frequency of computing solvent density
#define __DOIFOK if (__VAR.eq.izero) then; \
                  __MESSAGE(whoami, 'DENSITY UPDATE IS OFF. TURNING dasystat OFF.'); \
                  dasystat=.false. ; \
                 endif ! it does not make any sense to run dasystat without a density calculation !
#include "parser/parser_macro2.src"
 endif ! dasystat
!
 if (dasystat) then ! repeat if because dasystat may have been turned off
#define __VAR	surface_area_compute_freq
#define __TAG	volume_compute_freq
#define __NAME	frequency of computing solvent density
#define __DOIFOK if (__VAR.eq.izero) then; \ 
                  __MESSAGE(whoami, 'VOLUME COMPUTATION IS OFF. TURNING dasystat OFF.'); \
                  dasystat=.false. ; \
                 endif ! it does not make any sense to run dasystat without a volume calculation !
#include "parser/parser_macro2.src"
 endif ! dasystat
!
 if (dasystat) then
#define __VAR	surface_area_grid_check_freq
#define __TAG	volume_grid_check_freq
#define __NAME	frequency of checking grid limits for computing solvent density
#define __DOIFOK if (qper_parser_override) then ;\
                  __WRN(whoami, 'PARAMETER "'//__STRING(__TAG)//'" HAS NO EFFECT WHEN PBC ARE USED.');\
                 elseif (__VAR.eq.izero) then; \
                  __WRN(whoami, 'WILL NOT UPDATE VOLUME GRID DURING DYNAMICS (THIS IS PROBABLY NOT A GREAT IDEA).'); \
                 endif
!
#include "parser/parser_macro2.src"
#define __LEZEROERR
#define __VAR	density_max_samples
#define __TAG	density_relax_time
#define __NAME	dasystat relaxation time (in simulation steps)
#include "parser/parser_macro2.src"
!
#undef __INT // default is float
!
#define __VAR	surface_area_grid_recompute_change
#define __TAG	volume_grid_recompute_change
#define __NAME	domain size difference required to trigger reinitialization of volume grid
#define __DOIFOK if (qper_parser_override) then ;\
                  __WRN(whoami, 'PARAMETER "'//__STRING(__TAG)//'" HAS NO EFFECT WHEN PBC ARE USED.');\
                 endif
#include "parser/parser_macro2.src"
#undef __LEZEROERR
!
#define __VAR	density_target
#define __TAG	__VAR
#define __NAME	target density in g/mL
#include "parser/parser_macro2.src"
!
! surface area computation parameters (hopefully, adjusting from defaults should be unnecessary)
#define __LEZEROERR
#define __VAR	surface_area_grid_spacing
#define __TAG	volume_grid_spacing
#define __NAME	grid spacing for volume computation
#define __DOALWAYS oo_surface_area_grid_spacing=one/surface_area_grid_spacing
#include "parser/parser_macro2.src"
!
! NOTE : should consider the possibility of periodicity
#define __VAR	surface_area_grid_buffer
#define __TAG	volume_grid_buffer
#define __NAME	grid buffer for volume computation
#define __DOIFOK if (qper_parser_override) then ;\
                  __WRN(whoami, 'PARAMETER "'//__STRING(__TAG)//'" HAS NO EFFECT WHEN PBC ARE USED.');\
                 elseif (__VAR.lt. __CONCAT(default_,__VAR) ) then ; \
                      __WRN(whoami, 'SETTING A LOW VALUE FOR VOLUME GRID BUFFER MAY CAUSE INACCURACIES.');\
                 endif
#include "parser/parser_macro2.src"
!
! value for distance to bulk boundary from protein (approximate for density method)
#undef __LEZEROERR
#undef __MINUSERR
#define __VAR	bulk_boundary_distance
#define __TAG __VAR
#define __NAME	Distance from protein to bulk boundary
#define __DOALWAYS if (abs(__VAR).lt.__ERRTOL) then ; \
                    if (abs(surface_distance).gt.__ERRTOL) then;\
                     __VAR = -(__BULK_DISTANCE_SCALE) *abs(surface_distance);\
                     bulk_boundary_contour_value=__RHOSAFE(__VAR);\
                     __MESSAGE(whoami, 'SETTING LOCATION OF BULK BOUNDARY FROM SURFACE BOUNDARY TO '//ftoa(__VAR)) ; \
                    else;\
                     __MESSAGE(whoami, 'LOCATION OF BULK BOUNDARY WILL BE SET FROM SURFACE BOUNDARY.') ; \
                    endif;\
                   elseif((abs(__VAR).gt.abs(surface_distance)).and.(abs(surface_distance).gt.__ERRTOL)) then ;\
                    __WRN(whoami, 'BULK BOUNDARY MUST BE INSIDE SHELL SURFACE. ABORT');\
                    __ASSERT(abs(__VAR),<,abs(surface_distance)); \
                   else ;\
                    __VAR=-(abs(__VAR)) ; \
                    bulk_boundary_contour_value=__RHOSAFE(__VAR) ;\
                   endif ! make sure to set to a negative value
! check in all contexts :
#include "parser/parser_macro3.src"
#define __MINUSERR
 endif
#endif
! dasystat only ^ ===========================================================================================
!
#if defined(__BAROSTAT) || defined(__DASYSTAT)
! distance update
 if ( &
#ifdef __BAROSTAT
 & barostat .or. &
#endif
#ifdef __DASYSTAT
 & dasystat .or. &
#endif
 & .false.)  then
!
#undef __INT
#undef __LEZEROERR
#define __VAR distance_update_step
#define __TAG __VAR
#define __NAME memory constant for updating target distance from surface
#define __DOIFOK if (__VAR.le.zero) then ; __WRN(whoami, 'UPDATE OF SURFACE CONTOUR REFERENCE VALUE IS OFF.') ; endif
#include "parser/parser_macro2.src"
!
#define __INT
!
#define __VAR	distance_update_freq
#define __TAG	__VAR
#define __NAME	frequency of updating target distance from surface
#define __DOIFOK if (__VAR.eq.izero) __MESSAGE(whoami, 'UPDATE OF SURFACE DISTANCE VALUE IS OFF.')
#include "parser/parser_macro2.src"
!
  surf_dist_changed=.true.
 endif ! barostat or dasystat
#endif
!
#define __VAR	structure_update_freq
#define __TAG	__VAR
#define __NAME	frequency of updating reference structure
#define __DOIFOK if (__VAR.eq.izero) __MESSAGE(whoami, 'SURFACE UPDATE IS OFF.')
#include "parser/parser_macro2.src"
!
#define __VAR	output_freq
#define __TAG	__VAR
#define __NAME	frequency for writing output/restart file
#define __DOIFOK if (__VAR.le.izero) __WRN(whoami, 'RESTART FILE WILL BE WRITTEN AT THE END ONLY.')
#include "parser/parser_macro2.src"
#undef __INT
!
! read atom selections
! atoms to define surface
#define __CHAR
#define __WARNIFMISSING
#define __VAR	surface_atom_selection
#define __TAG	surface_atoms
#define __NAME	surface atoms
#include "parser/parser_macro2.src"
! (solvent) atoms to which surface forces are applied
#define __VAR	solvent_atom_selection
#define __TAG	solvent_atoms
#define __NAME	solvent atoms
#include "parser/parser_macro2.src"
!
! output file
#define __VAR	output_file
#define __TAG	__VAR
#define __NAME	watershell output file
#include "parser/parser_macro2.src"
#undef __CHAR
!
#undef __WARNIFMISSING
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
#define __INT
#define __VAR	full_sum_freq
#define __TAG	__VAR
#define __NAME	frequency of force calculation without truncation of solvent neighbor list
#define __DOALWAYS if (__VAR.le.zero) then ;\
                  __WRN(whoami, 'SOLVENT ATOM NEIGHBOR LISTS CANNOT BE USED WITH "'//__STRING(__VAR)//'"=0.') ;\
                  neighbor_list_factor=one ;\
                  qneighbor_list=.false. ;\
                 else ;\
                  neighbor_list_factor = seven + ( (__VAR * __VAR) * 2.0d-4); \
                  if (.not.qneighbor_list) __WRN(whoami, 'NEIGHBOR LIST WILL NOT BE USED BECAUSE "neighbor_list" set to "off"') ;\
                 endif
#include "parser/parser_macro2.src"
!#ifdef __DEBUG
!       __DBGOUT('FULL_SUM_FREQ IS ',full_sum_freq)
       __DBGOUT('NEIGHBOR_LIST_FACTOR SET TO ',neighbor_list_factor) ! , seven + (full_sum_freq**2 * 2.0d-4)) 
!#endif
!
#define __VAR	sort_neighbor_list_freq
#define __TAG	__VAR
#define __NAME	frequency of sorting solvent atom neighbor lists
#define __DOIFOK if (__VAR.eq.zero) then ;\
                  __WRN(whoami, 'WILL NOT SORT SOLVENT ATOM NEIGHBOR LISTS') ;\
                 endif
 if (qneighbor_list) then
#include "parser/parser_macro2.src"
 endif
#undef __INT
#endif
!
!
#ifndef __WARNIFMISSING
#define __WARNIFMISSING
#endif
#define __VAR structure_update_memory
#define __TAG __VAR
#define __NAME memory constant for reference structure update
#define __DOIFOK if (__VAR.le.zero) then ; __WRN(whoami, 'SURFACE UPDATE IS OFF.') ; \
 elseif (__VAR .gt. one ) then ; __WRN(whoami, ftoupper(__STRING(__NAME))//' SHOULD _NOT_ BE GREATER THAN ONE !') ; endif
#include "parser/parser_macro2.src"
!
#undef __WARNIFMISSING
#undef __MINUSERR
#define __LEZEROERR
!
!#define __VAR target_surface_energy
!#define __TAG __VAR
!#define __NAME target surface energy per area
!#define __DOIFOK if (__VAR.lt.__ERRTOL) __WRN(whoami, 'TARGET SURFACE ENERGY IS ALMOST ZERO.')
!#include "parser/parser_macro2.src"
!
#ifdef __RMFT
#define __BOOL
#define __VAR remove_net_torque
#define __TAG __VAR
#define __NAME flag to remove net torque from solvent atoms
#include "parser/parser_macro2.src"
! to remove net force :
#define __VAR remove_net_force
#define __TAG __VAR
#define __NAME flag to remove net force from solvent atoms
#define __DOIFOK \
 if (__VAR.and..not.remove_net_torque) then ; \
  __WRN(whoami, 'NET FORCE REMOVAL REQUIRES NET TORQUE REMOVAL. WILL NOT REMOVE FORCE.') ; \
 endif
#include "parser/parser_macro2.src"
#undef __BOOL
#undef __LEZEROERR
#define __MINUSERR
#define __VAR net_force_ave_update_memo
#define __TAG __VAR
#define __NAME memory constant for average net force removal
#include "parser/parser_macro2.src"
#endif
!
! done pocessing input file parameters
!
! read structure file
! (unless already read elsewhere ; at this point the data structures from dynamol are shared)
 if (.not. system_PDB_initialized) then
!=========== structure file
#define __CHAR
#define __VAR	structure_file
#define __TAG	__VAR
#define __NAME	structure file
#include "parser/parser_macro2.src"
#undef __CHAR
!===========
  __MESSAGE(whoami, 'READING STRUCTURE FROM FILE "'//trim(structure_file)//'"');
  call system_PDB_init(structure_file, 'PDB');
  if (.not. fatal_warning()) system_PDB_initialized=.true.
! save coordinates in rcomp, just in case we need them later ?
  if (associated(rcomp) .and. associated(r)) rcomp=r
 endif
!=========== end structure file
! initialize radii using a system function
!
#define __GET_RAD(_TAG)  if (existtag_nocase(__STRING(_TAG),context)) then;\
                            farray=>system_init_mol_scalar_nocase(__STRING(_TAG), context);\
                            if (associated(farray)) then;\
                             radius=farray;\
                             deallocate(farray);\
                             radii_initialized=.true.; \
                            endif

 __GET_RAD(radii)
 else __GET_RAD(radius) ! other tags here
 endif
!
 if (.not.radii_initialized) __WRN(whoami, 'COULD NOT INITIALIZE ATOMIC RADII');
! same for dasystat
#ifdef __DASYSTAT
!
#define __GET_MASS(_TAG)  if (existtag_nocase(__STRING(_TAG),context)) then;\
                            farray=>system_init_mol_scalar_nocase(__STRING(_TAG), context);\
                            if (associated(farray)) then;\
                             dasystat_masses=farray;\
                             deallocate(farray);\
                             dmasses_initialized=.true.; \
                            endif;

 if(dasystat) then
 __GET_MASS(masses)
 else __GET_MASS(mass)
 else __GET_MASS(dmasses)
 else __GET_MASS(dmass)
 else __GET_MASS(dasystat_masses)
 else __GET_MASS(dasystat_mass)
 endif ! get mass
 if (.not.dmasses_initialized) __WRN(whoami, 'COULD NOT INITIALIZE DASYSTAT MASSES');
 endif ! dasystat
#endif
!
! copy coordinates
!
 isurface_atoms=>system_getind(surface_atom_selection)
 if (associated(isurface_atoms)) then
  nsurface=size(isurface_atoms) ; oonsurface=one/nsurface ;
  __ALLOC(r_surf(3,nsurface))
  __ALLOC(rad_surf(nsurface))
! add atoms to list if provided
!  if (present(atoms)) then
   do l=1, nsurface
    ierr=atoms%uadd(isurface_atoms(l))
#if defined(__RMFT) && defined(__SIMPLE_NET_FORCE_SURFACE)
!  if (remove_net_torque.and.present(forced_atoms)) ierr=forced_atoms%uadd(isurface_atoms(l))
  if (remove_net_torque) ierr=forced_atoms%uadd(isurface_atoms(l))
#endif
   enddo
!  endif ! present
!
 else
  __WRN(whoami, 'COULD NOT ALLOCATE MEMORY FOR SURFACE ATOM INDICES.')
 endif
! repeat for solvent atoms
 isolvent_atoms=>system_getind(solvent_atom_selection)
 if (associated(isolvent_atoms)) then
  nsolvent=size(isolvent_atoms) ; oonsolvent=one/nsolvent ;
  __ALLOC(r_solv(3,nsolvent))
  __ALLOC(rho_solv(nsolvent))
#ifdef __DASYSTAT
  __ALLOC(mass_solv(nsolvent))
#endif
  __ALLOC(qforced_solv(nsolvent))
  dist_solv=>rho_solv
  __ALLOC(drho_solv(3,nsolvent))
  ddist_solv=>drho_solv
#ifdef __SORT_LIST
  __ALLOC(solute_neighbor_list(nsurface,nsolvent))
! initialize neighbor list with solute indices from 1 to nsurface for each solute atom:
#ifdef __DEBUG
  __DBGOUT('INITIALIZING SOLUTE NEIGHBOR LIST');
#endif
  do l=1,nsurface
   solute_neighbor_list(l,:)=l
  enddo
#ifdef __NEIGHBOR_LIST
  qneighbor_list_sorted=.not.qneighbor_list ! if not using qlist, set to true to avoid sorting
  __ALLOC(solute_neighbor_mind(nsolvent))
  solute_neighbor_mind=nsurface ! initialize to last position in the solute neighbor list array
#endif
#endif
! add atoms to lists if provided
!  if (present(atoms)) then
   do l=1, nsolvent
    ierr=atoms%uadd(isolvent_atoms(l))
   enddo
!  endif ! present
!
!  if (present(forced_atoms)) then
   do l=1, nsolvent
    ierr=forced_atoms%uadd(isolvent_atoms(l))
   enddo
!  endif ! present
!
 else
  __WRN(whoami, 'COULD NOT ALLOCATE MEMORY FOR SOLVENT ATOM INDICES.')
 endif
!
 if  (qrestart) then
! read surface atom coordinates from restart file (context __RESTARTCTX)
  do l=1, nsurface
   line=getval_nocase('rsurf_'//trim(itoa(l)),__STRING(__RESTARTCTX))
   if (len_trim(line).gt.0) then
    read(line,*,iostat=ierr) r_surf(:,l)
    if (ierr.ne.0) then
     __WRN(whoami, 'ERROR READING COORDINATE FROM LINE "'//trim(line)//'"')
     cycle
    endif
   else
    __WRN(whoami, 'ERROR READING COORDINATE FROM LINE "'//trim(line)//'"')
   endif ! line ok
  enddo ! over surface atoms
 else ! qrestart
! take surface atom coordinates from structure (PDB) file
  r_surf=r(:,isurface_atoms)
 endif ! qrestart
!
 rad_surf=radius(isurface_atoms)
#ifdef __DASYSTAT
 mass_solv=dasystat_masses(isolvent_atoms)
 solvent_mass=sum(mass_solv)
#endif
!
#if defined(__BAROSTAT) || defined(__DASYSTAT)
 if (&
#ifdef __BAROSTAT
&     barostat .or. &
#endif
#ifdef __DASYSTAT
&     dasystat .or. &
#endif
&     .false. ) then 
  r_surf_changed=.true. ! we only need this variable for barostat/dasystat
 endif
#endif
#ifdef __RMFT
! compute com if removing torque
 if (remove_net_torque) then 
#ifdef __TORQUE_COM_SURFACE
  r_com = oonsurface * sum(r_surf,2)
#ifdef __UNWRAP_PBC
  if (qper_parser_override) r_pbc_reference=r_com
#endif
#else
#ifdef __UNWRAP_PBC
 if (qper_parser_override) r_pbc_reference = oonsurface * sum(r_surf,2)
#endif
#endif
  if (qrestart) then ! read average force
   line=getval_nocase('average_net_force',__STRING(__RESTARTCTX))
   if (len_trim(line).gt.0) then
    read(line,*,iostat=ierr) net_force_ave
    if (ierr.ne.0) then
     __WRN(whoami, 'ERROR READING AVERAGE NET FORCE FROM LINE "'//trim(line)//'"')
    endif
   else
    __WRN(whoami, 'ERROR READING AVERAGE NET FORCE FROM LINE "'//trim(line)//'"')
   endif ! line ok
  else ! qrestart
   net_force_ave=zero; ! note that this value should not expected to be physical, since we do not have any statistics at the outset
  endif ! qrestart
 endif ! remove net_torque
#endif
!
#if defined(__BAROSTAT) || defined(__DASYSTAT)

#ifdef __BAROSTAT
! if using barostat, read current running pressure
 if (barostat) then
  if (qrestart) then
! (1) read pressure value
   line=getval_nocase('pressure',__STRING(__RESTARTCTX))
   if (len_trim(line).gt.0) then
    read(line,*,iostat=ierr) pressure_ave
    if (ierr.ne.0) then
     __WRN(whoami, 'ERROR READING PRESSURE FROM LINE "'//trim(line)//'"')
    endif
   else
    __WRN(whoami, 'ERROR READING PRESSURE FROM LINE "'//trim(line)//'"')
   endif ! line ok
! now, long-time average
   line=getval_nocase('average_pressure',__STRING(__RESTARTCTX))
   if (len_trim(line).gt.0) then
    read(line,*,iostat=ierr) pressure_long_ave
    if (ierr.ne.0) then
     __WRN(whoami, 'ERROR READING AVERAGE PRESSURE FROM LINE "'//trim(line)//'"')
    endif
   else ! restart file does not have lta pressure, so set it to zero
    pressure_long_ave=zero
    pressure_num_long_samples=izero
   endif ! line ok
  else ! qrestart
   pressure_ave=zero; ! value used for initialization
   pressure_long_ave=zero
  endif ! qrestart
 endif ! barostat
#endif
!
#ifdef __DASYSTAT
! read current running density
 if (dasystat) then
  if (qrestart) then
! (1) read density value
   line=getval_nocase('density',__STRING(__RESTARTCTX))
   if (len_trim(line).gt.0) then
    read(line,*,iostat=ierr) density_ave
    if (ierr.ne.0) then
     __WRN(whoami, 'ERROR READING DENSITY FROM LINE "'//trim(line)//'"')
    endif
   else
    __WRN(whoami, 'ERROR READING DENSITY FROM LINE "'//trim(line)//'"')
   endif ! line ok
  else ! qrestart
   density_ave=-one; ! this value used for initialization is not physical
  endif ! qrestart
 endif ! dasystat
#endif
!
! set com for SA/VOL gridding
 if (&
#ifdef __BAROSTAT
&     barostat .or. &
#endif
#ifdef __DASYSTAT
&     dasystat .or. &
#endif
&     .false. ) then
#if defined(__RMFT) && defined(__TORQUE_COM_SURFACE)
  if (remove_net_torque) then
   r_com_sa=r_com
  else
   r_com_sa=oonsurface * sum(r_surf,2)
  endif
#else
  r_com_sa=oonsurface * sum(r_surf,2)
#endif
! initialize grid-based SA computation
  if (qper_parser_override) then ! for periodic BC, use cell info
   call ucell%print()
   r_surf_minmax(1,:) = - half * (/ucell%a, ucell%b, ucell%c/) ! grid minima
   r_surf_minmax(2,:) = + half * (/ucell%a, ucell%b, ucell%c/) ! grid maxima
  else
   r_surf_minmax(1,:) = minval(r_surf,2) - r_com_sa - ( abs(surface_distance) + surface_area_grid_buffer)
   r_surf_minmax(2,:) = maxval(r_surf,2) - r_com_sa + ( abs(surface_distance) + surface_area_grid_buffer)
  endif
!
__DBGVAR(r_surf_minmax,1)
__DBGVAR(minval(r_surf,2),1)
__DBGVAR(maxval(r_surf,2),1)
__DBGVAR(r_com_sa,1)
!
  call ugrid_initialize(sagrid, 3, r_surf_minmax, (/surface_area_grid_spacing/), adjust_spacings_=qper_parser_override) ! when using PBC, adjust spacing, not length
!
  if (qminimum_distance) then
#ifdef __OMP
   allocate(sarho_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:omp_get_max_threads()-1))
#ifdef __DASYSTAT
   if (dasystat) allocate(inrho_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:omp_get_max_threads()-1))
#endif
#else
  allocate(sarho(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#ifdef __DASYSTAT
  if (dasystat) allocate(inrho(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#endif
#endif
  else ! qminimum_distance
#ifdef __OMP
   allocate(sarhof_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:omp_get_max_threads()-1))
#else
   allocate(sarhof(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#endif
  endif ! qmindist
! initialize random number generator for small random grid displacements
#ifdef __PERTURB_GRID
  if (.not.random_initialized) call random_init()
#endif
! NOTE: not computing surface area or volume here, because the shell distances may not yet be defined
 endif ! barostat or dasystat
#endif
!
 oo_surf_stdev=one/surf_stdev
 cutoff_surf  =cutoff_surf_stdev*surf_stdev
 cutoff_surf2 =cutoff_surf**2
!
 if (.not.fatal_warning() .and. radii_initialized &
#ifdef __DASYSTAT
 .and.(dmasses_initialized .or. .not. dasystat) &
#endif
& ) __NM(initialized)=.true.
!
 end __SUB(initialize)
!======================================
 __SUB(write_restart_file) ()
! = adapted from tempering
 __IAM(__NM(WRITE_RESTART_FILE))
 int :: ifile, i
 ifile=-1 ! make sure files_open determines the handle automatically
 call files_open(ifile, output_file, 'FORMATTED','WRITE')
!
#define _W write(ifile,*)
 _W '#WATERSHELL RESTART FILE'
 _W __STRING(__RESTARTCTX)//' {'
 _W 'iteration=',iteration
 if (qminimum_distance) _W 'minimum_distance=on # use the simpler minimum distance to solvent algorithm'
! _W 'surface_contour_value=',surface_contour_value, ' # value for which density isosurface is computed'
 _W 'surface_distance=',surface_distance, ' # distance of solvent surface from solute'
 _W 'surface_force_constant=',surface_force_constant, ' # surface force constant'
 _W 'surf_stdev=',surf_stdev, ' # standard deviation of Gaussian filter'
 _W 'cutoff_surf_stdev=',cutoff_surf_stdev, ' # distance from center beyond which it is set to zero (units of stdandard deviation)'
 _W 'surf_padding=',surf_padding, ' # scalar padding added to each atom radius'
!
#if defined(__SORT_LIST) & defined(__NEIGHBOR_LIST)
 if (qneighbor_list) then
  _W 'neighbor_list=on # use a neighbor list for solvent forces'
 else
  _W 'neighbor_list=off # do not use a neighbor list for solvent forces'
 endif
#endif
!
#ifdef __RMFT
! need to write out average force (since it is a time average)
 if (remove_net_torque) then
 _W 'average_net_force=(',net_force_ave,')'
 endif
#endif
#ifdef __BAROSTAT
 if (barostat) then
 _W 'pressure=',pressure_ave, '# (units of atm)'
 _W 'pressure_num_samples=',pressure_num_samples
 _W 'average_pressure=',pressure_long_ave, '# (units of atm)'
 _W 'pressure_num_long_samples=',pressure_num_long_samples
 endif
#endif
#ifdef __DASYSTAT
 if (dasystat) then
 _W 'density=',density_ave, '# (units of g/mL)'
 _W 'density_num_samples=',density_num_samples
 _W 'bulk_boundary_distance=',bulk_boundary_distance, ' # distance from solute to bulk solvent'
 endif
#endif
! write the current reference atoms :
 _W '# rsurf_i : reference coordinate triple for atom #i used to define surface'
 do i=1, nsurface
  _W 'rsurf_'//trim(itoa(i)),'=(',r_surf(:,i),')'
 enddo ! surface atoms
 _W '}'
! close file
 call files_close(ifile)
!
 end __SUB(write_restart_file)
!================================================================
 __SUB(done)
 __IAM(__NM(done))
 if (__NM(initialized)) then
  __MESSAGE(whoami, 'WRITING RESTART FILE.')
  call __NM(write_restart_file)()
 endif
!
 call system_done()
 call parser_done()
 __FREE(r_surf)
 __FREE(r_solv)
 __FREE(qforced_solv)
 __FREE(rad_surf)
 __FREE(rho_solv)
 nullify(dist_solv)
 __FREE(drho_solv)
 nullify(ddist_solv)
 __FREE(isurface_atoms)
 __FREE(isolvent_atoms)
#ifdef __SORT_LIST
 __FREE(solute_neighbor_list)
#ifdef __NEIGHBOR_LIST
 __FREE(solute_neighbor_mind)
#endif
#endif
#if defined(__BAROSTAT) || defined(__DASYSTAT)
#ifdef __OMP
 __DEALL(sarho_all_threads)
 __DEALL(sarhof_all_threads)
#ifdef __DASYSTAT
 __DEALL(inrho_all_threads)
#endif
#else
 __DEALL(sarho)
 __DEALL(sarhof)
#ifdef __DASYSTAT
 __DEALL(inrho)
#endif
#endif
 call ugrid_done(sagrid)
#endif
!
 __NM(initialized)=.false. ; radii_initialized=.false.
#ifdef __DASYSTAT
 dmasses_initialized=.false.
#endif
!
 end __SUB(done)
!================================================================
 __SUB(main)(r,fr,energy,qper_,mdcell) ! NOTE : qper/ucell is not supposed to change; keeping here for sanity check
#if defined(__RMFT) & !defined(__F_T_COUPLED)
 use lu
#endif
 use bestfit, only :  matinv3sym, norm3
!
 float, intent(in) :: r(:,:)   ! coordinate array
 float, intent(out) :: fr(:,:) ! force array
 float, intent(out) :: energy
!
 __OPAR(qper,bool)
!
 type (cell), optional :: mdcell
! int :: ibeg, iend ! atom indices for looping
 float :: distance_from_solute, distance_from_solute2, pre, d0
 float :: surface_energy, surface_force ! , density_beyond_contour ! useful ?
#ifdef __RMFT
! to update coefficients for computing torque matrix ; doing this way to separate com contribution :
#define __UPDATE_TMAT_C \
  __INCR(__U(ir1),ir(1));\
  __INCR(__U(ir2),ir(2));\
  __INCR(__U(ir3),ir(3));\
  __INCR(__U(ir1s),ir(1)**2);\
  __INCR(__U(ir2s),ir(2)**2);\
  __INCR(__U(ir3s),ir(3)**2);\
  __INCR(__U(ir12),ir(1)*ir(2));\
  __INCR(__U(ir13),ir(1)*ir(3));\
  __INCR(__U(ir23),ir(2)*ir(3));
 float, dimension(3) :: ir, iforce, itorque ! inst position, force and torque corresponding to an atom
 float :: ir1,ir2,ir3,ir1s,ir2s,ir3s,ir12,ir13,ir23, oontorque
 float, dimension(3) :: ir_sum
! float, dimension(3) :: oforce ! existing force
#ifdef __F_T_COUPLED
 float, dimension(6,6) :: A ! matrix for force and torque removal
#else
 float, dimension(3,3) :: B ! matrix for torque removal
#endif
 float, dimension(6) :: rhs ! vector for net force and torque removal
#endif
#ifdef __OMP
#//define __REDUCE(_W) __INCR(_W,__U(_W)) ! thread reduction
#define __REDUCE(_W) _W=_W+__U(_W) ! thread reduction
#define __AREDUCE(_W,_I) _W(_I)=_W(_I)+__U(_W)(_I)
 float :: __U(surface_energy)
 float :: __U(surface_force)
! float :: __U(density_beyond_contour) ! useful ?
 int :: __U(nsolvent_outside)
#ifdef __DASYSTAT
 float :: __U(solvent_mass_outside)
#endif
#ifdef __RMFT
 float, dimension(3) :: __U(net_force), __U(net_torque), __U(max_force) ! thread locals
 float :: __U(ir1),__U(ir2),__U(ir3),__U(ir1s),__U(ir2s),__U(ir3s),__U(ir12),__U(ir13),__U(ir23)
 float, dimension(6) :: __U(rhs)
#endif
#endif
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
 int :: ind, istep ! variables for binary search
#if defined(__OMP) & defined(__FORCE_OMP)
 float, allocatable :: distance2_all_threads(:,:)
 int :: tid
#else
 float, allocatable :: distance2(:)
#endif
 int :: ierr
#endif

 int :: i, ii
 __IAM(__NM(main))
!================================================================
 if (.not. __NM(initialized)) then
  __WRN(whoami, ftoupper(__STRING(_N))//'NOT INITIALIZED. NOTHING DONE.');
  return
 endif
!
 __INC(iteration)
! copy solvent coordinates
 r_solv=r(:,isolvent_atoms)
! sort neighbor list on first iteration
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
 if (qneighbor_list.and.sort_neighbor_list_freq.gt.izero) then
   if (__CHKUPDATE(sort_neighbor_list_freq)) qneighbor_list_sorted=.false.
 endif ! qneighbor_list
!
 if (.not. qneighbor_list_sorted) then
!
 if (.not. qminimum_distance) pre=(maxval(rad_surf) + surf_padding + cutoff_surf)**2
!
#if defined(__OMP) & defined(__FORCE_OMP)
  __ALLOC(distance2_all_threads(nsurface,0:omp_get_max_threads()-1))
!$omp parallel private(ierr,tid,i,ii,ind,istep &
#ifdef __PBC_UNWRAP
!$omp ,d0 &
#endif
!$omp )
  tid=omp_get_thread_num()
#define distance2(_ii) distance2_all_threads(_ii,tid)
#else
  __ALLOC(distance2(nsurface))
#endif

#ifdef __PBC_UNWRAP
  if(qper_parser_override) then
#endif
!
#if defined(__OMP) & defined(__FORCE_OMP)
!$omp do schedule(runtime)
#endif
   do i=1, nsolvent
    do ii=1, nsurface
#ifdef __PBC_UNWRAP
     distance2(ii)=zero
! x
     d0=r_surf(1,ii)-r_solv(1,i)
     __DIST_PBC(d0,ucell%a)
     __INCR(distance2(ii),d0*d0)
! y
     d0=r_surf(2,ii)-r_solv(2,i)
     __DIST_PBC(d0,ucell%b)
     __INCR(distance2(ii),d0*d0)
! z
     d0=r_surf(3,ii)-r_solv(3,i)
     __DIST_PBC(d0,ucell%c)
     __INCR(distance2(ii),d0*d0)
#else
!     distance2(ii) = sum ( (r_surf(:,ii)-r_solv(:,i))**2 )
! slightly faster :
     distance2(ii)=zero
     d0=r_surf(1,ii)-r_solv(1,i)
     __INCR(distance2(ii),d0*d0)
     d0=r_surf(2,ii)-r_solv(2,i)
     __INCR(distance2(ii),d0*d0)
     d0=r_surf(3,ii)-r_solv(3,i)
     __INCR(distance2(ii),d0*d0)
#endif
    enddo ! nsurface
!  sort neighbor list:
    call rsort_ind('i',nsurface,distance2(:),solute_neighbor_list(:,i),ierr)
!
    if (qminimum_distance) then
     solute_neighbor_mind(i)=min(nsurface,2) ! fo mindist only
    elseif (nsurface>0) then
! for the erf/density method, we need to find the largest index in the set of atoms supported by filter:
! use this search macro:
#define __MXLOC(_A,_a,_len,_ind,_istep) \
 _ind=(1+_len)/2;\
 _istep=(1+_ind)/2;\
 do;\
  if (_A(_ind)>(_a)) then;\
   _ind=max(1,_ind-_istep); \
  else; \
   _ind=min((_len),_ind+_istep); \
  endif;\
  if (_istep<2) exit;\
  _istep=(_istep+1)/2;\
 enddo;\
 if ( _A(_ind)>(_a) .and. _ind>1) _ind=_ind-1
!
     __MXLOC( distance2, pre, nsurface, ind, istep )
!
     solute_neighbor_mind(i)=ind
    endif
 __DBGVAR(pre,2)
 __DBGVAR(distance2(1:10),2)
 __DBGVAR(solute_neighbor_mind(i),2)
   enddo ! nsolvent
#if defined(__OMP) & defined(__FORCE_OMP)
!$omp end do
#endif
#ifdef __PBC_UNWRAP
  else ! qper_parser_override
#if defined(__OMP) & defined(__FORCE_OMP)
!$omp do schedule(runtime)
#endif
   do i=1, nsolvent
    do ii=1, nsurface
!     distance2(ii) = sum ( (r_surf(:,ii)-r_solv(:,i))**2 )
! slightly faster :
     distance2(ii)=zero
     d0=r_surf(1,ii)-r_solv(1,i)
     __INCR(distance2(ii),d0*d0)
     d0=r_surf(2,ii)-r_solv(2,i)
     __INCR(distance2(ii),d0*d0)
     d0=r_surf(3,ii)-r_solv(3,i)
     __INCR(distance2(ii),d0*d0)
    enddo ! nsurface
!  sort neighbor list:
    call rsort_ind('i',nsurface,distance2(:),solute_neighbor_list(:,i),ierr)
    if (qminimum_distance) then
     solute_neighbor_mind(i)=min(nsurface,2) ! for mindist only
    elseif (nsurface>0) then
     __MXLOC( distance2, pre, nsurface, ind, istep )
     solute_neighbor_mind(i)=ind
    endif
   enddo ! nsolvent
#if defined(__OMP) & defined(__FORCE_OMP)
!$omp end do
#endif
  endif ! qper_parser_override
#endif
#if defined(__OMP) & defined(__FORCE_OMP)
!$omp end parallel
  __DEALL(distance2_all_threads)
#undef distance2
#else
  __DEALL(distance2)
#endif
  qneighbor_list_sorted=.true.
 endif ! sorted
#endif
!
#ifdef __RMFT
#ifdef __SIMPLE_NET_FORCE_SURFACE
 if (remove_net_torque) then
#ifdef __UNWRAP_PBC
  if (qper_parser_override) then 
   r_com_inst=zero
#ifdef __OMP
!$omp parallel private(__U(r_com_inst), pre)
   __U(r_com_inst)=zero
!$omp do schedule(runtime)
#endif
   do i=1, nsurface
    ii=isurface_atoms(i)
!x
    pre=r(1,ii)-r_surf(1,i); __PBCDIST(pre,ucell%a)
    __INCR(__U(r_com_inst)(1), pre + r_surf(1,i))
!y
    pre=r(2,ii)-r_surf(2,i); __PBCDIST(pre,ucell%b)
    __INCR(__U(r_com_inst)(2), pre + r_surf(2,i))
!z
    pre=r(3,ii)-r_surf(3,i); __PBCDIST(pre,ucell%c)
    __INCR(__U(r_com_inst)(3), pre + r_surf(3,i))
   enddo
#ifdef __OMP
!$omp end do
!$omp atomic
   __AREDUCE(r_com_inst,1)
!$omp atomic
   __AREDUCE(r_com_inst,2)
!$omp atomic
   __AREDUCE(r_com_inst,3)
!$omp end parallel
#endif
   __SCALE(r_com_inst,oonsurface)
  else
#endif
  r_com_inst = oonsurface * sum(r(:,isurface_atoms),2) ; ! need instant com for SIMPLE_NET_FORCE_SURFACE, b/c forces applied to prot. atoms
 endif
#ifdef __UNWRAP_PBC
 endif
#endif

#endif
#endif
!============================================= update reference coordinates
 if (structure_update_freq.gt.izero) then
  if __CHKUPDATE(structure_update_freq) then

#ifdef __PBC_UNWRAP
   if (qper_parser_override) then
    d0=one-structure_update_memory
#ifdef __OMP
!$omp parallel private(pre,ii)
!$omp do schedule(runtime)
#endif
    do i=1, nsurface
     ii=isurface_atoms(i)
! x
     pre=r(1,ii)-r_surf(1,i); __PBCDIST(pre,ucell%a)
     __INCR(r_surf(1,ii), d0*pre)
! y
     pre=r(2,ii)-r_surf(2,i); __PBCDIST(pre,ucell%b)
     __INCR(r_surf(2,ii), d0*pre)
! z
     pre=r(3,ii)-r_surf(3,i); __PBCDIST(pre,ucell%c)
     __INCR(r_surf(3,ii), d0*pre)
    enddo
#ifdef __OMP
!$omp end do
!$omp end parallel
#endif
   else
#endif
    r_surf = structure_update_memory * r_surf + (one - structure_update_memory) * r(:,isurface_atoms)
#ifdef __PBC_UNWRAP
   endif ! qper override
#endif
!
#if defined(__BAROSTAT) || defined (__DASYSTAT)
   if (&
#ifdef __BAROSTAT
&       barostat .or. &
#endif
#ifdef __DASYSTAT
&       dasystat .or. &
#endif
&       .false. ) then 
  r_surf_changed=.true. ! we only need this variable for barostat/dasystat
 endif
#endif
!
#ifdef __RMFT
#ifdef __TORQUE_COM_SURFACE
! recompute COM if subtracting torque
   if (remove_net_torque) then 
#ifdef __SIMPLE_NET_FORCE_SURFACE
! update r_com
    r_com = structure_update_memory * r_com + (one - structure_update_memory) * r_com_inst ;
#else
    r_com = oonsurface * sum(r_surf,2) ;
#endif
   endif ! remove_net_torque
#ifdef __UNWRAP_PBC
   r_pbc_reference=r_com
#endif
#else
#ifdef __UNWRAP_PBC
   r_pbc_reference = oonsurface * sum(r_surf,2)
#endif
#endif
#endif
  endif ! structure_update
 endif ! structure_update
!
!============================================= compute contour value/distance and gradient at solvent coordinates
!
 surface_energy=zero
 distance_from_solute=zero
 distance_from_solute2=zero ! for computing second moment
!
!========================== compute contour value if needed
! if surface distance value is zero, estimate a reasonable value from current coordinates
 if ( abs(surface_distance) .lt. __ERRTOL) then
  if (qminimum_distance) then ! simple algorithm
   call __NM(compute_mindist_grad)(.false.) ! need entire sum
   do i=1, nsolvent
    d0 = dist_solv(i)
    __DBGOUT('Inst. distance from solute for atom ',i,' is ', d0);
    __INCR(distance_from_solute, d0)
    __INCR(distance_from_solute2, d0**2)
   enddo
   pre=1d0 ! prefactor for scaling std in computing reference distance
  else ! (NOT) qminimum_distance -- original erf algorithm
! first, set surface_contour value to an upper bound to make sure that the 
! no atoms can be marked as "inside" atoms; this ensures that the density routine cannot quit early
   surface_contour_value=nsurface
   call __NM(compute_density_grad)(.false.) ! need entire sum
   do i=1, nsolvent
! convert to distance
    if ( abs(rho_solv(i)) .eq. zero ) then ! proceed if the density is positive ; otherwise warn that we are outside of the support
     __WRN(whoami, 'SOLVENT ATOM '//itoa(isolvent_atoms(i))//' OUTSIDE OF SOLUTE SUPPORT. RESTART WITH A SMALLER SURFACE DISTANCE OR A LARGER FILTER CUTOFF.')
    endif
    d0 = __RHO_INVSAFE(rho_solv(i))
    __DBGOUT('Inst. density/distance from solute for atom ',i,' are ',rho_solv(i),'/',d0);
    __INCR(distance_from_solute, d0)
    __INCR(distance_from_solute2, d0**2)
   enddo
   pre=1d0
  endif ! qmin distance
! set contour value to average value + (a) x stdev ; a set empirically
  __SCALE(distance_from_solute,oonsolvent);
  __DBGOUT('Distance from solute ', distance_from_solute)
  __SCALE(distance_from_solute2,oonsolvent);
  __DBGOUT('Distance from solute stdDev ', sqrt ( distance_from_solute2 - distance_from_solute**2))
  surface_distance = distance_from_solute - & ! average (recall that distance_from_solute < 0, so this adds to the length)
&                    pre * sqrt( max(zero,distance_from_solute2 - distance_from_solute**2) ) ! analytically positive, but, just in case, protect from roundoff
  surface_contour_value = __RHOSAFE(surface_distance) ! for mindist, determine this for information, even though not relevant to algorithm
  __MESSAGE(whoami, 'COMPUTED SURFACE DISTANCE AT '//ftoa(surface_distance)//' A FROM PROTEIN. CONTOUR VALUE IS '//ftoa(surface_contour_value))
  __DBGOUT( 'COMPUTED SD, SCV: ', surface_distance, surface_contour_value)
!
#ifdef __DASYSTAT
!
! also check for distance to bulk boundary note that, since the bulk
! boundary distance is held fixed, it is possible that surface will shrink
! to be very close to the bulk boundary,  in which case we would need to
! recompute the bulk boundary distance to avoid instabilities (or
! ill-definedness, if the BBD happens to be OUTSIDE !)
!
  if (dasystat) then
   if(abs(bulk_boundary_distance).ge.abs(surface_distance)) then
    __WRN(whoami, 'BULK BOUNDARY MUST BE INSIDE SHELL SURFACE. ABORT');
    __ASSERT(abs(bulk_boundary_distance),<,abs(surface_distance));
    goto 999
!
   elseif( (abs(surface_distance) - abs(bulk_boundary_distance)) .lt. &
&    ( __BULK_BOUNDARY_RECOMPUTE_FACTOR * abs(surface_distance) ) ) then ! recompute bulk_bdry
    __MESSAGE(whoami, 'BULK BOUNDARY IS TOO CLOSE TO SURFACE BOUNDARY. WILL RECOMPUTE:')
!
   elseif ( abs(bulk_boundary_distance).lt.__ERRTOL ) then ! zero value signals auto-compute
    __MESSAGE(whoami, 'COMPUTING INITIAL LOCATION OF BULK BOUNDARY FROM SURFACE BOUNDARY:')
!
   else !
    goto 999
   endif
   bulk_boundary_distance = -(__BULK_DISTANCE_SCALE)*abs(surface_distance)
   bulk_boundary_contour_value = __RHOSAFE(bulk_boundary_distance)
   __MESSAGE(whoami, 'LOCATION OF BULK BOUNDARY SET TO '//ftoa(bulk_boundary_distance)//' A FROM PROTEIN. CONTOUR VALUE IS '//ftoa(bulk_boundary_contour_value))
 999  continue
  endif ! dasystat
#endif
!
! at this point, qforced_solv is wrong : it will be true everywhere, because surface distance was undefined (=0) in the calc. loop
! recompute qforced_solv :
  if (qminimum_distance) then
   qforced_solv=dist_solv.lt.surface_distance ! vector operation
!============================================================
  else ! (NOT) qminimum_distance
   qforced_solv=rho_solv.lt.surface_contour_value ! vector operation
  endif ! qminimum_distance
!====== NOTE : if we requested to run without neighbor lists then we need to reset solute_neighbor_mind to max
!====== otherwise, the early exit version of force routine could miss crucial atoms (the mind list is _not_ updated b/c qnlist=0)
!====== this is because solute_neighbor_mind is recomputed in a full loop, so it will be smaller than nsurf
#if defined(__NEIGHBOR_LIST) & defined(__SORT_LIST)
  if (.not. qneighbor_list) solute_neighbor_mind=nsurface
#endif
!=========================================================================
 else ! compute reference surface distance
! aa :  this is the most time consuming part of the force calculation ; perhaps we can do it on the GPU ? Or perhaps can regulate cost otherwise ?
  if (qminimum_distance) then ! simple min-dist calculation
!
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
   if (full_sum_freq.gt.izero) then
! CHKUPDATE false : to truncate sum if running density value exceeds reference
! ALSO if qneighbor_list = false, this algorithm will be used, looping over all solute/surface indices
! because in that case, the maximum index in solute_neighbor_mdist is nsurface
    call __NM(compute_mindist_grad)((.not.qneighbor_list) .or. (.not.__CHKUPDATE(full_sum_freq))) 
! NOTE that it makes no sense to run full sum w/o neighbor sorting, which requires nbr. list !
   else
#endif
    call __NM(compute_mindist_grad)(.true.) ! always call quit-early version; however, the max. index will be set to nsurface, so traverse full list
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
   endif ! full_sum_freq
#endif
!
  else ! original density-based (erf) calculation
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
   if (full_sum_freq.gt.izero) then
    call __NM(compute_density_grad)((.not.qneighbor_list) .or. (.not.__CHKUPDATE(full_sum_freq))) 
! as above for mindist
! truncate if running density value exceeds reference
   else
#endif
    call __NM(compute_density_grad)(.true.)
!
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
   endif
#endif
  endif ! qminimum_distance
! set surf changed flag
#if defined(__BAROSTAT) || defined (__DASYSTAT)
   if (&
#ifdef __BAROSTAT
&       barostat .or. &
#endif
#ifdef __DASYSTAT
&       dasystat .or. &
#endif
&       .false. ) surf_dist_changed=.true. ! we only need this variable for barostat/dasystat
#endif


 endif ! compute reference surface distance
!========================== compute contour value ^
!========================== compute forces :
! to do : calculate density integral using only atoms beyond contour (to estimate surface area)
! density_beyond_contour=zero ! useful ?
 surface_energy=zero
 surface_force=zero
 nsolvent_outside=izero
#ifdef __DASYSTAT
 solvent_mass_outside=zero
#endif
!
#ifdef __RMFT
 if (remove_net_torque) then
  ir1=zero ; ir2=zero; ir3=zero; ir1s=zero ; ir2s=zero ; ir3s=zero ; ir12=zero ; ir23=zero ; ir13=zero ;
  net_force=zero
  net_torque=zero
#ifdef __F_T_COUPLED
  A=zero
#endif
 endif
#endif
!
! NOTE: here OPENMP does not make much difference but keeping because we are good
! simple minimum distance algorithm
 if (qminimum_distance) then
#ifdef __OMP
!$omp parallel &
!$omp shared (dist_solv, ddist_solv, surface_distance, surface_force_constant, &
#ifdef __RMFT
!$omp remove_net_torque, net_force, net_torque, &
#ifdef __F_T_COUPLED
!$omp A, &
#endif
!$omp rhs, qforced_solv, r_com, &
!$omp ir1,ir2,ir3,ir1s,ir2s,ir3s,ir12,ir13,ir23, &
#endif
!$omp nsolvent, nsurface, nsolvent_outside, surface_force, surface_energy, &
#ifdef __DASYSTAT
!$omp solvent_mass_outside, mass_solv, &
#endif
!$omp isolvent_atoms, isurface_atoms, r_surf, r_solv, fr ) &
!$omp private (i, d0, pre, __U(nsolvent_outside), __U(surface_energy), __U(surface_force) &
#ifdef __DASYSTAT
!$omp , __U(solvent_mass_outside)  &
#endif
#ifdef __RMFT
!$omp ,ir, iforce, __U(net_force), __U(net_torque) &
!$omp ,__U(ir1),__U(ir2),__U(ir3),__U(ir1s),__U(ir2s),__U(ir3s),__U(ir12),__U(ir13),__U(ir23) &
#endif
!$omp )
 __U(surface_energy)=zero
 __U(surface_force)=zero
 __U(nsolvent_outside)=izero
#ifdef __DASYSTAT
 if (dasystat) __U(solvent_mass_outside)=zero
#endif
#ifdef __RMFT
  if (remove_net_torque) then
   __U(net_force)=zero
   __U(net_torque)=zero
   __U(ir1)=zero;__U(ir2)=zero;__U(ir3)=zero;__U(ir1s)=zero;__U(ir2s)=zero;__U(ir3s)=zero;__U(ir12)=zero;__U(ir13)=zero;__U(ir23)=zero
  endif
#endif
!
!$omp do schedule(runtime)
#endif
 do i=1, nsolvent
  if (qforced_solv(i)) then
   d0=dist_solv(i)
   __INC(__U(nsolvent_outside))
   pre = ( d0 - surface_distance ) ;
#ifdef __DASYSTAT
   if (dasystat) __INCR(__U(solvent_mass_outside), mass_solv(i))
#endif
!
#ifdef __RMFT
   if (remove_net_torque) then ! for now, here; optimize later, if needed
    ir=r_solv(:,i); ! removed r_com subtraction for extra flexibility ; to be accounted for later
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
!x
     __DECR(ir(1),r_pbc_reference(1))
     __PBCDIST(ir(1), ucell%a)
     __INCR(ir(1), r_pbc_reference(1))
!y
     __DECR(ir(2),r_pbc_reference(2))
     __PBCDIST(ir(2), ucell%b)
     __INCR(ir(2), r_pbc_reference(2))
!z
     __DECR(ir(3),r_pbc_reference(3))
     __PBCDIST(ir(3), ucell%c)
     __INCR(ir(3), r_pbc_reference(3))
    endif
#endif
!
#ifdef __TORQUE_FROM_FORCED_SOLVENT
    __UPDATE_TMAT_C
#endif
    iforce=surface_force_constant * pre / d0 * ddist_solv(:,i) ! re sign : note that surface_distance is negative
! set force
    __INCR(fr(1,isolvent_atoms(i)),iforce(1)) ;
    __INCR(fr(2,isolvent_atoms(i)),iforce(2)) ;
    __INCR(fr(3,isolvent_atoms(i)),iforce(3)) ;
! update net force & torque (torque missing COM contribution, to be added in later)
    __INCR(__U(net_force)(1),iforce(1))
    __INCR(__U(net_force)(2),iforce(2))
    __INCR(__U(net_force)(3),iforce(3))
    __INCR(__U(net_torque)(1), ir(2) * iforce(3) - ir(3) * iforce(2))
    __INCR(__U(net_torque)(2), ir(3) * iforce(1) - ir(1) * iforce(3))
    __INCR(__U(net_torque)(3), ir(1) * iforce(2) - ir(2) * iforce(1))
#if defined (__BAROSTAT) & defined (__FNORM)
    if (barostat) d0=norm3(iforce)
#endif
!
   else ! keep net force/torque
#endif
! just set the force
    d0=surface_force_constant * pre / d0
    __INCR(fr(1,isolvent_atoms(i)), d0 * ddist_solv(1,i))
    __INCR(fr(2,isolvent_atoms(i)), d0 * ddist_solv(2,i))
    __INCR(fr(3,isolvent_atoms(i)), d0 * ddist_solv(3,i))
#if defined (__BAROSTAT) & defined (__FNORM)
    if (barostat) d0=d0*norm3(ddist_solv(:,i))
#endif
!
#ifdef __RMFT
   endif
#endif
! sum "energy"
! NOT clear how the surface_force or energy are meaningful
#if defined(__BAROSTAT)
   if (barostat) &
#ifdef __FNORM
&   __INCR(__U(surface_force), d0) ! cumulative force magnitude
#else
&   __INCR(__U(surface_force), pre) ! x k, below
#endif
#endif
   __INCR(__U(surface_energy), pre**2) ! x k/2, below
  else ! distance check - atoms that are not forced

#ifdef __RMFT
   if (remove_net_torque) then ! for now, here; optimize later
#ifdef __TORQUE_FROM_FREE_SOLVENT
    ir=r_solv(:,i);
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
!x
     __DECR(ir(1),r_pbc_reference(1))
     __PBCDIST(ir(1), ucell%a)
     __INCR(ir(1), r_pbc_reference(1))
!y
     __DECR(ir(2),r_pbc_reference(2))
     __PBCDIST(ir(2), ucell%b)
     __INCR(ir(2), r_pbc_reference(2))
!z
     __DECR(ir(3),r_pbc_reference(3))
     __PBCDIST(ir(3), ucell%c)
     __INCR(ir(3), r_pbc_reference(3))
    endif
#endif
!
    __UPDATE_TMAT_C
#endif
   endif ! remove_net_torque
#endif
!   fr(:,isolvent_atoms(i))=zero ! make sure this is done somewhere
  endif ! distance check
 enddo ! nsolvent
#ifdef __OMP
!$omp end do
!$omp atomic
 __REDUCE(nsolvent_outside)
!$omp atomic
 __REDUCE(surface_energy)
#ifdef __BAROSTAT
if (barostat) then
!$omp atomic
 __REDUCE(surface_force)
endif
#endif
#ifdef __DASYSTAT
if (dasystat) then
!$omp atomic
 __REDUCE(solvent_mass_outside)
endif
#endif
#endif
! code section for torque removal; sorry, not a subroutine, but repeated below, hence outside
#include "watershell_rmft_aux1.ftn"
!
#ifdef __OMP
!$omp end parallel
#endif
 else ! not qminimum_distance, i.e. original algorithm
!================= original density based algorithm ==================
#ifdef __OMP
!$omp parallel &
!$omp shared (rho_solv, drho_solv, surface_contour_value, surface_distance, logistic_constant, surface_force_constant, &
#ifdef __DASYSTAT
!$omp solvent_mass_outside, solvent_mass, &
#endif
#ifdef __RMFT
!$omp remove_net_torque, net_force, net_torque, &
#ifdef __F_T_COUPLED
!$omp A, &
#endif
!$omp rhs, qforced_solv, r_com, &
!$omp ir1,ir2,ir3,ir1s,ir2s,ir3s,ir12,ir13,ir23, &
#endif
!$omp nsolvent_outside, surface_force, surface_energy, isolvent_atoms, fr) & !!! , density_beyond_contour) &
!$omp private (i, d0, pre, __U(nsolvent_outside), __U(surface_energy), __U(surface_force) & !!! , __U(density_beyond_contour)) &
#ifdef __DASYSTAT
!$omp , __U(solvent_mass_outside) &
#endif
#ifdef __RMFT
!$omp ,ir, iforce, __U(net_force), __U(net_torque) &
!$omp ,__U(ir1),__U(ir2),__U(ir3),__U(ir1s),__U(ir2s),__U(ir3s),__U(ir12),__U(ir13),__U(ir23) &
#endif
!$omp )
!
! __U(density_beyond_contour)=zero ! not clear whether useful
 __U(surface_energy)=zero
 __U(surface_force)=zero
 __U(nsolvent_outside)=izero
#ifdef __DASYSTAT
 __U(solvent_mass_outside)=zero
#endif
#ifdef __RMFT
  if (remove_net_torque) then
   __U(net_force)=zero
   __U(net_torque)=zero
   __U(ir1)=zero;__U(ir2)=zero;__U(ir3)=zero;__U(ir1s)=zero;__U(ir2s)=zero;__U(ir3s)=zero;__U(ir12)=zero;__U(ir13)=zero;__U(ir23)=zero
  endif
#endif
!$omp do schedule(runtime)
#endif
 do i=1, nsolvent
  if ( qforced_solv(i) ) then
   __INC(__U(nsolvent_outside))
#ifdef __DASYSTAT
   if(dasystat) __INCR(__U(solvent_mass_outside), mass_solv(i))
#endif
   if ( abs(rho_solv(i)) .eq. zero ) then ! proceed if the density is positive ; otherwise warn that we are outside of the support
    __WRN(whoami, '#'//itoa(iteration)//': SOLVENT ATOM '//itoa(isolvent_atoms(i))//' OUTSIDE OF SOLUTE SUPPORT. RESTART WITH A SMALLER SURFACE DISTANCE OR A LARGER FILTER CUTOFF.')
    cycle
   endif
!   __INCR(__U(density_beyond_contour), rho_solv(i)) ! not clear whether useful
   d0=__OORHO( rho_solv(i)) ! unsafe inverse, but rho > 0 per above
   pre = ( __RHO_INVERSE2 ( d0 ) - surface_distance ) ;
!
#ifdef __RMFT
   if (remove_net_torque) then ! for now, here; optimize later, if needed
    ir=r_solv(:,i); ! removed r_com subtraction for extra flexibility ; to be accounted for later
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
!x
     __DECR(ir(1),r_pbc_reference(1))
     __PBCDIST(ir(1), ucell%a)
     __INCR(ir(1), r_pbc_reference(1))
!y
     __DECR(ir(2),r_pbc_reference(2))
     __PBCDIST(ir(2), ucell%b)
     __INCR(ir(2), r_pbc_reference(2))
!z
     __DECR(ir(3),r_pbc_reference(3))
     __PBCDIST(ir(3), ucell%c)
     __INCR(ir(3), r_pbc_reference(3))
    endif
#endif
!
#ifdef __TORQUE_FROM_FORCED_SOLVENT
    __UPDATE_TMAT_C
#endif
!
! add atomic force
    d0=logistic_constant*d0*(__OORHOSAFE(one-rho_solv(i))) ! derivative of the inverse of logistic function
    iforce = - surface_force_constant * pre * d0 * drho_solv(:,i) ! (-) because surface_distance is negative ; grad points toward protein
!   fr(:,isolvent_atoms(i)) = - surface_force_constant * pre * d0 * drho_solv(:,i) ! (-) because surface_distance is negative ; grad points toward protein
    __INCR(fr(1,isolvent_atoms(i)),iforce(1))
    __INCR(fr(2,isolvent_atoms(i)),iforce(2))
    __INCR(fr(3,isolvent_atoms(i)),iforce(3))
! update net force & torque (torque missing COM contribution, to be added in later)
    __INCR(__U(net_force)(1),iforce(1))
    __INCR(__U(net_force)(2),iforce(2))
    __INCR(__U(net_force)(3),iforce(3))
    __INCR(__U(net_torque)(1), ir(2) * iforce(3) - ir(3) * iforce(2))
    __INCR(__U(net_torque)(2), ir(3) * iforce(1) - ir(1) * iforce(3))
    __INCR(__U(net_torque)(3), ir(1) * iforce(2) - ir(2) * iforce(1))
#ifdef __BAROSTAT
    d0=norm3(iforce)
#endif
   else ! keep net force/torque
#endif
    d0 = - surface_force_constant * pre * d0
    __INCR(fr(1,isolvent_atoms(i)), d0 * drho_solv(1,i))
    __INCR(fr(2,isolvent_atoms(i)), d0 * drho_solv(2,i))
    __INCR(fr(3,isolvent_atoms(i)), d0 * drho_solv(3,i))
#ifdef __BAROSTAT
    d0=d0*norm3(drho_solv(:,i))
#endif
#ifdef __RMFT
   endif
#endif

! sum "energy"
! NOT clear whether the surface_energy is meaningful
! surface force is used for pressure calculations (but only if barostat is on !)
#ifdef __BAROSTAT
   __INCR(__U(surface_force), d0) ! actual force magnitude
#endif
   __INCR(__U(surface_energy), pre**2) ! x k/2, below
  else ! for atoms that are not forced
#ifdef __RMFT
#ifdef __TORQUE_FROM_FREE_SOLVENT
   if (remove_net_torque) then ! for now, here; optimize later
    ir=r_solv(:,i);
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
!x
     __DECR(ir(1),r_pbc_reference(1))
     __PBCDIST(ir(1), ucell%a)
     __INCR(ir(1), r_pbc_reference(1))
!y
     __DECR(ir(2),r_pbc_reference(2))
     __PBCDIST(ir(2), ucell%b)
     __INCR(ir(2), r_pbc_reference(2))
!z
     __DECR(ir(3),r_pbc_reference(3))
     __PBCDIST(ir(3), ucell%c)
     __INCR(ir(3), r_pbc_reference(3))
    endif
#endif
!
    __UPDATE_TMAT_C
   endif ! remove_net_torque
#endif
#endif
!   fr(:,isolvent_atoms(i))=zero ! make sure this gets done somewhere
  endif ! density check
 enddo ! nsolvent
#ifdef __OMP
!$omp end do
!$omp atomic
  __REDUCE(nsolvent_outside)
!$omp atomic
  __REDUCE(surface_energy)
#ifdef __BAROSTAT
if (barostat) then
!$omp atomic
  __REDUCE(surface_force)
endif
#endif
!  __REDUCE(density_beyond_contour) ! not clear if useful
#ifdef __DASYSTAT
if (dasystat) then
!$omp atomic
 __REDUCE(solvent_mass_outside)
endif
#endif
#endif
#include "watershell_rmft_aux1.ftn"
#ifdef __OMP
!$omp end parallel
#endif
!
 endif ! qminimum_dist
!
! compute current surface distance from pre :
! NOTE: check below to make sure consistent for erf/density ; yes it is;
! we are using the boundary potential : k/2 x [ L^-1 (rho) - d0 ] ^ 2 ;
! d0 is the quasi-distance to boundary
! L^-1(rho) is the logistic function approximant
! are the forces on the body are still k ( L^-1(rho) - d0 ) ? NO, because d (d0) / d(r) is not 1 !
! but if k is large, then d0 is very close to L^-1(rho) and d d0/dr ~= |grad_r L^-1 (rho)| (which is the norm of the forces, as you might expect !)
! the forces on the atoms are obtained by differentiation w.r.t position (x) :
! F(x) = - k ( L^-1(rho) - d0 ) * logistic_const / (1-L) / L * grad (rho)

 if (nsolvent_outside .gt. 0) then
  oonsolvent_outside=one/nsolvent_outside
 else
  oonsolvent_outside=zero ;
 endif
!
#if defined(__BAROSTAT) & !defined(__FNORM)
 if (qminimum_distance) __SCALE(surface_force, -surface_force_constant) ! negative because of sign convention
#endif
 __SCALE(surface_energy, half*surface_force_constant)
!
 __INCR(energy,surface_energy)
!
! barostat-related code :
! ==========================================================================================
#ifdef __BAROSTAT
 if (barostat) then
!== compute/update pressure :
  if (pressure_update_freq.gt.0) then
   if __CHKUPDATE(pressure_update_freq) then
!
 __DBGVAR(r_surf_changed,1)
 __DBGVAR(surface_area_compute_freq,1)
 __DBGVAR(pressure_update_freq,1)
 __DBGVAR(iteration,1)
 __DBGVAR(__CHKUPDATE(surface_area_compute_freq*pressure_update_freq),1)
!== first, compute surface area :
    if (((r_surf_changed.or.surf_dist_changed).and.surface_area_compute_freq.gt.0).or.surface_area<zero) then ! note : a check to only recompute SA if surface atoms changed
     if (__CHKUPDATE(surface_area_compute_freq*pressure_update_freq) .or. surface_area<zero) then
! check periodicity flag
      __PRESENT(qper,qper_parser_override)
      if (qper.neqv.qper_parser_override) then
       __WRN(whoami, 'CANNOT CHANGE PERIODICITY FLAG DURING DYNAMICS WITH WATERSHELL BAROSTAT. INITIAL :'//ltoa(qper_parser_override)//', CURRENT :'//ltoa(qper))
      elseif (qper) then ! check that mdcell, if passed in, did not change
       if (present(mdcell)) then
        if &
&        ((abs(mdcell%a - sagrid%lengths(1)) .gt. __ERRTOL) .or. &
&         (abs(mdcell%b - sagrid%lengths(2)) .gt. __ERRTOL) .or. &
&         (abs(mdcell%c - sagrid%lengths(3)) .gt. __ERRTOL)) then
          __WRN(whoami, 'CANNOT CHANGE UNIT CELL DIMENSIONS DURING DYNAMICS WITH WATERSHELL BAROSTAT.')
          __ASSERT(abs(mdcell%a - sagrid%lengths(1)),<, __ERRTOL)
          __ASSERT(abs(mdcell%b - sagrid%lengths(2)),<, __ERRTOL)
          __ASSERT(abs(mdcell%c - sagrid%lengths(3)),<, __ERRTOL)
        endif
       endif
      endif ! qper
#if defined(__RMFT) && defined(__TORQUE_COM_SURFACE)
      if (remove_net_torque) then
       r_com_sa=r_com
      else
       r_com_sa=oonsurface * sum(r_surf,2)
      endif
#else
      r_com_sa=oonsurface * sum(r_surf,2)
#endif
! check that grid dimensions are still adequate : 
      if (.not.qper_parser_override.and.surface_area_grid_check_freq.gt.0) then
       if __CHKUPDATE(surface_area_grid_check_freq*surface_area_compute_freq*pressure_update_freq) then
        r_surf_minmax(1,:) = minval(r_surf,2) - r_com_sa - (abs(surface_distance)+surface_area_grid_buffer)
        r_surf_minmax(2,:) = maxval(r_surf,2) - r_com_sa + (abs(surface_distance)+surface_area_grid_buffer)
        if (any(abs(r_surf_minmax(2,:) - r_surf_minmax(1,:) - sagrid%lengths).gt.surface_area_grid_recompute_change)) then
         __MESSAGE(whoami, 'REINITIALIZING SURFACE AREA COMPUTATION GRID.');
         call ugrid_finalize(sagrid)
         call ugrid_initialize(sagrid, 3, r_surf_minmax, (/surface_area_grid_spacing/), adjust_spacings_=.false.)
!
#ifdef __DEBUG
         __DBGVAR(sagrid%n,1)
         write(666,'(2G20.10)') r_surf_minmax
         write(666,*) sagrid%initialized
         write(666,*) sagrid%ndim
         write(666,*) sagrid%n
         close(666)
#endif
!
          if (qminimum_distance) then
#ifdef __OMP
           __DEALL(sarho_all_threads)
           allocate(sarho_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:omp_get_max_threads()-1))
#else
          __DEALL(sarho)
           allocate(sarho(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#endif
          else
#ifdef __OMP
           __DEALL(sarhof_all_threads)
           allocate(sarhof_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:omp_get_max_threads()-1))
#else
          __DEALL(sarhof)
           allocate(sarhof(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#endif
          endif
!
        endif
       endif
      endif
! compute SA
      if (qminimum_distance) then
       call __NM(compute_surface_area_mindist)()
      else
       call __NM(compute_surface_area)()
      endif ! mindist
!
      r_surf_changed=.false.
      surf_dist_changed=.false.
!
     endif ! chkupdate
    endif ! surface area compute
!
    pressure = surface_force/surface_area * atm_per_akma ! note that for code generality this would have to be made nondimensional
__DBGVAR(surface_force,1)
__DBGVAR(surface_area,1)
__DBGVAR(akma_per_pa,1)
__DBGVAR(akma_per_atm,1)
__DBGVAR(atm_per_akma,1)
__DBGVAR(pressure,1)
__DBGVAR(pressure_ave,1)
!
! update running average
    if (pressure_num_samples<pressure_max_samples) __INC(pressure_num_samples)
    d0=1d0/pressure_num_samples
     __INCR(pressure_ave, d0 * (pressure - pressure_ave))
! repeat for long-time average pressure
    if (pressure_num_long_samples<pressure_max_long_samples) __INC(pressure_num_long_samples)
    d0=1d0/pressure_num_long_samples
     __INCR(pressure_long_ave, d0 * (pressure - pressure_long_ave))
   endif ! chkupdate
  endif ! pressure update
!
!=========================== evolve/update contour/distance value
  if (distance_update_freq.gt.0) then
! NOTE : it might happen that we did not yet compute the pressure; in this case, pressure_ave is unphysical ; unclear what to do in this case
! we could disallow negative pressures (which are unphysical, but could be useful in a controller) ; then could use pressure<0 as a flag, as done in the density case
   if __CHKUPDATE(distance_update_freq) then
!
! note that when the pressure is lower than the target pressure (NB: we technically cannot get below zero pressure because of the type of potential)
! the code will most likely adjust it up very slowly (since the pressures in question are quite small - e.g. 1 atm) ; in such cases, we should have a faster
! method of adjustment
!
    if (abs(distance_update_step).gt.0) then
#ifdef __PDIRECT
     d0 = ( pressure_target - pressure_ave )
#else
! a more gentle evolution, based loosely on the hypothesis that PV ~= const
! need to protect against large divide by zero
!    d0 = ( one/pressure_ave - one/pressure_target )
     d0 = ( one/max(__ERRTOL,pressure_ave) - oopressure_target )
#endif
!  limit large changes for stability, e.g.
     d0 = sign( min(one, abs(d0)), d0 );
     if ( (surface_distance.gt.__MINSURFDIST) .or. (d0.gt.zero)) then
      __INCR(surface_distance, distance_update_step * d0) ! note that surface_distance < 0 in our notation ; so too high p => dist decr.
      surf_dist_changed=.true.
! check to make sure the distance is not too large; if so, warn and limit
      if (surface_distance .lt. __MINSURFDIST) then
       __WRN(whoami, 'SHELL SURFACE DISTANCE HAS REACHED LARGEST ALLOWED VALUE ('//ftoa(abs(__MINSURFDIST))//'). RESTART WITH INCREASED CUTOFF OR PADDING')
       surface_distance = __MINSURFDIST
      endif
      surface_contour_value = __RHOSAFE(surface_distance)
     endif
 __DBGVAR(distance_update_step * d0, 1)
 __DBGVAR(surface_distance, 1)
 __DBGVAR(surface_contour_value, 1)
    endif
   endif
  endif
 endif ! barostat-related
#endif
! BAROSTAT-RELATED CODE ^
! ==========================================================================================
! DASYSTAT-RELATED CODE v (with much repetition from above, but otherwise too complicated to follow if intermingled with barostat)
#ifdef __DASYSTAT
 if (dasystat) then
!== compute/update density :
  if (density_update_freq.gt.0) then
   if __CHKUPDATE(density_update_freq) then
!
 __DBGVAR(r_surf_changed,1)
 __DBGVAR(surface_area_compute_freq,1)
 __DBGVAR(density_update_freq,1)
 __DBGVAR(iteration,1)
 __DBGVAR(__CHKUPDATE(surface_area_compute_freq*density_update_freq),1)
!== first, compute volume :
    if (((r_surf_changed.or.surf_dist_changed).and.surface_area_compute_freq.gt.0).or.volume_bulk<zero) then ! note : a check to only recompute SA if surface atoms changed
     if __CHKUPDATE(surface_area_compute_freq*density_update_freq) then
! check periodicity flag
      __PRESENT(qper,qper_parser_override)
      if (qper.neqv.qper_parser_override) then
       __WRN(whoami, 'CANNOT CHANGE PERIODICITY FLAG DURING DYNAMICS WITH WATERSHELL DASYSTAT. INITIAL :'//ltoa(qper_parser_override)//', CURRENT :'//ltoa(qper))
      elseif (qper) then ! check that mdcell, if passed in, did not change
       if (present(mdcell)) then
        if &
&        ((abs(mdcell%a - sagrid%lengths(1)) .gt. __ERRTOL) .or. &
&         (abs(mdcell%b - sagrid%lengths(2)) .gt. __ERRTOL) .or. &
&         (abs(mdcell%c - sagrid%lengths(3)) .gt. __ERRTOL)) then
          __WRN(whoami, 'CANNOT CHANGE UNIT CELL DIMENSIONS DURING DYNAMICS WITH WATERSHELL DASYSTAT.')
          __ASSERT(abs(mdcell%a - sagrid%lengths(1)),<, __ERRTOL)
          __ASSERT(abs(mdcell%b - sagrid%lengths(2)),<, __ERRTOL)
          __ASSERT(abs(mdcell%c - sagrid%lengths(3)),<, __ERRTOL)
        endif
       endif
      endif ! qper
#if defined(__RMFT) && defined(__TORQUE_COM_SURFACE)
      if (remove_net_torque) then
       r_com_sa=r_com
      else
       r_com_sa=oonsurface * sum(r_surf,2)
      endif
#else
      r_com_sa=oonsurface * sum(r_surf,2)
#endif
! check that grid dimensions are still adequate : 
      if (.not.qper_parser_override.and.surface_area_grid_check_freq.gt.0) then
       if __CHKUPDATE(surface_area_grid_check_freq*surface_area_compute_freq*density_update_freq) then
        r_surf_minmax(1,:) = minval(r_surf,2) - r_com_sa - (abs(surface_distance)+surface_area_grid_buffer)
        r_surf_minmax(2,:) = maxval(r_surf,2) - r_com_sa + (abs(surface_distance)+surface_area_grid_buffer)
        if (any(abs(r_surf_minmax(2,:) - r_surf_minmax(1,:) - sagrid%lengths).gt.surface_area_grid_recompute_change)) then
         __MESSAGE(whoami, 'REINITIALIZING VOLUME COMPUTATION GRID.');
         call ugrid_finalize(sagrid)
         call ugrid_initialize(sagrid, 3, r_surf_minmax, (/surface_area_grid_spacing/), adjust_spacings_=.false.)
!
         __DBGVAR(sagrid%n,1)
         __DBGVAR(r_surf_minmax,1)
         __DBGVAR(sagrid%initialized,1)
         __DBGVAR(sagrid%n,1)
!
         if (qminimum_distance) then
#ifdef __OMP
          __DEALL(sarho_all_threads)
          allocate(sarho_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:omp_get_max_threads()-1))
          __DEALL(inrho_all_threads)
          allocate(inrho_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:omp_get_max_threads()-1))
#else
          __DEALL(sarho)
          allocate(sarho(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
          __DEALL(inrho)
          allocate(inrho(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#endif
         else
#ifdef __OMP
          __DEALL(sarhof_all_threads)
          allocate(sarhof_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:omp_get_max_threads()-1))
#else
          __DEALL(sarhof)
          allocate(sarhof(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#endif
         endif
        endif ! reallocate
       endif ! grid size check
      endif ! grid size check
! compute volume
      if (qminimum_distance) then
       call __NM(compute_bulk_volume_mindist)()
      else
       call __NM(compute_bulk_volume)()
      endif ! mindist
!
  __DBGVAR(volume_bulk,1)
!
      r_surf_changed=.false.
      surf_dist_changed=.false.
!
     endif ! chkupdate area compute
    endif ! surface area/volume compute
!
    density = (solvent_mass - (solvent_mass_nonbulk + solvent_mass_outside))/volume_bulk*gml_per_akma ! note that for code generality this would have to be made nondimensional
__DBGVAR(surface_distance,1)
__DBGVAR(bulk_boundary_distance,1)
__DBGVAR(solvent_mass,1)
__DBGVAR(solvent_mass_nonbulk,1)
__DBGVAR(solvent_mass_outside,1)
__DBGVAR(volume_bulk,1)
__DBGVAR(gml_per_akma,1)
__DBGVAR(density,1)
__DBGVAR(density_ave,1)
!
! update running average
    if (density_num_samples<density_max_samples) __INC(density_num_samples)
    d0=1d0/density_num_samples
     __INCR(density_ave, d0 * (density - density_ave))
   endif ! chkupdate
  endif ! density update
!
!=========================== evolve/update contour/distance value
  if (distance_update_freq.gt.0) then
! NOTE : in the current code it might happen that we did not yet compute the density (if done infrequently); in that case d<0
   if (__CHKUPDATE(distance_update_freq) .and. density_ave>zero) then
    if (abs(distance_update_step).gt.zero) then
     d0 = ( density_target - density_ave )
     if ((surface_distance.gt.__MINSURFDIST) .or. (d0.gt.zero)) then
      __INCR(surface_distance, d0 * distance_update_step) ! note that surface_distance < 0 in our notation ; so too high p => dist decr.
      surf_dist_changed=.true.
! check to make sure the distance is not too large; if so, warn and limit (same as barostat code)
      if (surface_distance .lt. __MINSURFDIST) then
       __WRN(whoami, 'SHELL SURFACE DISTANCE HAS REACHED LARGEST ALLOWED VALUE ('//ftoa(abs(__MINSURFDIST))//'). RESTART WITH INCREASED CUTOFF OR PADDING')
       surface_distance = __MINSURFDIST
      endif
      surface_contour_value = __RHOSAFE(surface_distance)
     endif
    endif
   endif
!
   __DBGVAR(surface_contour_value,1)
!
! make sure that the bulk boundary is not too close to the surface to obtain an accurate density
   if( (abs(surface_distance) - abs(bulk_boundary_distance)) .lt. &
&    ( __BULK_BOUNDARY_RECOMPUTE_FACTOR * abs(surface_distance) ) ) then ! recompute bulk_bdry
    __MESSAGE(whoami, 'BULK BOUNDARY IS TOO CLOSE TO SURFACE BOUNDARY. WILL RECOMPUTE:') 
    bulk_boundary_distance = -(__BULK_DISTANCE_SCALE)*abs(surface_distance)
    bulk_boundary_contour_value = __RHOSAFE(bulk_boundary_distance)
    __MESSAGE(whoami, 'LOCATION OF BULK BOUNDARY SET TO '//ftoa(bulk_boundary_distance)//' A FROM PROTEIN. CONTOUR VALUE IS '//ftoa(bulk_boundary_contour_value))
   endif ! bulk_bdry
!
  endif
 endif ! dasystat-related
#endif
!============================================= output restart file
 if (output_freq.gt.0) then
  if __CHKUPDATE(output_freq) then
! write a short update of simulation parameters:
  i=0 ;
#define __OUT(...)  __INC(i);write(_MSGBUF(i),*) __VA_ARGS__
#define _TAB char(9)//char(9)
  __OUT('===================')
  __OUT('Iteration:', iteration)
  __OUT('Target distance to protein:      ', surface_distance)
! this needs to be computed here, because we do not need it at every step:
  if (qminimum_distance) then
   current_surface_distance = SUM(dist_solv, MASK = (qforced_solv.eqv..true.))*oonsolvent_outside
  else
   current_surface_distance = SUM (__RHO_INVSAFE(rho_solv), MASK = (qforced_solv.eqv..true.))*oonsolvent_outside
  endif
!
  __OUT('Current avg. distance to protein:', current_surface_distance)
  __OUT('Surface energy:                  ', surface_energy)
  __OUT('# Solute atoms used for density: ', nsurface)
  __OUT('# Solvent atoms outside / total: ', nsolvent_outside,'/',nsolvent)
 if (.not. qminimum_distance) then ! not relevant to mindist algorithm
  __OUT('Surface contour value:           ', surface_contour_value)
 endif
#if defined(__SHOW_TORQUE) && defined(__RMFT)
  if (remove_net_torque) then
   __OUT('Net force applied to system:    ', net_force)
   __OUT('Net torque applied to system:   ', net_torque)
  endif
#endif
#ifdef __BAROSTAT
  if (barostat) then
   __OUT('Target pressure (atm):           ', pressure_target)
   __OUT('Simulation pressure (short):     ', pressure_ave)
   __OUT('Average pressure (long):         ', pressure_long_ave)
   __OUT('Instantaneous pressure (atm):    ', pressure)
   __OUT('Total force on solvent shell :   ', surface_force)
   __OUT('Surface area of solvent shell :  ', surface_area)
  endif
#endif
#ifdef __DASYSTAT
  if (dasystat) then
   __OUT('Target density (g/mL):           ', density_target)
   __OUT('Simulation density (g/mL):       ', density_ave)
   __OUT('Instantaneous density (g/mL):    ', density)
   __OUT('Mass of bulk solvent (amu):      ', solvent_mass-solvent_mass_outside-solvent_mass_nonbulk)
   __OUT('Volume of bulk solvent (Ang^3):  ', volume_bulk)
   __OUT('Bulk boundary distance:          ', bulk_boundary_distance)
__DBGVAR(solvent_mass,1)
__DBGVAR(solvent_mass_outside,1)
__DBGVAR(solvent_mass_nonbulk,1)
  endif
#endif
  __OUT('===================')
!
  __PRINT(_MSGBUF)

! write restart file
   __MESSAGE(whoami, 'WRITING OUTPUT/RESTART FILE TO ("'//trim(output_file)//'")')
   call __NM(write_restart_file)
!
  endif
 endif
!
 end __SUB(main)
!================================================================
 __SUB(compute_density_grad)(qtruncate_loop)
#ifdef __OMP
 use omp_lib
#endif
!
 bool :: qtruncate_loop ! whether we can stop looping over solute atoms once the density reaches a threshold value
! ^ this allows the neighbor lists to be sorted only ; if __SORT_LIST is undefined then there is not effect
!   the density calculation is still truncated once the atom is determined to be inside
!   to avoid the truncation, you must define an upper bound to the surface contour, which is nsurface
 int :: i, j
 float :: rp(3), rw(3), dr(3), dr2, a, b, expa, expb, ooc
! real*4 :: as, bs
#ifdef __SORT_LIST
 int :: jj
 float :: dr2old ! squared distance difference from previous iteration
#if defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 float :: neighbor_list_length
 int :: neighbor_list_misses
#ifdef __OMP
 int :: __U(neighbor_list_misses)
#endif
#endif
#endif
#ifdef __ERFHYBRID
 float :: isgn_, x_, erfa, erfb
#endif
 float :: rmaxsurf, rsurf ! , rsurfn
#ifdef __DASYSTAT
#ifdef __OMP
 float :: __U(solvent_mass_nonbulk)
#endif
 bool :: qbulk
#endif
 bool :: qforced
 __IAM(__NM(compute_density_grad))
!
! different erf implementations/approximations
  float :: erfsun ! external erf function; code by Sun Microsystems
  float :: erfo7  ! approximation to within O(-7)
  float :: erfo5  ! approximation to within O(-5) [contains an exponential term]
!
#ifdef __DDEBUG
#ifdef __OMP
!$omp parallel
!$omp single
 __DBGOUT('OMP: Available processors: ',omp_get_num_procs());
 __DBGOUT('OMP: Maximum threads:      ',omp_get_max_threads());
 __DBGOUT('OMP: Current threads:      ',omp_get_num_threads());
 __DBGOUT('OMP: This thread:          ',omp_get_thread_num());
!$omp end single
!$omp end parallel
#endif __OMP
#endif
!
! naive algorithm to compute density at each solvent coordinate
! adapted from molecule.ftn in continua
!
! error function definition
#ifndef __erf
#//define __erf erf
#// get an improvement of 20% when using inlined erfo7
#//define __erf __erfo7s
#define __erf __erfo7
#endif
!
! if openmp is used, cannot call the function erfo7, so hack to call inlined macro here
#ifdef __OMP
#//define erfo7 __erfo7s
#define erfo7 __erfo7
#endif
!
#ifdef __DASYSTAT
 if (dasystat) solvent_mass_nonbulk=zero
#endif
 if (qtruncate_loop) then
#ifdef __OMP
!$omp parallel &
!$omp shared ( rho_solv, drho_solv, r_solv, r_surf, rad_surf, surf_padding, nsolvent, nsurface, cutoff_surf, oo_surf_stdev &
#ifdef __DASYSTAT
!$omp , solvent_mass_nonbulk, mass_solv &
#endif
#ifdef __SORT_LIST
!$omp , solute_neighbor_list &
#ifdef __NEIGHBOR_LIST
!$omp , solute_neighbor_mind &
#endif
#endif
!$omp ) &
!$omp private ( rw, i, j, rp, rsurf, rmaxsurf, dr, dr2, ooc, expa, expb, qforced &
#ifdef __DASYSTAT
!$omp , __U(solvent_mass_nonbulk) &
#endif
#ifdef __SORT_LIST
!$omp ,dr2old, jj &
#endif
!$omp )
#ifdef __DASYSTAT
 if (dasystat) __U(solvent_mass_nonbulk)=zero
#endif
!$omp do schedule(runtime)
#endif
  do i=1, nsolvent ! outer loop over solvent atoms
! does not help below
!#define zero 0d0
!#define one 1d0
!#define half 0.5d0
!#define osq2pi 0.398942280401433d0
!#define osq2   0.707106781186547d0
!
   qforced=.true.
   rho_solv(i)=zero ;
   drho_solv(:,i)=zero
   rw=r_solv(:,i);
#ifdef __SORT_LIST
   dr2old=-1.d0 ; ! set to a small number to guarantee that no swap is done on first iteration
#ifdef __NEIGHBOR_LIST
   do jj=1, __NEIGHBOR_LIST_LENGTH_DENSITY
#else
   do jj=1, nsurface ! inner loop over solute atoms
#endif
    j=solute_neighbor_list(jj,i)
#else
   do j=1, nsurface ! inner loop over solute atoms
#endif
!#define _nonce  rho_solv(i)=0.0001d0;
!    if (qtruncate_sum.and.rho.gt.surface_contour_value) &     ! density threshold exceeded ; will not apply force to this atom
!    exit
!     cycle ! could actually be faster than exit (vectorization?) ; get 107 w/o if above
! determine if atoms are too far away :
! _nonce cycle ! aa get 110
    rp=r_surf(:,j)
!
! _nonce cycle ! aa get 111
    rsurf    = ( rad_surf(j) + surf_padding )
    rmaxsurf = ( cutoff_surf + rsurf  ) ! note that this can be precomputed
!
!_nonce  cycle ! aa get 105
    dr = rp-rw ;
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
     __DIST_PBC(dr(1),ucell%a)
     __DIST_PBC(dr(2),ucell%b)
     __DIST_PBC(dr(3),ucell%c)
    endif
#endif
! _nonce  cycle ! aa get 105
!__DBGOUT('i ', i, ' RW: ', rw)
!__DBGOUT('j ', j, ' RP: ', rp)
!__DBGOUT(' DR: ', dr, rmaxsurf)
!    if (any(abs(dr) .gt. rmaxsurf)) cycle ! not necessary, might actually slow the code
    dr2=sum(dr**2);
#ifdef __SORT_LIST
! bubble sort between this and previous atom base on distance
! one issue here is that rmaxsurf depends on the atom radius ; 
! i.e. perhaps sorting should take that into account ?
! speccifically, should we compare :
!
! ( dr - rmax ) < ( drold - rmaxold) ? swap : continue
!
! Note that, in the above, the sign matters
! The point is that atoms with a larger radius contribute more to the density
! even though the distance between their center to the solvent atom is larger
! For now, will keep as is, since the adaptive algorithm should correct for the sort inaccuracy, but may be fixed in the future
!
    if (dr2 .lt. dr2old) then ! bubble sort
     solute_neighbor_list(jj,i)=solute_neighbor_list(jj-1,i)
     solute_neighbor_list(jj-1,i)=j
    endif
    dr2old=dr2
#endif
!
    if (dr2 .gt. rmaxsurf**2) cycle
! _nonce cycle ! aa get 54
! proceed with calculation
    rsurf=rsurf * oo_surf_stdev ! NOTE: redefining rsurf to get rid of variable rsurfn (rsurf <== rsurfn)
    dr2 = sqrt(dr2) * oo_surf_stdev
! _nonce cycle ! aa
! a and b
    a = osq2 * (dr2 + rsurf)
    b = osq2 * (dr2 - rsurf)
!    as=a
!    bs=b
    ooc = one / dr2
! _nonce cycle ! aa get 54
!
    expa = exp ( - a**2 )
    expb = exp ( - b**2 )
! _nonce cycle ! aa
!
! update density
#ifdef __ERFHYBRID
    __erfo7i(a,erfa)
    __erfo7i(b,erfb)
    __INCR(rho_solv(i), half * ( erfa - erfb ) + osq2pi * ooc * ( expa - expb )   )
#else
    __INCR(rho_solv(i), half * ( __erf(a) - __erf(b) ) + osq2pi * ooc * ( expa - expb )   )
#endif
!
#ifdef __DASYSTAT
    if (dasystat) then
     if(rho_solv(i).gt.bulk_boundary_contour_value) then ! atom is inside bulk boundary
      __INCR(__U(solvent_mass_nonbulk), mass_solv(i))
      qforced=.false.
      exit ! density threshold exceeded ; will not apply force to this atom
     elseif(qforced) then
      if (rho_solv(i).gt.surface_contour_value) then ! not bulk, but still inside ; if already marked (qforced=t, skip)
       qforced=.false. ! however, do not quit because we still do not know whether we are iside bulk
      else
! otherwise, compute gradient contribution : (note that I am flipping the direction of dr (in the notes it is r0-r)
! NOTE (10/18) : I think there is a mistake below : there should not be a half; MATLAB TEST : CORRECT ! Fixing below, keeping old code for notes
! MATLAB : dGdX_fix =  - 1/sqrt(2*pi) * ( (expa + expb) * radpad/s +       (expa - expb)./c)./(c*s).^2 .*dX ;% corrected analytical expression
!       __SCALE(dr, osq2pi * (ooc*oo_surf_stdev)**2 * ( (expa + expb) * rsurf + half * (expa - expb) * ooc) ) ! WRONG !!!
       __SCALE(dr, osq2pi * (ooc*oo_surf_stdev)**2 * ( (expa + expb) * rsurf + (expa - expb) * ooc) ) ! CORRECTED 10/18
! add gradient contribution
       __INCR(drho_solv(:,i),dr)
      endif ! rho > surface contour value
     endif ! rho > bulk contour value
    else & ! dasystat
#endif
    if(rho_solv(i).gt.surface_contour_value) then
     qforced=.false.
     exit ! density threshold exceeded ; will not apply force to this atom
    else
! otherwise, compute gradient contribution : (note that I am flipping the direction of dr (in the notes it is r0-r)
     __SCALE(dr, osq2pi * (ooc*oo_surf_stdev)**2 * ( (expa + expb) * rsurf + (expa - expb) * ooc) ) ! CORRECTED 10/18
! add gradient contribution
     __INCR(drho_solv(:,i),dr)
    endif
#if defined(__SORT_LIST) && defined( __NEIGHBOR_LIST)
! if we are here, that means that the jj index contributes to the calculation ; check it if it is inside the index support ; if not, increase index support
    if (jj>solute_neighbor_mind(i)) solute_neighbor_mind(i)=jj
#endif
   enddo ! nsurface
   qforced_solv(i)=qforced ! note that this is not quite enough, because it is possible that the solvent atom is outside of all supports;
!  so that while the default setting -- qforced=T -- persists, there are actually _no_ forces and rho(i)=zero ; therefore, we could do
!  qforced_solv(i)=qforced.and.rho_solv(i).gt.zero
!  however, in that case we are throwing away the information that a solvent atom has moved outside of support ; better to address this in the main loop, I think
!  Also, it is clear that the atom _should_ be forced (we just do not know which wat to push it since we are outside of the support) ; thus we are closer to the
!  actual physical situation, leaving as is
  enddo ! nsolvent
!#undef zero
!#undef half
!#undef one
!#undef osq2
!#undef osq2pi
#ifdef __OMP
!$omp end do
#ifdef __DASYSTAT
 if (dasystat) then
!$omp atomic
  __REDUCE(solvent_mass_nonbulk)
 endif
#endif
!$omp end parallel
#endif
 else ! qtruncate loop
#if defined(__SORT_LIST) & defined(__NEIGHBOR_LIST)
#ifdef __DDEBUG
  __DBGOUT('Called ', whoami,'(full loop) with neighbor_list_factor=',neighbor_list_factor)
#endif
#ifdef __NEIGHBOR_LIST_CHECK
  neighbor_list_misses=0
#endif
#endif
!=====================================================================================
#ifdef __OMP
!$omp parallel &
!$omp shared ( rho_solv, drho_solv, r_solv, r_surf, rad_surf, surf_padding, nsolvent, nsurface, cutoff_surf, oo_surf_stdev &
#ifdef __DASYSTAT
!$omp , solvent_mass_nonbulk, mass_solv &
#endif
#ifdef __SORT_LIST
!$omp , solute_neighbor_list &
#ifdef __NEIGHBOR_LIST
!$omp , solute_neighbor_mind &
#ifdef __NEIGHBOR_LIST_CHECK
!$omp , neighbor_list_misses &
#endif
#endif
#endif
!$omp ) &
!$omp private ( rw, i, j, rp, rsurf, rmaxsurf, dr, dr2, ooc, expa, expb, qforced &
#ifdef __DASYSTAT
!$omp , __U(solvent_mass_nonbulk), qbulk &
#endif
#ifdef __SORT_LIST
!$omp ,dr2old, jj &
#if defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
!$omp , __U(neighbor_list_misses), neighbor_list_length &
#endif
#endif
!$omp )
#ifdef __DASYSTAT
 if (dasystat) __U(solvent_mass_nonbulk)=zero
#endif
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 __U(neighbor_list_misses)=0
#endif
!$omp do schedule(runtime)
#endif
  do i=1, nsolvent ! outer loop over solvent atoms
   qforced=.true.
#ifdef __DASYSTAT
    if (dasystat) qbulk=.true.
#endif
   rho_solv(i)=zero ;
   drho_solv(:,i)=zero
   rw=r_solv(:,i);
#ifdef __SORT_LIST
   dr2old=-1.d0 ; ! set to a small number to guarantee that no swap is done on first iteration
#if defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
   neighbor_list_length = __NEIGHBOR_LIST_LENGTH_DENSITY
#endif
   do jj=1, nsurface ! inner loop over solute atoms
    j=solute_neighbor_list(jj,i)
#else
   do j=1, nsurface ! inner loop over solute atoms
#endif
    rp=r_surf(:,j)
    rsurf    = ( rad_surf(j) + surf_padding )
    rmaxsurf = ( cutoff_surf  + rsurf  )
    dr = rp-rw ;
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
     __DIST_PBC(dr(1),ucell%a)
     __DIST_PBC(dr(2),ucell%b)
     __DIST_PBC(dr(3),ucell%c)
    endif
#endif
    dr2=sum(dr**2);
#ifdef __SORT_LIST
!   bubble sort between this and previous atom based on distance
    if (dr2 .lt. dr2old) then ! bubble sort
     solute_neighbor_list(jj,i)=solute_neighbor_list(jj-1,i)
     solute_neighbor_list(jj-1,i)=j
    endif
    dr2old=dr2
#endif
    if (dr2 .gt. rmaxsurf**2) cycle ! solute atom outside cutoff for this solvent atom -- skip it
!   atom is within the cutoff; record its index before computing density contribution
#if defined(__SORT_LIST) & defined(__NEIGHBOR_LIST)
    solute_neighbor_mind(i)=jj
!   since jj is increasing, solute_neighbor_mindist(i) will store the largest index for any atom within the cutoff (otherwise we cycle above)
!   because the list is supposed to be sorted (in actuality it is not because the sort is approximate) this is a measure
!   of how far we have to go to compute all the interactions within the cutoff ; so we store this number
#endif
!
#ifdef __DASYSTAT
    if (dasystat) then
     if (qbulk) then
      rsurf=rsurf * oo_surf_stdev
      dr2 = sqrt(dr2) * oo_surf_stdev
      a = osq2 * (dr2 + rsurf)
      b = osq2 * (dr2 - rsurf)
!      as=a
!      bs=b
      ooc = one / dr2
      expa = exp ( - a**2 )
      expb = exp ( - b**2 )
! update density
#ifdef __ERFHYBRID
      __erfo7i(a,erfa)
      __erfo7i(b,erfb)
      __INCR(rho_solv(i), half * ( erfa - erfb ) + osq2pi * ooc * ( expa - expb )   )
#else
      __INCR(rho_solv(i), half * ( __erf(a) - __erf(b) ) + osq2pi * ooc * ( expa - expb )   )
#endif
      if (rho_solv(i).gt.bulk_boundary_contour_value) then
       __INCR(__U(solvent_mass_nonbulk), mass_solv(i))
       qbulk=.false. ! no need to compute erf further
       qforced=.false.
      elseif(qforced) then ! in the bulk, and possibly outside main shell
       if (rho_solv(i).gt.surface_contour_value) then
        qforced=.false.
       else
        __SCALE(dr, osq2pi * (ooc*oo_surf_stdev)**2 * ( (expa + expb) * rsurf + (expa - expb) * ooc) ) ! CORRECTED 10/18
! add gradient contribution
        __INCR(drho_solv(:,i),dr)
       endif ! rho > surface value
      endif ! rho > bulk value
     endif ! qbulk
    else &
#endif
    if (qforced) then
     rsurf=rsurf * oo_surf_stdev
     dr2 = sqrt(dr2) * oo_surf_stdev
     a = osq2 * (dr2 + rsurf)
     b = osq2 * (dr2 - rsurf)
!     as=a
!     bs=b
     ooc = one / dr2
     expa = exp ( - a**2 )
     expb = exp ( - b**2 )
! update density
#ifdef __ERFHYBRID
     __erfo7i(a,erfa)
     __erfo7i(b,erfb)
     __INCR(rho_solv(i), half * ( erfa - erfb ) + osq2pi * ooc * ( expa - expb )   )
#else
     __INCR(rho_solv(i), half * ( __erf(a) - __erf(b) ) + osq2pi * ooc * ( expa - expb )   )
#endif
     if (rho_solv(i).gt.surface_contour_value) then
      qforced=.false.
     else
      __SCALE(dr, osq2pi * (ooc*oo_surf_stdev)**2 * ( (expa + expb) * rsurf + (expa - expb) * ooc) ) ! CORRECTED 10/18
! add gradient contribution
      __INCR(drho_solv(:,i),dr)
     endif ! rho>contour value
    endif ! qforced
! _nonce
   enddo ! nsurface
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
! check for _potential_ neighbor list violations :
   if (qforced .and. solute_neighbor_mind(i) > neighbor_list_length ) __INC(__U(neighbor_list_misses)) ! count only if qforced, ok?
#endif
   qforced_solv(i)=qforced
  enddo ! nsolvent
#ifdef __OMP
!$omp end do
#ifdef __DASYSTAT
 if (dasystat) then
!$omp atomic
  __REDUCE(solvent_mass_nonbulk)
 endif
#endif
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 __REDUCE(neighbor_list_misses)
#endif
!$omp end parallel
#endif
#if defined(__NEIGHBOR_LIST) & defined(__SORT_LIST)
!#ifdef __DDEBUG
! write(666,'(7000(I4,"("I4")"))') (solute_neighbor_mind(i), solute_neighbor_list(solute_neighbor_mind(i),i), i=1,nsolvent)
! close(666)
!#endif
#endif
! should we output the violations here ?
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 if (neighbor_list_misses>0) then
  if (neighbor_list_misses==1) then
   __WRN(whoami, 'DETECTED '//itoa(neighbor_list_misses)//' POSSIBLE NEIGHBOR LIST MISS. NEIGHBOR LIST FACTOR IS '//ftoa(neighbor_list_factor))
  else
   __WRN(whoami, 'DETECTED '//itoa(neighbor_list_misses)//' POSSIBLE NEIGHBOR LIST MISSES. NEIGHBOR LIST FACTOR IS '//ftoa(neighbor_list_factor))
  endif
! increase neighbor_list_factor
  __INCR(neighbor_list_factor, neighbor_list_factor_grow)
 else
  __INCR(neighbor_list_factor, neighbor_list_factor_shrink)
! decrease neighbor_list_factor
 endif
#endif
!
 endif ! truncate sum
!
 end __SUB(compute_density_grad)
!================================================================
 __SUB(compute_mindist_grad)(quit_early)
#ifdef __OMP
 use omp_lib
#endif
!
 bool, intent(in) :: quit_early ! whether we can stop computation for each atom once distance to any atom less than distance to solute surface
 int :: i, j
 float :: rp(3), rw(3), dr(3), dr2, dr2min, drmin(3)
#ifdef __SORT_LIST
 int :: jj
 float :: dr2old ! squared minimum distance difference from previous iteration
#if defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 float :: neighbor_list_length
 int :: neighbor_list_misses
#ifdef __OMP
 int :: __U(neighbor_list_misses)
#endif
#endif
#endif
 float :: rmaxsurf, surface_distance2
#ifdef __DASYSTAT
 float :: bulk_distance2
 bool :: qbulk
#ifdef __OMP
 float :: __U(solvent_mass_nonbulk)
! float :: __U(solvent_mass_outside)
! float :: __U(solvent_mass_bulk)
#endif
#endif
 bool :: qforced ! whether an atom is a forced atom
 __IAM(__NM(compute_mindist_grad))
!
#ifdef __DDEBUG
#ifdef __OMP
!$omp parallel
!$omp single
 __DBGOUT('OMP: Available processors: ',omp_get_num_procs());
 __DBGOUT('OMP: Maximum threads:      ',omp_get_max_threads());
 __DBGOUT('OMP: Current threads:      ',omp_get_num_threads());
 __DBGOUT('OMP: This thread:          ',omp_get_thread_num());
!$omp end single
!$omp end parallel
#endif __OMP
#endif
!
! simple algorithm to find the closest atom
 surface_distance2=surface_distance**2
#ifdef __DASYSTAT
 if (dasystat) then
  bulk_distance2=bulk_boundary_distance**2
  solvent_mass_nonbulk=zero
 endif ! dasystat
#endif
!
 if (quit_early) then
#if defined(__SORT_LIST) & defined(__NEIGHBOR_LIST)
#ifdef __DDEBUG
  __DBGOUT('Called ', whoami,'(can quit early) with neighbor_list_factor=',neighbor_list_factor)
#endif
#endif
#ifdef __OMP
!$omp parallel &
!$omp shared ( dist_solv, ddist_solv, r_solv, nsolvent, nsurface, surface_distance2 &
#ifdef __DASYSTAT
!$omp , bulk_distance2, mass_solv, solvent_mass_nonbulk &
#endif
#ifdef __SORT_LIST
!$OMP , solute_neighbor_list &
#ifdef __NEIGHBOR_LIST
!$OMP , solute_neighbor_mind &
#endif
#endif
!$OMP ) &
!$omp private ( rw, i, j, rp, dr, drmin, dr2, dr2min, qforced &
#ifdef __DASYSTAT
!$omp , __U(solvent_mass_nonbulk) &
#endif
#ifdef __SORT_LIST
!$OMP ,dr2old, jj &
#endif
!$OMP )
#ifdef __DASYSTAT
 if (dasystat) __U(solvent_mass_nonbulk)=zero
#endif
!$omp do schedule(runtime)
#endif
  do i=1, nsolvent ! outer loop over solvent atoms
   qforced=.true.  ! assume that forces will be applied to this atom, check below
   rw=r_solv(:,i); ! solvent atom coordinate
   dr2min=ilarge
#ifdef __SORT_LIST
   dr2old=-1.d0 ; ! set to a small number to guarantee that no swap is done on first iteration
#ifdef __NEIGHBOR_LIST
   do jj=1, __NEIGHBOR_LIST_LENGTH_MINDIST
!   do jj=1,max(1,min(nsurface, solute_neighbor_mind(i) ))
#else
   do jj=1, nsurface ! inner loop over solute atoms ! to check the entire surface atom list
#endif
    j=solute_neighbor_list(jj,i) ! note that this is really a (partially) distance-sorted list of surface atoms for each solvent atom
#else
   do j=1, nsurface ! inner loop over solute atoms, without regard to their location relative to the solvent atom i
#endif
    rp=r_surf(:,j) ! protein atom coordinate
!
    dr = rp-rw ;
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
     __DIST_PBC(dr(1),ucell%a)
     __DIST_PBC(dr(2),ucell%b)
     __DIST_PBC(dr(3),ucell%c)
    endif
#endif
    dr2=sum(dr**2);
#ifdef __SORT_LIST
!   bubble sort between this and previous atom based on distance
    if (dr2 .lt. dr2old) then
     solute_neighbor_list(jj,i)=solute_neighbor_list(jj-1,i)
     solute_neighbor_list(jj-1,i)=j
    endif
    dr2old=dr2
#endif
!
#ifdef __DASYSTAT
    if (dasystat) then
     if (dr2 .lt. bulk_distance2) then ! the solvent atom is inside the shell, and also too close to the surface to be considered bulk
      __INCR(__U(solvent_mass_nonbulk), mass_solv(i))
      qforced=.false.
#ifdef __SORT_LIST
! put this atom first in the list to increase our chances of quitting early next time
!      solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!      solute_neighbor_list(1,i)=j
#endif
      exit ! atom is considered inside, so no need to loop further
     elseif (qforced .and. dr2 .lt. surface_distance2) then ! not bulk but still inside ; if already marked inside (qforced=.false.) then skip !
      qforced=.false.
!      __INCR(__solvent_mass_bulk, mass_solv(i)) ! direct sum ; algorithm not quite correct so commenting but not deleting
#ifdef __SORT_LIST
! put this atom first in the list to increase our chances of quitting early next time
!      solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!      solute_neighbor_list(1,i)=j
#endif
     endif
    else &
#endif
    if (dr2 .lt. surface_distance2) then ! the solvent atom is close enough to a surface atom to be considered inside
     qforced=.false.
#ifdef __SORT_LIST
! put this atom first in the list to increase our chances of quitting early next time
!     solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!     solute_neighbor_list(1,i)=j
#endif
     exit ! atom is considered inside, so no need to loop further (because dasystat off, no need to check whether bulk)
    endif
!
    if (dr2 .lt. dr2min) then
     dr2min=dr2
     drmin=dr
#ifdef __SORT_LIST
! put this atom first in the list
! note that is is possible to do two swaps one here and one above, in the same loop, which is an error, so turn off both, since no sizeable speed bump anyway
! should not do this when multiple threads are running
!     solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!     solute_neighbor_list(1,i)=j
#ifdef __NEIGHBOR_LIST
! if the atom with the minimum distance happens to be farther in index space than the stored index, increase the index :
     if (jj>solute_neighbor_mind(i)) solute_neighbor_mind(i)=jj-1 ; ! even this might be too aggressive
#endif
#endif
    endif
   enddo ! nsurface
   if (qforced) then
    dist_solv(i) = -sqrt(dr2min) ! negative distance by convention
    ddist_solv(:,i) = drmin      ! the minimum distance between this atom and a surface atom
! note that, technically, this is also a non-bulk atom, since it is outside of the surface shell, but we have a separate variable for those (mass_outside)
   else
    dist_solv(i)=zero            ! atom is inside, so set min. distance to zero
   endif
   qforced_solv(i)=qforced
  enddo ! nsolvent
#ifdef __OMP
!$omp end do
#ifdef __DASYSTAT
 if (dasystat) then
!$omp atomic
  __REDUCE(solvent_mass_nonbulk)
 endif
#endif
!$omp end parallel
#endif
 else ! (not) quit_early
#if defined(__SORT_LIST) & defined(__NEIGHBOR_LIST)
#ifdef __DDEBUG
  __DBGOUT('Called ', whoami,'(full loop) with neighbor_list_factor=',neighbor_list_factor)
#endif
#ifdef __NEIGHBOR_LIST_CHECK
  neighbor_list_misses=0
#endif
#endif
!=====================================================================================
#ifdef __OMP
!$omp parallel &
!$omp shared ( dist_solv, ddist_solv, r_solv, nsolvent, nsurface, surface_distance2 &
#ifdef __DASYSTAT
!$omp , bulk_distance2, solvent_mass_nonbulk &
#endif
#ifdef __SORT_LIST
!$omp , solute_neighbor_list &
#ifdef __NEIGHBOR_LIST
!$omp , solute_neighbor_mind &
#ifdef __NEIGHBOR_LIST_CHECK
!$omp , neighbor_list_misses &
#endif
#endif
#endif
!$omp ) &
!$omp private ( rw, i, j, rp, dr, drmin, dr2, dr2min, qforced &
#ifdef __DASYSTAT
!$omp , __U(solvent_mass_nonbulk), qbulk &
#endif
#ifdef __SORT_LIST
!$omp ,dr2old, jj &
#if defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
!$omp , __U(neighbor_list_misses), neighbor_list_length &
#endif
#endif
!$omp )
#ifdef __DASYSTAT
 if (dasystat) __U(solvent_mass_nonbulk)=zero
#endif
!
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 __U(neighbor_list_misses)=0
#endif
!$omp do schedule(runtime)
#endif
  do i=1, nsolvent ! outer loop over solvent atoms
   qforced=.true.
#ifdef __DASYSTAT
   if (dasystat) qbulk=.true. ! assume atom is outside of the bulk boundary
#endif
   rw=r_solv(:,i);
   dr2min=ilarge
#ifdef __SORT_LIST
   dr2old=-1.d0 ; ! set to a small number to guarantee that no swap is done on first iteration
#if defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
   neighbor_list_length = __NEIGHBOR_LIST_LENGTH_MINDIST
#endif
!
   do jj=1, nsurface ! inner loop over solute atoms
!   do jj=nsurface, 1, -1 ! inner loop over solute atoms, starting from the end
    j=solute_neighbor_list(jj,i)
#else
   do j=1, nsurface ! inner loop over solute atoms
#endif
    rp=r_surf(:,j) ! protein atom coordinate
!
    dr = rp-rw ;
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
     __DIST_PBC(dr(1),ucell%a)
     __DIST_PBC(dr(2),ucell%b)
     __DIST_PBC(dr(3),ucell%c)
    endif
#endif
    dr2=sum(dr**2);
#ifdef __SORT_LIST
!   bubble sort between this and previous atom based on distance
    if (dr2 .lt. dr2old) then
     solute_neighbor_list(jj,i)=solute_neighbor_list(jj-1,i)
     solute_neighbor_list(jj-1,i)=j
    endif
    dr2old=dr2
#endif
!
#ifdef __DASYSTAT
    if (dasystat) then
     if (qbulk .and. dr2 .lt. bulk_distance2) then ! the solvent atom is too close to the surface to be considered bulk
      __INCR(__U(solvent_mass_nonbulk), mass_solv(i))
      qbulk=.false. ! mark atom as non-bulk
      qforced=.false. ! also, mark as a non-forced atom
#ifdef __SORT_LIST
! put this atom first in the list to increase our chances of quitting early next time
!      solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!      solute_neighbor_list(1,i)=j
#endif
! atom is considered inside, but proceed to the end of list because we want to sort it
     elseif (qforced .and. dr2 .lt. surface_distance2) then ! not bulk but still inside ; if already marked inside (qforced=.false.) then skip !
      qforced=.false.
#ifdef __SORT_LIST
! put this atom first in the list to increase our chances of quitting early next time
!      solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!      solute_neighbor_list(1,i)=j
#endif
     endif ! dr2<dist
    else & ! dasystat
#endif
    if (qforced .and. dr2 .lt. surface_distance2) then ! since we are not exiting, use qforced flag in the conditional
     qforced=.false. ! this atom is inside, however, proceed to the end of the surface atom list because we want to sort it
#ifdef __SORT_LIST
! put this atom first in the list to increase our chances of quitting early next time
! NOTE : these section OMP sections have ad hoc problems, such as with -fcheck=all flags
! also : do not use critical; this produces a completely different compilation ; very slow !
!!$omp critical
! not necessary because the code block below will guarantee this
!     solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!     solute_neighbor_list(1,i)=j
!!$omp end critical
#endif
    endif
    if (dr2 .lt. dr2min) then
     dr2min=dr2
     drmin=dr
! minimum index inside solute_neighbor_list (before swap below)
#ifdef __SORT_LIST
#ifdef __NEIGHBOR_LIST
     solute_neighbor_mind(i)=jj
#endif
! note that it is technically possible to swap twice here and above, which would make two j's in the same list -- error
! put this atom first in the list
!     solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!     solute_neighbor_list(1,i)=j
#endif
    endif
   enddo ! nsurface
! check for _potential_ neighbor list violations :
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
   if (qforced .and. solute_neighbor_mind(i) > neighbor_list_length ) __INC(__U(neighbor_list_misses)) ! count only if qforced, ok?
#endif
#ifdef __DEBUG
! write(666,*) i,dr2min, ilarge
! close(666)
#endif
   dist_solv(i) = -sqrt(dr2min) ! sign convention ; keep outside of if below to compute average dist
   if (qforced) then
    ddist_solv(:,i) = drmin ! for force calculation
! note that, technically, this is also a non-bulk atom, since it is outside of the surface shell; but we also have mass_outside var
   endif
   qforced_solv(i)=qforced
  enddo ! nsolvent
#ifdef __OMP
!$omp end do
#ifdef __DASYSTAT
 if (dasystat) then
!$omp atomic
  __REDUCE(solvent_mass_nonbulk)
 endif
#endif
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 __REDUCE(neighbor_list_misses)
#endif
!$omp end parallel
#endif
#ifdef __DDEBUG
! write(666,'(1300(I4,"("I4")"))') (solute_neighbor_mind(i), solute_neighbor_list(solute_neighbor_mind(i),i), i=1,nsolvent)
! close(666)
#endif
! should we output the violations here ?
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 if (neighbor_list_misses>0) then
  if (neighbor_list_misses==1) then
   __WRN(whoami, 'DETECTED '//itoa(neighbor_list_misses)//' POSSIBLE NEIGHBOR LIST MISS. NEIGHBOR LIST FACTOR IS '//ftoa(neighbor_list_factor))
  else
   __WRN(whoami, 'DETECTED '//itoa(neighbor_list_misses)//' POSSIBLE NEIGHBOR LIST MISSES. NEIGHBOR LIST FACTOR IS '//ftoa(neighbor_list_factor))
  endif
! increase neighbor_list_factor
  __INCR(neighbor_list_factor, neighbor_list_factor_grow)
 else
  __INCR(neighbor_list_factor, neighbor_list_factor_shrink)
! decrease neighbor_list_factor
 endif
#endif
!
 endif ! quit_early
!
 end __SUB(compute_mindist_grad)
!================================================================
#ifdef __BAROSTAT
#undef _S
#define _S compute_surface_area
 __SUB(_S)
!
#ifdef __OMP
 use omp_lib
 int tid, numthreads, n
#endif
 int i, im, jm, km, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, nx, ny, nz
 float x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, x0, y0, z0
! float support, support2, rsurf, a, b, ooc, expa, expb, oos
 real*4 :: support, support2, rsurf, a, b, ooc, expa, expb, oos
 float, parameter :: sqrtmap(0:3)=(/zero, one, sqrt2, sqrt3/)
#ifdef __PERTURB_GRID
 float :: drand(3)
#endif
!
 integer*1 rhomx, thisrho, igrad
 float __U(grad)
 __IAM(__NM(_S))
!
! make use of existing definitions in compute_desity_grad routine above
! different erf implementations/approximations
 float :: erfsun ! external erf function; code by Sun Microsystems
! if openmp is used, cannot call the function erfo7, so hack to call inlined macro here
#ifndef __OMP
 float :: erfo7  ! approximation to within O(-7)
#endif
 float :: erfo5  ! approximation to within O(-5) [contains an exponential term]
!
#ifdef __PERTURB_GRID
 call randomu_vector(drand, 3, random_channel)
 drand=(drand-half)*surface_area_grid_spacing
#else
#define drand(_A)
#endif
!
 x0 = drand(1) + sagrid%limits(1,1)
 y0 = drand(2) + sagrid%limits(1,2)
 z0 = drand(3) + sagrid%limits(1,3)
!
 nx=sagrid%n(1)
 ny=sagrid%n(2)
 nz=sagrid%n(3)
!
#define qpbcx qper_parser_override
#define qpbcy qpbcx
#define qpbcz qpbcx

! initialize
 surface_area=zero
!
 oos=__OORHO(surface_contour_value)
!
#ifdef __OMP
!$omp parallel &
!$omp shared(sarho_all_threads, sarhof_all_threads) &
!$omp private(x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, tid, &
!$omp i, __U(grad), rhomx, thisrho, igrad, n, support, support2, rsurf, a, b, ooc, expa, expb)
 tid=omp_get_thread_num() ! thread index
 numthreads=omp_get_num_threads()
#ifdef rho
#undef rho
#endif
#define rho(i,j,k) sarhof_all_threads(i,j,k,tid)
#else
#define rho sarhof
#endif
! assign to each thread a local copy of surface indicator
 rho(:,:,:)=zero ! initialize
 __U(grad)=0
!$omp do schedule(runtime)
 do i=1, nsurface
! determine support for this atom, i.e. all grid points which are within the filter support
  rsurf = ( rad_surf(i) + surf_padding )
  support = ( rsurf + cutoff_surf )
  support2=support**2
  x=r_surf(1,i)-r_com_sa(1)
  xmin=x-support
  xmax=xmin + two*support
  imin = INT( (xmin-x0)*oo_surface_area_grid_spacing ) + 1 ! could be negative (i.e. off-the-grid), but the indices are consistent with the 1-based offset
  imax = INT( (xmax-x0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcx) then
   imin=max(imin,1)
   imax=min(imax,nx)
  endif
__DBGVAR(surface_area_grid_spacing,2)
__DBGVAR(oo_surface_area_grid_spacing,2)
__DBGVAR(x,2)
__DBGVAR(xmin,2)
__DBGVAR(xmax,2)
__DBGVAR(x0,2)
__DBGVAR(imin,2)
__DBGVAR(imax,2)
! same for y
  y=r_surf(2,i)-r_com_sa(2)
  ymin=y-support
  ymax=ymin + two*support
  jmin = INT( (ymin-y0)*oo_surface_area_grid_spacing ) + 1
  jmax = INT( (ymax-y0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcy) then
   jmin=max(jmin,1)
   jmax=min(jmax,ny)
  endif
__DBGVAR(y,2)
__DBGVAR(ymin,2)
__DBGVAR(ymax,2)
__DBGVAR(y0,2)
__DBGVAR(jmin,2)
__DBGVAR(jmax,2)
! and for z
  z=r_surf(3,i)-r_com_sa(3)
  zmin=z-support
  zmax=zmin + two*support
  kmin = INT( (zmin-z0)*oo_surface_area_grid_spacing ) + 1
  kmax = INT( (zmax-z0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcz) then
   kmin=max(kmin,1)
   kmax=min(kmax,nz)
  endif
__DBGVAR(z,2)
__DBGVAR(zmin,2)
__DBGVAR(zmax,2)
__DBGVAR(z0,2)
__DBGVAR(kmin,2)
__DBGVAR(kmax,2)

  do kk=kmin,kmax
   dz2=(surface_area_grid_spacing*(kk-1) - (z - z0) )**2; ! actual z-distance between gridpoint and atom
   km=modulo(kk-1,nz-1)+1 ! works for PBC
   do jj=jmin,jmax
    dy2=dz2+(surface_area_grid_spacing*(jj-1) - (y - y0) )**2;
    if (dy2>support2) cycle
    jm=modulo(jj-1,ny-1)+1
    do ii=imin,imax
     dx2=dy2+(surface_area_grid_spacing*(ii-1) - (x - x0) )**2;
     if (dx2>support2) cycle
     im=modulo(ii-1,nx-1)+1
! update density
     if (rho(im,jm,km).lt.surface_contour_value) then
      support=rsurf * oo_surf_stdev ! reuse support var
      dx2 = sqrt(dx2) * oo_surf_stdev
      a = osq2 * (dx2 + support)
      b = osq2 * (dx2 - support)
      ooc = one / dx2
      expa = exp ( - a**2 )
      expb = exp ( - b**2 )
! update density
#ifdef __ERFHYBRID
      __erfo7i(a,erfa)
      __erfo7i(b,erfb)
      __INCR(rho(im,jm,km), half * ( erfa - erfb ) + osq2pi * ooc * ( expa - expb )   )
#else
#define __erf(_Y) __erfo7s(_Y)
#// singe prec ^
      __INCR(rho(im,jm,km), half * ( __erf(a) - __erf(b) ) + osq2pi * ooc * ( expa - expb )   )
#endif
     endif ! rho<surface_contour value
    enddo !ii
   enddo !jj
  enddo !kk
 enddo ! nsurface atoms, i
#ifdef __OMP
!$omp end do
! now reduce all indicator arrays to master array (0th thread)
 n=1
 do while (n.lt.numthreads)
!$omp barrier ! make sure all threads have completed previous operation
  if (mod(tid,2*n)==0 .and. (tid+n).lt.numthreads) then
   __INCR(rho(:,:,:), sarhof_all_threads(:,:,:,tid+n))
  endif
  __SCALE(n,2)
 enddo
! now compute surface area integral
#if defined rho
#undef rho
#endif
#define rho(i,j,k) sarhof_all_threads(i,j,k,0)
#// use the same array below
#define irho(i,j,k) sarhof_all_threads(i,j,k,0)
!$omp barrier ! make sure thread reduction is complete, otherwise volumes will be too small
! first, digitize continuous density :
!$omp do schedule(runtime)
#else
#define irho sarhof
#endif
 do kk=1,nz
  do jj=1,ny
   do ii=1,nx
!    irho(ii,jj,kk)=INT(rho(ii,jj,kk)*oos)
    if (rho(ii,jj,kk).gt.surface_contour_value) then ; irho(ii,jj,kk)=1 ; else ; irho(ii,jj,kk)=0 ; endif
   enddo
  enddo
 enddo
#ifdef __OMP
!$omp end do
!$omp barrier ! make sure irho is computed everywhere
! second, integrate digitized gradient
!$omp do schedule(runtime)
#endif
 do kk=2,nz
  do jj=2,ny
   rhomx=irho(1,jj,kk)
   do ii=2,nx ; thisrho=irho(ii,jj,kk)
! specialized code below : we know that in this case, rho can only be 0,1;
! therefore diff(rho) can only be 0,1, which means igrad can be 0 1 2 or 3, and there is no need to use squares or square roots
! simpified :
    igrad = abs(thisrho-rhomx) + abs(thisrho-irho(ii,jj-1,kk)) + abs(thisrho-irho(ii,jj,kk-1))
    rhomx=thisrho
    __INCR(__U(grad),sqrtmap(igrad))
   enddo
  enddo
 enddo
#ifdef __OMP
!$omp end do
!$omp atomic
#endif
 surface_area=surface_area + __U(grad)
#ifdef __OMP
!$omp end parallel
#endif
 __SCALE(surface_area,surface_area_grid_spacing**2)
 __DBGVAR(surface_area,1)
!
 end __SUB(_S)
!================================================================
 __SUB(compute_surface_area_mindist)()
#ifdef __OMP
 use omp_lib
 int tid, numthreads, n
#endif
 int i, im, jm, km, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, nx, ny, nz
 float x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, x0, y0, z0
 float support2
#ifdef __PERTURB_GRID
 float :: drand(3)
#endif
 integer*1 rhomx, thisrho, igrad
 float __U(grad)
 __IAM(compute_surface_area_mindist)
!
 support2=surface_distance**2
!
#ifdef __PERTURB_GRID
! NOTE : the origin of the grid is the surface atoms' COM; since the grid is discrete, there is in principle
! a discretiation error that arises from the precise location of the grid boundaries
! this error will average out as the surface moves ; however, in some cases, the averaging out will probably
! be slow ; in that case, it might be advantageous to add a uniformly distributed random perturbation to the grid origin, 
! of the size dx/2, so that this particular contribution to the surface area averages out more quickly
! note, an extreme pathological case is that of one atom or a rigid body ; in that case, the surface are will always be exactly the
! same unless a random number is added to the grid origin
#define random_channel 50
!
 call randomu_vector(drand, 3, random_channel)
 drand=(drand-half)*surface_area_grid_spacing
#else
#define drand(_A)
#endif
!
 x0 = drand(1) + sagrid%limits(1,1)
 y0 = drand(2) + sagrid%limits(1,2)
 z0 = drand(3) + sagrid%limits(1,3)
!
 nx=sagrid%n(1)
 ny=sagrid%n(2)
 nz=sagrid%n(3)
!
#define qpbcx qper_parser_override
#define qpbcy qpbcx
#define qpbcz qpbcx

 surface_area=zero !initialize

#ifdef __OMP
!$omp parallel &
!$omp shared(support2, sarho_all_threads) &
!$omp private(x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, ii, dx2, dy2, dz2, jj, kk, imin, imax, jmin, jmax, kmin, kmax, tid, &
!$omp i, __U(grad), rhomx, thisrho, igrad, n)
 tid=omp_get_thread_num() ! thread index
 numthreads=omp_get_num_threads()
#define rho(i,j,k) sarho_all_threads(i,j,k,tid)
#else
#define rho sarho
#endif
! assign to each thread a local copy of surface indicator
 rho(:,:,:)=0 ! initialize
 __U(grad)=zero
! NOTE : partially adapted from elec code
!$omp do schedule(runtime)
 do i=1, nsurface
! determine support for this atom, i.e. all grid points which are within the cutoff
  x=r_surf(1,i)-r_com_sa(1)
  xmin=x+surface_distance ! remember the sign convention
  xmax=xmin - two*surface_distance
  imin = INT( (xmin-x0)*oo_surface_area_grid_spacing ) + 1 ! could be negative (i.e. off-the-grid), but the indices are consistent with the 1-based offset
  imax = INT( (xmax-x0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcx) then
   imin=max(imin,1)
   imax=min(imax,nx)
  endif
__DBGVAR(x,2)
__DBGVAR(xmin,2)
__DBGVAR(x0,2)
__DBGVAR(imin,2)
__DBGVAR(imax,2)
! same for y
  y=r_surf(2,i)-r_com_sa(2)
  ymin=y+surface_distance ! sign convention
  ymax=ymin - two*surface_distance
  jmin = INT( (ymin-y0)*oo_surface_area_grid_spacing ) + 1
  jmax = INT( (ymax-y0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcy) then
   jmin=max(jmin,1)
   jmax=min(jmax,ny)
  endif
__DBGVAR(y,2)
__DBGVAR(ymin,2)
__DBGVAR(y0,2)
__DBGVAR(jmin,2)
__DBGVAR(jmax,2)
! and for z
  z=r_surf(3,i)-r_com_sa(3)
  zmin=z+surface_distance ! sign convention
  zmax=zmin - two*surface_distance
  kmin = INT( (zmin-z0)*oo_surface_area_grid_spacing ) + 1
  kmax = INT( (zmax-z0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcz) then
   kmin=max(kmin,1)
   kmax=min(kmax,nz)
  endif
__DBGVAR(z,2)
__DBGVAR(zmin,2)
__DBGVAR(z0,2)
__DBGVAR(kmin,2)
__DBGVAR(kmax,2)

  do ii=imin,imax
   dx2=(surface_area_grid_spacing*(ii-1) - (x - x0) )**2; ! actual x-distance between gridpoint and atom
   im=modulo(ii-1,nx-1)+1 ! works for PBC
   do jj=jmin,jmax
    dy2=dx2+(surface_area_grid_spacing*(jj-1) - (y - y0) )**2;
    if (dy2>support2) cycle
    jm=modulo(jj-1,ny-1)+1
    do kk=kmin,kmax
     dz2=dy2+(surface_area_grid_spacing*(kk-1) - (z - z0) )**2;
     if (dz2>support2) cycle
     km=modulo(kk-1,nz-1)+1
     rho(im,jm,km) = 1
    enddo !kk
   enddo !jj
  enddo !ii
 enddo ! nsurface atoms, i
#ifdef __OMP
!$omp end do
! now reduce all indicator arrays to master array (0th thread)
 n=1
 do while (n.lt.numthreads)
!$omp barrier ! make sure all threads have completed previous operation
  if (mod(tid,2*n)==0 .and. (tid+n).lt.numthreads) then
!   __INCR(__U(rho), sarho_all_threads(:,:,:,tid+n))
!   __U(rho) = max(__U(rho), sarho_all_threads(:,:,:,tid+n))
!   __U(rho) = ior(__U(rho), sarho_all_threads(:,:,:,tid+n))
!   rho(:,:,:) = max(rho(:,:,:), sarho_all_threads(:,:,:,tid+n))
   rho(:,:,:) = ior(rho(:,:,:), sarho_all_threads(:,:,:,tid+n))
  endif
  __SCALE(n,2)
 enddo
! now compute surface area integral
#if defined rho
#undef rho
#endif
#define rho(i,j,k) sarho_all_threads(i,j,k,0)
!$omp barrier ! make sure thread reduction is complete, otherwise volumes will be too small
!$omp do schedule(runtime)
#endif
 do kk=2,nz
  do jj=2,ny
   rhomx=rho(1,jj,kk)
   do ii=2,nx ; thisrho=rho(ii,jj,kk)
! note that the code below is general, but we know that in this case, rho can only be 0,1;
! therefore diff(rho) can only be 0,1, which means igrad can be 0 1 2 or 3, and there is no need to use squares or square roots
! so, should simplify in the future !
     igrad= &
&     ( thisrho - rhomx )**2 + &
&     ( thisrho - rho(ii,jj-1,kk) )**2 + &
&     ( thisrho - rho(ii,jj,kk-1) )**2
    __INCR(__U(grad),sqrt(one*igrad))
    rhomx=thisrho
   enddo
  enddo
 enddo
#ifdef __OMP
!$omp end do
!$omp atomic
#endif
 surface_area=surface_area + __U(grad)
#ifdef __OMP
!$omp end parallel
#endif
 __SCALE(surface_area,surface_area_grid_spacing**2)
 __DBGVAR(surface_area,1)
!
 end __SUB(compute_surface_area_mindist)
!
!================================================================
!
#endif
#ifdef __DASYSTAT
#undef _S
#define _S compute_bulk_volume
 __SUB(_S)
!
#ifdef __OMP
 use omp_lib
 int tid, numthreads, n
 int :: __U(ivolume), __U(ivolume_nonbulk)
#endif
 int :: ivolume, ivolume_nonbulk
 int i, im, jm, km, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, nx, ny, nz
 float x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, x0, y0, z0
! float support, support2, rsurf, a, b, ooc, expa, expb, oos, oobs
 real*4 :: support, support2, rsurf, a, b, ooc, expa, expb, oos, oobs
#ifdef __PERTURB_GRID
 float :: drand(3)
#endif
!
 __IAM(__NM(_S))
!
! make use of existing definitions in compute_desity_grad routine above
! different erf implementations/approximations
 float :: erfsun ! external erf function; code by Sun Microsystems
! if openmp is used, cannot call the function erfo7, so hack to call inlined macro here
#ifndef __OMP
 float :: erfo7  ! approximation to within O(-7)
#endif
 float :: erfo5  ! approximation to within O(-5) [contains an exponential term]
!
#ifdef __PERTURB_GRID
 call randomu_vector(drand, 3, random_channel)
 drand=(drand-half)*surface_area_grid_spacing
#else
#define drand(_A)
#endif
!
 x0 = drand(1) + sagrid%limits(1,1)
 y0 = drand(2) + sagrid%limits(1,2)
 z0 = drand(3) + sagrid%limits(1,3)
!
 nx=sagrid%n(1)
 ny=sagrid%n(2)
 nz=sagrid%n(3)
!
#define qpbcx qper_parser_override
#define qpbcy qpbcx
#define qpbcz qpbcx

! initialize
 ivolume=0
 ivolume_nonbulk=0
!
 oos=__OORHO(surface_contour_value)
 oobs=__OORHO(bulk_boundary_contour_value)
!
#ifdef __OMP
!$omp parallel &
!$omp shared(sarhof_all_threads, ivolume, ivolume_nonbulk) &
!$omp private(x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, tid, &
!$omp i, __U(ivolume), __U(ivolume_nonbulk), n, support, support2, rsurf, a, b, ooc, expa, expb)
 tid=omp_get_thread_num() ! thread index
 numthreads=omp_get_num_threads()
#ifdef rho
#undef rho
#endif
#define rho(i,j,k) sarhof_all_threads(i,j,k,tid)
#else
#define rho sarhof
#endif
! assign to each thread a local copy of surface indicator
 rho(:,:,:)=zero ! initialize
 __U(ivolume)=0
 __U(ivolume_nonbulk)=0
!$omp do schedule(runtime)
 do i=1, nsurface
! determine support for this atom, i.e. all grid points which are within the filter support
  rsurf = ( rad_surf(i) + surf_padding )
  support = ( rsurf + cutoff_surf )
  support2=support**2
  x=r_surf(1,i)-r_com_sa(1)
  xmin=x-support
  xmax=xmin + two*support
  imin = INT( (xmin-x0)*oo_surface_area_grid_spacing ) + 1 ! could be negative (i.e. off-the-grid), but the indices are consistent with the 1-based offset
  imax = INT( (xmax-x0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcx) then
   imin=max(imin,1)
   imax=min(imax,nx)
  endif
__DBGVAR(surface_area_grid_spacing,2)
__DBGVAR(oo_surface_area_grid_spacing,2)
__DBGVAR(x,2)
__DBGVAR(xmin,2)
__DBGVAR(xmax,2)
__DBGVAR(x0,2)
__DBGVAR(imin,2)
__DBGVAR(imax,2)
! same for y
  y=r_surf(2,i)-r_com_sa(2)
  ymin=y-support
  ymax=ymin + two*support
  jmin = INT( (ymin-y0)*oo_surface_area_grid_spacing ) + 1
  jmax = INT( (ymax-y0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcy) then
   jmin=max(jmin,1)
   jmax=min(jmax,ny)
  endif
__DBGVAR(y,2)
__DBGVAR(ymin,2)
__DBGVAR(ymax,2)
__DBGVAR(y0,2)
__DBGVAR(jmin,2)
__DBGVAR(jmax,2)
! and for z
  z=r_surf(3,i)-r_com_sa(3)
  zmin=z-support
  zmax=zmin + two*support
  kmin = INT( (zmin-z0)*oo_surface_area_grid_spacing ) + 1
  kmax = INT( (zmax-z0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcz) then
   kmin=max(kmin,1)
   kmax=min(kmax,nz)
  endif
__DBGVAR(z,2)
__DBGVAR(zmin,2)
__DBGVAR(zmax,2)
__DBGVAR(z0,2)
__DBGVAR(kmin,2)
__DBGVAR(kmax,2)

  do kk=kmin,kmax
   dz2=(surface_area_grid_spacing*(kk-1) - (z - z0) )**2; ! actual z-distance between gridpoint and atom
   km=modulo(kk-1,nz-1)+1 ! works for PBC
   do jj=jmin,jmax
    dy2=dz2+(surface_area_grid_spacing*(jj-1) - (y - y0) )**2;
    if (dy2>support2) cycle
    jm=modulo(jj-1,ny-1)+1
    do ii=imin,imax
     dx2=dy2+(surface_area_grid_spacing*(ii-1) - (x - x0) )**2;
     if (dx2>support2) cycle
     im=modulo(ii-1,nx-1)+1
! update density
     if (rho(im,jm,km).lt.bulk_boundary_contour_value) then
      support=rsurf * oo_surf_stdev ! reuse support var
      dx2 = sqrt(dx2) * oo_surf_stdev
      a = osq2 * (dx2 + support)
      b = osq2 * (dx2 - support)
      ooc = one / dx2
      expa = exp ( - a**2 )
      expb = exp ( - b**2 )
! update density
#ifdef __ERFHYBRID
      __erfo7i(a,erfa)
      __erfo7i(b,erfb)
      __INCR(rho(im,jm,km), half * ( erfa - erfb ) + osq2pi * ooc * ( expa - expb )   )
#else
#define __erf(_Y) __erfo7s(_Y)
#// singe prec ^
      __INCR(rho(im,jm,km), half * ( __erf(a) - __erf(b) ) + osq2pi * ooc * ( expa - expb )   )
#endif
     endif ! rho<bulk_boundary_contour value
    enddo !ii
   enddo !jj
  enddo !kk
 enddo ! nsurface atoms, i
#ifdef __OMP
!$omp end do
! now reduce all indicator arrays to master array (0th thread)
 n=1
 do while (n.lt.numthreads)
!$omp barrier ! make sure all threads have completed previous operation
  if (mod(tid,2*n)==0 .and. (tid+n).lt.numthreads) then
   __INCR(rho(:,:,:), sarhof_all_threads(:,:,:,tid+n))
  endif
  __SCALE(n,2)
 enddo
! now compute volume integrals
#ifdef rho
#undef rho
#endif
#define rho(i,j,k) sarhof_all_threads(i,j,k,0)
!$omp barrier ! make sure thread reduction is complete, otherwise volumes will be too small
!$omp do schedule(runtime)
#endif
 do kk=2,nz
  do jj=2,ny
   do ii=2,nx
! not clear how to do this in the fastest way possible
! perhaps an if/else statement would be faster, densities that map to the outside of the main shell, also map to the outside of
! the nonbulk (i.e. interfacial) region
     __INCR(__U(ivolume), min(1,INT(rho(ii,jj,kk)*oos)))
     __INCR(__U(ivolume_nonbulk), min(1,INT(rho(ii,jj,kk)*oobs)))
   enddo
  enddo
 enddo
#ifdef __OMP
!$omp end do
!$omp atomic
 __REDUCE(ivolume)
!$omp atomic
 __REDUCE(ivolume_nonbulk)
#endif
#ifdef __OMP
!$omp end parallel
#endif
 volume_bulk=(max(1,ivolume-ivolume_nonbulk))*surface_area_grid_spacing**3 ! make sure volume is always positive
!
 __DBGVAR(ivolume,1)
 __DBGVAR(ivolume_nonbulk,1)
 __DBGVAR(volume_bulk,1)

 end __SUB(_S)
!================================================================
!
#undef _S
#define _S compute_bulk_volume_mindist
 __SUB(_S)
!
#ifdef __OMP
 use omp_lib
 int tid, numthreads, n
 int :: __U(ivolume), __U(ivolume_nonbulk)
#endif
 int :: ivolume, ivolume_nonbulk
 int i, im, jm, km, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, nx, ny, nz
 float x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, x0, y0, z0
 float support2, bulk_support2
#ifdef __PERTURB_GRID
 float :: drand(3)
#endif
!
 __IAM(__NM(_S))
!
 support2=surface_distance**2
 bulk_support2=bulk_boundary_distance**2
!
#ifdef __PERTURB_GRID
 call randomu_vector(drand, 3, random_channel)
 drand=(drand-half)*surface_area_grid_spacing
#else
#define drand(_A)
#endif
!
 x0 = drand(1) + sagrid%limits(1,1)
 y0 = drand(2) + sagrid%limits(1,2)
 z0 = drand(3) + sagrid%limits(1,3)
!
 nx=sagrid%n(1)
 ny=sagrid%n(2)
 nz=sagrid%n(3)
!
#define qpbcx qper_parser_override
#define qpbcy qpbcx
#define qpbcz qpbcx

! initialize
 ivolume=0
 ivolume_nonbulk=0
!
#ifdef __OMP
!$omp parallel &
!$omp shared(support2, bulk_support2, sarho_all_threads, inrho_all_threads, ivolume, ivolume_nonbulk) &
!$omp private(x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, tid, &
!$omp i, __U(ivolume), __U(ivolume_nonbulk), n)
 tid=omp_get_thread_num() ! thread index
 numthreads=omp_get_num_threads()
#ifdef rho
#undef rho
#endif
#define rho(i,j,k) sarho_all_threads(i,j,k,tid)
#ifdef inrho
#undef inrho
#endif
#define inrho(i,j,k) inrho_all_threads(i,j,k,tid)
#else
#define rho sarho
#endif
! assign to each thread a local copy of surface indicator
 rho(:,:,:)=zero ! initialize
 inrho(:,:,:)=zero
 __U(ivolume)=0
 __U(ivolume_nonbulk)=0
! NOTE : partially adapted from elec code
!$omp do schedule(runtime)
 do i=1, nsurface
! determine support for this atom, i.e. all grid points which are within the cutoff
  x=r_surf(1,i)-r_com_sa(1)
  xmin=x+surface_distance ! remember the sign convention
  xmax=xmin - two*surface_distance
  imin = INT( (xmin-x0)*oo_surface_area_grid_spacing ) + 1 ! could be negative (i.e. off-the-grid), but the indices are consistent with the 1-based offset
  imax = INT( (xmax-x0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcx) then
   imin=max(imin,1)
   imax=min(imax,nx)
  endif
__DBGVAR(surface_area_grid_spacing,2)
__DBGVAR(oo_surface_area_grid_spacing,2)
__DBGVAR(x,2)
__DBGVAR(xmin,2)
__DBGVAR(xmax,2)
__DBGVAR(x0,2)
__DBGVAR(imin,2)
__DBGVAR(imax,2)
! same for y
  y=r_surf(2,i)-r_com_sa(2)
  ymin=y+surface_distance ! sign convention
  ymax=ymin - two*surface_distance
  jmin = INT( (ymin-y0)*oo_surface_area_grid_spacing ) + 1
  jmax = INT( (ymax-y0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcy) then
   jmin=max(jmin,1)
   jmax=min(jmax,ny)
  endif
__DBGVAR(y,2)
__DBGVAR(ymin,2)
__DBGVAR(ymax,2)
__DBGVAR(y0,2)
__DBGVAR(jmin,2)
__DBGVAR(jmax,2)
! and for z
  z=r_surf(3,i)-r_com_sa(3)
  zmin=z+surface_distance ! sign convention
  zmax=zmin - two*surface_distance
  kmin = INT( (zmin-z0)*oo_surface_area_grid_spacing ) + 1
  kmax = INT( (zmax-z0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcz) then
   kmin=max(kmin,1)
   kmax=min(kmax,nz)
  endif
__DBGVAR(z,2)
__DBGVAR(zmin,2)
__DBGVAR(zmax,2)
__DBGVAR(z0,2)
__DBGVAR(kmin,2)
__DBGVAR(kmax,2)

  do kk=kmin,kmax
   dz2=(surface_area_grid_spacing*(kk-1) - (z - z0) )**2; ! actual z-distance between gridpoint and atom
   km=modulo(kk-1,nz-1)+1 ! works for PBC
   do jj=jmin,jmax
    dy2=dz2+(surface_area_grid_spacing*(jj-1) - (y - y0) )**2;
    if (dy2>support2) cycle
    jm=modulo(jj-1,ny-1)+1
    do ii=imin,imax
     dx2=dy2+(surface_area_grid_spacing*(ii-1) - (x - x0) )**2;
     if (dx2>support2) cycle
     im=modulo(ii-1,nx-1)+1
     rho(im,jm,km) = 1
! compute inner density (note that memory access might be more efficient if I inverleave the two arrays in i)
     if (dx2>bulk_support2) cycle
     inrho(im,jm,km) = 1 ! non-bulk
    enddo !ii
   enddo !jj
  enddo !kk
 enddo ! nsurface atoms, i
#ifdef __OMP
!$omp end do
! now reduce all indicator arrays to master array (0th thread)
 n=1
 do while (n.lt.numthreads)
!$omp barrier ! make sure all threads have completed previous operation
  if (mod(tid,2*n)==0 .and. (tid+n).lt.numthreads) then
!   rho(:,:,:) = max(rho(:,:,:), sarho_all_threads(:,:,:,tid+n))
   rho(:,:,:)   = ior(  rho(:,:,:), sarho_all_threads(:,:,:,tid+n))
   inrho(:,:,:) = ior(inrho(:,:,:), inrho_all_threads(:,:,:,tid+n))
  endif
  __SCALE(n,2)
 enddo
! now compute surface area integral
#ifdef rho
#undef rho
#endif
#define rho(i,j,k) sarho_all_threads(i,j,k,0)
#ifdef inrho
#undef inrho
#endif
#define inrho(i,j,k) inrho_all_threads(i,j,k,0)
!$omp barrier ! make sure thread reduction is complete, otherwise volumes will be too small
!$omp do schedule(runtime)
#endif
 do kk=2,nz
  do jj=2,ny
   do ii=2,nx
     __INCR(__U(ivolume), rho(ii,jj,kk))
     __INCR(__U(ivolume_nonbulk), inrho(ii,jj,kk))
   enddo
  enddo
 enddo
#ifdef __OMP
!$omp end do
!$omp atomic
 __REDUCE(ivolume)
!$omp atomic
 __REDUCE(ivolume_nonbulk)
#endif
#ifdef __OMP
!$omp end parallel
#endif
 volume_bulk=(max(1,ivolume-ivolume_nonbulk))*surface_area_grid_spacing**3 ! make sure volume is always positive
!
 __DBGVAR(ivolume,1)
 __DBGVAR(ivolume_nonbulk,1)
 __DBGVAR(volume_bulk,1)

 end __SUB(_S)

#endif
!
!================================================================
!
end module _N
!
