! error function definition
#// note that the number below should not be used with the erf approximation, which is at most accurate to within O(-7)
#define  __RHO_MIN ERRTOL()
#ifndef __erf
#define __erfs __erfo7s
#define __erf __erfo7
#// single precision small number :
#undef __RHO_MIN
#define  __RHO_MIN FERRTOL()
#endif
! to "regularize" variation of applied forces with the contour value,
! use a rough approximation to the inverse of the filter CDF;
! to avoid divide overflow, define minimum density
#// NOTE : because the sigmoid is centered on zero, arguments > 0 map to > 0.5, which puts them inside the shell
#define  __RHO_MAX twothirds
#define  __RHOSAFE(_X) (min(__RHO_MAX, __RHO(_X)))
#//-////////////////////// DISTANCE FUNCTION FROM DENSITY :
! for speed, use a logistic function matched to the Gaussian filter
#ifdef __LOGISTIC_INVERSE
#define  __RHO(_X) ( one/(one+exp(-_X/logistic_constant)) )
#define  __OORHO(_R) ( one/_R )
#//define  __OORHOSAFE(_R) ( one/(max(_R,__RHO_MIN)))
#// incorporate maximum density into above :
#define  __OORHOSAFE(_R) ( one/(min(__RHO_MAX,max(_R,__RHO_MIN))))
#define  __RHO_INVERSE(_L) ( - logistic_constant * log ( __OORHO(_L) - one) )
#define  __RHO_INVSAFE(_L) ( - logistic_constant * log ( __OORHOSAFE(_L) - one) )
#// if already have 1/rho
#define  __RHO_INVERSE2(_OL) ( - logistic_constant * log ( _OL - one) )
#else
#// error function inverse
#define __RHO(_X) half*(one + __erf((_X)*osq2*oo_surf_stdev))
#define __Q(_R) ierfo7(two*(_R)-one)
#define __QSAFE(_R) ierfo7(two * min(__RHO_MAX, max(_R,__RHO_MIN)) - one)
#define __RHO_INVERSE(_R) sqrt2*surf_stdev*__Q(_R)
#// if already computed erf inverse _Q
#define __RHO_INVERSE2(_Q) sqrt2*surf_stdev*_Q
#define __RHO_INVSAFE(_R) sqrt2*surf_stdev*__QSAFE(_R)
#endif


#// with __RHO_MIN specified, we also have the largest possible shell that can be defined ; note the (-) sign convention
#// this value should be considered when evolving the shell distance
#define  __MINSURFDIST __RHO_INVERSE(__RHO_MIN)
!
#define __CTX __WATERSHELLCTX
#define __RESTARTCTX __CONCAT(__WATERSHELLCTX,_RESTART)
#//define __CHKUPDATE(_WHAT)   ( (mod(iteration, _WHAT) .eq. ione) .or. _WHAT.eq.ione )
#define __CHKUPDATE(_WHAT)   (mod(iteration, max(_WHAT,1)) .eq. izero)

! for openmm local thread variables
#ifdef __OMP
#define _U _
#else
#define _U
#endif
#define __U(_WHAT) __CONCAT(_WHAT,_U)

#if defined(__SORT_LIST ) && defined(__NEIGHBOR_LIST)
! neighbor list length
#// to check a subset of surface atom list
#define __NEIGHBOR_LIST_LENGTH_MINDIST max(1,min(nsurface_coord, INT(solute_neighbor_mind(i) * neighbor_list_factor) ))
#//define __NEIGHBOR_LIST_LENGTH_DENSITY __NEIGHBOR_LIST_LENGTH_MINDIST
#define __NEIGHBOR_LIST_LENGTH_DENSITY max(1,min(nsurface_coord, INT (half * solute_neighbor_mind(i) * neighbor_list_factor) ))
#endif

#ifdef __UNWRAP_PBC
#// note that I assume that _PER is positive, no checks are done
#define __PBCDIST(_DIST,_PER) _DIST=modulo(_DIST, _PER);if((_DIST)*2 .gt. (_PER)) __DECR(_DIST,_PER)
#define __PBC_DIST(_DIST,_PER) __PBCDIST(_DIST,_PER)
#define __DISTPBC(_DIST,_PER) __PBCDIST(_DIST,_PER)
#define __DIST_PBC(_DIST,_PER) __PBCDIST(_DIST,_PER)
#endif

module _N

 use system, only : r, rcomp, fr, radius, natom, system_PDB_initialized, system_PDB_init, system_done, system_getind, &
#ifdef __DASYSTAT
!&                   dasystat_masses=>occupancy, & ! use occupancy to store masses used in density control ; this is BAD because occupanct cannot be used !
&                   dasystat_masses=>bcomp, & ! use backup beta array
#endif
&                   system_init_mol_scalar_nocase
 __DEP_OUTPUT
 __DEP_PARSER
 __DEP_CONST
 __DEP_FILES
 __DEP_MPI
#ifdef __PERTURB_GRID
 __DEP_RANDOM
#define random_channel 50
#endif
 use ugrid
 use unitcell
#ifdef __OMP
 use omp_lib
#endif
 __IMPNONE
 private

 public __NM(initialize)
 public __NM(main)
 public __NM(done)
!
! hack to make variables from system visible from plugin
 public natom
 public iteration
 public structure_update_freq
 public r
 public fr
 public surface_energy

 bool, public :: __NM(initialized)=.false.
 bool, private:: radii_initialized=.false.
#ifdef __DASYSTAT
 bool, private:: dmasses_initialized=.false. ! for dasystat ; not necessarily atomic, i.e. possibly molecular masses !
#endif
 bool, private :: qper_parser_override=.false. ! to turn off (override) periodicity in parser
!
! surface computation parameters :
! __PAR(surface_contour_value, float, -one) ! value of density isosurface which is defines the surface ; negative means to compute from structure
 __PAR(surface_distance, float, zero) ! in the original density method, obtained by `inverting` density (as an approximation)
#ifdef __DASYSTAT
 __PAR(bulk_boundary_distance, float, zero) ! distance to the bulk solvent boundary (should obviously be smaller than the shell surface distance)
 __PAR(qbulk_boundary_recompute, bool, .true.) ! whether to allow recomputing the bulk boundary if it becomes too close or too far relative to surface_dist
#ifdef __BULK2_DISTANCE_SCALE
 __PAR(bulk2_boundary_distance, float, zero) ! distance to the outer bulk solvent boundary
#endif
#endif
 __PAR(cutoff_surf_stdev,float,7.5d0)! smoothing cutoff normalized by standard deviation of gaussian (surface) ; bad idea to set < 6
 __PAR(surf_padding,float,0d0)       ! ( units of radius ) padding values to radii which might account for e.g. solvent layer(s)
 __PAR(surf_stdev,float,3d0)         ! standard deviation of smoothing filter
!
 float :: cutoff_surf, oo_surf_stdev
#ifdef __LOGISTIC_INVERSE
 float :: logistic_constant
#endif
 float :: surface_contour_value ! value of density which defines the surface ; negative means to compute from structure
 float :: surface_energy ! moved here to be acessible from outside
#ifdef __DASYSTAT
 float :: bulk_boundary_contour_value ! value of density which defines bulk boundary (will be greater than surface_contour_value)
#ifdef __BULK2_DISTANCE_SCALE
 float :: bulk2_boundary_contour_value ! value of density which defines outer bulk boundary
#endif
#endif
!
 __PAR(iteration,INTEGER*8,izero)   ! iteration
!
! surface evolution and output parameters
 __PAR(structure_update_freq, int, ione)         ! frequency of updating coordinates from which the surface is generated
 __PAR(structure_update_memory, float, 0.999d0)  ! memory constant for exponential update
 __PAR(output_freq, int, 1000)                   ! frequency of writing output file
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
 __PAR(full_sum_freq, int, 75)                   ! frequency of force calculation without density truncation
                                                 ! doing the full calculation allows all atoms to be sorted
 __PAR(sort_neighbor_list_freq, int, 10000)      ! frequency of completely sorting the neighbor list
#endif
 __PAR(restart_file, character(len=vartaglen), 'NONE') ! restart file name
 __PAR(structure_file, character(len=vartaglen),'NONE') ! coordinate file (e.g. PDB) with system information, such as atomic radii
 __PAR(output_file, character(len=vartaglen), 'watershell.restart.txt') ! output file name
 __PAR(surface_force_constant, float, one)      ! surface restraint force constant
! __PAR(target_surface_energy, float, 5d0) ! target average energy of surface potential / par area ( units of pressure or normal stress )
#ifdef __RMFT
 __PAR(remove_net_torque, bool, .false.) ! whether to remove net torque on the solvent atom
 __PAR(remove_net_force, bool, .true.)   ! whether to remove net force ( ONLY ACTIVE IF removing net torque )
#endif
 __PAR(qminimum_distance, bool, .false.) ! use the (cheaper) minimum distance method, rather than density method
!
#ifdef __BAROSTAT
! === v barostat parameters v ====
 __PAR(barostat, bool, .false.) ! optional, but if barostat=off then pressure control turned off
 __PAR(pressure_target, float, one) ! units of atm
 float :: oopressure_target
 float, parameter :: akma_per_pa = avogadro * 1d-30 * joule
 float, parameter :: pa_per_akma = 1d0/akma_per_pa 
 float, parameter :: atm_per_akma = atm_per_pa * pa_per_akma ! conversion from akma to atom (~ 14)
 float, parameter :: akma_per_atm = 1d0/atm_per_akma
 __PAR(pressure_num_long_samples, int, 0)    ! number of inst. pressure samples that make up long-time average
 __PAR(pressure_max_long_samples, int, 10000) ! max number of inst. samples to keep in long-time average
 __PAR(pressure_num_samples, int, 0)    ! number of inst. pressure samples that make up long-time average
 __PAR(pressure_max_samples, int, 1000) ! max number of inst. samples to keep in average
 __PAR(pressure_update_freq, int, 10)   ! how often pressure is updated from force and area
#endif
! === ^ barostat parameters ^ ====
#ifdef __DASYSTAT
! === v dasystat parameters v ====
 __PAR(dasystat, bool, .false.) ! optional, but if dasystat=off then density control turned off
! __PAR(density_target, float, 0.997) ! units of g/ml for pure water
 __PAR(density_target, float, 1.002) ! units of g/ml for pure water
 float, parameter :: g_per_amu = 1d0/avogadro
 float, parameter :: ml_per_angstrom3 = 1d-24
 float, parameter :: gml_per_akma = g_per_amu / ml_per_angstrom3 ! density conversion factor ; note that it is dimensional
 __PAR(density_num_samples, int, 0)    ! number of inst. density samples that make up average
 __PAR(density_max_samples, int, 100) ! max number of inst. samples to keep in average
 __PAR(density_update_freq, int, 100)   ! how often density is updated from volume and mass
#ifdef __OMP
 int1, allocatable, dimension(:,:,:,:), target :: inrho_all_threads ! density array for computing nonbulk solvent volume
#else
 int1, allocatable, dimension(:,:,:), target :: inrho
#endif
! === ^ dasystat parameters ^ ====
#endif
! variables common to barostat and dasystat
#if defined(__BAROSTAT) || defined(__DASYSTAT)
! distance update :
 __PAR(distance_update_freq, int, 10)          ! frequency of updating distance value
 __PAR(distance_update_step, float, 0.001d0)   ! constant for update
! surface area computation parameters (hopefully, adjusting from defaults should be unnecessary)
 __PAR(surface_area_grid_spacing, float, one)
 float :: oo_surface_area_grid_spacing
 __PAR(surface_area_grid_buffer, float, three)
 __PAR(surface_area_compute_freq, int, 1) ! surface area (or volume) gets recomputed every pressure_freq times this
 __PAR(surface_area_grid_check_freq, int, 1) ! if no pbc, sa grid gets checked/updated this times sa_compute_freq x pressure_freq
 __PAR(surface_area_grid_recompute_change, float, three) ! domain size increase/decrease required to trigger grid recomputation
 float :: r_com_sa(3)=(/zero, zero, zero/) ! center of protein for gridding in SA computation
 float :: r_surf_minmax(2,3)=reshape((/zero, zero, zero, zero, zero, zero/),(/2,3/))
 bool :: r_surf_changed=.true. ! for convenience, use flag that keeps track of whether surface atoms have been updated
 bool :: surf_dist_changed=.true. ! simlarly, use flag that keeps track of whether surface distance has changed
 type (grid) :: sagrid
#ifdef __OMP
 int1, allocatable, dimension(:,:,:,:), target :: sarho_all_threads ! density array for surface are computation
 real*4, allocatable, dimension(:,:,:,:), target :: sarhof_all_threads   ! density array for surface are computation
#else
 int1, allocatable, dimension(:,:,:), target :: sarho
 real*4, allocatable, dimension(:,:,:), target :: sarhof
#endif
#endif
!
!
!  atom selections
 __PAR(surface_atom_selection, character(len=vartaglen), 'ANAME=CA')  ! protein CA trace
 __PAR(solvent_atom_selection, character(len=vartaglen), 'ANAME=OH2') ! TIP3 oxygen atoms
 int, pointer, public :: isurface_atoms(:)=>NULL()
 int, pointer, public :: isolvent_atoms(:)=>NULL()
!
 float, pointer :: r_surf(:,:), & ! reference atom coordinates
&                  rad_surf(:), & ! reference atom radii
&                  r_solv(:,:), & ! solvent atom coordinates
&                  dr_surf(:,:), & ! displacement from current r_surf to instantaneous cordinates (useful for PBC unwrapping)
#ifdef __DASYSTAT
&                  mass_solv(:), & ! solvent atom/molecular mass
#endif
&                  rho_solv(:), & ! density value at solvent coordinate
&                  drho_solv(:,:),& ! density gradient at solvent coordinate (inward surface normal)
&                  dist_solv(:), &! minimum distance to solute
&                  ddist_solv(:,:) ! distance gradient at solvent coordinate (inward surface normal)
 bool, pointer :: qforced_solv(:) ! flags that indicate whether a force is to be applied on the atom
#ifdef __SORT_LIST
 shortint, pointer :: solute_neighbor_list(:,:) ! for each solvent atom, the solute atoms are sorted by proximity
#ifdef __NEIGHBOR_LIST
 __PAR(qneighbor_list, bool, .true.) ! whether to use a neighbor list to shorten loops over surface atoms
 float :: neighbor_list_factor ! coefficient used to relate sorting frequency and limit index to loop length
 int, pointer :: solute_neighbor_mind(:) ! for each solvent atom, index of closest solute atom in the mindist algorithm
 bool :: qneighbor_list_sorted ! flag to ensure initial sorting of neighbor list
!
 float, parameter :: neighbor_list_factor_grow = 0.1d0
 float, parameter :: neighbor_list_factor_shrink = - neighbor_list_factor_grow / 500d0
!                                        ! also, the largest index of an atom within the cutoff distance for original algorithm
! note : perhaps should implement a real test of the neighbor list algorithm, e.g. scanning the entire array and comparing with the
! short array result
#endif
#endif
!
 int, public :: nsurface_coord=-1, nsurface_atoms=-1, nsolvent=-1 ! 1/19 introducing surface atoms and coords to allow for atomless (dummy) coordinates
#define nsurface_coordinates nsurface_coord
#define nsurface_coords nsurface_coord
!
 int :: nsolvent_outside
 int :: nsolvent_unsupported ! solvent atoms that fall outside of the density support in the erf/density algorithm
#ifdef __ADAPTIVE_SUPPORT
 float, parameter :: solvent_support_factor_grow = 0.01d0
 float, parameter :: solvent_support_factor_shrink = - solvent_support_factor_grow / 500d0 ! not sure that it is a good idea to decrease it, perhaps not below original value ?
 float :: surf_padding_input ! save surface padding provided on input
! float, parameter :: surface_padding_max = ten
#endif
#ifdef __DASYSTAT
 float :: solvent_mass         ! total mass of solvent atoms (constant throughout simulation)
 float :: solvent_mass_outside ! mass of solvent atoms that are outside the shell surface
 float :: solvent_mass_nonbulk ! solvent mass that excludes solvent atoms that are too close to solute to be considered bulk, i.e. inside the inner surface
#ifdef __BULK2_DISTANCE_SCALE
 float :: solvent_mass_bulk    ! mass of solvent inside outer bulk shell
#endif
#endif
 float :: oonsurface, oonsolvent, oonsolvent_outside
 float :: current_surface_distance
#ifdef __RMFT
 float :: r_com(3) =(/zero, zero, zero/); ! center of mass (geometry) for torque computation
#ifdef __UNWRAP_PBC
 float :: r_pbc_reference(3)=(/zero, zero, zero/) ! to unwrap water coordinates for torque correction
#endif
 float :: net_force(3) = (/zero, zero, zero/);
 float :: net_force_ave(3) = (/zero, zero, zero/); ! running average of net force
 float :: rms_force_corr = zero, max_force_corr = zero
 float :: net_torque(3) = (/zero, zero, zero/);
 float :: net_torque_ave(3) = (/zero, zero, zero/); ! running average of net torque
 __PAR(net_force_ave_num_samples, int, 0); ! samples in force averages
 __PAR(net_force_ave_max_samples, int, __NET_FT_MAX_SAMPLES); ! max number of samples in force averages (memory = 1-1/net_force_max_samples)
#endif
!
#if defined(__RMFT) && defined(__SIMPLE_NET_FORCE_SURFACE) || defined(__ROTRES)
 float :: r_com_inst(3) =(/zero, zero, zero/); ! inst. center of mass (geometry) for torque computation
#endif
!
#ifdef __ROTRES
 __PAR(qrigid_body_restraint, bool, .false.)
 __PAR(rigid_body_force_constant, float, one)
 float :: rigid_body_rmsd, rigid_body_energy
 float :: A_rb(3,3) ! rotation matrix
 float :: r_com_ref(3) ! center of geometry of the reference coordinates set
 float, pointer :: r_surf_ref(:,:)
 float, pointer :: rb_wgt(:)
#endif
#ifdef __FD_CHECK
 float, pointer :: ffd(:,:)
 float, pointer :: ffd2(:,:) ! this array is used to isolate shell forces from other contributions
 float, parameter :: h = 0.001d0 ! too low for single precision
! float, parameter :: h = 0.01d0 ! ok for single precision
! float, parameter :: h = 0.05d0
#endif
!
! pressure variables
#if defined(__BAROSTAT) || defined(__DASYSTAT)
 float :: surface_area=-1d0
#ifdef __BAROSTAT
 float :: pressure, pressure_ave, pressure_long_ave ! will store in atm
#endif
#ifdef __DASYSTAT
 float :: volume_bulk=-1d0
 float :: density, density_ave ! mg/mL
#endif
#endif
!
#if defined(__BAROSTAT) || defined(__DASYSTAT) || defined(__UNWRAP_PBC)
 type (cell) :: ucell
#endif
!
 int :: fid
 bool :: qrestart=.false. ! whether we are restarting from a restart file
#ifdef __DUMSURF
 bool :: qdumsurf=.false. ! whether the surface atoms are fixed 'dummies'
#endif
!
 float, private, parameter :: osq2=one/sqrt2
 float, private, parameter :: sq2pi=sqrt(twopi), osq2pi=one/sq2pi
!
! for Hamiltonian dynamics
#ifdef __HAMILTONIAN
 int :: __U(nspt)
 int, allocatable, target :: ispt(:,:) ! support array , i.e. those atoms which contribute to the density at a particular solvent atom
 float, allocatable, target :: drho_surf(:,:,:) ! array that stores forces on surcace atoms 
#endif
!
#ifdef __OMP
 int :: numthreads
#endif
!
#ifdef __FORCE_STATS
 float :: total_solute_force(3), total_solvent_force(3), max_solute_force, max_solvent_force, rms_solute_force, rms_solvent_force
#endif

#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
 interface rsort_index
      SUBROUTINE RSORT_IND( ID, N, D, IND, INFO )
      CHARACTER :: ID
      int :: INFO
      int, intent(in) :: N
      float :: D( * )
      int, intent(out) :: IND( N ) ! will be overwritten
      end subroutine rsort_ind
!
      SUBROUTINE RSORT_INDSHORT( ID, N, D, IND, INFO )
      CHARACTER :: ID
      int :: INFO
      int, intent(in) :: N
      float :: D( * )
      int*2, intent(out) :: IND( N )
      end subroutine rsort_indshort

 end interface rsort_index
#endif
!
#include "erf/erf.H"

!= subroutines
 contains
!========
 __SUB(initialize) (atoms, forced_atoms, qper, mdcell)
 __DEP_VECTORS
 type (int_vector) :: atoms, forced_atoms
 bool, intent(in) :: qper
 type (cell), intent(in), optional :: mdcell

 character(len=vartaglen) :: keyword, context, contexts(2) ! all_context currently holds the input context and the restart file context
 int :: ictx ! ugly variables for context searching in macro : (ictx: context # ; qctx, whether tag present in context)
 bool :: qctx
 int, parameter :: main_context=2, restart_context=1 ! the order serves to provide desired override behavior ; DO NO CHANGE UNLESS YOU KNOW WHAT YOU ARE DOING
 int :: l, ierr
 character(len=maxlinelen) :: line
 float, pointer :: farray(:) => NULL()
 __IAM(__NM(initialize))
!
 contexts(main_context)=__STRING(__CTX)
 contexts(restart_context)=__STRING(__RESTARTCTX)
!
 context=contexts(main_context)
! first, check if we have the watershell context present
 if (parser_find_context(__STRING(__CTX)).le.0) then
  __MESSAGE(whoami, trim(ftoupper(__STRING(_N)))//' CONFIGURATION OPTIONS NOT PROVIDED. WILL NOT INITIALIZE.');
   return
 endif
!
! next, check for restart file
! if present, read it and skip initialization options
! read restart file
#define __DEFAULT
#define __CHAR
#define __VAR	restart_file
#define __TAG	__VAR
#define __NAME	restart file
#include "parser/parser_macro2.src"
!
 qrestart = ( existtag_nocase(__STRING(restart_file), context))
! formerly known under a "watershell_restart"
 if (.not.qrestart) then
#define __VAR	restart_file
#define __TAG	watershell_restart
#define __NAME	restart file
#include "parser/parser_macro2.src"
#undef __CHAR
 qrestart = ( existtag_nocase(__STRING(watershell_restart), context))
 endif
!
 if (qrestart) qrestart = trim(ftoupper(restart_file)).ne.'NONE'
!
 if (qrestart) then
  __MESSAGE(whoami,'WILL READ SURFACE DEFINITION PARAMETERS FROM RESTART FILE.')
! read and parse restart file
  fid=-1
  call files_open(fid, restart_file, 'FORMATTED', 'READ')
  call parse_file(fid, &
#ifdef __PARALLEL
 &  MPI_COMM_NULL, &
#endif
 &  quiet_=.false.)
  call files_close(fid)
! now comes a trick : change context name temporarily to process the restart file using the same calls
  context=contexts(restart_context)
!
 endif ! have restart file
!
#define __BOOL
#define __TAG minimum_distance
#define __VAR __CONCAT(q,__TAG)
#define __NAME flag to use the (faster) minimum distance to solute method
#include "parser/parser_macro2.src"
!
#if defined(__SORT_LIST) & defined(__NEIGHBOR_LIST)
#define __TAG neighbor_list
#define __VAR __CONCAT(q,__TAG)
#define __NAME flag to use a neighbor list for solvent forces (default=yes)
#define __DOALWAYS if (__VAR) then ;\
                    __MESSAGE(whoami, 'WILL USE A NEIGHBOR LIST FOR SOLVENT FORCES.');\
                   else ; \
                    __MESSAGE(whoami, 'WILL NOT USE A NEIGHBOR LIST FOR SOLVENT FORCES.');\
                   endif
#include "parser/parser_macro3.src"
#endif
#undef __BOOL
!
#define __WARNIFMISSING
#//define __MINUSERR
! density padding
#define __VAR	surf_padding
#define __TAG	surface_padding
#define __NAME	Density padding
#include "parser/parser_macro3.src"
#ifdef __ADAPTIVE_SUPPORT
 surf_padding_input=surf_padding ! save original padding value if padding could be adjusted adaptively
#endif
!
#//undef __MINUSERR
! value for density isosurface
! abandoning this in favor of distance
!#define __VAR	surface_contour_value
!#define __TAG __VAR
!#define __NAME	Value for density isosurface
!#define __DOIFOK if (__VAR.le.zero) __MESSAGE(whoami, ' DENSITY ISOSURFACE VALUE WILL BE COMPUTED FROM COORDINATES.')
!#include "parser/parser_macro2.src"
!
#define __VAR surface_force_constant
#define __TAG __VAR
#define __NAME force constant for surface potential
#define __DOIFOK if (abs(__VAR).le.__ERRTOL) __WRN(whoami, 'SURFACE FORCE IS OFF.')
! check all contexts:
#include "parser/parser_macro3.src"
!
#define __LEZEROERR
! cutoff for density
#define __VAR	cutoff_surf_stdev
#define __TAG __VAR
#define __NAME	Cutoff for density smoothing
#define __DOIFOK if (qminimum_distance) then ;\
                  __WARN(whoami,'PARAMETER "'//__STRING(__TAG)//'" HAS NO EFFECT WHEN THE MINIMUM DISTANCE METHOD IS USED.');\
                 endif;
! check all contexts, in case we want to increase support w/o modding restart file
#include "parser/parser_macro3.src"

! GAUSSIAN standard deviations for smoothing (irrelevant for mindist method)
#define __VAR	surf_stdev
#define __TAG __VAR
#define __NAME	Standard deviation of Gaussian filter for density smoothing
#define __DOIFOK if (qminimum_distance) then;\
                  __WARN(whoami,'PARAMETER "'//__STRING(__TAG)//'" HAS NO EFFECT WHEN THE MINIMUM DISTANCE METHOD IS USED.');\
                 endif
#include "parser/parser_macro2.src"
! compute constant (=1/a)  for logistic distribution that matches the stdev
! the distribution is a * exp (-xa) / ( 1 + exp (-xa ) )^2
! the corresponding cdf is 1 / ( 1 + exp (-xa) )
! MAKE sure to define variables below as soon as surf_stdev and cutoff_surf_stdev are known so that density calculations are valid hence
 oo_surf_stdev=one/surf_stdev
 cutoff_surf  =cutoff_surf_stdev*surf_stdev
!
#ifdef __LOGISTIC_INVERSE
 logistic_constant = sqrt3 * opi * surf_stdev ; ! need this for __RHO below
#ifdef __DEBUG
 __DBGOUT('Logistic constant :',logistic_constant);
#endif
#endif
!
#undef __LEZEROERR
!
! value for distance of the surface from protein (approximate for density method)
#define __VAR	surface_distance
#define __TAG __VAR
#define __NAME	Distance of solvent surface from protein
#define __DOALWAYS if (abs(__VAR).le.__ERRTOL) then ; \
                  __MESSAGE(whoami, 'LOCATION OF SOLVENT SURFACE WILL BE SET FROM SOLVENT COORDINATES.') ; \
                 else ;\
                  __VAR=-(abs(__VAR)) ; \
                  surface_contour_value=__RHOSAFE(__VAR) ;\
                 endif ! make sure to set to a negative value
!
#include "parser/parser_macro2.src"
#define __MINUSERR
#ifdef __DEBUG
 __DBGOUT('surface_contour_value :', surface_contour_value);
#endif
!
! other parameters
#define __INT
#define __VAR	iteration
#define __TAG	__VAR
#define __NAME	starting iteration
#include "parser/parser_macro2.src"
!
#ifdef __BAROSTAT
! number of samples in barostat (we may not need it because the barostat is specified in the input file)
#define __VAR	pressure_num_samples
#define __TAG	__VAR
#define __NAME	current number of instantaneous pressure samples
#include "parser/parser_macro2.src"
!
! number of long samples
!
#undef __WARNIFMISSING
#define __VAR	pressure_num_long_samples
#define __TAG	__VAR
#define __NAME	current number of instantaneous pressure samples in long-time average
#include "parser/parser_macro2.src"
#define __WARNIFMISSING
#endif
!
#ifdef __DASYSTAT
#undef __WARNIFMISSING
! number of samples in dasystat (we may not need it because the barostat is specified in the input file)
#define __VAR	density_num_samples
#define __TAG	__VAR
#define __NAME	current number of instantaneous density samples
#include "parser/parser_macro2.src"
#define __WARNIFMISSING
#endif
!
#ifdef __RMFT
#undef __WARNIFMISSING
! number of samples in the net force average (we may not need it)
#define __VAR net_force_ave_num_samples
#define __TAG average_net_ft_samples
#define __NAME current samples in average net force
#include "parser/parser_macro2.src"
#define __WARNIFMISSING
#endif
!
!
! ====== done with (possible) restart file data
 context=contexts(main_context) ! reset context if changed
!
#ifdef __BAROSTAT
! barostat flag :
#undef __INT
#define __BOOL
#define __VAR	barostat
#define __TAG	__VAR
#define __NAME	flag to turn barostat on/off
#define __DOIFOK if (.not.__VAR) __MESSAGE(whoami, 'BAROSTAT IS OFF. (WILL IGNORE BAROSTAT-RELATED SETTINGS).')
#include "parser/parser_macro2.src"
#undef __BOOL
#endif
!
#ifdef __DASYSTAT
! dasystat flag :
#undef __INT
#define __BOOL
#define __VAR	dasystat
#define __TAG	__VAR
#define __NAME	flag to turn dasystat on/off
#ifdef __BAROSTAT
#define __DOALWAYS if (__VAR.and.barostat) then ;\
                    __WRN(whoami, 'CANNOT USE BOTH A BAROSTAT AND A DASYSTAT. ABORT.') ;\
                    barostat=.false. ;\
                    dasystat=.false. ;\
                    return ;\
                   elseif (.not.__VAR) then ;\
                     __MESSAGE(whoami, 'DASYSTAT IS OFF. (WILL IGNORE DASYSTAT-RELATED SETTINGS).') ; \
                   endif
#else
#define __DOIFOK if (.not.__VAR) then ; __MESSAGE(whoami, 'DASYSTAT IS OFF. (WILL IGNORE DASYSTAT-RELATED SETTINGS).') ; endif
#endif
#include "parser/parser_macro2.src"
#undef __BOOL
#endif

#define __INT
#if defined(__BAROSTAT) || defined(__DASYSTAT) || defined(__UNWRAP_PBC)
!
 if ( &
#ifdef __BAROSTAT
 & barostat .or. &
#endif
#ifdef __DASYSTAT
 & dasystat .or. &
#endif
#ifdef __UNWRAP_PBC
 & .true. .or. &
#endif
 & .false.)  then
!
! check for periodicity override from parser :
  __GET_OPT_PAR_B(pbc, qper_parser_override, qper, __STRING(__WATERSHELLCTX)); ! if not present use qper that is passed in
  if (qper_parser_override) then
   if (present(mdcell)) then
    ucell=mdcell
   else
    __WARN(whoami, 'PBC OVERRIDE IN USE BUT UNIT CELL NOT PROVIDED. WILL NOT USE PBC.')
    qper_parser_override=.false.
   endif ! present mdcell
  endif
 endif ! barostat or dasystat
#endif
!
! barostat only :
!===================================================================================================
#ifdef __BAROSTAT
 if (barostat) then
!
#define __VAR	pressure_update_freq
#define __TAG	__VAR
#define __NAME	frequency of computing instantaneous shell pressure
#define __DOIFOK if (__VAR.eq.izero) then; \
                  __MESSAGE(whoami, 'PRESSURE UPDATE IS OFF. TURNING BAROSTAT OFF.'); \
                  barostat=.false. ; \
                 endif ! it does not make any sense to run barostat without a pressure calculation !
#include "parser/parser_macro2.src"
 endif ! barostat
!
 if (barostat) then ! repeat if because barostat may have been turned off
#define __VAR	surface_area_compute_freq
#define __TAG	__VAR
#define __NAME	frequency of computing instantaneous shell surface area
#define __DOIFOK if (__VAR.eq.izero) then; \
                  __MESSAGE(whoami, 'SURFACE AREA COMPUTATION IS OFF. TURNING BAROSTAT OFF.'); \
                  barostat=.false. ; \
                 endif ! it does not make any sense to run barostat without a surface area calculation !
#include "parser/parser_macro2.src"
 endif ! barostat
!
 if (barostat) then
#define __VAR	surface_area_grid_check_freq
#define __TAG	__VAR
#define __NAME	frequency of checking grid limits for computing shell surface area
#define __DOIFOK if (qper_parser_override) then ;\
                  __WRN(whoami, '"'//__STRING(__TAG)//'" HAS NO EFFECT WHEN PBC ARE USED.');\
                 elseif (__VAR.eq.izero) then; \
                  __WRN(whoami, 'WILL NOT UPDATE SURFACE AREA GRID DURING DYNAMICS (THIS IS PROBABLY NOT A GREAT IDEA).'); \
                 endif
!
#include "parser/parser_macro2.src"
#define __LEZEROERR
#define __VAR	pressure_max_samples
#define __TAG	pressure_relax_time
#define __NAME	barostat relaxation time (in simulation steps)
#include "parser/parser_macro2.src"
!
#undef __WARNIFMISSING
#define __VAR	pressure_max_long_samples
#define __TAG	__VAR
#define __NAME	maximum number of samples in long-time pressure average
#include "parser/parser_macro2.src"
#define __WARNIFMISSING
!
#// default is float
#undef __INT 
!
#define __VAR	surface_area_grid_recompute_change
#define __TAG	__VAR
#define __NAME	domain size difference required to trigger reinitialization of surface area grid
#define __DOIFOK if (qper_parser_override) then ;\
                  __WRN(whoami, '"'//__STRING(__TAG)//'" HAS NO EFFECT WHEN PBC ARE USED.');\
                 endif
#include "parser/parser_macro2.src"
!
#undef __LEZEROERR
#define __VAR	pressure_target
#define __TAG	__VAR
#define __NAME	target pressure in atm
#define __DOALWAYS oopressure_target=one/max(__ERRTOL,(__VAR))
#include "parser/parser_macro2.src"
!
! surface area computation parameters (hopefully, adjusting from defaults should be unnecessary)
#define __LEZEROERR
#define __VAR	surface_area_grid_spacing
#define __TAG	__VAR
#define __NAME	grid spacing for surface area computation
#define __DOALWAYS oo_surface_area_grid_spacing=one/surface_area_grid_spacing
#include "parser/parser_macro2.src"
!
! NOTE : should consider the possibility of periodicity
#define __VAR	surface_area_grid_buffer
#define __TAG	__VAR
#define __NAME	grid buffer for surface area computation
#define __DOIFOK if (qper_parser_override) then ;\
                  __WRN(whoami, '"'//__STRING(__TAG)//'" HAS NO EFFECT WHEN PBC ARE USED.');\
                 elseif (__VAR.lt. __CONCAT(default_,__VAR) ) then ; \
                      __WRN(whoami, 'SETTING A LOW VALUE FOR SURFACE AREA GRID BUFFER MAY CAUSE INACCURACIES.');\
                 endif
#include "parser/parser_macro2.src"
!
 endif
#define __INT
#endif
!
! dasystat only (similar to barostat, and using same variables with different tags):
!===================================================================================================
#undef __LEZEROERR
#ifdef __DASYSTAT
 if (dasystat) then
!
#define __VAR	density_update_freq
#define __TAG	__VAR
#define __NAME	frequency of computing solvent density
#define __DOIFOK if (__VAR.eq.izero) then; \
                  __MESSAGE(whoami, 'DENSITY UPDATE IS OFF. TURNING DASYSTAT OFF.'); \
                  dasystat=.false. ; \
                 endif ! it does not make any sense to run dasystat without a density calculation !
#include "parser/parser_macro2.src"
 endif ! dasystat
!
 if (dasystat) then ! repeat if because dasystat may have been turned off
#define __VAR	surface_area_compute_freq
#define __TAG	volume_compute_freq
#define __NAME	frequency of computing solvent density
#define __DOIFOK if (__VAR.eq.izero) then; \
                  __MESSAGE(whoami, 'VOLUME COMPUTATION IS OFF. TURNING DASYSTAT OFF.'); \
                  dasystat=.false. ; \
                 endif ! it does not make any sense to run dasystat without a volume calculation !
#include "parser/parser_macro2.src"
 endif ! dasystat
!
 if (dasystat) then
#define __VAR	surface_area_grid_check_freq
#define __TAG	volume_grid_check_freq
#define __NAME	frequency of checking grid limits for computing solvent density
#define __DOIFOK if (qper_parser_override) then ;\
                  __WRN(whoami, 'PARAMETER "'//__STRING(__TAG)//'" HAS NO EFFECT WHEN PBC ARE USED.');\
                 elseif (__VAR.eq.izero) then; \
                  __WRN(whoami, 'WILL NOT UPDATE VOLUME GRID DURING DYNAMICS (THIS IS PROBABLY NOT A GREAT IDEA).'); \
                 endif
!
#include "parser/parser_macro2.src"
#define __LEZEROERR
#define __VAR	density_max_samples
#define __TAG	density_relax_time
#define __NAME	dasystat relaxation time (in simulation steps)
#include "parser/parser_macro2.src"
!
#undef __INT
!
#define __VAR	surface_area_grid_recompute_change
#define __TAG	volume_grid_recompute_change
#define __NAME	domain size difference required to trigger reinitialization of volume grid
#define __DOIFOK if (qper_parser_override) then ;\
                  __WRN(whoami, 'PARAMETER "'//__STRING(__TAG)//'" HAS NO EFFECT WHEN PBC ARE USED.');\
                 endif
#include "parser/parser_macro2.src"
#undef __LEZEROERR
!
#define __VAR	density_target
#define __TAG	__VAR
#define __NAME	target density in g/mL
#include "parser/parser_macro2.src"
!
! surface area computation parameters (hopefully, adjusting from defaults should be unnecessary)
#define __LEZEROERR
#define __VAR	surface_area_grid_spacing
#define __TAG	volume_grid_spacing
#define __NAME	grid spacing for volume computation
#define __DOALWAYS oo_surface_area_grid_spacing=one/surface_area_grid_spacing
#include "parser/parser_macro2.src"
!
! NOTE : should consider the possibility of periodicity
#define __VAR	surface_area_grid_buffer
#define __TAG	volume_grid_buffer
#define __NAME	grid buffer for volume computation
#define __DOIFOK if (qper_parser_override) then ;\
                  __WRN(whoami, 'PARAMETER "'//__STRING(__TAG)//'" HAS NO EFFECT WHEN PBC ARE USED.');\
                 elseif (__VAR.lt. __CONCAT(default_,__VAR) ) then ; \
                      __WRN(whoami, 'SETTING A LOW VALUE FOR VOLUME GRID BUFFER MAY CAUSE INACCURACIES.');\
                 endif
#include "parser/parser_macro2.src"
!
! value for distance to bulk boundary from protein (approximate for density method)
#undef __LEZEROERR
#undef __MINUSERR
#define __VAR	bulk_boundary_distance
#define __TAG __VAR
#define __NAME	Distance from protein to bulk boundary
#define __DOALWAYS if (abs(__VAR).le.__ERRTOL) then ; \
                    if (abs(surface_distance).gt.__ERRTOL) then;\
                     __VAR = -(__BULK_DISTANCE_SCALE) *abs(surface_distance);\
                     bulk_boundary_contour_value=__RHOSAFE(__VAR);\
                     __MESSAGE(whoami, 'SETTING LOCATION OF BULK BOUNDARY FROM SURFACE BOUNDARY TO '//ftoa(__VAR)) ; \
                    else;\
                     __MESSAGE(whoami, 'LOCATION OF BULK BOUNDARY WILL BE SET FROM SURFACE BOUNDARY.') ; \
                    endif;\
                   elseif((abs(__VAR).gt.abs(surface_distance)).and.(abs(surface_distance).gt.__ERRTOL)) then ;\
                    __WRN(whoami, 'BULK BOUNDARY MUST BE INSIDE SHELL SURFACE. ABORT');\
                    __ASSERT(abs(__VAR),<,abs(surface_distance)); \
                   else ;\
                    __VAR=-(abs(__VAR)) ; \
                    bulk_boundary_contour_value=__RHOSAFE(__VAR) ;\
                   endif ! make sure to set to a negative value
! NB: it is possible that bulk value is set but not the surface value ! Need to be aware of this when computing the surface val. below
! check in all contexts :
#include "parser/parser_macro3.src"
!
#define __BOOL
#define __VAR qbulk_boundary_recompute
#define __TAG bulk_boundary_recompute
#define __NAME flag to allow automatic adjustment of bulk boundary
#undef __WARNIFMISSING
#include "parser/parser_macro3.src"
#define __WARNIFMISSING
#undef __BOOL

! check distances here
#ifdef __DEBUG
 write(666,*) 'bulk_distance', bulk_boundary_distance
 write(666,*) 'rho_bulk', __RHO(bulk_boundary_distance)
 write(666,*) 'rho_bulk_safe', __RHOSAFE(bulk_boundary_distance)
!
 write(666,*) 'surface_distance', surface_distance
 write(666,*) 'rho_surf', __RHO(surface_distance), surface_contour_value
 write(666,*) 'rho_surf_safe', __RHOSAFE(surface_distance)
 close(666)
#endif

#define __MINUSERR
 endif
#endif
! dasystat only ^ ===========================================================================================
!
#if defined(__BAROSTAT) || defined(__DASYSTAT)
! distance update
 if ( &
#ifdef __BAROSTAT
 & barostat .or. &
#endif
#ifdef __DASYSTAT
 & dasystat .or. &
#endif
 & .false.)  then
!
#undef __INT
#undef __LEZEROERR
#define __VAR distance_update_step
#define __TAG __VAR
#define __NAME constant for updating target distance from surface
#define __DOIFOK if (__VAR.le.zero) then ; __WRN(whoami, 'UPDATE OF SURFACE CONTOUR REFERENCE VALUE IS OFF.') ; endif
#include "parser/parser_macro2.src"
!
#define __INT
!
#define __VAR	distance_update_freq
#define __TAG	__VAR
#define __NAME	frequency of updating target distance from surface
#define __DOIFOK if (__VAR.eq.izero) __MESSAGE(whoami, 'UPDATE OF SURFACE DISTANCE VALUE IS OFF.')
#include "parser/parser_macro2.src"
!
  surf_dist_changed=.true.
 endif ! barostat or dasystat
#endif
!
#define __VAR	structure_update_freq
#define __TAG	__VAR
#define __NAME	frequency of updating reference structure
#define __DOIFOK if (__VAR.eq.izero) __MESSAGE(whoami, 'SURFACE UPDATE IS OFF.')
#include "parser/parser_macro2.src"
!
#define __VAR	output_freq
#define __TAG	__VAR
#define __NAME	frequency for writing output/restart file
#define __DOIFOK if (__VAR.le.izero) __WRN(whoami, 'RESTART FILE WILL BE WRITTEN AT THE END ONLY.')
#include "parser/parser_macro2.src"
#undef __INT
!
! read atom selections
! atoms to define surface
#define __CHAR
#define __WARNIFMISSING
#define __VAR	surface_atom_selection
#define __TAG	surface_atoms
#define __NAME	surface atoms
#include "parser/parser_macro2.src"
! (solvent) atoms to which surface forces are applied
#define __VAR	solvent_atom_selection
#define __TAG	solvent_atoms
#define __NAME	solvent atoms
#include "parser/parser_macro2.src"
!
! output file
#undef __WARNIFMISSING
#define __VAR	output_file
#define __TAG	__VAR
#define __NAME	watershell output file
#include "parser/parser_macro2.src"
! formerly known under watershell_output ; check for this tag, also
if (.not.existtag_nocase('output_file', context)) then
#define __WARNIFMISSING
#define __TAG	watershell_output
#define __VAR	output_file
#define __NAME	watershell output file
#include "parser/parser_macro2.src"
#undef __CHAR
endif

!
#undef __WARNIFMISSING
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
#define __INT
#define __VAR	full_sum_freq
#define __TAG	__VAR
#define __NAME	frequency of force calculation without truncation of solvent neighbor list
#define __DOALWAYS if (__VAR.le.zero) then ;\
                  __WRN(whoami, 'SOLVENT ATOM NEIGHBOR LISTS CANNOT BE USED WITH "'//__STRING(__VAR)//'"=0.') ;\
                  neighbor_list_factor=one ;\
                  qneighbor_list=.false. ;\
                 else ;\
                  neighbor_list_factor = seven + ( (__VAR * __VAR) * 2.0d-4); \
                  if (.not.qneighbor_list) __WRN(whoami, 'NEIGHBOR LIST WILL NOT BE USED BECAUSE "neighbor_list" set to "off"') ;\
                 endif
#include "parser/parser_macro3.src"
!#ifdef __DEBUG
!       __DBGOUT('FULL_SUM_FREQ IS ',full_sum_freq)
       __DBGOUT('NEIGHBOR_LIST_FACTOR SET TO ',neighbor_list_factor) ! , seven + (full_sum_freq**2 * 2.0d-4)) 
!#endif
!
#define __VAR	sort_neighbor_list_freq
#define __TAG	__VAR
#define __NAME	frequency of sorting solvent atom neighbor lists
#define __DOIFOK if (__VAR.eq.zero) then ;\
                  __WRN(whoami, 'WILL NOT SORT SOLVENT ATOM NEIGHBOR LISTS') ;\
                 endif
 if (qneighbor_list) then
#include "parser/parser_macro2.src"
 endif
#undef __INT
#endif
!
!
#ifndef __WARNIFMISSING
#define __WARNIFMISSING
#endif
#define __VAR structure_update_memory
#define __TAG __VAR
#define __NAME memory constant for reference structure update
#define __DOIFOK if (__VAR.le.zero) then ; __WRN(whoami, 'SURFACE UPDATE IS OFF.') ; \
 elseif (__VAR .gt. one ) then ; __WRN(whoami, ftoupper(__STRING(__NAME))//' SHOULD _NOT_ BE GREATER THAN ONE !') ; endif
#include "parser/parser_macro2.src"
!
#undef __WARNIFMISSING
#undef __MINUSERR
#define __LEZEROERR
!
!#define __VAR target_surface_energy
!#define __TAG __VAR
!#define __NAME target surface energy per area
!#define __DOIFOK if (abs(__VAR).le.__ERRTOL) __WRN(whoami, 'TARGET SURFACE ENERGY IS ALMOST ZERO.')
!#include "parser/parser_macro2.src"
!
#ifdef __RMFT
#define __BOOL
#define __VAR remove_net_torque
#define __TAG __VAR
#define __NAME flag to remove net torque from solvent atoms
#include "parser/parser_macro2.src"
!
#ifdef __HAMILTONIAN
 if (__VAR) then
  __WRN(whoami, 'NET TORQUE CORRECTION IS CURRENTLY UNSUPPORTED IF HAMILTONIAN FORCES ARE APPLIED TO SURFACE ATOMS. TURNING TORQUE CORRECTION OFF.');
  __VAR=.false.
#endif
!
! to remove net force :
#define __VAR remove_net_force
#define __TAG __VAR
#define __NAME flag to remove net force from solvent atoms
#define __DOIFOK \
 if (__VAR.and..not.remove_net_torque) then ; \
  __WRN(whoami, 'NET FORCE REMOVAL REQUIRES NET TORQUE REMOVAL. WILL NOT REMOVE FORCE.') ; \
 endif
#include "parser/parser_macro2.src"
#undef __BOOL
#define __INT
#define __VAR net_force_ave_max_samples
#define __TAG average_net_ft_max_samples
#define __NAME max. samples in average net force
#define __FATALWRNLEV -2
#include "parser/parser_macro2.src"
#undef __INT
#endif
!
#ifdef __ROTRES
#define __BOOL
#define __TAG rigid_body_restraint
#define __VAR __CONCAT(q,__TAG)
#define __NAME flag to restrict rigid-body motions of surface atoms
#include "parser/parser_macro2.src"
#undef __BOOL
!
 if (qrigid_body_restraint) then
#define __WARNIFMISSING
#define __DEFAULT
#define __TAG rigid_body_force_constant
#define __VAR __TAG
#define __NAME force constat for rigid-body restraint
#include "parser/parser_macro2.src"
 endif
!
#endif
!
! done processing input file parameters
!
! read structure file
! (unless already read elsewhere ; at this point the data structures from dynamol are shared)
 if (.not. system_PDB_initialized) then
!=========== structure file
#define __CHAR
#define __VAR	structure_file
#define __TAG	__VAR
#define __NAME	structure file
#include "parser/parser_macro2.src"
#undef __CHAR
!===========
  __MESSAGE(whoami, 'READING STRUCTURE FROM FILE "'//trim(structure_file)//'"');
  call system_PDB_init(structure_file, 'PDB');
  if (.not. fatal_warning()) system_PDB_initialized=.true.
! save coordinates in rcomp, just in case we need them later , e.g. for rigid-body restraint reference
  if (associated(rcomp) .and. associated(r)) rcomp=r
 endif
!=========== end structure file
! initialize radii using a system function
! relevant only for density method, so make this explicit :
!
 if (.not.qminimum_distance) then
#define __GET_RAD(_TAG)  if (existtag_nocase(__STRING(_TAG),context)) then;\
                            farray=>system_init_mol_scalar_nocase(__STRING(_TAG), context);\
                            if (associated(farray)) then;\
                             radius=farray;\
                             deallocate(farray);\
                             radii_initialized=.true.; \
                            endif

  __GET_RAD(radii)
  else __GET_RAD(radius) ! other tags here
 else
 endif
!
 if (.not.(radii_initialized)) __WRN(whoami, 'COULD NOT INITIALIZE ATOMIC RADII');
 endif ! qmindist
! same for dasystat
#ifdef __DASYSTAT
!
#define __GET_MASS(_TAG)  if (existtag_nocase(__STRING(_TAG),context)) then;\
                            farray=>system_init_mol_scalar_nocase(__STRING(_TAG), context);\
                            if (associated(farray)) then;\
                             dasystat_masses=farray;\
                             deallocate(farray);\
                             dmasses_initialized=.true.; \
                            endif;

 if(dasystat) then
 __GET_MASS(masses)
 else __GET_MASS(mass)
 else __GET_MASS(dmasses)
 else __GET_MASS(dmass)
 else __GET_MASS(dasystat_masses)
 else __GET_MASS(dasystat_mass)
 endif ! get mass
 if (.not.dmasses_initialized) __WRN(whoami, 'COULD NOT INITIALIZE DASYSTAT MASSES');
 endif ! dasystat
#endif
!
! initialize coordinate arrays
#ifdef __DUMSURF
! decide whether we are using dummy surface atoms
 call toupper(surface_atom_selection)
 select case(surface_atom_selection)
  case('DUMMY','DUMB', 'DUM', 'DUMMIES','FIXED','POINT', 'POINTS');
   qdumsurf=.true.
   if (structure_update_freq.gt.0) then
    __WRN(whoami, 'STRUCTURE UPDATE WILL BE DISABLED SINCE FIXED DUMMY ATOMS ARE USED.');
    structure_update_freq=0
   endif
  case default;
   qdumsurf=.false.
 end select
!
 if (qdumsurf) then
  allocate(isurface_atoms(0)) ! zero-sized array to be able to recycle most of the (non-dummy) code as is
! obtain number of dummy atoms from parser
#define __GET_NDUM(_TAG)  if (existtag_nocase(__STRING(_TAG),context)) then;\
                           nsurface_coord=atoi(getval_nocase(__STRING(_TAG), context)) ;
  __GET_NDUM(NDUMMY)
  else  __GET_NDUM(NDUMB)
  else  __GET_NDUM(NDUM)
  else  __GET_NDUM(NDUMMIES)
  else  __GET_NDUM(NFIXED)
  else  __GET_NDUM(NPOINT)
  else  __GET_NDUM(NPOINTS)
  else  __GET_NDUM(NSURF)
  else  __GET_NDUM(NSURFACE)
  else  __GET_NDUM(NSURFACE_ATOMS)
  else  __GET_NDUM(NUMDUMB)
  else  __GET_NDUM(NUMDUM)
  else  __GET_NDUM(NUMDUMMIES)
  else  __GET_NDUM(NUMFIXED)
  else  __GET_NDUM(NUMPOINT)
  else  __GET_NDUM(NUMPOINTS)
  else  __GET_NDUM(NUMSURF)
  else  __GET_NDUM(NUMSURFACE)
  else  __GET_NDUM(NUMSURFACE_ATOMS)
  endif
  __ASSERT(nsurface_coord,.gt.,0)
 else
#endif __DUMSURF
 isurface_atoms=>system_getind(surface_atom_selection)
#ifdef __DUMSURF
 endif ! qdumsurf

 __DBGVAR(qdumsurf,1)
 __DBGVAR(nsurface_coord,1)

#endif

 if (associated(isurface_atoms)) then
  nsurface_atoms=size(isurface_atoms) ; ! note that per above, isurface_atoms is always allocated but might be a 0-size array
#ifdef __DUMSURF
  if (.not.qdumsurf) &
#endif
  nsurface_coord=nsurface_atoms ! if the surface coordianates are physical atoms, their number equals the number of atoms
!
  oonsurface=one/nsurface_coord ! recall that nsurface_coord is either the number of surface dummies, or the number of surface atoms
!
  __ALLOC(r_surf(3,nsurface_coord))
  __ALLOC(dr_surf(3,nsurface_coord))
#ifdef __ROTRES
  if (qrigid_body_restraint) then
   __ALLOC(r_surf_ref(3,nsurface_coord))
   __ALLOC(rb_wgt(nsurface_coord))
  else
   nullify(r_surf_ref, rb_wgt)
  endif
#endif
  __ALLOC(rad_surf(nsurface_coord))
 
! add atoms to list if provided
!  if (present(atoms)) then
   do l=1, nsurface_atoms
    ierr=atoms%uadd(isurface_atoms(l))
! NOTE : it is important to record all atoms to which forces will be applied :
#if (defined(__RMFT) && defined(__SIMPLE_NET_FORCE_SURFACE)) || defined(__HAMILTONIAN) || defined(__ROTRES)
!  if (remove_net_torque.and.present(forced_atoms)) ierr=forced_atoms%uadd(isurface_atoms(l))
#ifndef __HAMILTONIAN
  if ( .false. &
#if (defined(__RMFT) && defined(__SIMPLE_NET_FORCE_SURFACE))
&  .or. remove_net_torque &
#endif
#if defined(__ROTRES)
&  .or. qrigid_body_restraint &
#endif
&    ) &
#endif
ierr=forced_atoms%uadd(isurface_atoms(l))
#endif
   enddo ! physical surface atoms
!  endif ! present
!
 else
  __WRN(whoami, 'COULD NOT ALLOCATE MEMORY FOR SURFACE ATOM INDICES.')
 endif
! repeat for solvent atoms
 isolvent_atoms=>system_getind(solvent_atom_selection)
 if (associated(isolvent_atoms)) then
  nsolvent=size(isolvent_atoms) ; oonsolvent=one/nsolvent ;
  __ALLOC(r_solv(3,nsolvent))
  __ALLOC(rho_solv(nsolvent))
#ifdef __DASYSTAT
  __ALLOC(mass_solv(nsolvent))
#endif
  __ALLOC(qforced_solv(nsolvent))
  dist_solv=>rho_solv
  __ALLOC(drho_solv(3,nsolvent))
  ddist_solv=>drho_solv
#ifdef __SORT_LIST
  __ALLOC(solute_neighbor_list(nsurface_coord,nsolvent))
! initialize neighbor list with solute indices from 1 to nsurface_coord for each solute atom:
#ifdef __DEBUG
  __DBGOUT('INITIALIZING SOLUTE NEIGHBOR LIST');
#endif
  do l=1,nsurface_coord
   solute_neighbor_list(l,:)=l
  enddo
! because we are possibly using short ints to store neighbor list indices, we should make sure that the largest index is representable:
  l=solute_neighbor_list(nsurface_coord,1)
  __ASSERT(l, .eq., nsurface_coord)
!
#ifdef __NEIGHBOR_LIST
  qneighbor_list_sorted=.not.qneighbor_list ! if not using qlist, set to true to avoid sorting
  __ALLOC(solute_neighbor_mind(nsolvent))
  solute_neighbor_mind=nsurface_coord ! initialize to last position in the solute neighbor list array
#endif
#endif
! add atoms to lists if provided
!  if (present(atoms)) then
   do l=1, nsolvent
    ierr=atoms%uadd(isolvent_atoms(l))
   enddo
!  endif ! present
!
!  if (present(forced_atoms)) then
   do l=1, nsolvent
    ierr=forced_atoms%uadd(isolvent_atoms(l))
   enddo
!  endif ! present
!
 else
  __WRN(whoami, 'COULD NOT ALLOCATE MEMORY FOR SOLVENT ATOM INDICES.')
 endif
!
#ifdef __OMP
 numthreads=omp_get_max_threads()
 __MESSAGE(whoami, 'WILL USE '//itoa(numthreads)//' OPENMP THREADS')
#endif
!
#ifdef __HAMILTONIAN
#ifdef __OMP
 __ALLOC(ispt(nsurface_coord,0:numthreads-1)) ! note that nsurface_coord could be referring to dummy atoms (i.e. those to which forces cannot be applied)
 __ALLOC(drho_surf(3,nsurface_coord,0:2*numthreads-1)) ! 2*numthreads sets ; for each thread, the first is the support for a particular solvent atom; second is the sum over solv. atoms
#else
 __ALLOC(ispt(nsurface_coord,0:0))
 __ALLOC(drho_surf(3,nsurface_coord,0:1))
#endif
#endif
!
 if  (qrestart &
#ifdef __DUMSURF
 .or. qdumsurf &
#endif
& ) then
#ifdef __DUMSURF
 if (qdumsurf) then
  context=contexts(main_context)
 else
#endif
 context=contexts(restart_context)
#ifdef __DUMSURF
 endif
#endif
! read surface atom coordinates from restart file (context __RESTARTCTX)
  do l=1, nsurface_coord
   line=getval_nocase('rsurf_'//trim(itoa(l)),context)
   if (len_trim(line).gt.0) then
    read(line,*,iostat=ierr) r_surf(:,l)
__DBGVAR(r_surf(:,l),1)
    if (ierr.ne.0) then
     __WRN(whoami, 'ERROR READING COORDINATE FROM LINE "'//trim(line)//'"')
     cycle
    endif
   else
    __WRN(whoami, 'ERROR READING COORDINATE FROM LINE "'//trim(line)//'"')
   endif ! line ok
  enddo ! over surface atom coordinates
 else ! qrestart
! take surface atom coordinates from structure (PDB) file
  r_surf(:,1:nsurface_atoms)=r(:,isurface_atoms)
 endif ! qrestart
#ifdef __ROTRES
 if (qrigid_body_restraint) then ! read reference restraint atoms
  r_surf_ref(:,1:nsurface_atoms)=rcomp(:,isurface_atoms)
  rb_wgt=oonsurface ! uniform orientation weights
! in the case of restarting with PBC, align r_surf_ref with r_surf (should not be needed)
#ifdef __PBC_UNWRAP
  dr_surf=r_surf_ref-r_surf
  do l=1, nsurface_atoms
   __PBCDIST(dr_surf(1,l),ucell%a)
   __PBCDIST(dr_surf(2,l),ucell%b)
   __PBCDIST(dr_surf(3,l),ucell%c)
  enddo
   __INCR(r_surf, dr_surf)
#endif
  r_com_ref=sum(r_surf_ref,2)*oonsurface ! compute center of geometry
! center reference structure on zero :
  do l=1, nsurface_atoms
   __DECR( r_surf_ref(:,l), r_com_ref )
  enddo
 endif
#endif
!
!
#ifdef __DUMSURF
 if (qdumsurf) then
! obtain radii for dummy atoms from parser (other options useful ?) ; adapted from above
  rad_surf=zero ! initialize to zero ; missing entries below will remain zero
  do l=1, nsurface_coord
! no explicit checking for missing radii in the parser here
   rad_surf(l)=atof(getval_nocase('radsurf_'//trim(itoa(l)),contexts(main_context)))
  enddo ! over surface atom coordinates
 else ! qdumsurf
#endif
  if (qminimum_distance) then 
   rad_surf=zero ! NOTE : with qmindist, radii are inly used in dasy/baro to define grid limits
  else
   rad_surf(1:nsurface_atoms)=radius(isurface_atoms)
  endif
#ifdef __DUMSURF
 endif
#endif
! check that the radius is positive
 if (.not.qminimum_distance) then
  do l=1, nsurface_coord
   __ASSERTWARN( rad_surf(l) + surf_padding, > , zero )
  enddo
 endif
#ifdef __DASYSTAT
 mass_solv=dasystat_masses(isolvent_atoms)
 solvent_mass=sum(mass_solv)
#endif
!
#if defined(__BAROSTAT) || defined(__DASYSTAT)
 if (&
#ifdef __BAROSTAT
&     barostat .or. &
#endif
#ifdef __DASYSTAT
&     dasystat .or. &
#endif
&     .false. ) then 
  r_surf_changed=.true. ! we only need this variable for barostat/dasystat
! note that the above flag is set to compute the SA/VOL initially, so we keep it even with fixed (dummy) coords
 endif
#endif
#ifdef __RMFT
! compute com if removing torque
 if (remove_net_torque) then 
#ifdef __TORQUE_COM_SURFACE
  r_com = oonsurface * sum(r_surf,2)
#ifdef __UNWRAP_PBC
  if (qper_parser_override) r_pbc_reference=r_com
#endif
#else
#ifdef __UNWRAP_PBC
 if (qper_parser_override) r_pbc_reference = oonsurface * sum(r_surf,2)
#endif
#endif
  if (qrestart) then ! read average torque and force
! net torque :
   line=getval_nocase('average_net_torque', contexts(restart_context))
   if (len_trim(line).gt.0) then
    read(line,*,iostat=ierr) net_torque_ave
    if (ierr.ne.0) then
      __WRN(whoami, 'ERROR READING AVERAGE NET TORQUE FROM LINE "'//trim(line)//'"')
    endif
   else
     __WRN(whoami, 'ERROR READING AVERAGE NET TORQUE FROM LINE "'//trim(line)//'"')
     net_torque_ave=zero
   endif ! line ok
! net force :
   if (remove_net_force) then
    line=getval_nocase('average_net_force', contexts(restart_context))
    if (len_trim(line).gt.0) then
     read(line,*,iostat=ierr) net_force_ave
     if (ierr.ne.0) then
      __WRN(whoami, 'ERROR READING AVERAGE NET FORCE FROM LINE "'//trim(line)//'"')
     endif
    else
     __WRN(whoami, 'ERROR READING AVERAGE NET FORCE FROM LINE "'//trim(line)//'"')
     net_force_ave=zero
    endif ! line ok
   endif ! remove net force
  else ! qrestart
   net_torque_ave=zero
   if (remove_net_force) net_force_ave=zero
  endif ! qrestart
 endif ! remove net_torque
#endif
!
#if defined(__BAROSTAT) || defined(__DASYSTAT)

#ifdef __BAROSTAT
! if using barostat, read current running pressure
 if (barostat) then
  if (qrestart) then
! (1) read pressure value
   line=getval_nocase('pressure',__STRING(__RESTARTCTX))
   if (len_trim(line).gt.0) then
    read(line,*,iostat=ierr) pressure_ave
    if (ierr.ne.0) then
     __WRN(whoami, 'ERROR READING PRESSURE FROM LINE "'//trim(line)//'"')
    endif
   else
    __WRN(whoami, 'ERROR READING PRESSURE FROM LINE "'//trim(line)//'"')
   endif ! line ok
! now, long-time average
   line=getval_nocase('average_pressure',__STRING(__RESTARTCTX))
   if (len_trim(line).gt.0) then
    read(line,*,iostat=ierr) pressure_long_ave
    if (ierr.ne.0) then
     __WRN(whoami, 'ERROR READING AVERAGE PRESSURE FROM LINE "'//trim(line)//'"')
    endif
   else ! restart file does not have lta pressure, so set it to zero
    pressure_long_ave=zero
    pressure_num_long_samples=izero
   endif ! line ok
  else ! qrestart
   pressure_ave=zero; ! value used for initialization
   pressure_long_ave=zero
  endif ! qrestart
 endif ! barostat
#endif
!
#ifdef __DASYSTAT
! read current running density
 if (dasystat) then
  if (qrestart) then
! (1) read density value
   line=getval_nocase('density',__STRING(__RESTARTCTX))
   if (len_trim(line).gt.0) then
    read(line,*,iostat=ierr) density_ave
    if (ierr.ne.0) then
     __WRN(whoami, 'ERROR READING DENSITY FROM LINE "'//trim(line)//'"')
    endif
   else
    __WRN(whoami, 'ERROR READING DENSITY FROM LINE "'//trim(line)//'"')
   endif ! line ok
  else ! qrestart
   density_ave=-one; ! this value used for initialization is not physical
  endif ! qrestart
 endif ! dasystat
#endif
!
! set com for SA/VOL gridding
 if (&
#ifdef __BAROSTAT
&     barostat .or. &
#endif
#ifdef __DASYSTAT
&     dasystat .or. &
#endif
&     .false. ) then
#if defined(__RMFT) && defined(__TORQUE_COM_SURFACE)
  if (remove_net_torque) then
   r_com_sa=r_com
  else
   r_com_sa=oonsurface * sum(r_surf,2)
  endif
#else
  r_com_sa=oonsurface * sum(r_surf,2)
#endif
! initialize grid-based SA computation
  if (qper_parser_override) then ! for periodic BC, use cell info
   call ucell%print()
   r_surf_minmax(1,:) = - half * (/ucell%a, ucell%b, ucell%c/) ! grid minima
   r_surf_minmax(2,:) = + half * (/ucell%a, ucell%b, ucell%c/) ! grid maxima
  else
! note : a problem here is that surface_distance might be undefined (or zero) to be computed on first iteration
! this should be moved entirely to the main routine, after surface_distance is known
! also : note that the radii are zero for mindist method, since there is not a straightforward method to incorporate them without overhead
! the whole point of the mindist methiod is to make it "dirt cheap" compared to the "state-of-the-art" erf density
   r_surf_minmax(1,1) = minval(r_surf(1,:)-rad_surf) - r_com_sa(1) - ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
   r_surf_minmax(2,1) = maxval(r_surf(1,:)+rad_surf) - r_com_sa(1) + ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
!
   r_surf_minmax(1,2) = minval(r_surf(2,:)-rad_surf) - r_com_sa(2) - ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
   r_surf_minmax(2,2) = maxval(r_surf(2,:)+rad_surf) - r_com_sa(2) + ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
!
   r_surf_minmax(1,3) = minval(r_surf(3,:)-rad_surf) - r_com_sa(3) - ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
   r_surf_minmax(2,3) = maxval(r_surf(3,:)+rad_surf) - r_com_sa(3) + ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
  endif
!
__DBGVAR(surface_distance,1)
__DBGVAR(surface_area_grid_buffer,1)
__DBGVAR(r_surf_minmax,1)
__DBGVAR(minval(r_surf,2),1)
__DBGVAR(maxval(r_surf,2),1)
__DBGVAR(r_com_sa,1)
!
  call ugrid_initialize(sagrid, 3, r_surf_minmax, (/surface_area_grid_spacing/), adjust_spacings_=qper_parser_override) ! when using PBC, adjust spacing, not length
!
  if (qminimum_distance) then
#ifdef __OMP
   allocate(sarho_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:numthreads-1))
#ifdef __DASYSTAT
   if (dasystat) allocate(inrho_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:numthreads-1))
#endif
#else
  allocate(sarho(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#ifdef __DASYSTAT
  if (dasystat) allocate(inrho(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#endif
#endif
  else ! qminimum_distance
#ifdef __OMP
   allocate(sarhof_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:numthreads-1))
#else
   allocate(sarhof(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#endif
  endif ! qmindist
! initialize random number generator for small random grid displacements
#ifdef __PERTURB_GRID
  if (.not.random_initialized) call random_init()
#endif
! NOTE: not computing surface area or volume here, because the shell distances may not yet be defined
 endif ! barostat or dasystat
#endif
!
 if (.not.fatal_warning() .and. (radii_initialized .or. qminimum_distance) &
#ifdef __DASYSTAT
 .and.(dmasses_initialized .or. .not. dasystat) &
#endif
& ) __NM(initialized)=.true.
!
 end __SUB(initialize)
!======================================
 __SUB(write_restart_file) ()
! adapted from tempering
 __IAM(__NM(WRITE_RESTART_FILE))
 int :: ifile, i
 ifile=-1 ! make sure files_open determines the handle automatically
 call files_open(ifile, output_file, 'FORMATTED','WRITE')
!
#define _W write(ifile,*)
 _W '#WATERSHELL RESTART FILE'
 _W __STRING(__RESTARTCTX)//' {'
 _W 'iteration=',iteration
 if (qminimum_distance) then 
  _W 'minimum_distance=on # use the simpler minimum distance to solvent algorithm'
 else
! _W 'surface_contour_value=',surface_contour_value, ' # value for which density isosurface is computed'
  _W 'surf_stdev=',surf_stdev, ' # standard deviation of Gaussian filter'
#ifdef __ADAPTIVE_SUPPORT
#ifdef __ADAPTIVE_CUTOFF
! write recomputed from current cutoff
  _W 'cutoff_surf_stdev=',cutoff_surf * oo_surf_stdev, ' # distance from center beyond which it is set to zero (units of standard deviation)'
#endif
#else
  _W 'cutoff_surf_stdev=',cutoff_surf_stdev, ' # distance from center beyond which it is set to zero (units of standard deviation)'
#endif
  _W 'surface_padding=',surf_padding, ' # scalar padding added to each atom radius'
 endif
 _W 'surface_distance=',surface_distance, ' # distance of solvent surface from solute'
 _W 'surface_force_constant=',surface_force_constant, ' # surface force constant'
!
#if defined(__SORT_LIST) & defined(__NEIGHBOR_LIST)
 if (qneighbor_list) then
  _W 'neighbor_list=on # use a neighbor list for solvent forces'
 else
  _W 'neighbor_list=off # do not use a neighbor list for solvent forces'
 endif
#endif
!
#ifdef __RMFT
! need to write out average force (since it is a time average)
 if (remove_net_torque) then
  _W 'average_net_torque=(',net_torque_ave,')'
  if (remove_net_force) then
   _W 'average_net_force=(',net_force_ave,')'
  endif
  _W 'average_net_ft_samples=',net_force_ave_num_samples
 endif
#endif
#ifdef __BAROSTAT
 if (barostat) then
 _W 'pressure=',pressure_ave, '# (units of atm)'
 _W 'pressure_num_samples=',pressure_num_samples
 _W 'average_pressure=',pressure_long_ave, '# (units of atm)'
 _W 'pressure_num_long_samples=',pressure_num_long_samples
 endif
#endif
#ifdef __DASYSTAT
 if (dasystat) then
 _W 'density=',density_ave, '# (units of g/mL)'
 _W 'density_num_samples=',density_num_samples
 _W 'bulk_boundary_distance=',bulk_boundary_distance, ' # distance from solute to bulk solvent'
 if (qbulk_boundary_recompute .neqv. default_qbulk_boundary_recompute) then
  if (qbulk_boundary_recompute) then
   _W 'bulk_boundary_recompute=on # adjust bulk boundary automatically'
  else
   _W 'bulk_boundary_recompute=off # do not adjust bulk boundary automatically'
  endif
 endif
 endif
#endif
! write the current reference atoms :
 _W '# rsurf_i : reference coordinate triple for atom #i used to define surface'
 do i=1, nsurface_coord
  _W 'rsurf_'//trim(itoa(i)),'=(',r_surf(:,i),')'
 enddo ! surface atoms
 _W '}'
! close file
 call files_close(ifile)
!
 end __SUB(write_restart_file)
!================================================================
 __SUB(done)
 __IAM(__NM(done))
 if (__NM(initialized)) then
  __MESSAGE(whoami, 'WRITING RESTART FILE.')
  call __NM(write_restart_file)()
 endif
!
 call system_done()
 call parser_done()
 __FREE(r_surf)
 __FREE(dr_surf)
#ifdef __ROTRES
 __FREE(r_surf_ref)
 __FREE(rb_wgt)
#endif
 __FREE(r_solv)
 __FREE(qforced_solv)
 __FREE(rad_surf)
 __FREE(rho_solv)
 nullify(dist_solv)
 __FREE(drho_solv)
 nullify(ddist_solv)
 __FREE(isurface_atoms)
 __FREE(isolvent_atoms)
#ifdef __SORT_LIST
 __FREE(solute_neighbor_list)
#ifdef __NEIGHBOR_LIST
 __FREE(solute_neighbor_mind)
#endif
#endif
#if defined(__BAROSTAT) || defined(__DASYSTAT)
#ifdef __OMP
 __DEALL(sarho_all_threads)
 __DEALL(sarhof_all_threads)
#ifdef __DASYSTAT
 __DEALL(inrho_all_threads)
#endif
#else
 __DEALL(sarho)
 __DEALL(sarhof)
#ifdef __DASYSTAT
 __DEALL(inrho)
#endif
#endif
 call ugrid_done(sagrid)
#endif
!
#ifdef __HAMILTONIAN
 __DEALL(ispt)
 __DEALL(drho_surf)
#endif
 __NM(initialized)=.false. ; radii_initialized=.false.
#ifdef __DASYSTAT
 dmasses_initialized=.false.
#endif
!
 end __SUB(done)
!================================================================
 __SUB(main)(r,fr,energy,qper_,mdcell) ! NOTE : qper/ucell is not supposed to change; keeping here for sanity check
#if defined(__RMFT) & !defined(__F_T_COUPLED)
 use lu
#endif
 use bestfit, only :  matinv3sym &
#ifdef __ROTRES
& , RMSBestFit &
#endif
& , norm3
!
 float, intent(in) :: r(:,:)   ! coordinate array
 float, intent(out) :: fr(:,:) ! force array
 float, intent(out), optional :: energy
!
 __OPAR(qper,bool)
!
 type (cell), optional :: mdcell
! int :: ibeg, iend ! atom indices for looping
 float :: distance_from_solute, distance_from_solute2, pre, d0
 float :: surface_force ! , density_beyond_contour ! useful ?
#ifdef __ROTRES
 float :: dcom(3), r1(3)
#endif
#if defined(__RMFT) || defined(__FORCE_STATS)
 float :: iforce(3)
#endif
#ifdef __RMFT
! to update coefficients for computing torque matrix ; doing this way to separate com contribution :
#define __UPDATE_TMAT_C \
  __INCR(__U(ir1),ir(1));\
  __INCR(__U(ir2),ir(2));\
  __INCR(__U(ir3),ir(3));\
  __INCR(__U(ir1s),ir(1)**2);\
  __INCR(__U(ir2s),ir(2)**2);\
  __INCR(__U(ir3s),ir(3)**2);\
  __INCR(__U(ir12),ir(1)*ir(2));\
  __INCR(__U(ir13),ir(1)*ir(3));\
  __INCR(__U(ir23),ir(2)*ir(3));
 float, dimension(3) :: ir, itorque ! inst position, force and torque corresponding to an atom
 float :: ir1,ir2,ir3,ir1s,ir2s,ir3s,ir12,ir13,ir23, oontorque
 float, dimension(3) :: ir_sum
! float, dimension(3) :: oforce ! existing force
#ifdef __F_T_COUPLED
 float, dimension(6,6) :: A ! matrix for force and torque removal
#else
 float, dimension(3,3) :: B ! matrix for torque removal
#endif
 float, dimension(6) :: rhs ! vector for net force and torque removal
#endif
#ifdef __OMP
#//define __REDUCE(_W) __INCR(_W,__U(_W)) ! thread reduction
#define __REDUCE(_W) _W=_W+__U(_W) ! thread reduction
#define __AREDUCE(_W,_I) _W(_I)=_W(_I)+__U(_W)(_I)
 float :: __U(surface_energy)
 float :: __U(surface_force)
! float :: __U(density_beyond_contour) ! useful ?
 int :: __U(nsolvent_outside)
#ifdef __DASYSTAT
 float :: __U(solvent_mass_outside)
#endif
#ifdef __RMFT
 float, dimension(3) :: __U(net_force), __U(net_torque), __U(max_force) ! thread locals
 float :: __U(ir1),__U(ir2),__U(ir3),__U(ir1s),__U(ir2s),__U(ir3s),__U(ir12),__U(ir13),__U(ir23)
 float, dimension(6) :: __U(rhs)
#endif
#endif
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
 int :: ind, istep ! variables for binary search
#if defined(__OMP) & defined(__FORCE_OMP)
 float, allocatable :: distance2_all_threads(:,:)
 int :: tid
#else
 float, allocatable :: distance2(:)
#endif
 int :: ierr
#endif

#ifdef __FD_CHECK
 int :: j
#ifdef __ROTRES
 int :: k
#endif
#endif

 int :: i, ii
 __IAM(__NM(main))
!================================================================
 if (.not. __NM(initialized)) then
  __WRN(whoami, ftoupper(__STRING(_N))//'NOT INITIALIZED. NOTHING DONE.');
  return
 endif
!
 __INC(iteration)
! copy solvent coordinates
 r_solv=r(:,isolvent_atoms)
! sort neighbor list on first iteration
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
 if (qneighbor_list.and.sort_neighbor_list_freq.gt.izero) then
  if (__CHKUPDATE(sort_neighbor_list_freq)) qneighbor_list_sorted=.false.
 endif ! qneighbor_list
!
 if (.not. qneighbor_list_sorted) then
!
 if (.not. qminimum_distance) pre=(maxval(rad_surf) + surf_padding + cutoff_surf)**2
!
#if defined(__OMP) & defined(__FORCE_OMP)
  __ALLOC(distance2_all_threads(nsurface_coord,0:numthreads-1))
!$omp parallel private(ierr,tid,i,ii,ind,istep &
#ifdef __PBC_UNWRAP
!$omp ,d0 &
#endif
!$omp )
  tid=omp_get_thread_num()
#define distance2(_ii) distance2_all_threads(_ii,tid)
#else
  __ALLOC(distance2(nsurface_coord))
#endif

#ifdef __PBC_UNWRAP
  if(qper_parser_override) then
#endif
!
#if defined(__OMP) & defined(__FORCE_OMP)
!$omp do schedule(runtime)
#endif
   do i=1, nsolvent
    do ii=1, nsurface_coord
#ifdef __PBC_UNWRAP
     distance2(ii)=zero
! x
     d0=r_surf(1,ii)-r_solv(1,i)
     __DIST_PBC(d0,ucell%a)
     __INCR(distance2(ii),d0*d0)
! y
     d0=r_surf(2,ii)-r_solv(2,i)
     __DIST_PBC(d0,ucell%b)
     __INCR(distance2(ii),d0*d0)
! z
     d0=r_surf(3,ii)-r_solv(3,i)
     __DIST_PBC(d0,ucell%c)
     __INCR(distance2(ii),d0*d0)
#else
!     distance2(ii) = sum ( (r_surf(:,ii)-r_solv(:,i))**2 )
! slightly faster :
     distance2(ii)=zero
     d0=r_surf(1,ii)-r_solv(1,i)
     __INCR(distance2(ii),d0*d0)
     d0=r_surf(2,ii)-r_solv(2,i)
     __INCR(distance2(ii),d0*d0)
     d0=r_surf(3,ii)-r_solv(3,i)
     __INCR(distance2(ii),d0*d0)
#endif
    enddo ! nsurface_coord
!  sort neighbor list:
    call rsort_index('i',nsurface_coord,distance2(:),solute_neighbor_list(:,i),ierr)
!
    if (qminimum_distance) then
     solute_neighbor_mind(i)=min(nsurface_coord,2) ! fo mindist only
    elseif (nsurface_coord>0) then
! for the erf/density method, we need to find the largest index in the set of atoms supported by filter:
! use this search macro:
#define __MXLOC(_A,_a,_len,_ind,_istep) \
 _ind=(1+_len)/2;\
 _istep=(1+_ind)/2;\
 do;\
  if (_A(_ind)>(_a)) then;\
   _ind=max(1,_ind-_istep); \
  else; \
   _ind=min((_len),_ind+_istep); \
  endif;\
  if (_istep<2) exit;\
  _istep=(_istep+1)/2;\
 enddo;\
 if ( _A(_ind)>(_a) .and. _ind>1) _ind=_ind-1
!
     __MXLOC( distance2, pre, nsurface_coord, ind, istep )
!
     solute_neighbor_mind(i)=ind
    endif
! __DBGVAR(pre,2)
! __DBGVAR(distance2(1:10),2)
! __DBGVAR(solute_neighbor_mind(i),2)
   enddo ! nsolvent
#if defined(__OMP) & defined(__FORCE_OMP)
!$omp end do
#endif
#ifdef __PBC_UNWRAP
  else ! qper_parser_override
#if defined(__OMP) & defined(__FORCE_OMP)
!$omp do schedule(runtime)
#endif
   do i=1, nsolvent
    do ii=1, nsurface_coord
!     distance2(ii) = sum ( (r_surf(:,ii)-r_solv(:,i))**2 )
! slightly faster :
     distance2(ii)=zero
     d0=r_surf(1,ii)-r_solv(1,i)
     __INCR(distance2(ii),d0*d0)
     d0=r_surf(2,ii)-r_solv(2,i)
     __INCR(distance2(ii),d0*d0)
     d0=r_surf(3,ii)-r_solv(3,i)
     __INCR(distance2(ii),d0*d0)
    enddo ! nsurface
!  sort neighbor list:
    call rsort_index('i',nsurface_coord,distance2(:),solute_neighbor_list(:,i),ierr)
    if (qminimum_distance) then
     solute_neighbor_mind(i)=min(nsurface_coord,2) ! for mindist only
    elseif (nsurface_coord>0) then
     __MXLOC( distance2, pre, nsurface_coord, ind, istep )
     solute_neighbor_mind(i)=ind
    endif
   enddo ! nsolvent
#if defined(__OMP) & defined(__FORCE_OMP)
!$omp end do
#endif
  endif ! qper_parser_override
#endif
#if defined(__OMP) & defined(__FORCE_OMP)
!$omp end parallel
  __DEALL(distance2_all_threads)
#undef distance2
#else
  __DEALL(distance2)
#endif
  qneighbor_list_sorted=.true.
 endif ! sorted
#endif
!
! compute displacement from inst. surface atom coordinates to current surface coordinates ; for convenience in subsequent calcs
! note that it is needed only in certain circumstances (compilations and runtime conditions), so we test for that below :

 if ( ((structure_update_freq.gt.izero) .and. __CHKUPDATE(structure_update_freq)) &
#if (defined(__RMFT) && defined(__SIMPLE_NET_FORCE_SURFACE))
&  .or. remove_net_torque &
#endif
#ifdef __ROTRES
&  .or. qrigid_body_restraint &
#endif
&    ) then
!
#ifdef __PBC_UNWRAP
   if (qper_parser_override) then
#ifdef __OMP
!$omp parallel private(ii)
!$omp do schedule(runtime)
#endif
    do i=1, nsurface_atoms
     ii=isurface_atoms(i)
     dr_surf(1,i)=r(1,ii)-r_surf(1,i); __PBCDIST(dr_surf(1,i),ucell%a) !x
     dr_surf(2,i)=r(2,ii)-r_surf(2,i); __PBCDIST(dr_surf(2,i),ucell%b) !y
     dr_surf(3,i)=r(3,ii)-r_surf(3,i); __PBCDIST(dr_surf(3,i),ucell%c) !z
    enddo
#ifdef __OMP
!$omp end do
!$omp end parallel
#endif
   else
#endif
#ifdef __DUMSURF
    if (nsurface_atoms.gt.0) &
#endif
     dr_surf = r(:,isurface_atoms) - r_surf
#ifdef __PBC_UNWRAP
   endif ! qper override
#endif
endif ! decide whether to compute dr_surf
!
#if (defined(__RMFT) && defined(__SIMPLE_NET_FORCE_SURFACE)) || defined (__ROTRES)
 if ( .false. &
#if (defined(__RMFT) && defined(__SIMPLE_NET_FORCE_SURFACE))
& .or. remove_net_torque &
#endif
#ifdef __ROTRES
& .or. qrigid_body_restraint &
#endif
               ) then
! note that rigid body restraints are not compatible with __DUMSURF ; partly because is unclear why that would be useful, or how to do it
#if defined(__RMFT) && defined(__SIMPLE_NET_FORCE_SURFACE) && defined (__DUMSURF)
  if (qdumsurf) then
   r_com_inst=r_com ! since the coordinates are fixed
  else
#endif
  r_com_inst = oonsurface * sum(dr_surf + r_surf,2) ; ! need instant com for SIMPLE_NET_FORCE_SURFACE, b/c forces applied to prot. atoms
#if defined(__RMFT) && defined(__SIMPLE_NET_FORCE_SURFACE) && defined (__DUMSURF)
 endif ! qdumsurf
#endif
 endif ! remove_net_torque || qrigid_body_restraint
#endif
!============================================= update surface coordinates
 if (structure_update_freq.gt.izero) then
  if __CHKUPDATE(structure_update_freq) then
   d0=(one-structure_update_memory)
#ifdef __DUMSURF
   if (nsurface_atoms.gt.0) &
#endif
    __INCR(r_surf, d0 * dr_surf)
!
#if defined(__BAROSTAT) || defined (__DASYSTAT)
   if (&
#ifdef __BAROSTAT
&       barostat .or. &
#endif
#ifdef __DASYSTAT
&       dasystat .or. &
#endif
&       .false. ) then 
  r_surf_changed=.true. ! we only need this variable for barostat/dasystat
 endif
#endif
!
#ifdef __RMFT
#ifdef __TORQUE_COM_SURFACE
! recompute COM if subtracting torque
   if (remove_net_torque) then 
#ifdef __SIMPLE_NET_FORCE_SURFACE
! update r_com
    __INCR(r_com,  d0 * (r_com_inst - r_com))
#else
    r_com = oonsurface * sum(r_surf,2) ; ! NOTE : a COG rather than COM
#endif
   endif ! remove_net_torque
#ifdef __UNWRAP_PBC
   r_pbc_reference=r_com
#endif
#else
#ifdef __UNWRAP_PBC
   r_pbc_reference = oonsurface * sum(r_surf,2)
#endif
#endif
#endif
  endif ! structure_update
 endif ! structure_update
!
#ifdef __ROTRES
!============================================= apply rigid body restraint forces
 if (qrigid_body_restraint) then
! obtain absolute inst. coordinates, shifted to zero COM
  do i=1, nsurface_atoms
   __INCR( dr_surf(1,i), r_surf(1,i) - r_com_inst(1) )
   __INCR( dr_surf(2,i), r_surf(2,i) - r_com_inst(2) )
   __INCR( dr_surf(3,i), r_surf(3,i) - r_com_inst(3) )
  enddo
  call RMSBestFit(r_surf_ref, dr_surf, rb_wgt, A_rb, qdimswap_=.true.)
! subtract Identity from A:
  __DECR(A_rb(1,1),__CONCAT3(1,__PCODE,0))
  __DECR(A_rb(2,2),__CONCAT3(1,__PCODE,0))
  __DECR(A_rb(3,3),__CONCAT3(1,__PCODE,0))
!
  __SCALE(A_rb, rigid_body_force_constant*oonsurface) ! pre-scale matrix for speed
  dcom=(r_com_inst-r_com_ref)*rigid_body_force_constant*oonsurface
! compute and apply forces on surface atoms :
#ifdef __FD_CHECK
! record current forces in case they are nonzero :
   __ALLOC(ffd2(3,nsurface_atoms))
   ffd2=fr(:,isurface_atoms(:))
#endif
#ifdef __OMP
!$omp parallel do schedule(runtime)
#endif
  do i=1, nsurface_atoms
   __DECR( fr(:,isurface_atoms(i)), (matmul(A_rb, r_surf_ref(:,i)) + dcom) )
  enddo
#ifdef __OMP
!$omp end parallel do
#endif
!
#ifdef __FD_CHECK
  __ALLOC(ffd(3,nsurface_atoms))
  do i=1, nsurface_atoms ; do j=1, 3
   ffd(j,i)=zero
   do ii=-1,1,2
    __INCR ( dr_surf(j,:) , r_com_inst(j) ) ! restore COM
    __INCR ( dr_surf(j,i) , ii * h ) ! perturb
    r_com_inst(j)=sum(dr_surf(j,:))*oonsurface ! recompute com
    __DECR ( dr_surf(j,:), r_com_inst(j)) ! subtract new COM
    call RMSBestFit(r_surf_ref, dr_surf, rb_wgt, A_rb, qdimswap_=.true.)
    dcom=(r_com_inst-r_com_ref)
! compute energy
    do k=1, nsurface_atoms
     __INCR  ( ffd(j,i), ii*sum( ( dr_surf(:,k) - r_surf_ref(:,k) + dcom )**2 ))
     __DECR  ( ffd(j,i), ii*sum( ( dr_surf(:,k) - matmul(A_rb, r_surf_ref(:,k)))**2))
    enddo ! k
! restore coordinate
    __INCR ( dr_surf(j,:) , r_com_inst(j) ) ! restore COM
    __INCR ( dr_surf(j,i) , -ii * h ) ! restore
    r_com_inst(j)=sum(dr_surf(j,:))*oonsurface ! recompute com
    __DECR ( dr_surf(j,:), r_com_inst(j)) ! subtract new COM
   enddo ! ii
  enddo ; enddo ! j, i
  __SCALE(ffd, - half * rigid_body_force_constant * oonsurface / ( 2*h ) )

#ifdef __DEBUG
 write(600,*) iteration
 write(600,*) ffd(1,:)
 write(600,*) fr(1,isurface_atoms(:))
 close(600)
#endif

   d0=sqrt(sum ( ffd(1,:)-(fr(1,isurface_atoms(:))-ffd2(1,:)) )**2 * oonsurface)
   __WARN(whoami, ' ABSOLUTE RMS X-GRAD FD ERROR IN RIGID RESTRAINT IS ', d0 )
   d0=d0/sqrt( sum ( fr(1,isurface_atoms(:))-ffd2(1,:) )**2 * oonsurface )
   __WARN(whoami, ' RELATIVE RMS X-GRAD FD ERROR IN RIGID RESTRAINT IS ', d0 )
!
   d0=sqrt(sum ( ffd(2,:)-(fr(2,isurface_atoms(:))-ffd2(2,:)) )**2 * oonsurface)
   __WARN(whoami, ' ABSOLUTE RMS Y-GRAD FD ERROR IN RIGID RESTRAINT IS ', d0 )
   d0=d0/sqrt( sum ( fr(2,isurface_atoms(:))-ffd2(2,:) )**2 * oonsurface )
   __WARN(whoami, ' RELATIVE RMS Y-GRAD FD ERROR IN RIGID RESTRAINT IS ', d0 )
!
   d0=sqrt(sum ( ffd(3,:)-(fr(3,isurface_atoms(:))-ffd2(3,:)) )**2 * oonsurface)
   __WARN(whoami, ' ABSOLUTE RMS Z-GRAD FD ERROR IN RIGID RESTRAINT IS ', d0 )
   d0=d0/sqrt( sum ( fr(3,isurface_atoms(:))-ffd2(3,:) )**2 * oonsurface )
   __WARN(whoami, ' RELATIVE RMS Z-GRAD FD ERROR IN RIGID RESTRAINT IS ', d0 )
!
  __DBGOUT('Free surface arrays for FD check')
  __FREE(ffd)
  __FREE(ffd2)
  __DBGOUT('Recompute correct rigid restraint forces')
! recompute A and dcom correctly for energy calc in the output section
!
  call RMSBestFit(r_surf_ref, dr_surf, rb_wgt, A_rb, qdimswap_=.true.)
! subtract Identity from A:
  __DECR(A_rb(1,1),__CONCAT3(1,__PCODE,0))
  __DECR(A_rb(2,2),__CONCAT3(1,__PCODE,0))
  __DECR(A_rb(3,3),__CONCAT3(1,__PCODE,0))
!
  __SCALE(A_rb, rigid_body_force_constant*oonsurface)
  dcom=(r_com_inst-r_com_ref)*rigid_body_force_constant*oonsurface

#endif __FD_CHECK
 endif
!============================================= compute contour value/distance and gradient at solvent coordinates
#endif // __ROTRES
!
 surface_energy=zero
 distance_from_solute=zero
 distance_from_solute2=zero ! for computing second moment
!
!========================== compute contour value if needed
! if surface distance value is zero, estimate a reasonable value from current coordinates
 if ( abs(surface_distance) .lt. __ERRTOL) then
  __DBGOUT('Will compute approximate surface distance')
  if (qminimum_distance) then ! simple algorithm
#ifdef __DASYSTAT
   if (dasystat) then
! note : need to make sure that no atoms are treated as bulk atoms, i.e. set bulk distance to 0
    d0=bulk_boundary_distance ! save in case it has been set
    bulk_boundary_distance=zero
#ifdef __BULK2_DISTANCE_SCALE
    bulk2_boundary_distance=zero
#endif
   endif
#endif
!
   call __NM(compute_mindist_grad)(.false.) ! need entire sum
#ifdef __DASYSTAT
   if (dasystat) bulk_boundary_distance=d0 ! restore
#endif
   do i=1, nsolvent
    d0 = dist_solv(i)
    __DBGOUT('Inst. distance from solute for atom ',i,' is ', d0);
    __INCR(distance_from_solute, d0)
    __INCR(distance_from_solute2, d0**2)
   enddo
   pre=1.0d0 ! prefactor for scaling std in computing reference distance
  else ! (NOT) qminimum_distance -- original erf algorithm
! first, set surface_contour value to an upper bound to make sure that
! no atoms can be marked as "inside" atoms; this ensures that the density routine will compute densities without truncation
   surface_contour_value=nsurface_coord
#ifdef __DASYSTAT
   if (dasystat) then
    d0=bulk_boundary_contour_value ! save in case it has been set
    bulk_boundary_contour_value=surface_contour_value
#ifdef __BULK2_DISTANCE_SCALE
    bulk2_boundary_contour_value=surface_contour_value
#endif
   endif ! dasystat
#endif
   call __NM(compute_density_grad)(.false.) ! false to traverse entire solvent atom list
#ifdef __DASYSTAT
   if (dasystat) bulk_boundary_contour_value=d0 ! restore
#endif
   do i=1, nsolvent
! convert to distance
    if ( rho_solv(i) .le. zero ) then ! warn that we are outside of the support
     __WRN(whoami, 'SOLVENT ATOM '//itoa(isolvent_atoms(i))//' OUTSIDE OF SOLUTE SUPPORT. RESTART WITH A LARGER FILTER CUTOFF OR PADDING.')
    endif
    d0 = __RHO_INVSAFE(rho_solv(i))
    __DBGOUT('Inst. density/distance from solute for atom ',i,' are ',rho_solv(i),'/',d0);
    __INCR(distance_from_solute, d0)
    __INCR(distance_from_solute2, d0**2)
   enddo
   pre=1.25d0
  endif ! qmin distance
! set contour value to average value + (a) x stdev ; a set empirically
  __SCALE(distance_from_solute,oonsolvent);
  __DBGOUT('Average distance from solute ', distance_from_solute)
  __SCALE(distance_from_solute2,oonsolvent);
  __DBGOUT('Distance from solute stdDev ', sqrt ( distance_from_solute2 - distance_from_solute**2))
  surface_distance = distance_from_solute - & ! average (recall that distance_from_solute < 0, so this adds to the length)
&                    pre * sqrt( max(zero,distance_from_solute2 - distance_from_solute**2) ) ! analytically positive, but, just in case, protect from roundoff
! 12.18 : unclear how to best determine the optimal value :
! in the original method above, I used a simple average ; however, when the surface force constants are large
! the initial shell is too 'tight' and leads to instabilities;
!
  surface_contour_value = __RHOSAFE(surface_distance) ! for mindist, determine this for information, even though not relevant to algorithm
  __DBGOUT( 'COMPUTED SD, SCV: ', surface_distance, surface_contour_value)
  if (qminimum_distance) then
   __MESSAGE(whoami, 'COMPUTED SURFACE DISTANCE AT '//ftoa(surface_distance)//' A FROM PROTEIN.')
  else
   __MESSAGE(whoami, 'COMPUTED SURFACE DISTANCE AT '//ftoa(surface_distance)//' A FROM PROTEIN. CONTOUR VALUE IS '//ftoa(surface_contour_value))
  endif
!
#ifdef __DASYSTAT
!
! also check for distance to bulk boundary; note that, since the bulk
! boundary distance is held fixed, it is possible that surface will shrink
! to be very close to the bulk boundary,  in which case we would need to
! recompute the bulk boundary distance to avoid instabilities (or
! ill-definedness, if the BBD happens to be OUTSIDE !)
! 4/19 : also recompute if the BBD is too far from the SD ; (e.g. so that simulations that converge on the same SD also converge on similar BBDs)
!
  if (dasystat) then
   if ( abs(bulk_boundary_distance).lt.__ERRTOL ) then ! zero value signals auto-compute
    __MESSAGE(whoami, 'COMPUTING INITIAL LOCATION OF BULK BOUNDARY FROM SURFACE BOUNDARY:')
!
   elseif(abs(bulk_boundary_distance).ge.abs(surface_distance)) then
    __WRN(whoami, 'BULK BOUNDARY MUST BE INSIDE SHELL SURFACE. ABORT');
    __ASSERT(abs(bulk_boundary_distance),<,abs(surface_distance));
    goto 999
!
   elseif( qbulk_boundary_recompute .and. ((abs(surface_distance) - abs(bulk_boundary_distance)) .lt. &
&    ( __BULK_BOUNDARY_RECOMPUTE_FACTOR * abs(surface_distance) )) ) then ! recompute bulk_bdry
    __MESSAGE(whoami, 'BULK BOUNDARY IS TOO CLOSE TO SURFACE BOUNDARY. WILL RECOMPUTE:')
!
   elseif( qbulk_boundary_recompute .and. ((abs(surface_distance) - abs(bulk_boundary_distance)) .gt. &
&    ( ( 2*(one-(__BULK_DISTANCE_SCALE)) - __BULK_BOUNDARY_RECOMPUTE_FACTOR) * abs(surface_distance) )) ) then ! recompute bulk_bdry
    __MESSAGE(whoami, 'BULK BOUNDARY ('//ftoa(bulk_boundary_distance)//') IS TOO FAR FROM SURFACE BOUNDARY ('//ftoa(surface_distance)//'). WILL RECOMPUTE:')
!
   else !
    goto 999
   endif
   bulk_boundary_distance = -(__BULK_DISTANCE_SCALE)*abs(surface_distance)
   bulk_boundary_contour_value = __RHOSAFE(bulk_boundary_distance)
   if (qminimum_distance) then
    __MESSAGE(whoami, 'LOCATION OF BULK BOUNDARY SET TO '//ftoa(bulk_boundary_distance)//' A FROM PROTEIN.')
   else
    __MESSAGE(whoami, 'LOCATION OF BULK BOUNDARY SET TO '//ftoa(bulk_boundary_distance)//' A FROM PROTEIN. CONTOUR VALUE IS '//ftoa(bulk_boundary_contour_value))
   endif
 999  continue
  endif ! dasystat
#endif
!
! at this point, qforced_solv is wrong : it will be true everywhere, because surface distance was undefined (=0) in the calc. loop
! recompute qforced_solv :
  if (qminimum_distance) then
#ifdef __HAMILTONIAN
! no easy solution but to recompute the gradients, now that surface distance is known
   call __NM(compute_mindist_grad(.false.))
#else
   qforced_solv=dist_solv.lt.surface_distance ! vector operation
#endif
!============================================================
  else ! (NOT) qminimum_distance
#ifdef __HAMILTONIAN
! no easy solution but to recompute the gradients, now that surface distance is known
   call __NM(compute_density_grad(.false.))
#else
   qforced_solv=rho_solv.lt.surface_contour_value ! vector operation
#endif
  endif ! qminimum_distance
!====== NOTE : if we requested to run without neighbor lists then we need to reset solute_neighbor_mind to max
!====== otherwise, the early exit version of force routine could miss crucial atoms (the mind list is _not_ updated b/c qnlist=0)
!====== this is because solute_neighbor_mind is recomputed in a full loop, so it will be smaller than nsurf
#if defined(__NEIGHBOR_LIST) & defined(__SORT_LIST)
  if (.not. qneighbor_list) solute_neighbor_mind=nsurface_coord
#endif
!=========================================================================
 else ! compute approximate reference surface distance from coordinates
! NOTE :  this is the most time consuming part of the force calculation ; perhaps in time we can move it to the GPU ?
  if (qminimum_distance) then ! simple min-dist calculation
!
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
   if (full_sum_freq.gt.izero) then
! CHKUPDATE false : to truncate sum if running density value exceeds reference
! ALSO if qneighbor_list = false, this algorithm will be used, looping over all solute/surface indices
! because in that case, the maximum index in solute_neighbor_mdist is nsurface_coord
    call __NM(compute_mindist_grad)((.not.qneighbor_list) .or. (.not.__CHKUPDATE(full_sum_freq))) ! rechecked conditional 12.18 -- OK
! NOTE that it makes no sense to run full sum w/o neighbor sorting, which requires nbr. list !
   else
#endif
    call __NM(compute_mindist_grad)(.true.) ! always call quit-early version; however, the max. index will be set to nsurface_coord, so traverse full list
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
   endif ! full_sum_freq
#endif
!
  else ! original density-based (erf) calculation
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
   if (full_sum_freq.gt.izero) then
    call __NM(compute_density_grad)((.not.qneighbor_list) .or. (.not.__CHKUPDATE(full_sum_freq))) 
! as above for mindist
! truncate if running density value exceeds reference
   else
#endif
    call __NM(compute_density_grad)(.true.)
!
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST)
   endif
#endif
  endif ! qminimum_distance
! set surf changed flag
#if defined(__BAROSTAT) || defined (__DASYSTAT)
   if (&
#ifdef __BAROSTAT
&       barostat .or. &
#endif
#ifdef __DASYSTAT
&       dasystat .or. &
#endif
&       .false. ) surf_dist_changed=.true. ! we only need this variable for barostat/dasystat
#endif

 endif ! compute surface distance / contour value
!========================== compute contour value ^
#ifdef __DASYSTAT
#ifdef __BULK2_DISTANCE_SCALE
 if (dasystat .and. abs(bulk2_boundary_distance).lt.__ERRTOL ) then
! at this point surface_distance and bulk_distance are defined, so we can compute bulk2_dist.
  bulk2_boundary_distance = surface_distance + (__BULK2_DISTANCE_SCALE) * ( bulk_boundary_distance - surface_distance )
  bulk2_boundary_contour_value = __RHOSAFE(bulk2_boundary_distance)
 endif
#endif
#endif
!========================== compute forces :
! density_beyond_contour=zero ! useful ?
 surface_energy=zero
 surface_force=zero
 nsolvent_outside=izero
#ifdef __DASYSTAT
 solvent_mass_outside=zero
#endif
!
#ifdef __RMFT
 if (remove_net_torque) then
  ir1=zero ; ir2=zero; ir3=zero; ir1s=zero ; ir2s=zero ; ir3s=zero ; ir12=zero ; ir23=zero ; ir13=zero ;
  net_force=zero
  net_torque=zero
#ifdef __F_T_COUPLED
  A=zero
#endif
 endif
#endif
!
! if running a FD check, first save current forces, in case they are nonzero
#ifdef __FD_CHECK
 __DBGOUT('Allocate solvent arrays for FD check')
 __ALLOC(ffd2(3,nsolvent))
 ffd2=-fr(:,isolvent_atoms(:))
#endif
! simple minimum distance algorithm
! NOTE: here OPENMP does not make much difference but keeping for consistency and completeness
 if (qminimum_distance) then
#ifdef __OMP
!$omp parallel &
!$omp shared (dist_solv, ddist_solv, surface_distance, surface_force_constant, &
#ifdef __RMFT
!$omp remove_net_torque, net_force, net_torque, &
#ifdef __F_T_COUPLED
!$omp A, &
#endif
!$omp rhs, qforced_solv, r_com, &
!$omp ir1,ir2,ir3,ir1s,ir2s,ir3s,ir12,ir13,ir23, &
#endif
!$omp nsolvent, nsurface_coord, nsurface_atoms, nsolvent_outside, surface_force, surface_energy, &
#ifdef __DASYSTAT
!$omp solvent_mass_outside, mass_solv, &
#endif
!$omp isolvent_atoms, isurface_atoms, r_surf, r_solv, fr ) &
!$omp private (i, d0, pre, __U(nsolvent_outside), __U(surface_energy), __U(surface_force) &
#ifdef __DASYSTAT
!$omp , __U(solvent_mass_outside)  &
#endif
#ifdef __RMFT
!$omp ,ir, iforce, __U(net_force), __U(net_torque) &
!$omp ,__U(ir1),__U(ir2),__U(ir3),__U(ir1s),__U(ir2s),__U(ir3s),__U(ir12),__U(ir13),__U(ir23) &
#endif
!$omp )
 __U(surface_energy)=zero
 __U(surface_force)=zero
 __U(nsolvent_outside)=izero
#ifdef __DASYSTAT
 if (dasystat) __U(solvent_mass_outside)=zero
#endif
#ifdef __RMFT
  if (remove_net_torque) then
   __U(net_force)=zero
   __U(net_torque)=zero
   __U(ir1)=zero;__U(ir2)=zero;__U(ir3)=zero;__U(ir1s)=zero;__U(ir2s)=zero;__U(ir3s)=zero;__U(ir12)=zero;__U(ir13)=zero;__U(ir23)=zero
  endif
#endif
!
!$omp do schedule(runtime)
#endif
 do i=1, nsolvent
  if (qforced_solv(i)) then
   d0=dist_solv(i)
   __INC(__U(nsolvent_outside))
   pre = ( d0 - surface_distance ) ;
#ifdef __DASYSTAT
   if (dasystat) __INCR(__U(solvent_mass_outside), mass_solv(i))
#endif
!
#ifdef __RMFT
   if (remove_net_torque) then ! for now, here; optimize later, if needed
    ir=r_solv(:,i); ! removed r_com subtraction for extra flexibility ; to be accounted for later
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
!x
     __DECR(ir(1),r_pbc_reference(1))
     __PBCDIST(ir(1), ucell%a)
     __INCR(ir(1), r_pbc_reference(1))
!y
     __DECR(ir(2),r_pbc_reference(2))
     __PBCDIST(ir(2), ucell%b)
     __INCR(ir(2), r_pbc_reference(2))
!z
     __DECR(ir(3),r_pbc_reference(3))
     __PBCDIST(ir(3), ucell%c)
     __INCR(ir(3), r_pbc_reference(3))
    endif
#endif
!
#ifdef __TORQUE_FROM_FORCED_SOLVENT
    __UPDATE_TMAT_C
#endif
#ifdef __HAMILTONIAN
! prefactor already included in gradient
    iforce=ddist_solv(:,i)
#else
    iforce=surface_force_constant * pre / d0 * ddist_solv(:,i) ! re sign : note that surface_distance is negative
#endif
! set force
    __INCR(fr(1,isolvent_atoms(i)),iforce(1)) ;
    __INCR(fr(2,isolvent_atoms(i)),iforce(2)) ;
    __INCR(fr(3,isolvent_atoms(i)),iforce(3)) ;
! update net force & torque (torque missing COM contribution, to be added in later)
    __INCR(__U(net_force)(1),iforce(1))
    __INCR(__U(net_force)(2),iforce(2))
    __INCR(__U(net_force)(3),iforce(3))
    __INCR(__U(net_torque)(1), ir(2) * iforce(3) - ir(3) * iforce(2))
    __INCR(__U(net_torque)(2), ir(3) * iforce(1) - ir(1) * iforce(3))
    __INCR(__U(net_torque)(3), ir(1) * iforce(2) - ir(2) * iforce(1))
#if defined (__BAROSTAT) & defined (__FNORM)
    if (barostat) d0=norm3(iforce)
#endif
!
   else ! keep net force/torque
#endif
! just set the force
#ifndef __HAMILTONIAN
    d0=surface_force_constant * pre / d0
    __INCR(fr(1,isolvent_atoms(i)), d0 * ddist_solv(1,i))
    __INCR(fr(2,isolvent_atoms(i)), d0 * ddist_solv(2,i))
    __INCR(fr(3,isolvent_atoms(i)), d0 * ddist_solv(3,i))
#if defined (__BAROSTAT) & defined (__FNORM)
    if (barostat) d0=d0*norm3(ddist_solv(:,i))
#endif
#else
! prefactor already included in force
    __INCR(fr(1,isolvent_atoms(i)), ddist_solv(1,i))
    __INCR(fr(2,isolvent_atoms(i)), ddist_solv(2,i))
    __INCR(fr(3,isolvent_atoms(i)), ddist_solv(3,i))
#if defined (__BAROSTAT) & defined (__FNORM)
    if (barostat) d0=norm3(ddist_solv(:,i))
#endif
!
#endif
!
#ifdef __RMFT
   endif
#endif
! sum "energy"
! NOT clear how the surface energy is physically meaningful
#if defined(__BAROSTAT)
   if (barostat) &
#ifdef __FNORM
&   __INCR(__U(surface_force), d0) ! cumulative force magnitude
#else
!
#ifndef __HAMILTONIAN
&   __INCR(__U(surface_force), pre) ! x k, below
#else
&   __INCR(__U(surface_force), dist_solv(i)-surface_distance) ! x k, below
#endif
#endif
#endif
#ifndef __HAMILTONIAN
   __INCR(__U(surface_energy), pre**2) ! x k/2, below
#else
   __INCR(__U(surface_energy), (dist_solv(i)-surface_distance)**2) ! x k/2, below
#endif
  else ! distance check - atoms that are not forced
!
#ifdef __RMFT
   if (remove_net_torque) then ! for now, here; optimize later
#ifdef __TORQUE_FROM_FREE_SOLVENT
    ir=r_solv(:,i);
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
!x
     __DECR(ir(1),r_pbc_reference(1))
     __PBCDIST(ir(1), ucell%a)
     __INCR(ir(1), r_pbc_reference(1))
!y
     __DECR(ir(2),r_pbc_reference(2))
     __PBCDIST(ir(2), ucell%b)
     __INCR(ir(2), r_pbc_reference(2))
!z
     __DECR(ir(3),r_pbc_reference(3))
     __PBCDIST(ir(3), ucell%c)
     __INCR(ir(3), r_pbc_reference(3))
    endif
#endif
!
    __UPDATE_TMAT_C
#endif
   endif ! remove_net_torque
#endif
!   fr(:,isolvent_atoms(i))=zero ! make sure this is done somewhere
  endif ! distance check
 enddo ! nsolvent
#ifdef __OMP
!$omp end do
!$omp atomic
 __REDUCE(nsolvent_outside)
!$omp atomic
 __REDUCE(surface_energy)
#ifdef __BAROSTAT
if (barostat) then
!$omp atomic
 __REDUCE(surface_force)
endif
#endif
#ifdef __DASYSTAT
if (dasystat) then
!$omp atomic
 __REDUCE(solvent_mass_outside)
endif
#endif
#endif
!
#ifdef __FD_CHECK
 __DBGOUT('save forces before torque removal code')
! make sure torque removal forces do not contaminate shell the potential forces in the FD comparison :
#ifdef __OMP
!$omp do schedule(runtime)
#endif
 do i=1,nsolvent
  __INCR(ffd2(:,i), fr(:,isolvent_atoms(i))) ! ffd2 was set to -fr earlier
 enddo
#ifdef __OMP
!$omp end do
#endif
#endif
! code section for torque removal; sorry, not a subroutine, but repeated below, hence outside
#include "watershell_rmft_aux1.ftn"
!
#ifdef __OMP
!$omp end parallel
#endif
!
#ifdef __FD_CHECK
! FD test of shell potential
 __ALLOC(ffd(3,nsolvent))
  do i=1, nsolvent ; do j=1, 3
   ffd(j,i)=zero ! initialize
   d0=r_solv(j,i) ! save coordinate
   do ii=-1,1,2
    __INCR ( r_solv(j,i) , ii * h ) ! perturb
#if (_DBGLEV>1)
    __DBGOUT('calling compute_mindist_grad to compute forces by FD on coordinate', i, j)
#endif
#if defined(NEIGHBOR_LIST) && defined(SORT_LIST)
    call __NM(compute_mindist_grad)(.not.qneighbor_list) ! do not quit early
#else
    call __NM(compute_mindist_grad)(.true.)
#endif
! incorporate into FD
    __INCR  ( ffd(j,i), ii * (min(zero, dist_solv(i)-surface_distance))**2 ) ! recall that distance is negative, or inside shell
! restore coordinate
    r_solv(j,i)=d0
   enddo ! ii
  enddo ; enddo ! j, i
  __SCALE(ffd, - half * surface_force_constant / ( 2*h ) ) ! negative for force direction

#ifdef __DDEBUG
 write(700,*) iteration
 write(700,*) ffd(1,:)
 write(700,*) ffd2(1,isolvent_atoms(:))
 close(700)
#endif

   d0=sqrt(sum ( ffd(1,:)-ffd2(1,:) )**2 / nsolvent_outside)
   __WARN(whoami, ' ABSOLUTE RMS X-GRAD FD ERROR IN SOLVENT BOUNDARY POTENTIAL IS ', d0 )
   d0=d0/sqrt( sum ( ffd2(1,:) )**2 / nsolvent_outside )
   __WARN(whoami, ' RELATIVE RMS X-GRAD FD ERROR IN SOLVENT BOUNDARY POTENTIAL IS ', d0 )
!
   d0=sqrt(sum ( ffd(2,:)-ffd2(2,:) )**2 / nsolvent_outside)
   __WARN(whoami, ' ABSOLUTE RMS Y-GRAD FD ERROR IN SOLVENT BOUNDARY POTENTIAL IS ', d0 )
   d0=d0/sqrt( sum ( ffd2(2,:) )**2 / nsolvent_outside )
   __WARN(whoami, ' RELATIVE RMS Y-GRAD FD ERROR IN SOLVENT BOUNDARY POTENTIAL IS ', d0 )
!
   d0=sqrt(sum ( ffd(3,:)-ffd2(3,:) )**2 / nsolvent_outside)
   __WARN(whoami, ' ABSOLUTE RMS Z-GRAD FD ERROR IN SOLVENT BOUNDARY POTENTIAL IS ', d0 )
   d0=d0/sqrt( sum ( ffd2(3,:) )**2 / nsolvent_outside )
   __WARN(whoami, ' RELATIVE RMS Z-GRAD FD ERROR IN SOLVENT BOUNDARY POTENTIAL IS ', d0 )
!
  __FREE(ffd)
  __FREE(ffd2)
! at this point the distance and derivatives are computed with one coordinate off ; is there any need to recompute them correctly ? They do not seem to be used below.
#endif //__FD_CHECK
!
 else ! not qminimum_distance, i.e. original algorithm
  nsolvent_unsupported=0 ! for counting unsupported atoms in the erf density method
!================= original density based algorithm ==================
#ifdef __OMP
!$omp parallel &
!$omp shared (rho_solv, drho_solv, surface_contour_value, surface_distance, surface_force_constant, nsolvent_unsupported, &
#ifdef __LOGISTIC_INVERSE
!$omp logistic_constant, &
#endif
#ifdef __DASYSTAT
!$omp solvent_mass_outside, solvent_mass, &
#endif
#ifdef __HAMILTONIAN
!$omp drho_surf, &
#endif
#ifdef __RMFT
!$omp remove_net_torque, net_force, net_torque, &
#ifdef __F_T_COUPLED
!$omp A, &
#endif
!$omp rhs, qforced_solv, r_com, &
!$omp ir1,ir2,ir3,ir1s,ir2s,ir3s,ir12,ir13,ir23, &
#endif
!$omp nsolvent_outside, surface_force, surface_energy, isolvent_atoms, fr) & !!! , density_beyond_contour) &
!$omp private (i, d0, pre, __U(nsolvent_outside), __U(surface_energy), __U(surface_force) & !!! , __U(density_beyond_contour)) &
#if defined(__HAMILTONIAN) && !defined(__H_THREAD_REDUCE)
!$omp , ii &
#endif
#ifdef __DASYSTAT
!$omp , __U(solvent_mass_outside) &
#endif
#ifdef __RMFT
!$omp ,ir, iforce, __U(net_force), __U(net_torque) &
!$omp ,__U(ir1),__U(ir2),__U(ir3),__U(ir1s),__U(ir2s),__U(ir3s),__U(ir12),__U(ir13),__U(ir23) &
#endif
!$omp )
!
! __U(density_beyond_contour)=zero ! not clear whether useful
 __U(surface_energy)=zero
 __U(surface_force)=zero
 __U(nsolvent_outside)=izero
#ifdef __DASYSTAT
 __U(solvent_mass_outside)=zero
#endif
#ifdef __RMFT
  if (remove_net_torque) then
   __U(net_force)=zero
   __U(net_torque)=zero
   __U(ir1)=zero;__U(ir2)=zero;__U(ir3)=zero;__U(ir1s)=zero;__U(ir2s)=zero;__U(ir3s)=zero;__U(ir12)=zero;__U(ir13)=zero;__U(ir23)=zero
  endif
#endif

#ifdef __HAMILTONIAN
  if (structure_update_freq.gt.0) then 
   if (__CHKUPDATE(structure_update_freq)) then
! note : this is incorrect if dummy atoms are present !
!$omp do schedule(runtime)
   do i=1, nsurface_coord
#ifdef __H_THREAD_REDUCE
    __INCR(fr(1,isurface_atoms(i)),drho_surf(1,i,1)) ! note that the 1 array corresponds to the global sum on 0th thread (0th array is the inst support)
    __INCR(fr(2,isurface_atoms(i)),drho_surf(2,i,1))
    __INCR(fr(3,isurface_atoms(i)),drho_surf(3,i,1))
#else
! each thread sums up contributions previously computed by different threads
    do ii=1, 2*numthreads, 2
     __INCR(fr(1,isurface_atoms(i)),drho_surf(1,i,ii))
     __INCR(fr(2,isurface_atoms(i)),drho_surf(2,i,ii))
     __INCR(fr(3,isurface_atoms(i)),drho_surf(3,i,ii))
    enddo
#endif
   enddo
!$omp end do
  endif
  endif
#endif

!$omp do schedule(runtime)
#endif
 do i=1, nsolvent
  if ( qforced_solv(i) ) then
   __INC(__U(nsolvent_outside))
#ifdef __DASYSTAT
   if(dasystat) __INCR(__U(solvent_mass_outside), mass_solv(i))
#endif
   if ( rho_solv(i) .le. zero ) then ! proceed if the density is positive ; otherwise warn that we are outside of the support and cycle
! note that is is also possible that erf/exp approximations (or single precision calc) near zero densities will produce negative numbers, hence above
!    __WRN(whoami, '#'//itoa(iteration)//': SOLVENT ATOM '//itoa(isolvent_atoms(i))//' OUTSIDE OF SOLUTE SUPPORT. RESTART WITH A SMALLER SURFACE DISTANCE OR A LARGER FILTER CUTOFF OR PADDING.')
#ifdef __OMP
!$omp atomic update
#endif
    nsolvent_unsupported = nsolvent_unsupported + 1 ! openmp compiler cannot take __INC()
#ifdef __OMP
!$omp end atomic
#endif
    cycle
   endif
!   __INCR(__U(density_beyond_contour), rho_solv(i)) ! not clear whether useful
!
#ifndef __HAMILTONIAN
#ifdef __LOGISTIC_INVERSE
   d0=__OORHO( rho_solv(i)) ! unsafe inverse, but rho > 0 per above
#else
   d0=__Q(rho_solv(i))
#endif
   pre = ( __RHO_INVERSE2 ( d0 ) - surface_distance ) ;
! otherwise, already computed prefactor and absorbed into gradients
! What happens if we do not know surface distance going into the grad routine ? In that case, the computed prefactor will be wrong !
#endif
#if (_DBGLEV>1)
 __DBGOUT('solv. atom#:', i, 'density:', rho_solv(i), 'distance:', __RHO_INVERSE2(d0), 'forced?:', qforced_solv(i)
#ifndef __HAMILTONIAN
 , 'pre:', pre
#endif
 )
#endif
!
!
#ifdef __RMFT
   if (remove_net_torque) then ! for now, here; optimize later, if needed
    ir=r_solv(:,i); ! removed r_com subtraction for extra flexibility ; to be accounted for later
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
!x
     __DECR(ir(1),r_pbc_reference(1))
     __PBCDIST(ir(1), ucell%a)
     __INCR(ir(1), r_pbc_reference(1))
!y
     __DECR(ir(2),r_pbc_reference(2))
     __PBCDIST(ir(2), ucell%b)
     __INCR(ir(2), r_pbc_reference(2))
!z
     __DECR(ir(3),r_pbc_reference(3))
     __PBCDIST(ir(3), ucell%c)
     __INCR(ir(3), r_pbc_reference(3))
    endif
#endif
!
#ifdef __TORQUE_FROM_FORCED_SOLVENT
    __UPDATE_TMAT_C
#endif
!
! add atomic force
#ifdef __HAMILTONIAN
! derivative already includes force prefactor
    iforce = - drho_solv(:,i);
#else
#ifdef __LOGISTIC_INVERSE
    d0 = logistic_constant * d0 * ( one/(one-min(__RHO_MAX, rho_solv(i)))) ! derivative of the inverse of logistic function
#else
    d0 = surf_stdev * sq2pi * exp (d0**2) ! note that exp(d0^2) could be infinite ; unclear whether this will be a problem, since the gradients will be (almost) zero
#endif
    iforce = - surface_force_constant * pre * d0 * drho_solv(:,i) ! (-) because surface_distance is negative ; grad points toward protein
!   fr(:,isolvent_atoms(i)) = - surface_force_constant * pre * d0 * drho_solv(:,i) ! (-) because surface_distance is negative ; grad points toward protein
#endif
    __INCR(fr(1,isolvent_atoms(i)),iforce(1))
    __INCR(fr(2,isolvent_atoms(i)),iforce(2))
    __INCR(fr(3,isolvent_atoms(i)),iforce(3))
! update net force & torque (torque missing COM contribution, to be added in later)
    __INCR(__U(net_force)(1),iforce(1))
    __INCR(__U(net_force)(2),iforce(2))
    __INCR(__U(net_force)(3),iforce(3))
    __INCR(__U(net_torque)(1), ir(2) * iforce(3) - ir(3) * iforce(2))
    __INCR(__U(net_torque)(2), ir(3) * iforce(1) - ir(1) * iforce(3))
    __INCR(__U(net_torque)(3), ir(1) * iforce(2) - ir(2) * iforce(1))
#ifdef __BAROSTAT
    d0=norm3(iforce)
#endif
   else ! keep net force/torque
#endif
#ifndef __HAMILTONIAN
#ifdef __LOGISTIC_INVERSE
    d0 = logistic_constant * d0 * ( one/(one-min(__RHO_MAX, rho_solv(i))))
#else
    d0 = surf_stdev * sq2pi * exp (d0**2)
#endif
    d0 = - surface_force_constant * pre * d0
    __INCR(fr(1,isolvent_atoms(i)), d0 * drho_solv(1,i))
    __INCR(fr(2,isolvent_atoms(i)), d0 * drho_solv(2,i))
    __INCR(fr(3,isolvent_atoms(i)), d0 * drho_solv(3,i))
#ifdef __BAROSTAT
    d0=d0*norm3(drho_solv(:,i))
#endif
#else
! derivative already includes force prefactor
    __DECR(fr(1,isolvent_atoms(i)), drho_solv(1,i))
    __DECR(fr(2,isolvent_atoms(i)), drho_solv(2,i))
    __DECR(fr(3,isolvent_atoms(i)), drho_solv(3,i))
#ifdef __BAROSTAT
    d0=norm3(drho_solv(:,i))
#endif
#endif
!
#ifdef __RMFT
   endif
#endif

! sum "energy"
! NOT clear whether the surface_energy is physically meaningful
! surface force is used for pressure calculations (but only if barostat is on !)
#ifdef __BAROSTAT
   __INCR(__U(surface_force), d0) ! actual force magnitude
#endif
#ifndef __HAMILTONIAN
   __INCR(__U(surface_energy), pre**2) ! x k/2, below
#else
   __INCR(__U(surface_energy), (__RHO_INVERSE(rho_solv(i)) - surface_distance)**2) ! x k/2, below
#endif
  else ! for atoms that are not forced
#ifdef __RMFT
#ifdef __TORQUE_FROM_FREE_SOLVENT
   if (remove_net_torque) then ! for now, here; optimize later
    ir=r_solv(:,i);
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
!x
     __DECR(ir(1),r_pbc_reference(1))
     __PBCDIST(ir(1), ucell%a)
     __INCR(ir(1), r_pbc_reference(1))
!y
     __DECR(ir(2),r_pbc_reference(2))
     __PBCDIST(ir(2), ucell%b)
     __INCR(ir(2), r_pbc_reference(2))
!z
     __DECR(ir(3),r_pbc_reference(3))
     __PBCDIST(ir(3), ucell%c)
     __INCR(ir(3), r_pbc_reference(3))
    endif
#endif
!
    __UPDATE_TMAT_C
   endif ! remove_net_torque
#endif
#endif
!   fr(:,isolvent_atoms(i))=zero ! make sure this gets done somewhere
  endif ! density check
 enddo ! nsolvent
#ifdef __OMP
!$omp end do
!$omp atomic
  __REDUCE(nsolvent_outside)
!$omp atomic
  __REDUCE(surface_energy)
#ifdef __BAROSTAT
if (barostat) then
!$omp atomic
  __REDUCE(surface_force)
endif
#endif
!  __REDUCE(density_beyond_contour) ! not clear if useful
#ifdef __DASYSTAT
if (dasystat) then
!$omp atomic
 __REDUCE(solvent_mass_outside)
endif
#endif // __DASYSTAT
#endif // __OMP
!
#ifdef __FD_CHECK
! make sure torque removal forces do not contaminate shell the potential forces in the FD comparison :
#ifdef __OMP
!$omp do schedule(runtime)
#endif
 do i=1,nsolvent
  __INCR(ffd2(:,i), fr(:,isolvent_atoms(i))) ! ffd2 was set to -fr earlier
 enddo
#ifdef __OMP
!$omp end do
#endif
#endif //__FD_CHECK
!
#include "watershell_rmft_aux1.ftn"
#ifdef __OMP
!$omp end parallel
#endif
!
#ifdef __FD_CHECK
! FD test of shell potential
 __ALLOC(ffd(3,nsolvent))
  do i=1, nsolvent ; do j=1, 3
   ffd(j,i)=zero ! initialize
   d0=r_solv(j,i) ! save coordinate
   do ii=-1,1,2
    __INCR ( r_solv(j,i) , ii * h ) ! perturb
#if defined(NEIGHBOR_LIST) && defined(SORT_LIST)
    call __NM(compute_density_grad)(.not.qneighbor_list)
#else
    call __NM(compute_density_grad)(.true.)
#endif
! incorporate into FD
    __INCR ( ffd(j,i), ii * min(zero, (__RHO_INVERSE(rho_solv(i))-surface_distance))**2 ) ! recall that distance is negative, or inside shell
! restore coordinate
    r_solv(j,i)=d0
   enddo ! ii
  enddo ; enddo ! j, i
  __SCALE(ffd, - half * surface_force_constant / ( 2*h ) ) ! negative for force direction

#ifdef __DEBUG
 write(800,*) iteration
 write(800,*) ffd(1,:)
 write(800,*) ffd2(1,isurface_atoms(:))
 close(800)
#endif

   d0=sqrt(sum ( ffd(1,:)-ffd2(1,:) )**2 / nsolvent_outside)
   __WARN(whoami, ' ABSOLUTE RMS X-GRAD FD ERROR IN SOLVENT BOUNDARY POTENTIAL IS ', d0 )
   d0=d0/sqrt( sum ( ffd2(1,:) )**2 / nsolvent_outside )
   __WARN(whoami, ' RELATIVE RMS X-GRAD FD ERROR IN SOLVENT BOUNDARY POTENTIAL IS ', d0 )
!
   d0=sqrt(sum ( ffd(2,:)-ffd2(2,:) )**2 / nsolvent_outside)
   __WARN(whoami, ' ABSOLUTE RMS Y-GRAD FD ERROR IN SOLVENT BOUNDARY POTENTIAL IS ', d0 )
   d0=d0/sqrt( sum ( ffd2(2,:) )**2 / nsolvent_outside )
   __WARN(whoami, ' RELATIVE RMS Y-GRAD FD ERROR IN SOLVENT BOUNDARY POTENTIAL IS ', d0 )
!
   d0=sqrt(sum ( ffd(3,:)-ffd2(3,:) )**2 / nsolvent_outside)
   __WARN(whoami, ' ABSOLUTE RMS Z-GRAD FD ERROR IN SOLVENT BOUNDARY POTENTIAL IS ', d0 )
   d0=d0/sqrt( sum ( ffd2(3,:) )**2 / nsolvent_outside )
   __WARN(whoami, ' RELATIVE RMS Z-GRAD FD ERROR IN SOLVENT BOUNDARY POTENTIAL IS ', d0 )
!
  __FREE(ffd)
  __FREE(ffd2)
! at this point the distance and derivatives are computed with one coordinate off ; is there any need to recompute them correctly ? They do not seem to be used below.
#endif //__FD_CHECK
!
!
  if (nsolvent_unsupported.gt.0) then
#ifdef __ADAPTIVE_SUPPORT
#ifdef __ADAPTIVE_CUTOFF
   __WRN(whoami, 'DETECTED '//itoa(nsolvent_unsupported)//' ATOM(S) OUTSIDE SOLUTE SUPPORT. DENSITY CUTOFF IS '//ftoa(cutoff_surf));
! increase cutoff adaptively
   __INCR(cutoff_surf, solvent_support_factor_grow)
  else
   if (cutoff_surf.gt.cutoff_surf_stdev*surf_stdev) then 
    __INCR(cutoff_surf, solvent_support_factor_shrink)
   endif
#else
   __WRN(whoami, 'DETECTED '//itoa(nsolvent_unsupported)//' ATOM(S) OUTSIDE SOLUTE SUPPORT. SURFACE PADDING IS '//ftoa(surf_padding));
! increase padding adaptively
   __INCR(surf_padding, solvent_support_factor_grow)
  else
   if (surf_padding.gt.surf_padding_input) then
    __INCR(surf_padding, solvent_support_factor_shrink)
   else
    surf_padding=surf_padding_input
   endif
#endif
#else
   __WRN(whoami, 'DETECTED '//itoa(nsolvent_unsupported)//' ATOM(S) OUTSIDE SOLUTE SUPPORT. RESTART WITH A LARGER CUTOFF OR SURFACE PADDING.')
#endif
  endif
!
! NOTE: check below to make sure consistent for erf/density ; yes it is;
! NOTE: just notes, nocode
#ifdef __LOGISTIC_INVERSE
! we are using the boundary potential : k/2 x [ L^-1 (rho) - d0 ] ^ 2 ;
! d0 is the quasi-distance to boundary
! L^-1(rho) is the logistic function approximant
! are the forces on the body are still k ( L^-1(rho) - d0 ) ? NO, because d (d0) / d(r) is not 1 !
! but if k is large, then d0 is very close to L^-1(rho) and d d0/dr ~= |grad_r L^-1 (rho)| (which is the norm of the forces, as you might expect !)
! the forces on the atoms are obtained by differentiation w.r.t position (x) :
! F(x) = - k ( L^-1(rho) - d0 ) * logistic_const / (1-L) / L * grad (rho)
#endif
 endif ! qminimum_dist

 if (nsolvent_outside .gt. 0) then
  oonsolvent_outside=one/nsolvent_outside
 else
  oonsolvent_outside=zero ;
 endif
!
#if defined(__BAROSTAT) & !defined(__FNORM)
 if (qminimum_distance) __SCALE(surface_force, -surface_force_constant) ! negative because of sign convention
#endif
 __SCALE(surface_energy, half*surface_force_constant)
!
 if (present(energy)) then
  __INCR(energy,surface_energy)
 endif
!
#ifdef __BAROSTAT
! barostat-related code :
! ==========================================================================================
 if (barostat) then
!== compute/update pressure :
  if (pressure_update_freq.gt.0) then
   if __CHKUPDATE(pressure_update_freq) then
!
 __DBGVAR(r_surf_changed,1)
 __DBGVAR(surface_area_compute_freq,1)
 __DBGVAR(pressure_update_freq,1)
 __DBGVAR(iteration,1)
 __DBGVAR(__CHKUPDATE(surface_area_compute_freq*pressure_update_freq),1)
!== first, compute surface area :
    if (((r_surf_changed.or.surf_dist_changed).and.surface_area_compute_freq.gt.0).or.surface_area<zero) then ! note : a check to only recompute SA if surface atoms changed
     if (__CHKUPDATE(surface_area_compute_freq*pressure_update_freq) .or. surface_area<zero) then
! check periodicity flag
      __PRESENT(qper,qper_parser_override)
      if (qper.neqv.qper_parser_override) then
       __WRN(whoami, 'CANNOT CHANGE PERIODICITY FLAG DURING DYNAMICS WITH WATERSHELL BAROSTAT. INITIAL :'//ltoa(qper_parser_override)//', CURRENT :'//ltoa(qper))
      elseif (qper) then ! check that mdcell, if passed in, did not change
       if (present(mdcell)) then
        if &
&        ((abs(mdcell%a - sagrid%lengths(1)) .gt. __ERRTOL) .or. &
&         (abs(mdcell%b - sagrid%lengths(2)) .gt. __ERRTOL) .or. &
&         (abs(mdcell%c - sagrid%lengths(3)) .gt. __ERRTOL)) then
          __WRN(whoami, 'CANNOT CHANGE UNIT CELL DIMENSIONS DURING DYNAMICS WITH WATERSHELL BAROSTAT.')
          __ASSERT(abs(mdcell%a - sagrid%lengths(1)),<, __ERRTOL)
          __ASSERT(abs(mdcell%b - sagrid%lengths(2)),<, __ERRTOL)
          __ASSERT(abs(mdcell%c - sagrid%lengths(3)),<, __ERRTOL)
        endif
       endif
      endif ! qper
#if defined(__RMFT) && defined(__TORQUE_COM_SURFACE)
      if (remove_net_torque) then
       r_com_sa=r_com
      else
       r_com_sa=oonsurface * sum(r_surf,2)
      endif
#else
      r_com_sa=oonsurface * sum(r_surf,2)
#endif
! check that grid dimensions are still adequate : 
      if (.not.qper_parser_override.and.surface_area_grid_check_freq.gt.0) then
       if __CHKUPDATE(surface_area_grid_check_freq*surface_area_compute_freq*pressure_update_freq) then
!
        r_surf_minmax(1,1) = minval(r_surf(1,:)-rad_surf) - r_com_sa(1) - ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
        r_surf_minmax(2,1) = maxval(r_surf(1,:)+rad_surf) - r_com_sa(1) + ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
!
        r_surf_minmax(1,2) = minval(r_surf(2,:)-rad_surf) - r_com_sa(2) - ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
        r_surf_minmax(2,2) = maxval(r_surf(2,:)+rad_surf) - r_com_sa(2) + ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
!
        r_surf_minmax(1,3) = minval(r_surf(3,:)-rad_surf) - r_com_sa(3) - ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
        r_surf_minmax(2,3) = maxval(r_surf(3,:)+rad_surf) - r_com_sa(3) + ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
!
        if (any(abs(r_surf_minmax(2,:) - r_surf_minmax(1,:) - sagrid%lengths).gt.surface_area_grid_recompute_change)) then
         __MESSAGE(whoami, 'REINITIALIZING SURFACE AREA COMPUTATION GRID.');
         call ugrid_finalize(sagrid)
         call ugrid_initialize(sagrid, 3, r_surf_minmax, (/surface_area_grid_spacing/), adjust_spacings_=.false.)
!
#ifdef __DEBUG
         __DBGVAR(sagrid%n,1)
         write(666,'(2G20.10)') r_surf_minmax
         write(666,*) sagrid%initialized
         write(666,*) sagrid%ndim
         write(666,*) sagrid%n
         close(666)
#endif
!
          if (qminimum_distance) then
#ifdef __OMP
           __DEALL(sarho_all_threads)
           allocate(sarho_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:numthreads-1))
#else
          __DEALL(sarho)
           allocate(sarho(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#endif
          else
#ifdef __OMP
           __DEALL(sarhof_all_threads)
           allocate(sarhof_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:numthreads-1))
#else
          __DEALL(sarhof)
           allocate(sarhof(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#endif
          endif
!
        endif
       endif
      endif
! compute SA
      if (qminimum_distance) then
       call __NM(compute_surface_area_mindist)()
      else
       call __NM(compute_surface_area)()
      endif ! mindist
!
      r_surf_changed=.false.
      surf_dist_changed=.false.
!
     endif ! chkupdate
    endif ! surface area compute
!
    pressure = surface_force/surface_area * atm_per_akma ! note that for code generality this would have to be made nondimensional
__DBGVAR(surface_force,1)
__DBGVAR(surface_area,1)
__DBGVAR(akma_per_pa,1)
__DBGVAR(akma_per_atm,1)
__DBGVAR(atm_per_akma,1)
__DBGVAR(pressure,1)
__DBGVAR(pressure_ave,1)
!
! update running average
    if (pressure_num_samples < pressure_max_samples) __INC(pressure_num_samples)
    d0=1d0/pressure_num_samples
     __INCR(pressure_ave, d0 * (pressure - pressure_ave))
! repeat for long-time average pressure
    if (pressure_num_long_samples<pressure_max_long_samples) __INC(pressure_num_long_samples)
    d0=1d0/pressure_num_long_samples
     __INCR(pressure_long_ave, d0 * (pressure - pressure_long_ave))
   endif ! chkupdate
  endif ! pressure update
!
!=========================== evolve/update contour/distance value
  if (distance_update_freq.gt.0) then
! NOTE : it might happen that we did not yet compute the pressure; in this case, pressure_ave is unphysical ; unclear what to do in this case
! we could disallow negative pressures (which are unphysical, but could be useful in a controller) ; then could use pressure<0 as a flag, as done in the density case
   if __CHKUPDATE(distance_update_freq) then
!
! note that when the pressure is lower than the target pressure (NB: we technically cannot get below zero pressure because of the type of potential)
! the code will most likely adjust it up very slowly (since the pressures in question are quite small - e.g. 1 atm) ; in such cases, we should have a faster
! method of adjustment
!
    if (abs(distance_update_step).gt.0) then
#ifdef __PDIRECT
     d0 = ( pressure_target - pressure_ave )
#else
! a more gentle evolution, based loosely on the hypothesis that PV ~= const
! need to protect against large divide by zero
!    d0 = ( one/pressure_ave - one/pressure_target )
     d0 = ( one/max(__ERRTOL,pressure_ave) - oopressure_target )
#endif
!  limit large changes for stability, e.g.
     d0 = sign( min(one, abs(d0)), d0 );
     if (qminimum_distance .or. (surface_distance.gt.__MINSURFDIST) .or. (d0.gt.zero)) then
      __INCR(surface_distance, distance_update_step * d0) ! note that surface_distance < 0 in our notation ; so too high p => dist decr.
      surf_dist_changed=.true.
! check to make sure the distance is not too large; if so, warn and limit
      if (.not. qminimum_distance .and. surface_distance .lt. __MINSURFDIST) then
       __WRN(whoami, 'SHELL SURFACE DISTANCE HAS REACHED LOWEST ALLOWED VALUE ('//ftoa(__MINSURFDIST)//'). RESTART WITH INCREASED CUTOFF OR PADDING')
       surface_distance = __MINSURFDIST
      endif
      surface_contour_value = __RHOSAFE(surface_distance)
     else
      __WRN(whoami, 'SHELL SURFACE DISTANCE HAS REACHED LOWEST ALLOWED VALUE ('//ftoa(__MINSURFDIST)//'). RESTART WITH INCREASED CUTOFF OR PADDING')
     endif
 __DBGVAR(distance_update_step * d0, 1)
 __DBGVAR(surface_distance, 1)
 __DBGVAR(surface_contour_value, 1)
    endif
   endif
  endif
 endif ! barostat-related
! BAROSTAT-RELATED CODE ^
#endif
! ==========================================================================================
#ifdef __DASYSTAT
! DASYSTAT-RELATED CODE v (much overlap with barostat code, but otherwise too complicated to follow if intermingled with barostat)
 if (dasystat) then
!== compute/update density :
  if (density_update_freq.gt.0) then
   if __CHKUPDATE(density_update_freq) then
!
 __DBGVAR(r_surf_changed,1)
 __DBGVAR(surface_area_compute_freq,1)
 __DBGVAR(density_update_freq,1)
 __DBGVAR(iteration,1)
 __DBGVAR(__CHKUPDATE(surface_area_compute_freq*density_update_freq),1)
!== first, compute volume :
    if (((r_surf_changed.or.surf_dist_changed).and.surface_area_compute_freq.gt.0).or.volume_bulk<zero) then ! note : a check to only recompute SA if surface atoms changed
     if (__CHKUPDATE(surface_area_compute_freq*density_update_freq).or.volume_bulk<zero) then
! check periodicity flag
      __PRESENT(qper,qper_parser_override)
      if (qper.neqv.qper_parser_override) then
       __WRN(whoami, 'CANNOT CHANGE PERIODICITY FLAG DURING DYNAMICS WITH WATERSHELL DASYSTAT. INITIAL :'//ltoa(qper_parser_override)//', CURRENT :'//ltoa(qper))
      elseif (qper) then ! check that mdcell, if passed in, did not change
       if (present(mdcell)) then
        if &
&        ((abs(mdcell%a - sagrid%lengths(1)) .gt. __ERRTOL) .or. &
&         (abs(mdcell%b - sagrid%lengths(2)) .gt. __ERRTOL) .or. &
&         (abs(mdcell%c - sagrid%lengths(3)) .gt. __ERRTOL)) then
          __WRN(whoami, 'CANNOT CHANGE UNIT CELL DIMENSIONS DURING DYNAMICS WITH WATERSHELL DASYSTAT.')
          __ASSERT(abs(mdcell%a - sagrid%lengths(1)),<, __ERRTOL)
          __ASSERT(abs(mdcell%b - sagrid%lengths(2)),<, __ERRTOL)
          __ASSERT(abs(mdcell%c - sagrid%lengths(3)),<, __ERRTOL)
        endif
       endif
      endif ! qper
#if defined(__RMFT) && defined(__TORQUE_COM_SURFACE)
      if (remove_net_torque) then
       r_com_sa=r_com
      else
       r_com_sa=oonsurface * sum(r_surf,2)
      endif
#else
      r_com_sa=oonsurface * sum(r_surf,2)
#endif
! check that grid dimensions are still adequate : 
      if (.not.qper_parser_override.and.surface_area_grid_check_freq.gt.0) then
       if __CHKUPDATE(surface_area_grid_check_freq*surface_area_compute_freq*density_update_freq) then
!
!        r_surf_minmax(1,:) = minval(r_surf,2) - r_com_sa - (abs(surface_distance)+surface_area_grid_buffer)
!        r_surf_minmax(2,:) = maxval(r_surf,2) - r_com_sa + (abs(surface_distance)+surface_area_grid_buffer)
!
        r_surf_minmax(1,1) = minval(r_surf(1,:)-rad_surf) - r_com_sa(1) - ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
        r_surf_minmax(2,1) = maxval(r_surf(1,:)+rad_surf) - r_com_sa(1) + ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
!
        r_surf_minmax(1,2) = minval(r_surf(2,:)-rad_surf) - r_com_sa(2) - ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
        r_surf_minmax(2,2) = maxval(r_surf(2,:)+rad_surf) - r_com_sa(2) + ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
!
        r_surf_minmax(1,3) = minval(r_surf(3,:)-rad_surf) - r_com_sa(3) - ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
        r_surf_minmax(2,3) = maxval(r_surf(3,:)+rad_surf) - r_com_sa(3) + ( abs(surface_distance) + surface_area_grid_buffer + surf_padding)
!
        if (any(abs(r_surf_minmax(2,:) - r_surf_minmax(1,:) - sagrid%lengths).gt.surface_area_grid_recompute_change)) then
         __MESSAGE(whoami, 'REINITIALIZING VOLUME COMPUTATION GRID.');
         call ugrid_finalize(sagrid)
         call ugrid_initialize(sagrid, 3, r_surf_minmax, (/surface_area_grid_spacing/), adjust_spacings_=.false.)
!
         __DBGVAR(sagrid%n,1)
         __DBGVAR(r_surf_minmax,1)
         __DBGVAR(sagrid%initialized,1)
         __DBGVAR(sagrid%n,1)
!
         if (qminimum_distance) then
#ifdef __OMP
          __DEALL(sarho_all_threads)
          allocate(sarho_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:numthreads-1))
          __DEALL(inrho_all_threads)
          allocate(inrho_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:numthreads-1))
#else
          __DEALL(sarho)
          allocate(sarho(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
          __DEALL(inrho)
          allocate(inrho(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#endif
         else
#ifdef __OMP
          __DEALL(sarhof_all_threads)
          allocate(sarhof_all_threads(sagrid%n(1),sagrid%n(2),sagrid%n(3),0:numthreads-1))
#else
          __DEALL(sarhof)
          allocate(sarhof(sagrid%n(1),sagrid%n(2),sagrid%n(3)))
#endif
         endif
        endif ! reallocate
       endif ! grid size check
      endif ! grid size check
! compute volume
      if (qminimum_distance) then
       call __NM(compute_bulk_volume_mindist)()
      else
       call __NM(compute_bulk_volume)()
      endif ! mindist
!
  __DBGVAR(volume_bulk,1)
!
      r_surf_changed=.false.
      surf_dist_changed=.false.
!
     endif ! chkupdate area compute
    endif ! surface area/volume compute
!
#ifdef __BULK2_DISTANCE_SCALE
    density = (solvent_mass_bulk - solvent_mass_nonbulk)/volume_bulk*gml_per_akma
#else
    density = (solvent_mass - (solvent_mass_nonbulk + solvent_mass_outside))/volume_bulk*gml_per_akma ! note that for code generality this would have to be made nondimensional
#endif
! to keep outside mass :
!    density = (solvent_mass - (solvent_mass_nonbulk))/volume_bulk*gml_per_akma ! note that for code generality this would have to be made nondimensional
__DBGVAR(surface_distance,1)
__DBGVAR(bulk_boundary_distance,1)
#ifdef __BULK2_DISTANCE_SCALE
__DBGVAR(bulk2_boundary_distance,1)
#endif
__DBGVAR(solvent_mass,1)
__DBGVAR(solvent_mass_nonbulk,1)
__DBGVAR(solvent_mass_outside,1)
__DBGVAR(volume_bulk,1)
__DBGVAR(gml_per_akma,1)
__DBGVAR(density,1)
__DBGVAR(density_ave,1)
__DBGVAR(density_target,1)
!
! update running average
    if (density_num_samples .lt. density_max_samples) __INC(density_num_samples)
    d0=1d0/density_num_samples
     __INCR(density_ave, d0 * (density - density_ave))
   endif ! chkupdate
  endif ! density update
!
!=========================== evolve/update contour/distance value
  __DBGVAR(distance_update_freq,1)
  __DBGVAR(distance_update_step,1)
  if (distance_update_freq.gt.0) then
! NOTE : in the current code it might happen that we did not yet compute the density (if done infrequently); in that case d<0
   if (__CHKUPDATE(distance_update_freq) .and. density_ave>zero) then
    if (abs(distance_update_step).gt.zero) then
     d0 = ( density_target - density_ave )
     if (qminimum_distance .or. (surface_distance.gt.__MINSURFDIST) .or. (d0.gt.zero)) then
      __INCR(surface_distance, d0 * distance_update_step) ! note that surface_distance < 0 in our notation ; so too high p => dist decr.
      surf_dist_changed=.true.
! check to make sure the distance is not too large; if so, warn and limit (same as barostat code)
      if (.not. qminimum_distance .and. surface_distance .lt. __MINSURFDIST) then
       __WRN(whoami, 'SHELL SURFACE DISTANCE HAS REACHED LOWEST ALLOWED VALUE ('//ftoa(__MINSURFDIST)//'). RESTART WITH INCREASED CUTOFF OR PADDING')
       surface_distance = __MINSURFDIST
      endif
      surface_contour_value = __RHOSAFE(surface_distance)
     else
      __WRN(whoami, 'SHELL SURFACE DISTANCE HAS REACHED LOWEST ALLOWED VALUE ('//ftoa(__MINSURFDIST)//'). RESTART WITH INCREASED CUTOFF OR PADDING')
     endif
    endif
   endif
!
   __DBGVAR(surface_distance,1)
   __DBGVAR(surface_contour_value,1)
!
! make sure that the bulk boundary is not too close to the surface to obtain an accurate density
   if( qbulk_boundary_recompute ) then
    if ((abs(surface_distance) - abs(bulk_boundary_distance)) .lt. &
&    ( __BULK_BOUNDARY_RECOMPUTE_FACTOR * abs(surface_distance) ) ) then ! recompute bulk_bdry
    __MESSAGE(whoami, 'BULK BOUNDARY ('//ftoa(bulk_boundary_distance)//') IS TOO CLOSE TO SURFACE BOUNDARY ('//ftoa(surface_distance)//'). WILL RECOMPUTE:')
!
    elseif( (abs(surface_distance) - abs(bulk_boundary_distance)) .gt. &
&    ( ( 2*(one-(__BULK_DISTANCE_SCALE)) - __BULK_BOUNDARY_RECOMPUTE_FACTOR) * abs(surface_distance) ) ) then ! recompute bulk_bdry
    __MESSAGE(whoami, 'BULK BOUNDARY ('//ftoa(bulk_boundary_distance)//') IS TOO FAR FROM SURFACE BOUNDARY ('//ftoa(surface_distance)//'). WILL RECOMPUTE:')
    else !
     goto 998
    endif ! bulk_bdry distance
    bulk_boundary_distance = -(__BULK_DISTANCE_SCALE)*abs(surface_distance)
    bulk_boundary_contour_value = __RHOSAFE(bulk_boundary_distance)
    if (qminimum_distance) then
     __MESSAGE(whoami, 'LOCATION OF BULK BOUNDARY SET TO '//ftoa(bulk_boundary_distance)//' A FROM PROTEIN.')
    else
     __MESSAGE(whoami, 'LOCATION OF BULK BOUNDARY SET TO '//ftoa(bulk_boundary_distance)//' A FROM PROTEIN. CONTOUR VALUE IS '//ftoa(bulk_boundary_contour_value))
    endif
#ifdef __BULK2_DISTANCE_SCALE
    bulk2_boundary_distance = surface_distance + (__BULK2_DISTANCE_SCALE) * ( bulk_boundary_distance - surface_distance )
    bulk2_boundary_contour_value = __RHOSAFE(bulk2_boundary_distance)
#endif
 998  continue
   endif ! qbulk_recompute
  endif ! distance update
 endif ! dasystat-related
#endif
!============================================= output restart file
 if (output_freq.gt.0) then
  if __CHKUPDATE(output_freq) then
! write a short update of simulation parameters:
  i=0 ;
#define __OUT(...)  __INC(i);write(_MSGBUF(i),*) __VA_ARGS__
#define _TAB char(9)//char(9)
  __OUT('==========================================================================================')
  __OUT('Iteration:', iteration)
  __OUT('Target distance to protein:      ', surface_distance)
! this needs to be computed here, because we do not need it at every step:
  if (qminimum_distance) then
   current_surface_distance = SUM(dist_solv, MASK = (qforced_solv.eqv..true.))*oonsolvent_outside
  else
#ifdef __LOGISTIC_INVERSE
   current_surface_distance = SUM (__RHO_INVSAFE(rho_solv), MASK = (qforced_solv.eqv..true.))*oonsolvent_outside
#else
! cannot use vector operation since a function is involved
   current_surface_distance=zero
   do ii=1, nsolvent
    if (qforced_solv(ii)) then
     __INCR(current_surface_distance , __RHO_INVSAFE(rho_solv(ii)))
    endif
   enddo
   __SCALE(current_surface_distance, oonsolvent_outside)
#endif
  endif
!
  __OUT('Current avg. distance to protein:', current_surface_distance)
  __OUT('Surface energy:                  ', surface_energy)
  __OUT('# Solute atoms used for density: ', nsurface_atoms)
#ifdef __DUMSURF
  if (qdumsurf) __OUT('# Fixed dummy atoms used for density: ', nsurface_coord)
#endif
  __OUT('# Solvent atoms outside / total: ', nsolvent_outside,'/',nsolvent)
  if (.not. qminimum_distance) then ! not relevant to mindist algorithm
  __OUT('Surface contour value:           ', surface_contour_value)
  endif

#ifdef __FORCE_STATS
  total_solute_force=zero
  total_solvent_force=zero
  max_solute_force=zero
  max_solvent_force=zero
  rms_solute_force=zero
  rms_solvent_force=zero
!
  do ii=1, nsurface_atoms
   iforce=fr(:,isurface_atoms(ii))
   __INCR(total_solute_force, iforce)
   d0=iforce(1)**2 + iforce(2)**2 + iforce(3)**2
   __INCR(rms_solute_force, d0)
   max_solute_force=max(max_solute_force,d0)
  enddo
  do ii=1, nsolvent
   iforce=fr(:,isolvent_atoms(ii))
   __INCR(total_solvent_force, iforce)
   d0=iforce(1)**2 + iforce(2)**2 + iforce(3)**2
   __INCR(rms_solvent_force, d0)
   max_solvent_force=max(max_solvent_force,d0)
  enddo
   __OUT('======= FORCE STATISTICS =======')
   __OUT('Total force applied to surface atoms:  ', total_solute_force)
   __OUT('RMS of surface atom forces:            ', sqrt(rms_solute_force*oonsurface))
   __OUT('Largest force acting on a surface atom:', sqrt(max_solute_force))
   __OUT('Total force applied to solvent atoms:  ', total_solvent_force)
   __OUT('RMS of solvent atom forces:            ', sqrt(rms_solvent_force*oonsolvent) )
   __OUT('Largest force acting on a solvent atom:', sqrt(max_solvent_force))
#endif
!
#if defined(__SHOW_TORQUE) && defined(__RMFT)
  if (remove_net_torque) then
   __OUT('Total force applied to system:      ', net_force)
   __OUT('Total torque applied to system:     ', net_torque)
!
   __OUT('Corrective force applied to system: ', -net_force_ave)
   __OUT('Corrective torque applied to system:', -net_torque_ave)
  endif
#endif
!
#ifdef __ROTRES
  if (qrigid_body_restraint) then
#ifdef __OBSOLETE
! compute energy here, since this will happen rarely
! note that the dot product version is not accurate in single prec. produces negative energies, not sure why.
   rigid_body_energy=zero
   if ( abs(rigid_body_force_constant).gt.__ERRTOL) then
    do ii=1, nsurface_atoms
! line below is inaccurate in single precision, not sure why !
!     __INCR(rigid_body_energy, dot_product( dr_surf(:,ii), matmul(A_rb,r_surf_ref(:,ii))) )
     __INCR(rigid_body_energy, sum( dr_surf(:,ii) * matmul(A_rb,r_surf_ref(:,ii))) )
    enddo
   __OUT('Rotational restraint energy:        ', rigid_body_energy)
! translational component is accurate :
    d0=nsurface_atoms**2 * dot_product(dcom, dcom) / (rigid_body_force_constant * 2 )
    __OUT('Translational restraint energy:     ', d0)
    __INCR(rigid_body_energy, d0)
   endif
   __OUT('Total rigid-body restraint energy:  ', rigid_body_energy)
#endif
   rigid_body_energy=zero
   if ( abs(rigid_body_force_constant).gt.__ERRTOL) then
    dcom = dcom / rigid_body_force_constant * nsurface_atoms ! remove scaling from COM difference
    A_rb = A_rb / rigid_body_force_constant * nsurface_atoms + Id3 ! remove scaling from rotation matrix and add back identity
    do ii=1, nsurface_atoms
     __INCR(rigid_body_energy, sum( ( dr_surf(:,ii) - r_surf_ref(:,ii) )**2 ))
     __DECR(rigid_body_energy, sum( ( dr_surf(:,ii) - matmul(A_rb, r_surf_ref(:,ii)))**2))
    enddo
    __SCALE(rigid_body_energy, half*rigid_body_force_constant*oonsurface)
    __OUT('Rotational restraint energy:        ', rigid_body_energy)
     d0=half*rigid_body_force_constant*dot_product( dcom, dcom )
    __OUT('Translational restraint energy:     ', d0)
    __INCR(rigid_body_energy, d0)
    __OUT('Total rigid-body restraint energy:  ', rigid_body_energy)
   endif
#ifdef __DEBUG
! repeat
! alternative calculation, close to the unsimplified analytical definition
   rigid_body_energy=zero
   if ( abs(rigid_body_force_constant).gt.__ERRTOL) then
    do ii=1, nsurface_atoms
     __INCR(rigid_body_energy, sum( ( dr_surf(:,ii) - r_surf_ref(:,ii) + dcom )**2 ))
     __DECR(rigid_body_energy, sum( ( dr_surf(:,ii) - matmul(A_rb, r_surf_ref(:,ii)))**2))
    enddo
    __SCALE(rigid_body_energy, half*rigid_body_force_constant*oonsurface)
    __OUT('Rigid-body restraint energy (DBG):  ', rigid_body_energy)
   endif
#endif
  endif
#endif
!
#ifdef __FORCE_STATS
  __OUT('================================')
#endif
#ifdef __BAROSTAT
  if (barostat) then
   __OUT('Target pressure (atm):           ', pressure_target)
   __OUT('Simulation pressure (short):     ', pressure_ave)
   __OUT('Average pressure (long):         ', pressure_long_ave)
   __OUT('Instantaneous pressure (atm):    ', pressure)
   __OUT('Total force on solvent shell :   ', surface_force)
   __OUT('Surface area of solvent shell :  ', surface_area)
  endif
#endif
#ifdef __DASYSTAT
  if (dasystat) then
   __OUT('Target density (g/mL):           ', density_target)
   __OUT('Simulation density (g/mL):       ', density_ave)
   __OUT('Instantaneous density (g/mL):    ', density)
   __OUT('Volume of bulk solvent (Ang^3):  ', volume_bulk)
#ifdef __BULK2_DISTANCE_SCALE
   __OUT('Mass of bulk solvent (amu):      ', solvent_mass_bulk-solvent_mass_nonbulk)
   __OUT('Inner bulk boundary distance:    ', bulk_boundary_distance)
   __OUT('Outer bulk boundary distance:    ', bulk2_boundary_distance)
   if (.not. qminimum_distance) then
   __OUT('Inner bulk boundary contour value:', bulk_boundary_contour_value)
   __OUT('Outer bulk boundary contour value:', bulk2_boundary_contour_value)
   endif
#else
   __OUT('Mass of bulk solvent (amu):      ', solvent_mass-solvent_mass_outside-solvent_mass_nonbulk)
   __OUT('Bulk boundary distance:          ', bulk_boundary_distance)
   if (.not. qminimum_distance) then
   __OUT('Bulk boundary contour value:     ', bulk_boundary_contour_value)
   endif
#endif
__DBGVAR(solvent_mass,1)
__DBGVAR(solvent_mass_outside,1)
__DBGVAR(solvent_mass_nonbulk,1)
  endif
#endif
  __OUT('================================')
!
  __PRINT(_MSGBUF)

! write restart file
   __MESSAGE(whoami, 'WRITING OUTPUT/RESTART FILE TO ("'//trim(output_file)//'")')
   call __NM(write_restart_file)
!
  endif
 endif
!
#ifdef __DEBUGDUMP
! write simulation state to file for force debugging
 i=-1;
 call files_open(i, 'surfind.dat', 'FORMATTED','WRITE')
 write(i,*) isurface_atoms
 call files_close(i)
!
 call files_open(i, 'solvind.dat', 'FORMATTED','WRITE')
 write(i,*) isolvent_atoms
 call files_close(i)
!
 call files_open(i, 'forces.dat', 'FORMATTED','WRITE')
 write(i,*) fr
 call files_close(i)
!
 call files_open(i, 'positions.dat', 'FORMATTED','WRITE')
 write(i,*) r
 call files_close(i)
!
 call files_open(i, 'radii.dat', 'FORMATTED','WRITE')
 write(i,*) rad_surf
 call files_close(i)
!
 call files_open(i, 'r_surf.dat', 'FORMATTED','WRITE')
 write(i,*) r_surf
 call files_close(i)
!
 call files_open(i, 'r_solv.dat', 'FORMATTED','WRITE')
 write(i,*) r_solv
 call files_close(i)
!
 call files_open(i, 'rho_solv.dat', 'FORMATTED','WRITE')
 write(i,*) rho_solv
 call files_close(i)
!
 call files_open(i, 'drho_solv.dat', 'FORMATTED','WRITE')
 write(i,*) drho_solv
 call files_close(i)
!
 call files_open(i, 'misc.dat', 'FORMATTED','WRITE')
 write(i,*) surf_stdev, surf_padding, surface_distance, surface_contour_value, surface_energy, surface_force_constant, cutoff_surf
 call files_close(i)
#endif
!
 end __SUB(main)
!================================================================
 __SUB(compute_density_grad)(qtruncate_loop)
#ifdef __OMP
 use omp_lib
#endif
!
 bool :: qtruncate_loop ! whether we can stop looping over solute atoms once the density reaches a threshold value
! ^ this allows the neighbor lists to be sorted only ; if __SORT_LIST is undefined then there is not effect
!   the density calculation is still truncated once the atom is determined to be inside
!   to avoid the truncation, you must define an upper bound to the surface contour, which is nsurface_coord
 int :: i, j
 float :: rp(3), rw(3), dr(3), dr2, a, b, expa, expb, ooc
#ifdef __SORT_LIST
 int :: jj
 float :: dr2old ! squared distance difference from previous iteration
#if defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 float :: neighbor_list_length
 int :: neighbor_list_misses
#ifdef __OMP
 int :: __U(neighbor_list_misses)
#endif
#endif
#endif
!
#ifdef __HAMILTONIAN
#ifdef __OMP
 int :: tid
#endif
 int, dimension(:), pointer :: ispt_this_thread
 float, dimension(:,:), pointer :: drho_surf_this_thread, drho_surf_all_thread
#endif
!
#ifdef __ERFHYBRID
 float :: isgn_, x_, erfa, erfb
#endif
 float :: rmaxsurf, rsurf ! , rsurfn
#ifdef __DASYSTAT
#ifdef __OMP
 float :: __U(solvent_mass_nonbulk)
#ifdef __BULK2_DISTANCE_SCALE
 float :: __U(solvent_mass_bulk)
#endif
#endif
 bool :: qbulk, qchkbulk
#endif
 bool :: qforced
 __IAM(__NM(compute_density_grad))
!
! different erf implementations/approximations
  float :: erfsun ! external erf function; code by Sun Microsystems
  float :: erfo7  ! approximation to within O(-7)
  float :: erfo5  ! approximation to within O(-5) [contains an exponential term]
!
#ifdef __OMP
#ifdef __DDEBUG
!$omp parallel
!$omp single
 __DBGOUT('OMP: Available processors: ',omp_get_num_procs());
 __DBGOUT('OMP: Maximum threads:      ',numthreads);
 __DBGOUT('OMP: Current threads:      ',omp_get_num_threads());
 __DBGOUT('OMP: This thread:          ',omp_get_thread_num());
!$omp end single
!$omp end parallel
#endif
#endif
!
! compute density at each solvent coordinate
! adapted from molecule.ftn in continua
!
! if openmp is used, cannot call the function erfo7, so hack to call inlined macro here
#ifdef __OMP
#//define erfo7 __erfo7s
#define erfo7 __erfo7
#endif
!
#ifdef __DASYSTAT
 if (dasystat) then 
  solvent_mass_nonbulk=zero
#ifdef __BULK2_DISTANCE_SCALE
  solvent_mass_bulk=zero
#endif
!
__DBGVAR(surface_distance,1)
__DBGVAR(bulk_boundary_distance,1)
#ifdef __BULK2_DISTANCE_SCALE
__DBGVAR(bulk2_boundary_distance,1)
#endif
__DBGVAR(surface_contour_value,1)
__DBGVAR(bulk_boundary_contour_value,1)
!
 endif
#endif
 if (qtruncate_loop) then
#ifdef __OMP
!$omp parallel &
!$omp shared ( rho_solv, drho_solv, r_solv, r_surf, rad_surf, surf_padding, nsolvent, nsurface_coord, cutoff_surf, oo_surf_stdev &
#ifdef __DASYSTAT
!$omp , solvent_mass_nonbulk, mass_solv &
#ifdef __BULK2_DISTANCE_SCALE
!$omp , solvent_mass_bulk &
#endif
#endif
#ifdef __SORT_LIST
!$omp , solute_neighbor_list &
#ifdef __NEIGHBOR_LIST
!$omp , solute_neighbor_mind &
#endif
#endif
!$omp ) &
!$omp private ( rw, i, j, rp, rsurf, rmaxsurf, dr, dr2, ooc, a, b, expa, expb, qforced &
#ifdef __DASYSTAT
!$omp , __U(solvent_mass_nonbulk) &
#ifdef __BULK2_DISTANCE_SCALE
!$omp , __U(solvent_mass_bulk), qchkbulk &
#endif
#endif
#ifdef __SORT_LIST
!$omp ,dr2old, jj &
#endif
#ifdef __HAMILTONIAN
!$omp , tid, ispt_this_thread, drho_surf_this_thread, drho_surf_all_thread, __U(nspt) &
#endif
!$omp )
!
#ifdef __DASYSTAT
 if (dasystat) then 
  __U(solvent_mass_nonbulk)=zero
#ifdef __BULK2_DISTANCE_SCALE
  __U(solvent_mass_bulk)=zero
#endif
 endif
#endif
#endif
!
#ifdef __HAMILTONIAN
#ifdef __OMP
 tid=omp_get_thread_num()
 ispt_this_thread=>ispt(:,tid)
#else
#define tid 0
#endif
 ispt_this_thread=>ispt(:,tid)
 drho_surf_this_thread=>drho_surf(:,:,2*tid)
 drho_surf_all_thread=>drho_surf(:,:,2*tid+1)
 drho_surf_all_thread=zero ! initialize this aray because it is updated incrementally
#ifndef __OMP
#undef tid
#endif
#endif
!
#ifdef __OMP
!$omp do schedule(runtime)
#endif
  do i=1, nsolvent ! outer loop over solvent atoms
! does not help below
!#define zero 0d0
!#define one 1d0
!#define half 0.5d0
!#define osq2pi 0.398942280401433d0
!#define osq2   0.707106781186547d0
!
#ifdef __HAMILTONIAN
   __U(nspt)=0 ! set number of surface support atoms for this solvent atom to zero
#endif
!
   qforced=.true.
#ifdef __BULK2_DISTANCE_SCALE
   if (dasystat) qchkbulk=.true. ! flag to check whether atom is inside outer bulk shell
#endif
!
   rho_solv(i)=zero ;
   drho_solv(:,i)=zero
   rw=r_solv(:,i);
#ifdef __SORT_LIST
   dr2old=-1.d0 ; ! set to a small number to guarantee that no swap is done on first iteration
#ifdef __NEIGHBOR_LIST
   do jj=1, __NEIGHBOR_LIST_LENGTH_DENSITY
#else
   do jj=1, nsurface_coord ! inner loop over solute atoms
#endif
    j=solute_neighbor_list(jj,i)
#else
   do j=1, nsurface_coord ! inner loop over solute atoms
#endif
!#define _nonce  rho_solv(i)=0.0001d0;
!    if (qtruncate_sum.and.rho.gt.surface_contour_value) &     ! density threshold exceeded ; will not apply force to this atom
!    exit
!     cycle ! could actually be faster than exit (vectorization?)
! determine if atoms are too far away :
! _nonce cycle ! aa get 110
    rp=r_surf(:,j)
!
! _nonce cycle ! aa get 111
    rsurf    = ( rad_surf(j) + surf_padding )
    rmaxsurf = ( cutoff_surf + rsurf  ) ! note that this can be precomputed
!
!_nonce  cycle ! aa get 105
    dr = rp-rw ;
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
     __DIST_PBC(dr(1),ucell%a)
     __DIST_PBC(dr(2),ucell%b)
     __DIST_PBC(dr(3),ucell%c)
    endif
#endif
! _nonce  cycle ! aa get 105
!__DBGOUT('i ', i, ' RW: ', rw)
!__DBGOUT('j ', j, ' RP: ', rp)
!__DBGOUT(' DR: ', dr, rmaxsurf)
!    if (any(abs(dr) .gt. rmaxsurf)) cycle ! not necessary, might actually slow the code
    dr2=sum(dr**2);
#ifdef __SORT_LIST
! bubble sort between this and previous atom base on distance
! one issue here is that rmaxsurf depends on the atom radius ;
! i.e. perhaps sorting should take that into account ?
! specifically, should we compare :
!
! ( dr - rmax ) < ( drold - rmaxold) ? swap : continue
!
! Note that, in the above, the sign matters
! The point is that atoms with a larger radius could contribute more to the density
! even though the distance between their centers to the solvent atom is larger
! For now, will keep as is, since the adaptive algorithm should correct for the sort inaccuracy, but may be changed in the future
! Keep in mind however, that the "better" test above would require computing a square root, where none may be required otherwise
!
    if (dr2 .lt. dr2old) then ! bubble sort
     solute_neighbor_list(jj,i)=solute_neighbor_list(jj-1,i)
     solute_neighbor_list(jj-1,i)=j
    endif
    dr2old=dr2
#endif
!
    if (dr2 .gt. rmaxsurf**2) cycle
! _nonce cycle ! aa get 54
! proceed with calculation
    rsurf=rsurf * oo_surf_stdev ! NOTE: redefining rsurf to get rid of variable rsurfn (rsurf <== rsurfn)
    dr2 = sqrt(dr2) * oo_surf_stdev
! a and b
    a = osq2 * (dr2 + rsurf)
    b = osq2 * (dr2 - rsurf)
    ooc = one / dr2
!
    expa = __gauss(a)
    expb = __gauss(b)
!
! note that, if dr ~ small, ( expa - expb ) / c is singular, although the limit (and asymptote) exists
! however, in the calculations here, that would imply atoms being very close together, which we consider impossible, so ignore this case
!
! update density
#ifdef __ERFHYBRID
    __erfo7i(a,erfa)
    __erfo7i(b,erfb)
    __INCR(rho_solv(i), half * ( erfa - erfb ) + osq2pi * ooc * ( expa - expb )   )
#else
    __INCR(rho_solv(i), half * ( __erf(a) - __erf(b) ) + osq2pi * ooc * ( expa - expb )   )
#endif
#if (_DBGLEV>1)
    __DBGOUT('FORCECOMP : solv. atom#:', i, 'solute. atom#:',j, 'current density:', rho_solv(i), rw, rp)
#endif
!
#ifdef __DASYSTAT
    if (dasystat) then
     if(rho_solv(i).gt.bulk_boundary_contour_value) then ! atom is inside inner bulk boundary
      __INCR(__U(solvent_mass_nonbulk), mass_solv(i))
#ifdef __BULK2_DISTANCE_SCALE
      __INCR(__U(solvent_mass_bulk), mass_solv(i)) ! also add to 'outer' bulk mass
!      qchkbulk=.false. ! not used after this
#endif
      qforced=.false.
      exit ! density threshold exceeded ; will not apply force to this atom
#ifdef __BULK2_DISTANCE_SCALE
     elseif(qchkbulk .and.&
&      (rho_solv(i).gt.bulk2_boundary_contour_value)) then ! atom is inside outer bulk boundary
       __INCR(__U(solvent_mass_bulk), mass_solv(i))
       qforced=.false.
       qchkbulk=.false. ! mark as bulk to avoid mass addition since in subsequent iterations
#endif
     elseif(qforced) then
      if (rho_solv(i).gt.surface_contour_value) then ! not bulk, but still inside ; if already marked (qforced=t, skip)
       qforced=.false. ! however, do not quit because we still do not know whether we are inside bulk
      else
! otherwise, compute gradient contribution : (note that I am flipping the direction of dr (in the notes it is r0-r)
! MATLAB : dGdX_fix =  - 1/sqrt(2*pi) * ( (expa + expb) * radpad/s +       (expa - expb)./c)./(c*s).^2 .*dX ;% correct analytical expression
       __SCALE(dr, osq2pi * (ooc*oo_surf_stdev)**2 * ( (expa + expb) * rsurf + (expa - expb) * ooc) ) ! CORRECTED 10/18
! add gradient contribution
       __INCR(drho_solv(:,i),dr)
!
#ifdef __HAMILTONIAN
! propagate force onto surface atoms
     __INC(__U(nspt)) ! number of atoms in support
     ispt_this_thread(__U(nspt)) = j ! index of support atom
     drho_surf_this_thread(:,j) = dr ! density gradient (i.e. to compute force exerted on support atom)
#endif
!
      endif ! rho > surface contour value
     endif ! rho > bulk contour value
    else & ! dasystat
#endif
    if(rho_solv(i).gt.surface_contour_value) then
     qforced=.false.
     exit ! density threshold exceeded ; will not apply force to this atom
    else
! otherwise, compute gradient contribution : (note that I am flipping the direction of dr (in the notes it is r0-r)
     __SCALE(dr, osq2pi * (ooc*oo_surf_stdev)**2 * ( (expa + expb) * rsurf + (expa - expb) * ooc) ) ! CORRECTED 10/18
! add gradient contribution
     __INCR(drho_solv(:,i),dr)
!
#ifdef __HAMILTONIAN
! propagate force onto surface atoms
     __INC(__U(nspt)) ! number of atoms in support
     ispt_this_thread(__U(nspt)) = j ! index of support atom
     drho_surf_this_thread(:,j) = dr ! density gradient (i.e. to compute force exerted on support atom)
#endif
    endif
#if defined(__SORT_LIST) && defined( __NEIGHBOR_LIST)
! if we are here, that means that the jj index contributes to the calculation ; check it if it is inside the index support ; if not, increase index support
    if (jj>solute_neighbor_mind(i)) solute_neighbor_mind(i)=jj
#endif
   enddo ! nsurface_coord
#if (_DBGLEV>1)
    __DBGOUT('FORCECOMP : solv. atom#:', i, 'density:', rho_solv(i))
#endif
   qforced_solv(i)=qforced ! note that this is not quite enough, because it is possible that the solvent atom is outside of all supports;
!  so that while the default setting -- qforced=T -- persists, there are actually _no_ forces and rho(i)=zero ; therefore, we could do
!  qforced_solv(i)=qforced.and.rho_solv(i).gt.zero
!  however, in that case we are throwing away the information that a solvent atom has moved outside of support ; better to address this in the main loop, I think
!  Also, it is clear that the atom _should_ be forced (we just do not know which way to push it since we are outside of the support) ; thus we are closer to the
!  actual physical situation, leaving as is
#ifdef __HAMILTONIAN
! Need to propagate Hamiltonian forces to surface atoms ; therefore, compute force prefactor and apply to gradients here
! Also, do not recompute the prefactor in the main loop for solvent atoms (see main routine)
   if (qforced) then
#ifdef __LOGISTIC_INVERSE
    a=__OORHOSAFE(rho_solv(i)) ! reuse a
    a = surface_force_constant * logistic_constant * a * one/( one - min(rho_solv(i),__RHO_MAX)) * ( __RHO_INVERSE2(a)-surface_distance )
#else
    a=__QSAFE(rho_solv(i))
    a = surface_force_constant * surf_stdev * sq2pi * exp (a**2) * ( __RHO_INVERSE2(a) - surface_distance )
#endif
    __SCALE(drho_solv(:,i),a)
    __SCALE(a, (one - structure_update_memory) )
    do j=1,__U(nspt)
     __INCR(drho_surf_all_thread(:,ispt_this_thread(j)), a * drho_surf_this_thread(:,ispt_this_thread(j)))
    enddo
!write(0,*) i, a, __U(nspt), ispt_this_thread(1:__U(nspt))
   endif ! qforced
#endif
  enddo ! nsolvent
!#undef zero
!#undef half
!#undef one
!#undef osq2
!#undef osq2pi
#ifdef __OMP
!$omp end do
#ifdef __DASYSTAT
 if (dasystat) then
!$omp atomic
  __REDUCE(solvent_mass_nonbulk)
#ifdef __BULK2_DISTANCE_SCALE
!$omp atomic
  __REDUCE(solvent_mass_bulk)
#endif
 endif
#endif
!
#ifdef __HAMILTONIAN
#ifdef __H_THREAD_REDUCE
! reduce Hamiltonian forces on surface atoms (0th thread has final data)
! adapted from volume/surface compute
 i=1
 do while (i.lt.numthreads)
!$omp barrier ! make sure all threads have completed previous operation
  if (mod(tid,2*i)==0 .and. (tid+i).lt.numthreads) then
   __INCR(drho_surf_all_thread, drho_surf(:,:,2*(tid+i)+1)) ! maybe better to reindex to tid+i, as in the volume/surface code ?
  endif
  __SCALE(i,2)
 enddo
#endif
#endif
!$omp end parallel
#endif
 else ! qtruncate loop
#if defined(__SORT_LIST) & defined(__NEIGHBOR_LIST)
#ifdef __DDEBUG
  __DBGOUT('Called ', whoami,'(full loop) with neighbor_list_factor=',neighbor_list_factor)
#endif
#ifdef __NEIGHBOR_LIST_CHECK
  neighbor_list_misses=0
#endif
#endif
!==========================================================================================
#ifdef __OMP
!$omp parallel &
!$omp shared ( rho_solv, drho_solv, r_solv, r_surf, rad_surf, surf_padding, nsolvent, nsurface_coord, cutoff_surf, oo_surf_stdev &
#ifdef __DASYSTAT
!$omp , solvent_mass_nonbulk, mass_solv &
#ifdef __BULK2_DISTANCE_SCALE
!$omp , solvent_mass_bulk &
#endif
#endif
#ifdef __SORT_LIST
!$omp , solute_neighbor_list &
#ifdef __NEIGHBOR_LIST
!$omp , solute_neighbor_mind &
#ifdef __NEIGHBOR_LIST_CHECK
!$omp , neighbor_list_misses &
#endif
#endif
#endif
!$omp ) &
!$omp private ( rw, i, j, rp, rsurf, rmaxsurf, dr, dr2, ooc, a, b, expa, expb, qforced &
#ifdef __DASYSTAT
!$omp , __U(solvent_mass_nonbulk), qbulk &
#ifdef __BULK2_DISTANCE_SCALE
!$omp , __U(solvent_mass_bulk), qchkbulk &
#endif
#endif
#ifdef __SORT_LIST
!$omp ,dr2old, jj &
#if defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
!$omp , __U(neighbor_list_misses), neighbor_list_length &
#endif
#endif
#ifdef __HAMILTONIAN
!$omp , tid, ispt_this_thread, drho_surf_this_thread, drho_surf_all_thread, __U(nspt) &
#endif
!$omp )
!
#ifdef __DASYSTAT
 if (dasystat) then
  __U(solvent_mass_nonbulk)=zero
#ifdef __BULK2_DISTANCE_SCALE
  __U(solvent_mass_bulk)=zero
#endif
 endif
#endif
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 __U(neighbor_list_misses)=0
#endif
#endif
!
#ifdef __HAMILTONIAN
#ifdef __OMP
 tid=omp_get_thread_num()
#else
#define tid 0
#endif
 ispt_this_thread=>ispt(:,tid)
 drho_surf_this_thread=>drho_surf(:,:,2*tid)
 drho_surf_all_thread=>drho_surf(:,:,2*tid+1)
 drho_surf_all_thread=zero ! initialize this aray because it is updated incrementally
#ifndef __OMP
#undef tid
#endif
#endif
!
#ifdef __OMP
!$omp do schedule(runtime)
#endif
  do i=1, nsolvent ! outer loop over solvent atoms!
!
#ifdef __HAMILTONIAN
   __U(nspt)=0 ! set number of surface support atoms for this solvent atom to zero
#endif
!
   qforced=.true.
#ifdef __DASYSTAT
    if (dasystat) then 
     qbulk=.true.
#ifdef __BULK2_DISTANCE_SCALE
     qchkbulk=.true.
#endif
    endif
#endif
   rho_solv(i)=zero
   drho_solv(:,i)=zero
   rw=r_solv(:,i);
#ifdef __SORT_LIST
   dr2old=-1.d0  ! set to a small number to guarantee that no swap is done on first iteration
#if defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
   neighbor_list_length = __NEIGHBOR_LIST_LENGTH_DENSITY
#endif
   do jj=1, nsurface_coord ! inner loop over solute atoms
    j=solute_neighbor_list(jj,i)
#else
   do j=1, nsurface_coord ! inner loop over solute atoms
#endif
    rp=r_surf(:,j)
    rsurf    = ( rad_surf(j) + surf_padding )
    rmaxsurf = ( cutoff_surf  + rsurf  )
    dr = rp-rw ;
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
     __DIST_PBC(dr(1),ucell%a)
     __DIST_PBC(dr(2),ucell%b)
     __DIST_PBC(dr(3),ucell%c)
    endif
#endif
    dr2=sum(dr**2);
#ifdef __SORT_LIST
!   bubble sort between this and previous atom based on distance
    if (dr2 .lt. dr2old) then ! bubble sort
     solute_neighbor_list(jj,i)=solute_neighbor_list(jj-1,i)
     solute_neighbor_list(jj-1,i)=j
    endif
    dr2old=dr2
#endif
    if (dr2 .gt. rmaxsurf**2) cycle ! solute atom outside cutoff for this solvent atom -- skip it
!   atom is within the cutoff; record its index before computing density contribution
#if defined(__SORT_LIST) & defined(__NEIGHBOR_LIST)
    solute_neighbor_mind(i)=jj
!   since jj is increasing, solute_neighbor_mindist(i) will store the largest index for any atom within the cutoff (otherwise we cycle above)
!   because the list is supposed to be sorted (in actuality it is not because the sort is approximate) this is a measure
!   of how far we have to go to compute all the interactions within the cutoff ; so we store this number
#endif
!
#ifdef __DASYSTAT
    if (dasystat) then
     if (qbulk) then
      rsurf=rsurf * oo_surf_stdev
      dr2 = sqrt(dr2) * oo_surf_stdev
      a = osq2 * (dr2 + rsurf)
      b = osq2 * (dr2 - rsurf)
      ooc = one / dr2
      expa = __gauss(a)
      expb = __gauss(b)
! repeated from above, since it is important :
! note that, if dr ~ small, ( expa - expb ) / c is singular, thought the limit (and asymptote) exists
! however, in the calculations here, that would imply atoms being very close together, which we consider impossible, so ignore this case
!
! update density
#ifdef __ERFHYBRID
      __erfo7i(a,erfa)
      __erfo7i(b,erfb)
      __INCR(rho_solv(i), half * ( erfa - erfb ) + osq2pi * ooc * ( expa - expb )   )
#else
      __INCR(rho_solv(i), half * ( __erf(a) - __erf(b) ) + osq2pi * ooc * ( expa - expb )   )
#endif
      if (rho_solv(i).gt.bulk_boundary_contour_value) then
       __INCR(__U(solvent_mass_nonbulk), mass_solv(i))
#ifdef __BULK2_DISTANCE_SCALE
       __INCR(__U(solvent_mass_bulk), mass_solv(i))
       qchkbulk=.false. ! no need to check vs outer bulk value
#endif
       qbulk=.false. ! no need to compute erf further, but will iterate to the end to sort list
       qforced=.false.
#ifdef __BULK2_DISTANCE_SCALE
      elseif(qchkbulk .and. (rho_solv(i).gt.bulk2_boundary_contour_value)) then
       __INCR(__U(solvent_mass_bulk), mass_solv(i))
       qchkbulk=.false.
       qforced=.false.
#endif
      elseif(qforced) then ! in the bulk, and possibly outside main shell
       if (rho_solv(i).gt.surface_contour_value) then
        qforced=.false.
       else
        __SCALE(dr, osq2pi * (ooc*oo_surf_stdev)**2 * ( (expa + expb) * rsurf + (expa - expb) * ooc) ) ! CORRECTED 10/18
! add gradient contribution
        __INCR(drho_solv(:,i),dr)
!
#ifdef __HAMILTONIAN
! propagate force onto surface atoms
        __INC(__U(nspt)) ! number of atoms in support
        ispt_this_thread(__U(nspt)) = j ! index of support atom
        drho_surf_this_thread(:,j) = dr ! density gradient (i.e. to compute force exerted on support atom)
#endif
!
       endif ! rho > surface value
      endif ! rho > bulk value
     endif ! qbulk
    else & ! dasystat
#endif
    if (qforced) then
     rsurf = rsurf * oo_surf_stdev
     dr2 = sqrt(dr2) * oo_surf_stdev
     a = osq2 * (dr2 + rsurf)
     b = osq2 * (dr2 - rsurf)
     ooc = one / dr2
     expa = __gauss(a)
     expb = __gauss(b)
! update density
#ifdef __ERFHYBRID
     __erfo7i(a,erfa)
     __erfo7i(b,erfb)
     __INCR(rho_solv(i), half * ( erfa - erfb ) + osq2pi * ooc * ( expa - expb )   )
#else
     __INCR(rho_solv(i), half * ( __erf(a) - __erf(b) ) + osq2pi * ooc * ( expa - expb )   )
#endif
     if (rho_solv(i).gt.surface_contour_value) then
      qforced=.false.
     else
      __SCALE(dr, osq2pi * (ooc*oo_surf_stdev)**2 * ( (expa + expb) * rsurf + (expa - expb) * ooc) ) ! CORRECTED 10/18
! add gradient contribution
      __INCR(drho_solv(:,i),dr)
!
#ifdef __HAMILTONIAN
! propagate force onto surface atoms
      __INC(__U(nspt)) ! number of atoms in support
      ispt_this_thread(__U(nspt)) = j ! index of support atom
      drho_surf_this_thread(:,j) = dr ! density gradient (i.e. to compute force exerted on support atom)
#endif
!
     endif ! rho>contour value
    endif ! qforced
! _nonce
   enddo ! nsurface_coord
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
! check for _potential_ neighbor list violations :
   if (qforced .and. solute_neighbor_mind(i) > neighbor_list_length ) __INC(__U(neighbor_list_misses)) ! count only if qforced, ok?
#endif
   qforced_solv(i)=qforced
#ifdef __HAMILTONIAN
! Need to propagate Hamiltonian forces to surface atoms ; therefore, compute force prefactor and apply to gradients here
! Also, do not recompute the prefactor in the main loop for solvent atoms (see main routine)
   if (qforced) then
#ifdef __LOGISTIC_INVERSE
    a=__OORHOSAFE(rho_solv(i)) ! reuse a
    a= surface_force_constant * logistic_constant * a * one/( one - min(rho_solv(i),__RHO_MAX)) * ( __RHO_INVERSE2(a)-surface_distance )
#else
    a=__QSAFE(rho_solv(i))
    a = surface_force_constant * surf_stdev * sq2pi * exp (a**2) * ( __RHO_INVERSE2(a) - surface_distance )
#endif
    __SCALE(drho_solv(:,i),a)
    __SCALE(a,one - structure_update_memory)
    do j=1,__U(nspt)
     __INCR(drho_surf_all_thread(:,ispt_this_thread(j)), a * drho_surf_this_thread(:,ispt_this_thread(j)) )
    enddo
   endif ! qforced
#endif
!
  enddo ! nsolvent
#ifdef __OMP
!$omp end do
#ifdef __DASYSTAT
 if (dasystat) then
!$omp atomic
  __REDUCE(solvent_mass_nonbulk)
#ifdef __BULK2_DISTANCE_SCALE
!$omp atomic
  __REDUCE(solvent_mass_bulk)
#endif
 endif
#endif
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
!$omp atomic
 __REDUCE(neighbor_list_misses) ! maybe faster via atomic, since most of the time there will be no misses
#endif
!
#ifdef __HAMILTONIAN
#ifdef __H_THREAD_REDUCE
! reduce Hamiltonian forces on surface atoms (0th thread has final data)
! adapted from volume/surface compute
 i=1
 do while (i.lt.numthreads)
!$omp barrier ! make sure all threads have completed previous operation
  if (mod(tid,2*i)==0 .and. (tid+i).lt.numthreads) then
   __INCR(drho_surf_all_thread, drho_surf(:,:,2*(tid+i)+1)) ! maybe better to reindex to tid+i, as in the volume/surface code ?
  endif
  __SCALE(i,2)
 enddo
#endif
#endif
!$omp end parallel
#endif
#if defined(__NEIGHBOR_LIST) & defined(__SORT_LIST)
!#ifdef __DDEBUG
! write(666,'(7000(I4,"("I4")"))') (solute_neighbor_mind(i), solute_neighbor_list(solute_neighbor_mind(i),i), i=1,nsolvent)
! close(666)
!#endif
#endif
! should we output the violations here ?
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 if (neighbor_list_misses>0) then
  if (neighbor_list_misses==1) then
   __WRN(whoami, 'DETECTED '//itoa(neighbor_list_misses)//' POSSIBLE NEIGHBOR LIST MISS. NEIGHBOR LIST FACTOR IS '//ftoa(neighbor_list_factor))
  else
   __WRN(whoami, 'DETECTED '//itoa(neighbor_list_misses)//' POSSIBLE NEIGHBOR LIST MISSES. NEIGHBOR LIST FACTOR IS '//ftoa(neighbor_list_factor))
  endif
! increase neighbor_list_factor
  __INCR(neighbor_list_factor, neighbor_list_factor_grow)
 else
  __INCR(neighbor_list_factor, neighbor_list_factor_shrink)
! decrease neighbor_list_factor
 endif
#endif
!
!
 endif ! truncate sum
!
 end __SUB(compute_density_grad)
!================================================================
 __SUB(compute_mindist_grad)(quit_early)
#ifdef __OMP
 use omp_lib
#endif
!
 bool, intent(in) :: quit_early ! whether we can stop computation for each atom once distance to any atom less than distance to solute surface
 int :: i, j
 float :: rp(3), rw(3), dr(3), dr2, dr2min, drmin(3)
#ifdef __SORT_LIST
 int :: jj
 float :: dr2old ! squared minimum distance difference from previous iteration
#if defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 float :: neighbor_list_length
 int :: neighbor_list_misses
#ifdef __OMP
 int :: __U(neighbor_list_misses)
#endif
#endif
#endif
 float :: rmaxsurf, surface_distance2
#ifdef __DASYSTAT
 float :: bulk_distance2
 bool :: qbulk
#ifdef __BULK2_DISTANCE_SCALE
 float :: bulk2_distance2
 bool :: qchkbulk
#endif
#ifdef __OMP
 float :: __U(solvent_mass_nonbulk)
! float :: __U(solvent_mass_outside)
#ifdef __BULK2_DISTANCE_SCALE
 float :: __U(solvent_mass_bulk)
#endif
#endif
#endif
 bool :: qforced ! whether an atom is a forced atom
 __IAM(__NM(compute_mindist_grad))
!
#ifdef __DDEBUG
#ifdef __OMP
!$omp parallel
!$omp single
 __DBGOUT('OMP: Available processors: ',omp_get_num_procs());
 __DBGOUT('OMP: Maximum threads:      ',numthreads);
 __DBGOUT('OMP: Current threads:      ',omp_get_num_threads());
 __DBGOUT('OMP: This thread:          ',omp_get_thread_num());
!$omp end single
!$omp end parallel
#endif __OMP
#endif
!
! simple algorithm to find the closest atom
 surface_distance2=surface_distance**2
#ifdef __DASYSTAT
 if (dasystat) then
  bulk_distance2=bulk_boundary_distance**2
  solvent_mass_nonbulk=zero
#ifdef __BULK2_DISTANCE_SCALE
  solvent_mass_bulk=zero
  bulk2_distance2=bulk2_boundary_distance**2
#endif
 endif ! dasystat
#endif
!
 if (quit_early) then
#if defined(__SORT_LIST) & defined(__NEIGHBOR_LIST)
#ifdef __DDEBUG
  __DBGOUT('Called ', whoami,'(can quit early) with neighbor_list_factor=',neighbor_list_factor)
#endif
#endif
#ifdef __OMP
!$omp parallel &
!$omp shared ( dist_solv, ddist_solv, r_solv, nsolvent, nsurface_coord, surface_distance2 &
#ifdef __DASYSTAT
!$omp , bulk_distance2, mass_solv, solvent_mass_nonbulk &
#ifdef __BULK2_DISTANCE_SCALE
!$omp , solvent_mass_bulk, bulk2_distance2 &
#endif
#endif
#ifdef __SORT_LIST
!$OMP , solute_neighbor_list &
#ifdef __NEIGHBOR_LIST
!$OMP , solute_neighbor_mind &
#endif
#endif
!$OMP ) &
!$omp private ( rw, i, j, rp, dr, drmin, dr2, dr2min, qforced &
#ifdef __DASYSTAT
!$omp , __U(solvent_mass_nonbulk) &
#ifdef __BULK2_DISTANCE_SCALE
!$omp , __U(solvent_mass_bulk), qchkbulk &
#endif
#endif
#ifdef __SORT_LIST
!$OMP ,dr2old, jj &
#endif
!$OMP )
#ifdef __DASYSTAT
 if (dasystat) then
  __U(solvent_mass_nonbulk)=zero
#ifdef __BULK2_DISTANCE_SCALE
  __U(solvent_mass_bulk)=zero
#endif
 endif
#endif
!$omp do schedule(runtime)
#endif
  do i=1, nsolvent ! outer loop over solvent atoms
   qforced=.true.  ! assume that forces will be applied to this atom, check below
#ifdef __BULK2_DISTANCE_SCALE
   qchkbulk=.true.
#endif
   rw=r_solv(:,i); ! solvent atom coordinate
   dr2min=ilarge
#ifdef __SORT_LIST
   dr2old=-1.d0 ; ! set to a small number to guarantee that no swap is done on first iteration
#ifdef __NEIGHBOR_LIST
   do jj=1, __NEIGHBOR_LIST_LENGTH_MINDIST
!   do jj=1,max(1,min(nsurface_coord, solute_neighbor_mind(i) ))
#else
   do jj=1, nsurface_coord ! inner loop over solute atoms ! to check the entire surface atom list
#endif
    j=solute_neighbor_list(jj,i) ! note that this is really a (partially) distance-sorted list of surface atoms for each solvent atom
#else
   do j=1, nsurface_coord ! inner loop over solute atoms, without regard to their location relative to the solvent atom i
#endif
    rp=r_surf(:,j) ! protein atom coordinate
!
    dr = rp-rw ; ! note : there is no fast way to incorporate radii without a square root somewhere in the inner loop, so for now, radii are effectively zero (not used)
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
     __DIST_PBC(dr(1),ucell%a)
     __DIST_PBC(dr(2),ucell%b)
     __DIST_PBC(dr(3),ucell%c)
    endif
#endif
    dr2=sum(dr**2);
#ifdef __SORT_LIST
!   bubble sort between this and previous atom based on distance
    if (dr2 .lt. dr2old) then
     solute_neighbor_list(jj,i)=solute_neighbor_list(jj-1,i)
     solute_neighbor_list(jj-1,i)=j
    endif
    dr2old=dr2
#endif
!
#ifdef __DASYSTAT
    if (dasystat) then
     if (dr2 .lt. bulk_distance2) then ! the solvent atom is inside the shell, and also too close to the surface to be considered bulk
      __INCR(__U(solvent_mass_nonbulk), mass_solv(i))
      qforced=.false.
#ifdef __BULK2_DISTANCE_SCALE
      __INCR(__U(solvent_mass_bulk), mass_solv(i)) ! add to mass inside outer bulk shell
!      qchkbulk=.false.
#endif
#ifdef __SORT_LIST
! put this atom first in the list to increase our chances of quitting early next time
!      solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!      solute_neighbor_list(1,i)=j
#endif
      exit ! atom is considered inside, so no need to loop further
#ifdef __BULK2_DISTANCE_SCALE
     elseif (qchkbulk .and. dr2 .lt. bulk2_distance2) then ! inside outer bulk bdry
      __INCR(__U(solvent_mass_bulk), mass_solv(i)) ! add to mass inside outer bulk shell
      qchkbulk=.false.
      qforced=.false.
#endif
     elseif (qforced .and. dr2 .lt. surface_distance2) then ! not bulk but still inside ; if already marked inside (qforced=.false.) then skip !
      qforced=.false.
!      __INCR(__solvent_mass_bulk, mass_solv(i)) ! direct sum ; algorithm not quite correct so commenting but not deleting
#ifdef __SORT_LIST
! put this atom first in the list to increase our chances of quitting early next time
!      solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!      solute_neighbor_list(1,i)=j
#endif
     endif
    else &
#endif
    if (dr2 .lt. surface_distance2) then ! the solvent atom is close enough to a surface atom to be considered inside
     qforced=.false.
#ifdef __SORT_LIST
! put this atom first in the list to increase our chances of quitting early next time
!     solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!     solute_neighbor_list(1,i)=j
#endif
     exit ! atom is considered inside, so no need to loop further (because dasystat off, no need to check whether bulk)
    endif
!
    if (dr2 .lt. dr2min) then
     dr2min=dr2
     drmin=dr
#ifdef __SORT_LIST
! put this atom first in the list
! note that is is possible to do two swaps one here and one above, in the same loop, which is an error, so turn off both, since no sizeable speed bump anyway
! should not do this when multiple threads are running
!     solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!     solute_neighbor_list(1,i)=j
#ifdef __NEIGHBOR_LIST
! if the atom with the minimum distance happens to be farther in index space than the stored index, increase the index :
     if (jj>solute_neighbor_mind(i)) solute_neighbor_mind(i)=jj-1 ; ! even this might be too aggressive
#endif
#endif
    endif
   enddo ! nsurface_coord
   if (qforced) then
    dist_solv(i) = -sqrt(dr2min) ! negative distance by convention
    ddist_solv(:,i) = drmin      ! the minimum distance between this atom and a surface atom
! note that, technically, this is also a non-bulk atom, since it is outside of the surface shell, but we have a separate variable for those (mass_outside)
   else
    dist_solv(i)=zero            ! atom is inside, so set min. distance to zero
   endif
   qforced_solv(i)=qforced
  enddo ! nsolvent
#ifdef __OMP
!$omp end do
#ifdef __DASYSTAT
 if (dasystat) then
!$omp atomic
  __REDUCE(solvent_mass_nonbulk)
#ifdef __BULK2_DISTANCE_SCALE
!$omp atomic
  __REDUCE(solvent_mass_bulk)
#endif
 endif
#endif
!$omp end parallel
#endif
 else ! (not) quit_early
#if defined(__SORT_LIST) & defined(__NEIGHBOR_LIST)
#ifdef __DDEBUG
  __DBGOUT('Called ', whoami,'(full loop) with neighbor_list_factor=',neighbor_list_factor)
#endif
#ifdef __NEIGHBOR_LIST_CHECK
  neighbor_list_misses=0
#endif
#endif
!=====================================================================================
#ifdef __OMP
!$omp parallel &
!$omp shared ( dist_solv, ddist_solv, r_solv, nsolvent, nsurface_coord, surface_distance2 &
#ifdef __DASYSTAT
!$omp , bulk_distance2, solvent_mass_nonbulk &
#ifdef __BULK2_DISTANCE_SCALE
!$omp , bulk2_distance2, solvent_mass_bulk &
#endif
#endif
#ifdef __SORT_LIST
!$omp , solute_neighbor_list &
#ifdef __NEIGHBOR_LIST
!$omp , solute_neighbor_mind &
#ifdef __NEIGHBOR_LIST_CHECK
!$omp , neighbor_list_misses &
#endif
#endif
#endif
!$omp ) &
!$omp private ( rw, i, j, rp, dr, drmin, dr2, dr2min, qforced &
#ifdef __DASYSTAT
!$omp , __U(solvent_mass_nonbulk), qbulk &
#ifdef __BULK2_DISTANCE_SCALE
!$omp , __U(solvent_mass_bulk), qchkbulk &
#endif
#endif
#ifdef __SORT_LIST
!$omp ,dr2old, jj &
#if defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
!$omp , __U(neighbor_list_misses), neighbor_list_length &
#endif
#endif
!$omp )
#ifdef __DASYSTAT
 if (dasystat) then
  __U(solvent_mass_nonbulk)=zero
#ifdef __BULK2_DISTANCE_SCALE
  __U(solvent_mass_bulk)=zero
#endif
 endif
#endif
!
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 __U(neighbor_list_misses)=0
#endif
!$omp do schedule(runtime)
#endif
  do i=1, nsolvent ! outer loop over solvent atoms
   qforced=.true.
#ifdef __DASYSTAT
   if (dasystat) then
    qbulk=.true. ! assume atom is outside of the bulk boundary
#ifdef __BULK2_DISTANCE_SCALE
    qchkbulk=.true.
#endif
   endif
#endif
   rw=r_solv(:,i);
   dr2min=ilarge
#ifdef __SORT_LIST
   dr2old=-1.d0 ; ! set to a small number to guarantee that no swap is done on first iteration
#if defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
   neighbor_list_length = __NEIGHBOR_LIST_LENGTH_MINDIST
#endif
!
   do jj=1, nsurface_coord ! inner loop over solute atoms
!   do jj=nsurface_coord, 1, -1 ! inner loop over solute atoms, starting from the end
    j=solute_neighbor_list(jj,i)
#else
   do j=1, nsurface_coord ! inner loop over solute atoms
#endif
    rp=r_surf(:,j) ! protein atom coordinate
!
    dr = rp-rw ;
#ifdef __UNWRAP_PBC
    if (qper_parser_override) then
     __DIST_PBC(dr(1),ucell%a)
     __DIST_PBC(dr(2),ucell%b)
     __DIST_PBC(dr(3),ucell%c)
    endif
#endif
    dr2=sum(dr**2);
#ifdef __SORT_LIST
!   bubble sort between this and previous atom based on distance
    if (dr2 .lt. dr2old) then
     solute_neighbor_list(jj,i)=solute_neighbor_list(jj-1,i)
     solute_neighbor_list(jj-1,i)=j
    endif
    dr2old=dr2
#endif
!
#ifdef __DASYSTAT
    if (dasystat) then
     if (qbulk .and. dr2 .lt. bulk_distance2) then ! the solvent atom is too close to the surface to be considered bulk
      __INCR(__U(solvent_mass_nonbulk), mass_solv(i))
#ifdef __BULK2_DISTANCE_SCALE
      __INCR(__U(solvent_mass_bulk), mass_solv(i))
      qchkbulk=.false.
#endif
      qbulk=.false. ! mark atom as non-bulk
      qforced=.false. ! also, mark as a non-forced atom
#ifdef __SORT_LIST
! put this atom first in the list to increase our chances of quitting early next time
!      solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!      solute_neighbor_list(1,i)=j
#endif
! atom is considered inside, but proceed to the end of list because we want to sort it
#ifdef __BULK2_DISTANCE_SCALE
     elseif (qchkbulk .and. dr2 .lt. bulk2_distance2) then
      __INCR(__U(solvent_mass_bulk), mass_solv(i))
      qchkbulk=.false.
      qforced=.false.
#endif
     elseif (qforced .and. dr2 .lt. surface_distance2) then ! not bulk but still inside ; if already marked inside (qforced=.false.) then skip !
      qforced=.false.
#ifdef __SORT_LIST
! put this atom first in the list to increase our chances of quitting early next time
!      solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!      solute_neighbor_list(1,i)=j
#endif
     endif ! dr2<dist
    else & ! dasystat
#endif
    if (qforced .and. dr2 .lt. surface_distance2) then ! since we are not exiting, use qforced flag in the conditional
     qforced=.false. ! this atom is inside, however, proceed to the end of the surface atom list because we want to sort it
#ifdef __SORT_LIST
! put this atom first in the list to increase our chances of quitting early next time
! NOTE : these section OMP sections have ad hoc problems, such as with -fcheck=all flags
! also : do not use critical; this produces a completely different compilation ; very slow !
!!$omp critical
! not necessary because the code block below will guarantee this
!     solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!     solute_neighbor_list(1,i)=j
!!$omp end critical
#endif
    endif
    if (dr2 .lt. dr2min) then
     dr2min=dr2
     drmin=dr
! minimum index inside solute_neighbor_list (before swap below)
#ifdef __SORT_LIST
#ifdef __NEIGHBOR_LIST
     solute_neighbor_mind(i)=jj
#endif
! note that it is technically possible to swap twice here and above, which would make two j`s in the same list -- error
! put this atom first in the list
!     solute_neighbor_list(jj,i)=solute_neighbor_list(1,i)
!     solute_neighbor_list(1,i)=j
#endif
    endif
   enddo ! nsurface_coord
! check for _potential_ neighbor list violations :
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
   if (qforced .and. solute_neighbor_mind(i) > neighbor_list_length ) __INC(__U(neighbor_list_misses)) ! count only if qforced, ok?
#endif
#ifdef __DEBUG
! write(666,*) i,dr2min, ilarge
! close(666)
#endif
   dist_solv(i) = -sqrt(dr2min) ! sign convention ; keep outside of if below to compute average dist
   if (qforced) then
    ddist_solv(:,i) = drmin ! for force calculation
! note that, technically, this is also a non-bulk atom, since it is outside of the surface shell; but we also have mass_outside var
   endif
   qforced_solv(i)=qforced
  enddo ! nsolvent
#ifdef __OMP
!$omp end do
#ifdef __DASYSTAT
 if (dasystat) then
!$omp atomic
  __REDUCE(solvent_mass_nonbulk)
#ifdef __BULK2_DISTANCE_SCALE
!$omp atomic
  __REDUCE(solvent_mass_bulk)
#endif
 endif
#endif
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
!$omp atomic
 __REDUCE(neighbor_list_misses)
#endif
!$omp end parallel
#endif
#ifdef __DDEBUG
! write(666,'(1300(I4,"("I4")"))') (solute_neighbor_mind(i), solute_neighbor_list(solute_neighbor_mind(i),i), i=1,nsolvent)
! close(666)
#endif
! should we output the violations here ?
#if defined(__SORT_LIST) && defined(__NEIGHBOR_LIST) && defined(__NEIGHBOR_LIST_CHECK)
 if (neighbor_list_misses>0) then
  if (neighbor_list_misses==1) then
   __WRN(whoami, 'DETECTED '//itoa(neighbor_list_misses)//' POSSIBLE NEIGHBOR LIST MISS. NEIGHBOR LIST FACTOR IS '//ftoa(neighbor_list_factor))
  else
   __WRN(whoami, 'DETECTED '//itoa(neighbor_list_misses)//' POSSIBLE NEIGHBOR LIST MISSES. NEIGHBOR LIST FACTOR IS '//ftoa(neighbor_list_factor))
  endif
! increase neighbor_list_factor
  __INCR(neighbor_list_factor, neighbor_list_factor_grow)
 else
  __INCR(neighbor_list_factor, neighbor_list_factor_shrink)
! decrease neighbor_list_factor
 endif
#endif
!
 endif ! quit_early
!
 end __SUB(compute_mindist_grad)
!================================================================
#ifdef __BAROSTAT
#undef _S
#define _S compute_surface_area
 __SUB(_S)
!
#ifdef __OMP
 use omp_lib
 int tid, numthreads, n
#endif
 int i, im, jm, km, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, nx, ny, nz
 float x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, x0, y0, z0
! float support, support2, rsurf, a, b, oos
 real*4 :: support, support2, rsurf, a, b, oos
 float, parameter :: sqrtmap(0:3)=(/zero, one, sqrt2, sqrt3/)
#ifdef __PERTURB_GRID
 float :: drand(3)
#endif
!
 int1 :: rhomx, thisrho, igrad
 float __U(grad)
 __IAM(__NM(_S))
!
! make use of existing definitions in compute_desity_grad routine above
! different erf implementations/approximations
 float :: erfsun ! external erf function; code by Sun Microsystems
! if openmp is used, cannot call the function erfo7, so hack to call inlined macro here
#ifndef __OMP
 float :: erfo7  ! approximation to within O(-7)
#endif
 float :: erfo5  ! approximation to within O(-5) [contains an exponential term]
!
#ifdef __PERTURB_GRID
 call randomu_vector(drand, 3, random_channel)
 drand=(drand-half)*surface_area_grid_spacing
#else
#define drand(_A)
#endif
!
 x0 = drand(1) + sagrid%limits(1,1)
 y0 = drand(2) + sagrid%limits(1,2)
 z0 = drand(3) + sagrid%limits(1,3)
!
 nx=sagrid%n(1)
 ny=sagrid%n(2)
 nz=sagrid%n(3)
!
#define qpbcx qper_parser_override
#define qpbcy qpbcx
#define qpbcz qpbcx

! initialize
 surface_area=zero
!
 oos=one/surface_contour_value
!
#ifdef __OMP
!$omp parallel &
!$omp shared(sarho_all_threads, sarhof_all_threads) &
!$omp private(x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, tid, &
!$omp i, __U(grad), rhomx, thisrho, igrad, n, support, support2, rsurf, a, b )
 tid=omp_get_thread_num() ! thread index
 numthreads=omp_get_num_threads()
#ifdef rho
#undef rho
#endif
#define rho(i,j,k) sarhof_all_threads(i,j,k,tid)
#else
#define rho sarhof
#endif
! assign to each thread a local copy of surface indicator
 rho(:,:,:)=zero ! initialize
 __U(grad)=0
!$omp do schedule(runtime)
 do i=1, nsurface_coord
! determine support for this atom, i.e. all grid points which are within the filter support
  rsurf = ( rad_surf(i) + surf_padding )
  support = ( rsurf + cutoff_surf )
  support2=support**2
  x=r_surf(1,i)-r_com_sa(1)
  xmin=x-support
  xmax=xmin + two*support
  imin = INT( (xmin-x0)*oo_surface_area_grid_spacing ) + 1 ! could be negative (i.e. off-the-grid), but the indices are consistent with the 1-based offset
  imax = INT( (xmax-x0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcx) then
   imin=max(imin,1)
   imax=min(imax,nx)
  endif
__DBGVAR(surface_area_grid_spacing,2)
__DBGVAR(oo_surface_area_grid_spacing,2)
__DBGVAR(x,2)
__DBGVAR(xmin,2)
__DBGVAR(xmax,2)
__DBGVAR(x0,2)
__DBGVAR(imin,2)
__DBGVAR(imax,2)
! same for y
  y=r_surf(2,i)-r_com_sa(2)
  ymin=y-support
  ymax=ymin + two*support
  jmin = INT( (ymin-y0)*oo_surface_area_grid_spacing ) + 1
  jmax = INT( (ymax-y0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcy) then
   jmin=max(jmin,1)
   jmax=min(jmax,ny)
  endif
__DBGVAR(y,2)
__DBGVAR(ymin,2)
__DBGVAR(ymax,2)
__DBGVAR(y0,2)
__DBGVAR(jmin,2)
__DBGVAR(jmax,2)
! and for z
  z=r_surf(3,i)-r_com_sa(3)
  zmin=z-support
  zmax=zmin + two*support
  kmin = INT( (zmin-z0)*oo_surface_area_grid_spacing ) + 1
  kmax = INT( (zmax-z0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcz) then
   kmin=max(kmin,1)
   kmax=min(kmax,nz)
  endif
__DBGVAR(z,2)
__DBGVAR(zmin,2)
__DBGVAR(zmax,2)
__DBGVAR(z0,2)
__DBGVAR(kmin,2)
__DBGVAR(kmax,2)

  do kk=kmin,kmax
   dz2=(surface_area_grid_spacing*(kk-1) - (z - z0) )**2; ! actual z-distance between gridpoint and atom
   km=modulo(kk-1,nz-1)+1 ! works for PBC
! NOTE : assume dz < support because indices kmin, kmax computed accordingly
   do jj=jmin,jmax
    dy2=dz2+(surface_area_grid_spacing*(jj-1) - (y - y0) )**2;
    if (dy2>support2) cycle
    jm=modulo(jj-1,ny-1)+1
    do ii=imin,imax
     dx2=dy2+(surface_area_grid_spacing*(ii-1) - (x - x0) )**2;
     if (dx2>support2) cycle
     im=modulo(ii-1,nx-1)+1
! update density
     if (rho(im,jm,km).lt.surface_contour_value) then
      support=rsurf * oo_surf_stdev ! reuse support var
      dx2 = sqrt(dx2) * oo_surf_stdev
      a = osq2 * (dx2 + support)
      b = osq2 * (dx2 - support)
#ifdef __ERFHYBRID
      __erfo7i(a,erfa)
      __erfo7i(b,erfb)
#else
#ifdef __erf
#undef __erf
#endif
#// use the single precision version
#define __erf(_Y) __erfo7s(_Y)
#// singe prec ^
#define erfa __erf(a)
#define erfb __erf(b)
#endif
! NOTE that we will have a singularity for small dx ; treat this case here
#ifdef __ERF_REGULARIZE
      if ( dx2 .gt. 1e-5 ) then
#endif
       __INCR(rho(im,jm,km), half * ( erfa - erfb ) + osq2pi * ( __gauss1(a) - __gauss1(b) ) / dx2 )
#ifdef __ERF_REGULARIZE
      else
       __INCR(rho(im,jm,km), half * ( erfa - erfb ) - osq2pi * support * (two + third * ( support * dx2 )**2 ) * exp ( - half * ( support**2 + dx2**2) ) )
      endif
#endif
     endif ! rho<surface_contour value
    enddo !ii
   enddo !jj
  enddo !kk
 enddo ! nsurface atoms, i
#ifdef __OMP
!$omp end do
! now reduce all indicator arrays to master array (0th thread)
 n=1
 do while (n.lt.numthreads)
!$omp barrier ! make sure all threads have completed previous operation
  if (mod(tid,2*n)==0 .and. (tid+n).lt.numthreads) then
   __INCR(rho(:,:,:), sarhof_all_threads(:,:,:,tid+n))
  endif
  __SCALE(n,2)
 enddo
! now compute surface area integral
#if defined rho
#undef rho
#endif
#define rho(i,j,k) sarhof_all_threads(i,j,k,0)
#// use the same array below
#define irho(i,j,k) sarhof_all_threads(i,j,k,0)
!$omp barrier ! make sure thread reduction is complete, otherwise volumes will be too small
! first, digitize continuous density :
!$omp do schedule(runtime)
#else
#define irho sarhof
#endif
 do kk=1,nz
  do jj=1,ny
   do ii=1,nx
!    irho(ii,jj,kk)=INT(rho(ii,jj,kk)*oos)
    if (rho(ii,jj,kk).gt.surface_contour_value) then ; irho(ii,jj,kk)=1 ; else ; irho(ii,jj,kk)=0 ; endif
   enddo
  enddo
 enddo
#ifdef __OMP
!$omp end do
!$omp barrier ! make sure irho is computed everywhere
! second, integrate digitized gradient
!$omp do schedule(runtime)
#endif
 do kk=2,nz
  do jj=2,ny
   rhomx=irho(1,jj,kk)
   do ii=2,nx ; thisrho=irho(ii,jj,kk)
! specialized code below : we know that in this case, rho can only be 0,1;
! therefore diff(rho) can only be 0,1, which means igrad can be 0 1 2 or 3, and there is no need to use squares or square roots
! simpified :
    igrad = abs(thisrho-rhomx) + abs(thisrho-irho(ii,jj-1,kk)) + abs(thisrho-irho(ii,jj,kk-1))
    rhomx=thisrho
    __INCR(__U(grad),sqrtmap(igrad))
   enddo
  enddo
 enddo
#ifdef __OMP
!$omp end do
!$omp atomic
#endif
 surface_area=surface_area + __U(grad)
#ifdef __OMP
!$omp end parallel
#endif
 __SCALE(surface_area,surface_area_grid_spacing**2)
 __DBGVAR(surface_area,1)
!
#undef rho
 end __SUB(_S)
!================================================================
 __SUB(compute_surface_area_mindist)()
#ifdef __OMP
 use omp_lib
 int tid, numthreads, n
#endif
 int i, im, jm, km, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, nx, ny, nz
 float x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, x0, y0, z0
 float support2
#ifdef __PERTURB_GRID
 float :: drand(3)
#endif
 int1 rhomx, thisrho, igrad
 float __U(grad)
 __IAM(compute_surface_area_mindist)
!
 support2=surface_distance**2
!
#ifdef __PERTURB_GRID
! NOTE : the origin of the grid is the surface atoms` COM; since the grid is discrete, there is in principle
! a discretiation error that arises from the precise location of the grid boundaries
! this error will average out as the surface moves ; however, in some cases, the averaging out will probably
! be slow ; in that case, it might be advantageous to add a uniformly distributed random perturbation to the grid origin, 
! of the size dx/2, so that this particular contribution to the surface area averages out more quickly
! note, an extreme pathological case is that of one atom or a rigid body ; in that case, the surface are will always be exactly the
! same unless a random number is added to the grid origin
#define random_channel 50
!
 call randomu_vector(drand, 3, random_channel)
 drand=(drand-half)*surface_area_grid_spacing
#else
#define drand(_A)
#endif
!
 x0 = drand(1) + sagrid%limits(1,1)
 y0 = drand(2) + sagrid%limits(1,2)
 z0 = drand(3) + sagrid%limits(1,3)
!
 nx=sagrid%n(1)
 ny=sagrid%n(2)
 nz=sagrid%n(3)
!
#define qpbcx qper_parser_override
#define qpbcy qpbcx
#define qpbcz qpbcx

 surface_area=zero !initialize

#ifdef __OMP
!$omp parallel &
!$omp shared(support2, sarho_all_threads) &
!$omp private(x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, ii, dx2, dy2, dz2, jj, kk, imin, imax, jmin, jmax, kmin, kmax, tid, &
!$omp i, __U(grad), rhomx, thisrho, igrad, n)
 tid=omp_get_thread_num() ! thread index
 numthreads=omp_get_num_threads()
#define rho(i,j,k) sarho_all_threads(i,j,k,tid)
#else
#define rho sarho
#endif
! assign to each thread a local copy of surface indicator
 rho(:,:,:)=0 ! initialize
 __U(grad)=zero
! NOTE : partially adapted from elec code
!$omp do schedule(runtime)
 do i=1, nsurface_coord
! determine support for this atom, i.e. all grid points which are within the cutoff
  x=r_surf(1,i)-r_com_sa(1)
  xmin=x+surface_distance ! remember the sign convention
  xmax=xmin - two*surface_distance
  imin = INT( (xmin-x0)*oo_surface_area_grid_spacing ) + 1 ! could be negative (i.e. off-the-grid), but the indices are consistent with the 1-based offset
  imax = INT( (xmax-x0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcx) then
   imin=max(imin,1)
   imax=min(imax,nx)
  endif
__DBGVAR(x,2)
__DBGVAR(xmin,2)
__DBGVAR(x0,2)
__DBGVAR(imin,2)
__DBGVAR(imax,2)
! same for y
  y=r_surf(2,i)-r_com_sa(2)
  ymin=y+surface_distance ! sign convention
  ymax=ymin - two*surface_distance
  jmin = INT( (ymin-y0)*oo_surface_area_grid_spacing ) + 1
  jmax = INT( (ymax-y0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcy) then
   jmin=max(jmin,1)
   jmax=min(jmax,ny)
  endif
__DBGVAR(y,2)
__DBGVAR(ymin,2)
__DBGVAR(y0,2)
__DBGVAR(jmin,2)
__DBGVAR(jmax,2)
! and for z
  z=r_surf(3,i)-r_com_sa(3)
  zmin=z+surface_distance ! sign convention
  zmax=zmin - two*surface_distance
  kmin = INT( (zmin-z0)*oo_surface_area_grid_spacing ) + 1
  kmax = INT( (zmax-z0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcz) then
   kmin=max(kmin,1)
   kmax=min(kmax,nz)
  endif
__DBGVAR(z,2)
__DBGVAR(zmin,2)
__DBGVAR(z0,2)
__DBGVAR(kmin,2)
__DBGVAR(kmax,2)

  do ii=imin,imax
   dx2=(surface_area_grid_spacing*(ii-1) - (x - x0) )**2; ! actual x-distance between gridpoint and atom
   im=modulo(ii-1,nx-1)+1 ! works for PBC
   do jj=jmin,jmax
    dy2=dx2+(surface_area_grid_spacing*(jj-1) - (y - y0) )**2;
    if (dy2>support2) cycle
    jm=modulo(jj-1,ny-1)+1
    do kk=kmin,kmax
     dz2=dy2+(surface_area_grid_spacing*(kk-1) - (z - z0) )**2;
     if (dz2>support2) cycle
     km=modulo(kk-1,nz-1)+1
     rho(im,jm,km) = 1
    enddo !kk
   enddo !jj
  enddo !ii
 enddo ! nsurface atoms, i
#ifdef __OMP
!$omp end do
! now reduce all indicator arrays to master array (0th thread)
 n=1
 do while (n.lt.numthreads)
!$omp barrier ! make sure all threads have completed previous operation
  if (mod(tid,2*n)==0 .and. (tid+n).lt.numthreads) then
!   __INCR(__U(rho), sarho_all_threads(:,:,:,tid+n))
!   __U(rho) = max(__U(rho), sarho_all_threads(:,:,:,tid+n))
!   __U(rho) = ior(__U(rho), sarho_all_threads(:,:,:,tid+n))
!   rho(:,:,:) = max(rho(:,:,:), sarho_all_threads(:,:,:,tid+n))
   rho(:,:,:) = ior(rho(:,:,:), sarho_all_threads(:,:,:,tid+n))
  endif
  __SCALE(n,2)
 enddo
! now compute surface area integral
#if defined rho
#undef rho
#endif
#define rho(i,j,k) sarho_all_threads(i,j,k,0)
!$omp barrier ! make sure thread reduction is complete, otherwise volumes will be too small
!$omp do schedule(runtime)
#endif
 do kk=2,nz
  do jj=2,ny
   rhomx=rho(1,jj,kk)
   do ii=2,nx ; thisrho=rho(ii,jj,kk)
! note that the code below is general, but we know that in this case, rho can only be 0,1;
! therefore diff(rho) can only be 0,1, which means igrad can be 0 1 2 or 3, and there is no need to use squares or square roots
! so, should simplify in the future !
     igrad= &
&     ( thisrho - rhomx )**2 + &
&     ( thisrho - rho(ii,jj-1,kk) )**2 + &
&     ( thisrho - rho(ii,jj,kk-1) )**2
    __INCR(__U(grad),sqrt(one*igrad))
    rhomx=thisrho
   enddo
  enddo
 enddo
#ifdef __OMP
!$omp end do
!$omp atomic
#endif
 surface_area=surface_area + __U(grad)
#ifdef __OMP
!$omp end parallel
#endif
 __SCALE(surface_area,surface_area_grid_spacing**2)
 __DBGVAR(surface_area,1)
!
 end __SUB(compute_surface_area_mindist)
!
!================================================================
!
#endif
#ifdef __DASYSTAT
#undef _S
#define _S compute_bulk_volume
 __SUB(_S)
!
#ifdef __OMP
 use omp_lib
 int tid, n !, numthreads
 int :: __U(ivolume), __U(ivolume_nonbulk)
#endif
 int :: ivolume, ivolume_nonbulk
 int i, im, jm, km, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, nx, ny, nz
 float x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, x0, y0, z0
! real*4 ::  x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, x0, y0, z0
! float :: support, support2, rsurf, a, b, oos, oobs
 real*4 :: support, support2, rsurf, a, b, oos, oobs
#ifdef __PERTURB_GRID
 float :: drand(3)
#endif
!
 __IAM(__NM(_S))
!
! make use of existing definitions in compute_desity_grad routine above
! different erf implementations/approximations
 float :: erfsun ! external erf function; code by Sun Microsystems
! if openmp is used, cannot call the function erfo7, so hack to call inlined macro here
#ifndef __OMP
 float :: erfo7  ! approximation to within O(-7)
#endif
 float :: erfo5  ! approximation to within O(-5) [contains an exponential term]
!
#ifdef __PERTURB_GRID
 call randomu_vector(drand, 3, random_channel)
 drand=(drand-half)*surface_area_grid_spacing
#else
#define drand(_A)
#endif
!
 x0 = drand(1) + sagrid%limits(1,1)
 y0 = drand(2) + sagrid%limits(1,2)
 z0 = drand(3) + sagrid%limits(1,3)
!
 nx=sagrid%n(1)
 ny=sagrid%n(2)
 nz=sagrid%n(3)
!
#define qpbcx qper_parser_override
#define qpbcy qpbcx
#define qpbcz qpbcx

! initialize
 ivolume=0
 ivolume_nonbulk=0
!
#if defined(__VOLUME_THREAD_REDUCE) || !defined(__OMP)
#ifdef __BULK2_DISTANCE_SCALE
 oos=one/bulk2_boundary_contour_value ! outer boundary of bulk region
#else
 oos=one/surface_contour_value ! use surface distance as the outer boundary
#endif
 oobs=one/bulk_boundary_contour_value
#else
#ifdef __BULK2_DISTANCE_SCALE
 oos=bulk2_boundary_contour_value
#else
 oos=surface_contour_value
#endif
 oobs=bulk_boundary_contour_value
#define surface_contour_value4 oos
#define bulk_boundary_contour_value4 oobs
#endif
!
#ifdef __OMP
!$omp parallel &
!$omp shared(sarhof_all_threads, ivolume, ivolume_nonbulk) &
!$omp private(x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, tid, &
!$omp i, __U(ivolume), __U(ivolume_nonbulk), n, support, support2, rsurf, a, b)
 tid=omp_get_thread_num() ! thread index
! numthreads=omp_get_num_threads()
#ifdef rho
#undef rho
#endif
#define rho(i,j,k) sarhof_all_threads(i,j,k,tid)
#else
#define rho sarhof
#endif
! assign to each thread a local copy of surface indicator
 rho(:,:,:)=zero ! initialize
 __U(ivolume)=0
 __U(ivolume_nonbulk)=0
!$omp do schedule(runtime)
 do i=1, nsurface_coord
! determine support for this atom, i.e. all grid points which are within the filter support
  rsurf = ( rad_surf(i) + surf_padding )
  support = ( rsurf + cutoff_surf )
  support2=support**2
  x=r_surf(1,i)-r_com_sa(1)
  xmin=x-support
  xmax=xmin + two*support
  imin = INT( (xmin-x0)*oo_surface_area_grid_spacing ) + 1 ! could be negative (i.e. off-the-grid), but the indices are consistent with the 1-based offset
  imax = INT( (xmax-x0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcx) then
   imin=max(imin,1)
   imax=min(imax,nx)
  endif
__DBGVAR(surface_area_grid_spacing,2)
__DBGVAR(oo_surface_area_grid_spacing,2)
__DBGVAR(x,2)
__DBGVAR(xmin,2)
__DBGVAR(xmax,2)
__DBGVAR(x0,2)
__DBGVAR(imin,2)
__DBGVAR(imax,2)
! same for y
  y=r_surf(2,i)-r_com_sa(2)
  ymin=y-support
  ymax=ymin + two*support
  jmin = INT( (ymin-y0)*oo_surface_area_grid_spacing ) + 1
  jmax = INT( (ymax-y0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcy) then
   jmin=max(jmin,1)
   jmax=min(jmax,ny)
  endif
__DBGVAR(y,2)
__DBGVAR(ymin,2)
__DBGVAR(ymax,2)
__DBGVAR(y0,2)
__DBGVAR(jmin,2)
__DBGVAR(jmax,2)
! and for z
  z=r_surf(3,i)-r_com_sa(3)
  zmin=z-support
  zmax=zmin + two*support
  kmin = INT( (zmin-z0)*oo_surface_area_grid_spacing ) + 1
  kmax = INT( (zmax-z0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcz) then
   kmin=max(kmin,1)
   kmax=min(kmax,nz)
  endif
__DBGVAR(z,2)
__DBGVAR(zmin,2)
__DBGVAR(zmax,2)
__DBGVAR(z0,2)
__DBGVAR(kmin,2)
__DBGVAR(kmax,2)

  do kk=kmin,kmax
   dz2=(surface_area_grid_spacing*(kk-1) - (z - z0) )**2; ! actual z-distance between gridpoint and atom
   km=modulo(kk-1,nz-1)+1 ! works for PBC
   do jj=jmin,jmax
    dy2=dz2+(surface_area_grid_spacing*(jj-1) - (y - y0) )**2;
    if (dy2>support2) cycle
    jm=modulo(jj-1,ny-1)+1
    do ii=imin,imax
     dx2=dy2+(surface_area_grid_spacing*(ii-1) - (x - x0) )**2;
     if (dx2>support2) cycle
     im=modulo(ii-1,nx-1)+1
! update density
     if (rho(im,jm,km).lt.bulk_boundary_contour_value) then ! otherwise will already exceed threshold
      support=rsurf * oo_surf_stdev ! reuse support var
      dx2 = sqrt(dx2) * oo_surf_stdev
      a = osq2 * (dx2 + support)
      b = osq2 * (dx2 - support)
#ifdef __ERFHYBRID
      __erfo7i(a,erfa)
      __erfo7i(b,erfb)
#else
#ifdef __erf
#undef __erf
#endif
#define __erf(_Y) __erfo7s(_Y)
#// single prec          ^
#define erfa __erf(a)
#define erfb __erf(b)
#endif
! NOTE that we will have a singularity for small dx ; treat this case here
#ifdef __ERF_REGULARIZE
      if ( dx2 .lt. 1e-5 ) then ! Taylor expansion for exponentials
#endif
       __INCR(rho(im,jm,km), half * ( erfa - erfb ) - osq2pi * exp ( - half * ( support**2 + dx2**2) ) * support * (two + third * ( support * dx2 )**2 )  )
#ifdef __ERF_REGULARIZE
      else ! standard expression
       __INCR(rho(im,jm,km), half * ( erfa - erfb ) + osq2pi * ( __gauss1(a) - __gauss1(b) ) / dx2 )
      endif
#endif
     endif ! rho<bulk_boundary_contour value
    enddo !ii
   enddo !jj
  enddo !kk
 enddo ! nsurface atoms, i
#ifdef __OMP
!$omp end do
#ifdef __VOLUME_THREAD_REDUCE
! now reduce all indicator arrays to master array (0th thread)
 n=1
 do while (n.lt.numthreads)
!$omp barrier ! make sure all threads have completed previous operation
  if (mod(tid,2*n)==0 .and. (tid+n).lt.numthreads) then
   __INCR(rho(:,:,:), sarhof_all_threads(:,:,:,tid+n))
  endif
  __SCALE(n,2)
 enddo
#endif
! now compute volume integrals
#ifdef rho
#undef rho
#endif
#define rho(i,j,k) sarhof_all_threads(i,j,k,0)
!$omp barrier ! make sure thread reduction is complete, otherwise volumes will be too small
!$omp do schedule(runtime)
#endif
 do kk=2,nz
  do jj=2,ny
   do ii=2,nx
! not clear how to do this in the fastest way possible
! perhaps an if/else statement would be faster, densities that map to the outside of the main shell, also map to the outside of
! the nonbulk (i.e. interfacial) region
#if defined(__VOLUME_THREAD_REDUCE) || !defined(__OMP)
     __INCR(__U(ivolume), min(1,INT(rho(ii,jj,kk)*oos)))
     __INCR(__U(ivolume_nonbulk), min(1,INT(rho(ii,jj,kk)*oobs)))
#else
     a=0.0
     do n=0,numthreads-1
      __INCR(a,sarhof_all_threads(ii,jj,kk,n))
      if (a.gt.bulk_boundary_contour_value4) then
       __INC(__U(ivolume_nonbulk))
       exit ! quit do loop since highest possible threshold exceeded
      endif
     enddo ! n; if this loop completes, then a has the reduced density from all threads
     if (a.gt.surface_contour_value4) then
      __INC(__U(ivolume))
     endif
#endif
   enddo
  enddo
 enddo
#ifdef __OMP
!$omp end do
!$omp atomic
 __REDUCE(ivolume)
!$omp atomic
 __REDUCE(ivolume_nonbulk)
#endif
#ifdef __OMP
!$omp end parallel
#endif
 volume_bulk=(max(1,ivolume-ivolume_nonbulk))*surface_area_grid_spacing**3 ! make sure volume is always positive
!
 __DBGVAR(ivolume,1)
 __DBGVAR(ivolume_nonbulk,1)
 __DBGVAR(volume_bulk,1)

 end __SUB(_S)
!================================================================
!
#undef _S
#define _S compute_bulk_volume_mindist
 __SUB(_S)
!
#ifdef __OMP
 use omp_lib
 int tid, n ! , numthreads
 int :: __U(ivolume), __U(ivolume_nonbulk)
#endif
 int :: ivolume, ivolume_nonbulk
 int i, im, jm, km, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, nx, ny, nz
 float x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, x0, y0, z0
 float support2, bulk_support2
#ifdef __PERTURB_GRID
 float :: drand(3)
#endif
!
#ifndef __VOLUME_THREAD_REDUCE
 int:: irho
 int1, parameter :: i1zero=0
#endif
!
 __IAM(__NM(_S))
!
#ifdef __BULK2_DISTANCE_SCALE
 support2=bulk2_boundary_distance**2
#else
 support2=surface_distance**2
#endif
 bulk_support2=bulk_boundary_distance**2
!
#ifdef __PERTURB_GRID
 call randomu_vector(drand, 3, random_channel)
 drand=(drand-half)*surface_area_grid_spacing
#else
#define drand(_A)
#endif
!
 x0 = drand(1) + sagrid%limits(1,1)
 y0 = drand(2) + sagrid%limits(1,2)
 z0 = drand(3) + sagrid%limits(1,3)
!
 nx=sagrid%n(1)
 ny=sagrid%n(2)
 nz=sagrid%n(3)
!
#define qpbcx qper_parser_override
#define qpbcy qpbcx
#define qpbcz qpbcx

! initialize
 ivolume=0
 ivolume_nonbulk=0
!
#ifdef __OMP
!$omp parallel &
!$omp shared(support2, bulk_support2, sarho_all_threads, inrho_all_threads, ivolume, ivolume_nonbulk, numthreads) &
!$omp private(x, y, z, xmin, ymin, zmin, xmax, ymax, zmax, dx2, dy2, dz2, ii, jj, kk, imin, imax, jmin, jmax, kmin, kmax, tid, &
!$omp i, __U(ivolume), __U(ivolume_nonbulk), n)
 tid=omp_get_thread_num() ! thread index
! numthreads=omp_get_num_threads() ! moved to module var
#ifdef rho
#undef rho
#endif
#define rho(i,j,k) sarho_all_threads(i,j,k,tid)
#ifdef inrho
#undef inrho
#endif
#define inrho(i,j,k) inrho_all_threads(i,j,k,tid)
#else
#define rho sarho
#endif
! assign to each thread a local copy of surface indicator
 rho(:,:,:)=zero ! initialize
 inrho(:,:,:)=zero
 __U(ivolume)=0
 __U(ivolume_nonbulk)=0
! NOTE : partially adapted from elec code
!$omp do schedule(runtime)
 do i=1, nsurface_coord
! determine support for this atom, i.e. all grid points which are within the cutoff
  x=r_surf(1,i)-r_com_sa(1)
  xmin=x+surface_distance ! remember the sign convention
  xmax=xmin - two*surface_distance
  imin = INT( (xmin-x0)*oo_surface_area_grid_spacing ) + 1 ! could be negative (i.e. off-the-grid), but the indices are consistent with the 1-based offset
  imax = INT( (xmax-x0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcx) then
   imin=max(imin,1)
   imax=min(imax,nx)
  endif
__DBGVAR(surface_area_grid_spacing,2)
__DBGVAR(oo_surface_area_grid_spacing,2)
__DBGVAR(x,2)
__DBGVAR(xmin,2)
__DBGVAR(xmax,2)
__DBGVAR(x0,2)
__DBGVAR(imin,2)
__DBGVAR(imax,2)
! same for y
  y=r_surf(2,i)-r_com_sa(2)
  ymin=y+surface_distance ! sign convention
  ymax=ymin - two*surface_distance
  jmin = INT( (ymin-y0)*oo_surface_area_grid_spacing ) + 1
  jmax = INT( (ymax-y0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcy) then
   jmin=max(jmin,1)
   jmax=min(jmax,ny)
  endif
__DBGVAR(y,2)
__DBGVAR(ymin,2)
__DBGVAR(ymax,2)
__DBGVAR(y0,2)
__DBGVAR(jmin,2)
__DBGVAR(jmax,2)
! and for z
  z=r_surf(3,i)-r_com_sa(3)
  zmin=z+surface_distance ! sign convention
  zmax=zmin - two*surface_distance
  kmin = INT( (zmin-z0)*oo_surface_area_grid_spacing ) + 1
  kmax = INT( (zmax-z0)*oo_surface_area_grid_spacing ) + 2
  if (.not.qpbcz) then
   kmin=max(kmin,1)
   kmax=min(kmax,nz)
  endif
__DBGVAR(z,2)
__DBGVAR(zmin,2)
__DBGVAR(zmax,2)
__DBGVAR(z0,2)
__DBGVAR(kmin,2)
__DBGVAR(kmax,2)

  do kk=kmin,kmax
   dz2=(surface_area_grid_spacing*(kk-1) - (z - z0) )**2; ! actual z-distance between gridpoint and atom
   km=modulo(kk-1,nz-1)+1 ! works for PBC
   do jj=jmin,jmax
    dy2=dz2+(surface_area_grid_spacing*(jj-1) - (y - y0) )**2;
    if (dy2>support2) cycle
    jm=modulo(jj-1,ny-1)+1
    do ii=imin,imax
     dx2=dy2+(surface_area_grid_spacing*(ii-1) - (x - x0) )**2;
     if (dx2>support2) cycle
     im=modulo(ii-1,nx-1)+1
     rho(im,jm,km) = 1
! compute inner density (note that memory access might be more efficient if I interleave the two arrays in i)
     if (dx2>bulk_support2) cycle
     inrho(im,jm,km) = 1 ! non-bulk
    enddo !ii
   enddo !jj
  enddo !kk
 enddo ! nsurface atoms, i
#ifdef __OMP
!$omp end do
#ifdef __VOLUME_THREAD_REDUCE
! now reduce all indicator arrays to master array (0th thread)
 n=1
 do while (n.lt.numthreads)
!$omp barrier ! make sure all threads have completed previous operation
  if (mod(tid,2*n)==0 .and. (tid+n).lt.numthreads) then
!   rho(:,:,:) = max(rho(:,:,:), sarho_all_threads(:,:,:,tid+n))
   rho(:,:,:)   = ior(  rho(:,:,:), sarho_all_threads(:,:,:,tid+n))
   inrho(:,:,:) = ior(inrho(:,:,:), inrho_all_threads(:,:,:,tid+n))
  endif
  __SCALE(n,2)
 enddo
#endif
! now compute surface area integral
#ifdef rho
#undef rho
#endif
#define rho(i,j,k) sarho_all_threads(i,j,k,0)
#ifdef inrho
#undef inrho
#endif
#define inrho(i,j,k) inrho_all_threads(i,j,k,0)
!$omp barrier ! make sure thread reduction is complete, otherwise volumes will be too small
!$omp do schedule(runtime)
#endif
 do kk=2,nz
  do jj=2,ny
   do ii=2,nx
#if defined(__VOLUME_THREAD_REDUCE) || !defined(__OMP)
     __INCR(__U(ivolume), rho(ii,jj,kk))
     __INCR(__U(ivolume_nonbulk), inrho(ii,jj,kk))
#else
     irho=0
     do n=0,numthreads-1
      if (inrho_all_threads(ii,jj,kk,n) .gt. i1zero) then
       __INC(__U(ivolume_nonbulk)) ! increase non-bulk volume
       irho=1 ! also increase total volume (added below)
       exit
      elseif (sarho_all_threads(ii,jj,kk,n) .gt. i1zero) then
       irho=1 ! increase total volume below ; do not exit since need to test for non-bulk in next thread`s array
      endif
     enddo ! n
      __INCR(__U(ivolume),irho)
#endif
   enddo
  enddo
 enddo
#ifdef __OMP
!$omp end do
!$omp atomic
 __REDUCE(ivolume)
!$omp atomic
 __REDUCE(ivolume_nonbulk)
#endif
#ifdef __OMP
!$omp end parallel
#endif
 volume_bulk=(max(1,ivolume-ivolume_nonbulk))*surface_area_grid_spacing**3 ! make sure volume is always positive
!
 __DBGVAR(ivolume,1)
 __DBGVAR(ivolume_nonbulk,1)
 __DBGVAR(volume_bulk,1)

 end __SUB(_S)

#endif
!
!================================================================
!
end module _N
!
