! to "regularize" variation of applied forces with the contour value, 
! use a rough approximation to the inverse of the filter CDF;
! for efficiency, use a logistic function matched to the Gaussian filter
!
! to avoid divide iverflow, define minimum density as the smallest float in single precision
#define  __RHO_MIN FERRTOL()
#define  __RHO(_X) ( one/(one+exp(-_X/logistic_constant)) )
#define  __OORHO(_R) ( one/(max(_R,__RHO_MIN)))
#define  __RHO_INVERSE(_L) ( - logistic_constant * log ( __OORHO(_L) - one) )
#// if already have 1/rho
#define  __RHO_INVERSE2(_OL) ( - logistic_constant * log ( _OL - one) )
!
#define __CTX __WATERSHELLCTX
#define __RESTARTCTX __CONCAT(__WATERSHELLCTX,_RESTART)
#//define __CHKUPDATE(_WHAT)   ( (mod(iteration, _WHAT) .eq. ione) .or. _WHAT.eq.ione )
#define __CHKUPDATE(_WHAT)   (mod(iteration, _WHAT) .eq. izero)

module _N

 use system, only : r, rcomp, fr, radius, natom, system_PDB_initialized, system_PDB_init, system_done, system_getind, &
&                   system_init_mol_scalar_nocase
 __DEP_OUTPUT
 __DEP_PARSER
 __DEP_CONST
 __DEP_FILES
 __DEP_MPI
 __IMPNONE

 private

 public __NM(initialize)
 public __NM(main)
 public __NM(done)
 private __NM(write_restart_file)
!
! hack to make variables from system visible from plugin
 public natom
 public iteration
 public structure_update_freq
 public r
 public fr

 bool, public :: __NM(initialized)=.false.
 bool, private:: radii_initialized=.false.

! macro for parameters with defaults
#define __PAR(_PAR,_TYPE,_DEF) _TYPE, save :: _PAR ; _TYPE, parameter :: __CONCAT(default_,_PAR)=_DEF;
!
! surface computation parameters :
! __PAR(surface_contour_value, float, -one) ! value of density isosurface which is defines the surface ; negative means to compute from structure
 __PAR(surface_distance, float, zero)! approximate distance from surface ; obtained by inverting logistic function of density (as an approximation)
 __PAR(cutoff_surf_stdev,float,5d0)  ! grid smoothing cutoff normalized by standard deviation of gaussian (surface)
 __PAR(surf_padding,float,0d0)       ! ( units of radius ) padding values to radii which might account for e.g. solvent layer(s)
 __PAR(surf_stdev,float,2d0)         ! standard deviation of smoothing filter
!
 float :: cutoff_surf, cutoff_surf2, oo_surf_stdev, logistic_constant
 float :: surface_contour_value ! value of density isosurface which is defines the surface ; negative means to compute from structure
!
 __PAR(iteration,int,izero)   ! iteration
! surface evolution and output parameters
 __PAR(distance_update_freq, int, ione)          ! frequency of updating distance value
 __PAR(distance_update_step, float, 0.001d0)     ! constant for update
 __PAR(structure_update_freq, int, ione)         ! frequency of updating coordinats from which the surface is generated
 __PAR(structure_update_memory, float, 0.999d0)  ! memory constant for exponential update
 __PAR(output_file_freq, int, 1000)              ! frequency of writing output file
 __PAR(restart_file, character(len=vartaglen), 'NONE') ! restart file name
 __PAR(structure_file, character(len=vartaglen),'NONE') ! coordinate file (e.g. PDB) with system information, such as atomic radii
 __PAR(output_file, character(len=vartaglen), 'watershell.restart.txt') ! output file name
 __PAR(surface_force_constant, float, one)      ! surface restraint force constant
 __PAR(target_surface_energy, float, 5d0) ! target average energy of surface potential / par area ( units of pressure or normal stress )
 __PAR(remove_force_torque, bool, .false.) ! whether to remove net force and torque on the solvent atom
!
!  atom selections
 __PAR(surface_atom_selection, character(len=vartaglen), 'ANAME=CA')  ! protein CA trace
 __PAR(solvent_atom_selection, character(len=vartaglen), 'ANAME=OH2') ! TIP3 oxygens atoms
 int, pointer, public :: isurface_atoms(:)=>NULL()
 int, pointer, public :: isolvent_atoms(:)=>NULL()
!
 float, pointer :: r_surf(:,:), & ! reference atom coordinates
&                  rad_surf(:), & ! reference atom radii
&                  r_solv(:,:), & ! solvent atom coordinates
&                  rho_solv(:), & ! density value at solvent coordinate
&                  drho_solv(:,:) ! density gradient at solvent coordinate (inward surface normal)
 int, pointer :: solute_neighbor_list(:,:) ! for each solvent atom, the solute atoms are sorted in terms of proximity
!
 int, public :: nsurface=-1, nsolvent=-1
 int :: nsolvent_outside
 float :: oonsolvent, oonsolvent_outside
 float :: current_surface_distance
!
 int :: fid
 bool :: qrestart=.false. ! whether we are restarting from a restart file
!
 float, private, parameter :: osq2=one/sqrt2
 float, private, parameter :: osq2pi=one/sqrt(twopi)
!
!= subroutines
 contains
!========
 __SUB(initialize) ()
 character(len=vartaglen) :: keyword, context
 int :: l, ierr
 character(len=maxlinelen) :: line
 float, pointer :: farray(:) => NULL()
 __IAM(__NM(INITIALIZE))
!
#define __CONTEXT __STRING(__CTX)
 context=__CONTEXT ;
#define __DEFAULT
! first, check for restart file
! if present, read it and skip initialization options
! read restart file
#define __CHAR
#define __VAR	restart_file
#define __TAG	restart_file
#define __NAME	restart file
#include "parser/parser_macro2.src"
#undef __CHAR
!
 qrestart = ( existtag_nocase('restart_file', context) .and. trim(ftoupper(restart_file)).ne.'NONE')
!
 if (qrestart) then
  __MESSAGE(whoami,'WILL READ SURFACE DEFINITION PARAMETERS FROM RESTART FILE.')
! read and parse restart file
  fid=-1
  call files_open(fid, restart_file, 'FORMATTED', 'READ')
  call parse_file(fid, &
#ifdef __PARALLEL
 &  MPI_COMM_NULL, &
#endif
 &  quiet_=.false.)
  call files_close(fid)
! now comes a trick : change context name temporarily to process the restart file using the same calls
  context= __STRING(__RESTARTCTX)
!
 endif ! have restart file
!
#define __WARNIFMISSING
#define __MINUSERR
! density padding
#define __VAR	surf_padding
#define __TAG __VAR
#define __NAME	Density padding
#include "parser/parser_macro2.src"
!
#undef __MINUSERR
! value for density isosurface
! abandoning this in favor of distance
!#define __VAR	surface_contour_value
!#define __TAG __VAR
!#define __NAME	Value for density isosurface
!#define __DOIFOK if (__VAR.le.zero) __MESSAGE(whoami, ' DENSITY ISOSURFACE VALUE WILL BE COMPUTED FROM COORDINATES.')
!#include "parser/parser_macro2.src"
! value for distance of the surface from protein (approximate)
#define __VAR	surface_distance
#define __TAG __VAR
#define __NAME	Distance of solvent surface from protein
#define __DOIFOK if (__VAR.lt.__ERRTOL) then ; \
                  __MESSAGE(whoami, 'LOCATION OF SOLVENT SURFACE WILL BE SET FROM SOLVENT COORDINATES.') ; \
                 else ;\
                  __VAR=-(abs(__VAR)) ; \
                  surface_contour_value=__RHO(surface_distance) ;\
                 endif ! make sure to set to a negative value
!
#include "parser/parser_macro2.src"
!
#define __VAR surface_force_constant
#define __TAG __VAR
#define __NAME force constant for surface potential
#define __DOIFOK if (__VAR.lt.__ERRTOL) __WRN(whoami, 'SURFACE FORCE IS OFF.')
#include "parser/parser_macro2.src"
!
#define __LEZEROERR
! cutoff for density
#define __VAR	cutoff_surf_stdev
#define __TAG __VAR
#define __NAME	Cutoff for density smoothing
#include "parser/parser_macro2.src"

! GAUSSIAN standard deviations for smoothing
#define __VAR	surf_stdev
#define __TAG __VAR
#define __NAME	Standard deviation of Gaussian filter for density smoothing
#include "parser/parser_macro2.src"

#undef __LEZEROERR
#define __MINUSERR

! ====== done with (possible) restart file data
 context=__CONTEXT ! reset context if changed
! other parameters
#define __INT
#define __VAR	iteration
#define __TAG	__VAR
#define __NAME	starting iteration
!
#include "parser/parser_macro2.src"
#define __VAR	distance_update_freq
#define __TAG	__VAR
#define __NAME	frequency of updating target distance from surface
#define __DOIFOK if (__VAR.eq.izero) __MESSAGE(whoami, 'UPDATE OF SURFACE DISTANCE VALUE IS OFF.')
#include "parser/parser_macro2.src"
!
#define __VAR	structure_update_freq
#define __TAG	__VAR
#define __NAME	frequency of updating reference structure
#define __DOIFOK if (__VAR.eq.izero) __MESSAGE(whoami, 'SURFACE UPDATE IS OFF.')
#include "parser/parser_macro2.src"
!
#define __VAR	output_file_freq
#define __TAG	__VAR
#define __NAME	frequency for writing output/restart file
#define __DOIFOK if (__VAR.le.izero) __WRN(whoami, 'RESTART FILE WILL BE WRITTEN AT THE END ONLY')
#include "parser/parser_macro2.src"
#undef __INT
!
! output file
#define __CHAR
! read structure file
#define __VAR	structure_file
#define __TAG	__VAR
#define __NAME	structure file
#include "parser/parser_macro2.src"
! read atom selections
! atoms to define surface
#define __CHAR
#define __WARNIFMISSING
#define __VAR	surface_atom_selection
#define __TAG	surface_atoms
#define __NAME	surface atoms
#include "parser/parser_macro2.src"
! (solvent) atoms to which surface forces are applied
#define __VAR	solvent_atom_selection
#define __TAG	solvent_atoms
#define __NAME	solvent atoms
#include "parser/parser_macro2.src"
!
#undef __WARNIFMISSING
#define __VAR	output_file
#define __TAG	__VAR
#define __NAME	watershell output file
#include "parser/parser_macro2.src"
#undef __CHAR
!
#undef __MINUSERR
#define __LEZEROERR
!
#define __VAR distance_update_step
#define __TAG __VAR
#define __NAME memory constant for surface contour update
#define __DOIFOK if (__VAR.le.zero) __WRN(whoami, 'UPDATE OF SURFACE CONTOUR REFERENCE VALUE IS OFF.')
#include "parser/parser_macro2.src"
!
#define __VAR structure_update_memory
#define __TAG __VAR
#define __NAME memory constant for reference structure update
#define __DOIFOK if (__VAR.le.zero) then ; __WRN(whoami, 'SURFACE UPDATE IS OFF.') ; \
 elseif (__VAR .gt. one ) then ; __WRN(whoami, ftoupper(__STRING(__NAME))//' SHOULD _NOT_ BE GREATER THAN ONE !') ; endif
#include "parser/parser_macro2.src"
!
#define __VAR target_surface_energy
#define __TAG __VAR
#define __NAME target surface energy per area
#define __DOIFOK if (__VAR.lt.__ERRTOL) __WRN(whoami, 'TARGET SURFACE ENERGY IS ALMOST ZERO.')
#include "parser/parser_macro2.src"
!
#define __BOOL
#define __VAR remove_force_torque
#define __TAG __VAR
#define __NAME flag to remove net force and torque from solvent atoms
#include "parser/parser_macro2.src"
!
! done pocessing input file parameters
!
! read structure file
!
 __MESSAGE(whoami, 'READING STRUCTURE FROM FILE "'//trim(structure_file)//'"');
 call system_PDB_init(structure_file, 'PDB');
 if (.not. fatal_warning()) system_PDB_initialized=.true.
! save coordinates in rcomp, just in case we need them later ?
 if (associated(rcomp) .and. associated(r)) rcomp=r
! initialize radii using a system function

#define __GET_RAD(_TAG)  if (existtag_nocase(__STRING(_TAG),context)) then;\
                            farray=>system_init_mol_scalar_nocase(__STRING(_TAG), context);\
                            if (associated(farray)) then;\
                             radius=farray;\
                             deallocate(farray);\
                             radii_initialized=.true.; \
                            endif

 __GET_RAD(radii)
 else __GET_RAD(radius) ! other tags here
 endif
!
 if (.not.radii_initialized) __WRN(whoami, 'COULD NOT INITIALIZE ATOMIC RADII');
!
! copy coordinates
!
 isurface_atoms=>system_getind(surface_atom_selection)
 if (associated(isurface_atoms)) then
  nsurface=size(isurface_atoms)
  __ALLOC(r_surf(3,nsurface))
  __ALLOC(rad_surf(nsurface))
 else
  __WRN(whoami, 'COULD NOT ALLOCATE MEMORY FOR SURFACE ATOM INDICES.')
 endif
! repeat for solvent atoms
 isolvent_atoms=>system_getind(solvent_atom_selection)
 if (associated(isolvent_atoms)) then
  nsolvent=size(isolvent_atoms) ; oonsolvent=one/nsolvent ;
  __ALLOC(r_solv(3,nsolvent))
  __ALLOC(rho_solv(nsolvent))
  __ALLOC(drho_solv(3,nsolvent))
  __ALLOC(solute_neighbor_list(nsurface,nsolvent))
! initialize neighbor list with solute indices from 1 to nsurface for each solute atom:
#ifdef __DEBUG
  __DBGOUT('INITIALIZING SOLUTE NEIGHBOR LIST');
#endif
  do l=1,nsurface
   solute_neighbor_list(l,:)=l
  enddo
!
 else
  __WRN(whoami, 'COULD NOT ALLOCATE MEMORY FOR SOLVENT ATOM INDICES.')
 endif
!
 if  (qrestart) then
! read surface atom coordinates from restart file (context __RESTARTCTX)
  do l=1, nsurface
   line=getval_nocase('rsurf_'//trim(itoa(l)),__STRING(__RESTARTCTX))
   if (len_trim(line).gt.0) then
    read(line,*,iostat=ierr) r_surf(:,l)
    if (ierr.ne.0) then
     __WRN(whoami, 'ERROR READING COORDINATE FROM LINE "'//trim(line)//'"')
     cycle
    endif
   else
    __WRN(whoami, 'ERROR READING COORDINATE FROM LINE "'//trim(line)//'"')
   endif ! line ok
  enddo ! over surface atoms
 else ! qrestart
! take surface atom coordinates from structure (PDB) file
  r_surf=r(:,isurface_atoms)
 endif ! qrestart
!
 rad_surf=radius(isurface_atoms)
!
 oo_surf_stdev=one/surf_stdev
 cutoff_surf  =cutoff_surf_stdev*surf_stdev
 cutoff_surf2 =cutoff_surf**2
! compute constant (=1/a)  for logistic distribution that matches the stdev
! the distribution is a * exp (-xa) / ( 1 + exp (-xa ) )^2
! the corresponding cdf is 1 / ( 1 + exp (-xa) )
 logistic_constant = sqrt3 * opi * surf_stdev ;
!
 if (.not.fatal_warning()) __NM(initialized)=.true.
!
 end __SUB(initialize)
!======================================
 __SUB(write_restart_file) ()
! = adapted from tempering
 __IAM(__NM(WRITE_RESTART_FILE))
 int :: ifile, i
 ifile=-1 ! make sure files_open determines the handle automatically
 call files_open(ifile, output_file, 'FORMATTED','WRITE')
!
#define _W write(ifile,*)
 _W '#WATERSHELL RESTART FILE'
 _W __STRING(__RESTARTCTX)//' {'
 _W 'iteration=',iteration
! _W 'surface_contour_value=',surface_contour_value, ' # value for which density isosurface is computed'
 _W 'surface_distance=',surface_distance, ' # distance of solvent surface from solute'
 _W 'surface_force_constant=',surface_force_constant, ' # surface force constant'
 _W 'surf_stdev=',surf_stdev, ' # standard deviation of Gaussian filter'
 _W 'cutoff_surf_stdev=',cutoff_surf_stdev, ' # distance from center beyond which it set to zero (units of stdandard deviation)'
 _W 'surf_padding=',surf_padding, ' # scalar padding added to each atom radius'
!
! write the current reference atoms :
 _W '# rsurf_i : reference coordinate triple for atom #i used to define surface'
 do i=1, nsurface
  _W 'rsurf_'//trim(itoa(i)),'=(',r_surf(:,i),')'
 enddo ! surface atoms
 _W '}'
! close file
 call files_close(ifile)
!
 end __SUB(write_restart_file)
!================================================================
 __SUB(done)
 __IAM(__NM(done))
 if (__NM(initialized)) then
  __MESSAGE(whoami, 'WRITING RESTART FILE.')
  call __NM(write_restart_file)()
 endif
!
 call system_done()
 call parser_done()
 __FREE(r_surf)
 __FREE(r_solv)
 __FREE(rad_surf)
 __FREE(rho_solv)
 __FREE(drho_solv)
 __FREE(isurface_atoms)
 __FREE(isolvent_atoms)
 __FREE(solute_neighbor_list)
!
 __NM(initialized)=.false. ; radii_initialized=.false.
!
 end __SUB(done)
!================================================================
 __SUB(main)(r,fr,energy)
 float, intent(in) :: r(:,:)   ! coordinate array
 float, intent(out) :: fr(:,:) ! force array
 float, intent(out) :: energy
! int :: ibeg, iend ! atom indices for looping
 float :: distance_from_solute, distance_from_solute2, pre, d0
 float :: surface_energy, surface_force, density_beyond_contour
 int :: i
 __IAM(__NM(main))
!aa
!return
!================================================================
 if (.not. __NM(initialized)) then
  __WRN(whoami, ftoupper(__STRING(_N))//'NOT INITIALIZED. NOTHING DONE.');
  return
 endif
!
 __INC(iteration)
! copy solvent coordinates
 r_solv=r(:,isolvent_atoms)
!
!============================================= update reference coordinates
 if (structure_update_freq.gt.izero) then
  if __CHKUPDATE(structure_update_freq) then
   r_surf = structure_update_memory * r_surf + (one - structure_update_memory) * r(:,isurface_atoms)
  endif
 endif

!============================================= compute contour value and gradient at solvent coordinates
! compute forces, average density at contour value
! this is the time-consuming part ; it could benefit from GPU acceleration and/or nonbonded lists
! moving down below
! call __NM(compute_density_grad)
!
 surface_energy=zero
 distance_from_solute=zero
 distance_from_solute2=zero ! for computing second moment
!
!return ! aa
!========================== compute contour value if needed
! if reference contour value is negative, estimate a reasonable value from density distribution
 if ( abs(surface_distance) .lt. __ERRTOL) then
  call __NM(compute_density_grad)(.false.) ! need entire sum
  do i=1, nsolvent
! convert to distance
   d0 = __RHO_INVERSE(rho_solv(i))
   __DBGOUT('Inst distance from solute  ', d0);
   __INCR(distance_from_solute, d0)
   __INCR(distance_from_solute2, d0**2)
  enddo
! set contour value to average value + (a) x stdev ; a set empirically
#define _a 0.25d0
  __SCALE(distance_from_solute,oonsolvent);
  __DBGOUT('Distance from solute ', distance_from_solute)
  __SCALE(distance_from_solute2,oonsolvent);
  __DBGOUT('Distance from solute std ', sqrt ( distance_from_solute2 - distance_from_solute**2))
  surface_distance = distance_from_solute - & ! average
&                         _a * sqrt( max(zero,distance_from_solute2 - distance_from_solute**2) ) ! analytically positive, but, just in case, protect from roundoff
  surface_contour_value = __RHO(surface_distance)
  __MESSAGE(whoami, 'COMPUTED SURFACE DISTANCE AT '//ftoa(surface_distance)//' A FROM PROTEIN. CONTOUR VALUE IS '//ftoa(surface_contour_value))
  __DBGOUT( 'COMPUTED SD, SCV: ', surface_distance, surface_contour_value)
 else
! aa :  this is the most time consuming part of the force calculation ; perhaps we can do it on the GPU ? Or perhaps can regulate cost otherwise ?
  call __NM(compute_density_grad)(.true.) ! truncate if value exceeds
 endif
!========================== compute contour value ^
!========================== compute forces :
! calculate density integral using only atoms beyond contour (to estimate surface area)
 density_beyond_contour=zero
!
 nsolvent_outside=izero;
 do i=1, nsolvent
  if ( rho_solv(i) .lt. surface_contour_value) then
   __INC(nsolvent_outside);
   __INCR(density_beyond_contour, rho_solv(i))
   d0=__OORHO( rho_solv(i))
   pre = ( __RHO_INVERSE2 ( d0 ) - surface_distance ) ;
!
! add atomic force
   d0=logistic_constant*d0*(__OORHO(one-rho_solv(i))) ! derivative of the inverse of logistic function
   fr(:,isolvent_atoms(i)) = - surface_force_constant * pre * d0 * drho_solv(:,i) ! (-) because surface_distance is negative ; grad points toward protein
! sum "energy"
! NOT clear whether the surface_force or energy are meaningful
   __INCR(surface_force, pre) ! x k, below
   __INCR(surface_energy, pre**2) ! x k/2, below
  else
   fr(:,isolvent_atoms(i))=zero
  endif
 enddo
!
! compute current surface distance from pre :
 if (nsolvent_outside .gt. 0) then 
  oonsolvent_outside=one/nsolvent_outside
 else
  oonsolvent_outside=zero ;
 endif
 current_surface_distance=surface_distance + surface_force * oonsolvent_outside
!
 __SCALE(surface_force, surface_force_constant)
 __SCALE(surface_energy, half*surface_force_constant)
 energy=surface_energy
!
!=========================== evolve/update contour value using surface energy
!
 if (distance_update_freq.gt.izero) then
  if __CHKUPDATE(distance_update_freq) then
! for now, a very simple update strategy
! in the future will add estimation of pressure and surface tension
!
! if the surface energy is higher than the target, d0 < 0, and the surface distance (which is nagative ) will decrease
    d0 = ( target_surface_energy - oonsolvent_outside * surface_energy );
    __INCR(surface_distance, distance_update_step * d0)
    surface_contour_value = __RHO(surface_distance)

  endif
 endif
!============================================= output restart file
 if (output_file_freq.gt.izero) then
  if __CHKUPDATE(output_file_freq) then
! write a short update of simulation parameters:
  i=0 ;
#define __OUT(...)  __INC(i);write(_MSGBUF(i),*) __VA_ARGS__
#define _TAB char(9)//char(9)
  __OUT('===================')
  __OUT('Iteration:', iteration)
  __OUT('Target distance to protein:      ', surface_distance)
  __OUT('Current avg. distance to protein:', current_surface_distance)
  __OUT('# Solute atoms used for density: ', nsurface)
  __OUT('# Solvent atoms outside / total: ', nsolvent_outside,'/',nsolvent)
  __OUT('Surface contour value:           ', surface_contour_value)
  __OUT('Target surface energy:           ', target_surface_energy)
  __OUT('Current avg. surface energy:     ', surface_energy * oonsolvent_outside )
  __OUT('===================')
!
  __PRINT(_MSGBUF)

! write restart file
   __MESSAGE(whoami, 'WRITING OUTPUT/RESTART FILE TO ("'//trim(output_file)//'")')
   call __NM(write_restart_file)
!
  endif
 endif
!
 end __SUB(main)
!================================================================
 __SUB(compute_density_grad)(qtruncate_sum)
#ifdef __OMP
 use omp_lib
#endif
!
 bool :: qtruncate_sum ! whether we can stop computation for each atom once the density reaches a threshold value
 int :: i, j, jj
 float :: rp(3), rw(3), dr(3), dr2, a, b, expa, expb, ooc
 float :: dr2old ! squared distance difference from previous iteration
#ifdef __ERFHYBRID
 float :: isgn_, x_, erfa, erfb
#endif
 float :: rmaxsurf, rsurf, rsurfn
 __IAM(__NM(compute_density_grad))
!
! NOTE : using approximations does not make much speed difference
  float :: erfsun ! external erf function; code by Sun Microsystems
  float :: erfo7  ! approximation to within O(-7)
  float :: erfo5  ! approximation to within O(-5) [contains an exponential term]
!
#ifdef __DEBUG
#ifdef __OMP
!$omp parallel
!$omp single
 __DBGOUT('OMP: Available processors: ',omp_get_num_procs());
 __DBGOUT('OMP: Maximum threads:      ',omp_get_max_threads());
 __DBGOUT('OMP: Current threads:      ',omp_get_num_threads());
 __DBGOUT('OMP: This thread:          ',omp_get_thread_num());
!$omp end single
!$omp end parallel
#endif __OMP
#endif
!
! naive algorithm to compute density at each solvent coordinate
! adapted from molecule.ftn in continua
!
! error function definition
#ifndef __erf
#//define __erf erf
#// get an improvement of 20% when using inlined erfo7
#define __erf __erfo7
#endif
!
! if openmp is used, cannot call the function erfo7, so hack to call inlined macro here
#ifdef __OMP
#define erfo7 __erfo7
#endif
!
 if (qtruncate_sum) then
!$omp parallel &
!$omp shared ( rho_solv, drho_solv, r_solv, r_surf, rad_surf, surf_padding, nsolvent, nsurface, cutoff_surf, oo_surf_stdev, solute_neighbor_list ) &
!$omp private ( rw, i, j, jj, rp, rsurf, rmaxsurf, dr, dr2, dr2old, ooc, expa, expb)
!!$omp do schedule(runtime)
!$omp do schedule(static)
  do i=1, nsolvent ! outer loop over solvent atoms
! does not help below
!#define zero 0d0
!#define one 1d0
!#define half 0.5d0
!#define osq2pi 0.398942280401433d0
!#define osq2   0.707106781186547d0
!
   rho_solv(i)=zero ;
   drho_solv(:,i)=zero
   rw=r_solv(:,i);
   dr2old=0d0 ; ! set to a small number to guarantee that no swap is done on first iteration
   do jj=1, nsurface ! inner loop over solute atoms
    j=solute_neighbor_list(jj,i)
!#define _nonce  rho_solv(i)=0.0001d0;
!    if (qtruncate_sum.and.rho.gt.surface_contour_value) &     ! density threshold exceeded ; will not apply force to this atom
!    exit
!     cycle ! could actually be faster than exit (vectorization?) ; get 107 w/o if above
! determine if atoms are too far away :
! _nonce cycle ! aa get 110
    rp=r_surf(:,j)
!
! _nonce cycle ! aa get 111
    rsurf    = ( rad_surf(j) + surf_padding )
    rmaxsurf = ( cutoff_surf  + rsurf  ) ! note that this can be precomputed
!
!_nonce  cycle ! aa get 105
    dr = rp-rw ;
! _nonce  cycle ! aa get 105
!__DBGOUT('i ', i, ' RW: ', rw)
!__DBGOUT('j ', j, ' RP: ', rp)
!__DBGOUT(' DR: ', dr, rmaxsurf)
!    if (any(abs(dr) .gt. rmaxsurf)) cycle ! not necessary, might actually slow the code
    dr2=sum(dr**2);
!   bubble sort between this and previous atom base on distance
    if (dr2 .lt. dr2old) then ! bubble sort
     solute_neighbor_list(jj,i)=solute_neighbor_list(jj-1,i)
     solute_neighbor_list(jj-1,i)=j
    endif
    dr2old=dr2
!
    if (dr2 .gt. rmaxsurf**2) cycle
! _nonce cycle ! aa get 54
! proceed with calculation
    rsurf=rsurf * oo_surf_stdev ! NOTE: redefining rsurf to get rid o variable rsurfn (rsurf <== rsurfn)
    dr2 = sqrt(dr2) * oo_surf_stdev
! _nonce cycle ! aa get 54
! a and b
    a = osq2 * (dr2 + rsurf)
    b = osq2 * (dr2 - rsurf)
    ooc = one / dr2
! _nonce cycle ! aa get 54
!
    expa = exp ( - a**2 )
    expb = exp ( - b**2 )
! _nonce cycle ! aa get 54
!
! update density
#ifdef __ERFHYBRID
    __erfo7i(a,erfa)
    __erfo7i(b,erfb)
    __INCR(rho_solv(i), half * ( erfa - erfb ) + osq2pi * ooc * ( expa - expb )   )
#else
    __INCR(rho_solv(i), half * ( __erf(a) - __erf(b) ) + osq2pi * ooc * ( expa - expb )   )
#endif
! _nonce cycle ! aa get 24
!    if (qtruncate_sum .and.&
    if(rho_solv(i).gt.surface_contour_value) exit ! density threshold exceeded ; will not apply force to this atom
! otherwise, compute gradient contribution : (note that I am flipping the direction of dr (in the notes it is r0-r)
    __SCALE(dr, osq2pi * (ooc*oo_surf_stdev)**2 * ( (expa + expb) * rsurf + half * (expa - expb) * ooc) )
! add gradient contribution
    __INCR(drho_solv(:,i),dr)
! _nonce
   enddo ! nsurface
  enddo ! nsolvent
!#undef zero
!#undef half
!#undef one
!#undef osq2
!#undef osq2pi
!$omp end do
!$omp end parallel
 else ! qtruncate sum
  do i=1, nsolvent ! outer loop over solvent atoms
   rho_solv(i)=zero ;
   drho_solv(:,i)=zero
   rw=r_solv(:,i);
   do j=1, nsurface ! inner loop over solute atoms
    rp=r_surf(:,j)
    rsurf    = ( rad_surf(j) + surf_padding )
    rmaxsurf = ( cutoff_surf  + rsurf  )
    dr = rp-rw ;
    dr2=sum(dr**2);
    if (dr2 .gt. rmaxsurf**2) cycle
    rsurfn=rsurf * oo_surf_stdev
    dr2 = sqrt(dr2) * oo_surf_stdev
    a = osq2 * (dr2 + rsurfn)
    b = osq2 * (dr2 - rsurfn)
    ooc = one / dr2
    expa = exp ( - a**2 )
    expb = exp ( - b**2 )
! update density
    __INCR(rho_solv(i), half * ( __erf(a) - __erf(b) ) + osq2pi * ooc * ( expa - expb )   )
    __SCALE(dr, osq2pi * (ooc*oo_surf_stdev)**2 * ( (expa + expb) * rsurfn + half * (expa - expb) * ooc) )
! add gradient contribution
    __INCR(drho_solv(:,i),dr)
! _nonce
   enddo ! nsurface
  enddo ! nsolvent
 endif ! truncate sum
!
 end __SUB(compute_density_grad)
!================================================================
end module _N

