#// to use the more accurate erf :
#//define __erf erf
#// use older (logistic function) approximation to the density inverse ; it is known to greatly overestimate distance for very small densities (b/c decays too slowly)
#define __LOGISTIC_INVERSE
#// flag below should be used, even though it causes a slowdown if the grid (dasy/baso) loop by about 10% ; tried everything but c`est la vie
#define __ERF_REGULARIZE

#// to allow the use of fixed dummy atoms as surface atoms
#//define __DUMSURF

#//if using periodic boundary conditions, take care to unwrap coordinates using minimum image convention
#//define __UNWRAP_PBC

#define __DASYSTAT
#// note that there should be an option (perhaps unadversized) to set bulk distance scale from the input file
#define __BULK_DISTANCE_SCALE 0.85d0
#// bulk boundary location should be recomputed when the difference between it and the surface boundary location is less than this:
#// __BULK_BOUNDARY_RECOMPUTE_FACTOR * surface_distance
#define __BULK_BOUNDARY_RECOMPUTE_FACTOR (0.5d0*(1d0-(__BULK_DISTANCE_SCALE)))
#//define __VOLUME_THREAD_REDUCE
#define __BAROSTAT
#// exact normal force computation
#ifdef __BAROSTAT
#define __FNORM
#endif

#define __PERTURB_GRID
#define __SORT_LIST
#define __NEIGHBOR_LIST
#define __NEIGHBOR_LIST_CHECK
#define __RMFT
#// propagate shell forces onto surface atoms to have a quasi-Hamiltonian ; this was not found to improve COM translational and rotational drift
#//define __HAMILTONIAN
#//define __H_THREAD_REDUCE
#define __FORCE_STATS

#//define __DEBUG
#define _DBGLEV 1
#ifndef __OMP
#define __OMP
#endif

#// NOTE : the main problem with the force/torque removal algorithm is the force, not the torque
#// below are two mutually conflicting options
#//define __SIMPLE_NET_FORCE_SOLVENT
#define __SIMPLE_NET_FORCE_SURFACE
#define __TORQUE_FROM_FREE_SOLVENT
#define __TORQUE_FROM_FORCED_SOLVENT
#//define __TORQUE_COM_SURFACE
#define __TORQUE_COM_SOLVENT

#//to force 6x6 matrix computation :
#//define __F_T_COUPLED

#define __SHOW_TORQUE

#//undef __OMP
#//define __FORCE_OMP

#//define _N WATERSHELL
#define _N watershell

#if defined(__BINDC)
#define __FCFLOAT c_double 
#define __CFLOAT double 
#define __CFLOATFMT "%lf"
#define __FCINT c_int
#define __CINT int
#define __CINTFMT "%d"
#define __FCBOOL c_bool
#define __CBOOL _Bool
#define __FCCHAR c_char
#define __CCHAR char
#endif

#define __NM(_S) __CONCAT3(_N,_,_S)
#define __SUB(_S) subroutine __NM(_S)
#define __FUN(_S) function __NM(_S)

#ifdef __DBGOUT
#undef __DBGOUT
#endif

#ifdef __DEBUG
#define __DBGOUT(...) __MESG(whoami, 'DEBUG:', __VA_ARGS__)
#define __DBGVAR(_V,_LEV) if (_LEV <=_DBGLEV) then ;  __DBGOUT(__STRING(_V),':=',_V) ; endif
#else
#define __DBGOUT(...)
#define __DBGVAR(...)
#endif
#//define __DBGOUT(...)
#//define __DBGVAR(...)


#//sanity checks :
#ifdef __RMFT

#if defined(__HAMILTONIAN)
#error(CANNOT SET BOTH __RMFT AND __HAMILTONIAN. STOPPING)
#endif

#if defined(__SIMPLE_NET_FORCE_SOLVENT) && defined(__SIMPLE_NET_FORCE_SURFACE)
#error(CANNOT SET BOTH __SIMPLE_NET_FORCE_SOLVENT AND __SIMPLE_NET_FORCE_SURFACE. STOPPING)
#endif

#if defined(__TORQUE_COM_SOLVENT) && defined(__TORQUE_COM_SURFACE)
#error(CANNOT SET BOTH __TORQUE_COM_SOLVENT AND __TORQUE_COM_SURFACE. STOPPING)
#elif !(defined(__TORQUE_COM_SOLVENT) || defined(__TORQUE_COM_SURFACE))
#error(MUST SET ONE EITHER __TORQUE_COM_SOLVENT OR __TORQUE_COM_SURFACE. STOPPING)
#endif

#if defined(__TORQUE_FROM_FORCED_SOLVENT) && defined(__TORQUE_FROM_FREE_SOLVENT)
#define __TORQUE_FROM_ALL_SOLVENT
#else
#undef __TORQUE_FROM_ALL_SOLVENT
#endif


#if !(defined(__TORQUE_FROM_FORCED_SOLVENT) || defined(__TORQUE_FROM_FREE_SOLVENT))
#error(TORQUE REMOVAL NEEDS AT LEAST ONE OF __TORQUE_FROM_FORCED_SOLVENT or __TORQUE_FROM_FREE_SOLVENT TO BE SET)
#endif

#ifndef __TORQUE_COM_SOLVENT
#define __F_T_COUPLED
#endif

#endif

#define __CLASS // to bind OOP style procedure pointers in type

#ifdef __UNWRAP_PBC
#define __PBC_UNWRAP
#elif defined(__PBC_UNWRAP)
#define __UNWRAP_PBC
#endif

