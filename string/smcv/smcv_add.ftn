! THIS FILE CONTAINS ROUTINES FOR ADDING NEW CV
! THERE IS A SEPARATE ROUTINE FOR EACH CV TYPE
!
#define __SETQROOT qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0
!
#define __IFMTW 664
#define __IFMTNOW 665
#define __FMTW    "(A,' WILL ADD ',A,' CV WITH K =',F10.3,' WEIGHT =',F7.3,' AND GAMMA =',F7.3)"
#define __FMTNOW  "(A,' WILL ADD ',A,' CV WITH K =',F10.3,' AND GAMMA =',F7.3)"
!
#define __GET(_V, _NM, _TYPE, _DEF) if (__INDX(comlyn, comlen, __STRING(_NM), len(__STRING(_NM))).gt.0) then;\
                                     _V=__CONCAT(__GET_RM_,_TYPE)(comlyn,comlen,__STRING(_NM),_DEF);
!====================================
      module smcv_add
!
__CHARMM_ONLY##IF STRINGM
      use cv_types
      use cv_common
      use ivector
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI
      __DEP_OUTPUT
      __DEP_SIZE
      __DEP_COORDINATES
      __DEP_PARSER
      __DEP_MPI
      __DEP_SELECT
      __DEP_NUMBER
!
      __IMPNONE
!
 __DECLARE_MSGBUF

      private
      public smcv_add_cv
      public smcv_frame_add
!
      bool, save :: qroot
      float :: k, w, gam, temp
!
      contains
!cccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_add_kwg(comlyn,comlen)
      character(len=*) :: comlyn
      int :: comlen
      k=zero;__GET(k,FORC,F,zero) ! force k
      else  __GET(k,FC,   F,zero)
      endif
      w=-one;__GET(w,WEIG,F,-one) ! weight
      else   __GET(w,WGT, F,-one)
      endif
      gam=one;__GET(gam,GAM,F,one) ! friction
      else    __GET(gam,GM, F,one)
      endif
      end subroutine smcv_add_kwg
!cccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_add_cv(comlyn,comlen)
      use cv_quaternion, only: quat_initialized, quat, quat_init
      use sm_config, only: qt_send_displ, qt_send_count, imap_displ, imap_count
      use smcv_check_set
      __DEP_CONST
!
      character(len=*) :: COMLYN
      int :: COMLEN
!    local
      int :: i, j, k, ind
      bool :: qfbwidth, qtemp, qbc
      float :: fbwidth
      character(len=20) :: keyword
      __IAM(SMCV_ADD)
__SETQROOT
!
      keyword=__NEXTLONGA(comlyn,comlen)  ! directive
!
      ind=0
! preprocessor tricks to simplify code
      qfbwidth=.true. ! whether to check for flat-bottom width specification after default add
      qtemp=.true. ! whether to check for BD evolution temperature specification after default add
      qbc=.true. ! whether to check for CV boundary (min/max) values
      if (.false.) then ! note that the statements below _WILL_ be executed
#define __TRY(__WHAT) elseif (__STRNCMP(keyword,__STRING(__WHAT),len(__STRING(__WHAT)))) then; call smcv_add_kwg(comlyn,comlen); ind=__CONCAT3(smcv_,__WHAT,_add)(__ADD_ARGS)
#define __ADD_ARGS comlyn, comlen /* note that these two arguments are considered a single argument by CPP */
#define smcv_POSI_COM_X_add(__1,...) smcv_posi_com_add(__1, (/one, zero, zero/))
#define smcv_POSI_COM_Y_add(__1,...) smcv_posi_com_add(__1, (/zero, one, zero/))
#define smcv_POSI_COM_Z_add(__1,...) smcv_posi_com_add(__1, (/zero, zero, one/))
#define smcv_DRMSD_add(__1,...) smcv_rmsd_add(__1, drmsd)
#define smcv_PROJ_add(__1,...) smcv_rmsd_add(__1, proj)
!
      __TRY(POSI_COM_X)
      __TRY(POSI_COM_Y)
      __TRY(POSI_COM_Z)
      __TRY(POSI_COM)
      __TRY(DIHE_COM)
      __TRY(ANGLE_COM)
      __TRY(ANGLVEC)
      __TRY(DIST_COM)
      __TRY(FRAME)      ; qfbwidth=.false.; qtemp=.false.; qbc=.false.
      __TRY(QUATERNION) ; qfbwidth=.false.; qbc=.false. ; ! this need not be in principle, but I struggle to envision a physical scenario in which it is useful; maybe later
! more quaternion-related code :
!     (re)compute quaternion index limits (for parallelization) after each addition
!
       if (SIZE_LOCAL.gt.0) then
        if (.not.quat_initialized) call quat_init() ! make sure frames%num_frames is defined
        j=ceiling(one*quat%num_quat/SIZE_LOCAL) ! max. number of frames assigned to slave node
        k=ceiling(one*cv%amap%last/SIZE_LOCAL) ! max. number of amap indices assigned to slave node
!
        do i=1,SIZE_LOCAL
         qt_send_displ(i)=min((i-1)*j,quat%num_quat-1) ! cannot exceed num_cv
         qt_send_count(i)=max(0,min(j,quat%num_quat-j*(i-1))) ! how many CV I will send to CPU i
! atom map partitioning (for parallel computation of M
!
         imap_displ(i)=min((i-1)*k,cv%amap%last-1)
         imap_count(i)=max(0,min(k,cv%amap%last-k*(i-1)))
        enddo
       endif ! SIZE
!=============================================================
      __TRY(DRMSD)
      __TRY(PROJ)
      __TRY(CVRMS)
#undef __ADD_ARGS
#define __ADD_ARGS comlyn, comlen, rmsd
      __TRY(RMSD)
      else
        __WARN(whoami,'UNRECOGNIZED CV TYPE: ',keyword)
      endif
!
      if (ind.gt.0) then
       if (qfbwidth) call smcv_check_set_fbwidth(comlyn,comlen,ind,ind,zero)
       if (qtemp) call smcv_check_set_temp(comlyn,comlen,ind,ind,zero)
       if (qbc) then ! minimum / maximum cv values
        call smcv_check_set_minval(comlyn,comlen,ind,ind,-__INF)
        call smcv_check_set_maxval(comlyn,comlen,ind,ind,__INF)
       endif
      endif ! valid index
!
#undef __TRY
      end subroutine smcv_add_cv
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccc CV-SPECIFIC CODE ccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function smcv_posi_com_add(comlyn, comlen, vec_) result(ind)
      use cv_posi_com
      use sm_var
      __DEP_BESTFIT
      __DEP_CONST
!
      character(len=*) comlyn
      int :: comlen
      float, optional :: vec_(3) ! projection vector can be passed in
!    locals
      character(len=10) :: key
      float :: vec(3) ! projection vector
!
#ifdef __CHARMM
      int :: imode, iselct(natom)
#elif defined(__DMOL)
 __DECLARE_DMOL_SELECT
#endif
!
      int :: i, j, nslct, ind
      int :: frame
      type (int_vector) :: posi_com_list ! for storing atom indices
!
      __IAM(SMCV_POSI_COM_ADD)
      __STRING_PAR(cv_name, POSI_COM)
!
__SETQROOT
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
             __GET(frame,FR,I,0)
        endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      ind=0
!     now process atom selections;
!     expecting 1 atom group
#ifdef __CHARMM
      imode=0
      CALL SELRPN(COMLYN,COMLEN,ISELCT,NATOM,1,IMODE,                    &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
      IF(IMODE.NE.0) THEN
       CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
       RETURN
      ENDIF
      NSLCT=NSELCT(NATOM,ISELCT)
!
#elif defined(__DMOL)
#include "dmol_select_macro.def"
      if (associated(__INDEX)) then ; nslct=size(__INDEX) ; else ; nslct=0 ; endif
#endif
!
      if(nslct.eq.0) then
       __WRN(whoami,'ZERO ATOMS SELECTED. ABORTING.')
#ifdef __DMOL
       __FREE(__INDEX)
#endif
       return
      endif
!
      call int_vector_init(posi_com_list)
#ifdef __CHARMM
      do i=1,natom ! loop over all atoms
       if (iselct(i).eq.1) then
        j=int_vector_add(posi_com_list,i)
        if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
       endif
      enddo
#elif defined (__DMOL)
      do i=1,size(__INDEX)
       j=int_vector_add(posi_com_list,__INDEX (i))
       if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
      enddo
      __FREE(__INDEX)
#endif
!
! now process specification of projection vector
! this is a 3-point vector specification
! if omitted, the current selection will provide the projection vector (origin to com-position)
!
     if (present(vec_)) then
      vec=vec_
     else
      vec=zero
!     now process projection vector specification
       key=__NEXTA(comlyn, comlen)
       if (__STRNCMP(key,'V',1)&
     & .or.__STRNCMP(key,'VEC',3)&
     & .or.__STRNCMP(key,'VECTOR',5)&
     & .or.__STRNCMP(key,'PROJ',4)&
     & .or.__STRNCMP(key,'PROJECT',7)&
     & .or.__STRNCMP(key,'PROJECTION',8)) then
       ! specify point manually
       do i=1,3;  vec(i)=__NEXTF(comlyn, comlen); enddo
       endif ! vector spec
      endif
!     print short summary
      if (qroot) then
       if (w.lt.zero) then
        write(_MSGBUF, __FMTNOW) whoami,cv_name,k,gam
       else
        write(_MSGBUF, __FMTW) whoami,cv_name,k,w,gam
       endif
!
       if (frame.ge.1) then
        write(_MSGBUF(2),'(A,I3)') whoami//' RELATIVE TO LOCAL FRAME ',frame
       else
        write(_MSGBUF(2),'(A)') whoami//' RELATIVE TO THE ABSOLUTE FRAME'
       endif
!
       if ( norm3(vec).gt.zero ) then
        write(_MSGBUF(3),'(A,3'//real_fmt//',A)')  whoami//' THE PROJECTION VECTOR IS (', vec, ')'
       endif
       __PRINT(_MSGBUF) ! qroot
      endif
!
!       now attempt to add CV
      ind=cv_posi_com_add(posi_com,posi_com_list,k,gam,w,max(frame,0),vec) ! no mass weighting; disallow negative frame indices
      if (ind.le.0) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate lists
      call int_vector_done(posi_com_list)
!     done!
      end function smcv_posi_com_add
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function smcv_dihe_com_add(comlyn, comlen) result(ind)
      use cv_dihe_com
!
      character(len=*) :: comlyn
      int :: comlen
!    locals
      __STRING_PAR(cv_name, DIHE_COM)
!
#ifdef __CHARMM
      int :: imode, iselct(natom)
#elif defined (__DMOL)
 __DECLARE_DMOL_SELECT
#endif
!
      int :: i, j, atom_group, nslct, ind
      type (int_vector), dimension(4) :: dihe_com_list ! for storing atom indices
!
      __IAM(SMCV_DIHE_COM_ADD)
!
__SETQROOT
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! (none)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      ind=0
!     now process atom selections;
!     expecting 4 atom selections that specify each atom group in succession;
!     process each selection sequentially
      do atom_group=1,4
!
#ifdef __CHARMM
!
       imode=0
       CALL SELRPN(COMLYN,COMLEN,ISELCT,NATOM,1,IMODE,                   &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
       IF(IMODE.NE.0) THEN
        CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
        RETURN
       ENDIF
!
       NSLCT=NSELCT(NATOM,ISELCT)
!
#elif defined(__DMOL)
#include "dmol_select_macro.def"
      if (associated(__INDEX)) then ; nslct=size(__INDEX) ; else ; nslct=0 ; endif
#endif
!
       IF(NSLCT.EQ.0) THEN
       __WRN(whoami,'ZERO ATOMS SELECTED. ABORTING.')
#ifdef __DMOL
       __FREE(__INDEX)
#endif
       return
       endif
!
       call int_vector_init(dihe_com_list(atom_group))
#ifdef __CHARMM
       do i=1,natom ! loop over all atoms
        if (iselct(i).eq.1) then
         j=int_vector_add(dihe_com_list(atom_group),i)
         if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
        endif
       enddo
!
#elif defined (__DMOL)
       do i=1,size(__INDEX)
        j=int_vector_add(dihe_com_list(atom_group),__INDEX(i))
        if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
       enddo
       __FREE(__INDEX)
#endif
      enddo ! loop over dihe_com selections
!
!     print short summary
      if (qroot) then
       if (w.lt.zero) then
        write(_MSGBUF, __FMTNOW) whoami,cv_name,k,gam
       else
        write(_MSGBUF, __FMTW) whoami,cv_name,k,w,gam
       endif
       __PRINT(_MSGBUF)
      endif
!
!       now attempt to add CV
      ind=cv_dihe_com_add(dihe_com_list,k,gam,w) ! no mass weighting
      if (ind.le.0) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate lists
      do i=1,4; call int_vector_done(dihe_com_list(i)); enddo
!     done!
      end function smcv_dihe_com_add
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function smcv_angle_com_add(comlyn, comlen) result(ind)
      use cv_angle_com
!
      character(len=*) :: comlyn
      int :: comlen
!    locals
      __STRING_PAR(cv_name, ANGLE_COM)
!
#ifdef __CHARMM
      int :: imode, iselct(natom)
#elif defined (__DMOL)
 __DECLARE_DMOL_SELECT
#endif
!
      int :: i, j, atom_group, nslct, ind
      type (int_vector), dimension(3) :: angle_com_list ! for storing atom indices
!
      __IAM(SMCV_ANGLE_COM_ADD)
__SETQROOT
!
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! (none)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      ind=0
!     now process atom selections;
!     expecting 3 atom selections that specify each atom group in succession;
!     process each selection sequentially
      do atom_group=1,3
#ifdef __CHARMM
       imode=0
       CALL SELRPN(COMLYN,COMLEN,ISELCT,NATOM,1,IMODE,                   &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
       IF(IMODE.NE.0) THEN
        CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
        RETURN
       ENDIF
!
       NSLCT=NSELCT(NATOM,ISELCT)
#elif defined(__DMOL)
#include "dmol_select_macro.def"
      if (associated(__INDEX)) then ; nslct=size(__INDEX) ; else ; nslct=0 ; endif
#endif
!
       if (nslct.eq.0) then
        __WRN(whoami,'ZERO ATOMS SELECTED. ABORTING.')
#ifdef __DMOL
        __FREE(__INDEX)
#endif
        return
       endif
!
       call int_vector_init(angle_com_list(atom_group))
#ifdef __CHARMM
       do i=1,natom ! loop over all atoms
        if (iselct(i).eq.1) then
         j=int_vector_add(angle_com_list(atom_group),i)
         if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
        endif
       enddo
#elif defined(__DMOL)
       do i=1,size(__INDEX)
        j=int_vector_add(angle_com_list(atom_group),__INDEX (i))
        if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
       enddo
       __FREE(__INDEX)
#endif
      enddo ! loop over angle_com selections
!
!     print short summary
      if (qroot) then
       if (w.lt.zero) then
        write(_MSGBUF, __FMTNOW) whoami,cv_name,k,gam
       else
        write(_MSGBUF, __FMTW) whoami,cv_name,k,w,gam
       endif
       __PRINT(_MSGBUF)
      endif
!
!       now attempt to add CV
      ind=cv_angle_com_add(angle_com_list,k,gam,w) ! no mass weighting
      if (ind.le.0) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate lists
      do i=1,3; call int_vector_done(angle_com_list(i)); enddo
!     done!
      end function smcv_angle_com_add
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function smcv_dist_com_add(comlyn, comlen) result(ind)
      use cv_dist_com
!
      character(len=*) comlyn
      int :: comlen
!    locals
      __STRING_PAR(cv_name, DIST_COM)
!
#ifdef __CHARMM
      int :: imode, iselct(natom)
#elif defined (__DMOL)
 __DECLARE_DMOL_SELECT
#endif
!
      int :: i, j, atom_group, nslct, ind
      type (int_vector), dimension(2) :: dist_com_list ! for storing atom indices
!
      __IAM(SMCV_DIST_COM_ADD)
!
__SETQROOT
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!(none)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      ind=0
!     now process atom selections;
!     expecting 2 atom selections that specify each atom group in succession;
!     process each selection sequentially
      do atom_group=1,2
!
#ifdef __CHARMM
!
       imode=0
       CALL SELRPN(COMLYN,COMLEN,ISELCT,NATOM,1,IMODE,                   &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
       IF(IMODE.NE.0) THEN
        CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
        RETURN
       ENDIF
!
       NSLCT=NSELCT(NATOM,ISELCT)
!
#elif defined (__DMOL)
#include "dmol_select_macro.def"
      if (associated(__INDEX)) then ; nslct=size(__INDEX) ; else ; nslct=0 ; endif
#endif
!
       if (nslct.eq.0) then
        __WRN(whoami,'ZERO ATOMS SELECTED. ABORTING.')
#ifdef __DMOL
        __FREE(__INDEX)
#endif
        return
       endif
!
       call int_vector_init(dist_com_list(atom_group))
#ifdef __CHARMM
       do i=1,natom ! loop over all atoms
        if (iselct(i).eq.1) then
         j=int_vector_add(dist_com_list(atom_group),i)
         if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
        endif
       enddo
#elif defined (__DMOL)
       do i=1,size(__INDEX)
        j=int_vector_add(dist_com_list(atom_group),__INDEX (i))
        if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
       enddo
       __FREE(__INDEX)
#endif
      enddo ! loop over dist_com selections
!
!     print short summary
      if (qroot) then
       if (w.lt.zero) then
        write(_MSGBUF, __FMTNOW) whoami,cv_name,k,gam
       else
        write(_MSGBUF, __FMTW) whoami,cv_name,k,w,gam
       endif
       __PRINT(_MSGBUF)
      endif
!
      ind=cv_dist_com_add(dist_com_list,k,gam,w) ! no mass weighting
      if (ind.le.0) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate lists
      do i=1,2; call int_vector_done(dist_com_list(i)); enddo
!     done!
      end function smcv_dist_com_add
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function smcv_anglvec_add(comlyn, comlen) result(ind)
      use cv_anglvec
!
      character(len=*) :: comlyn
      int :: comlen
!    locals
      __STRING_PAR(cv_name, ANGLVEC)
      character(len=8) :: key
!
#ifdef __CHARMM
      int ::  imode, iselct(natom)
#elif defined (__DMOL)
 __DECLARE_DMOL_SELECT
#endif
!
      int :: i, ipt, j, l, nslct, ind
      type (int_vector), dimension(4) :: atom_list ! for storing atom indices
      int :: f1, f2
      float :: p(4,3) ! for point definition
      bool :: qp1=.false., qp2=.false., qp3=.false., qp4=.false.
!
      __IAM(SMCV_ANGLVEC_ADD)
!
__SETQROOT
!     first check for CV options
      ind=0
!    check for frame specification, so that comlyn is cleaned up
      f1=0;__GET(f1,F1,I,0)
      else __GET(f1,FR1,I,0)
      else __GET(f1,FRA1,I,0)
      else __GET(f1,FRAM1,I,0)
      else __GET(f1,FRAME1,I,0)
      endif
      f2=0;__GET(f2,F2,I,0)
      else __GET(f2,FR2,I,0)
      else __GET(f2,FRA2,I,0)
      else __GET(f2,FRAM2,I,0)
      else __GET(f2,FRAME2,I,0)
      endif
!
!    initialize atom arrays
      do i=1,4; call int_vector_init(atom_list(i)); enddo
!
      p=zero ! initialize points
      do l=1,4
!     now process vector specifications (expecting four points)
       key=__NEXTA(comlyn, comlen)
       if (__STRNCMP(key,'P1',2)) then
        ipt=1 ;        qp1=.true.
       elseif (__STRNCMP(key,'P2',2)) then
        ipt=2 ;        qp2=.true.
       elseif (__STRNCMP(key,'P3',2)) then
        ipt=3 ;        qp3=.true.
       elseif (__STRNCMP(key,'P4',2)) then
        ipt=4 ;        qp4=.true.
       else
        __WARN(whoami,'VECTOR DEFINITION ERROR. EXPECTED "P[1-4]", GOT "',key,'"')
       endif
!
       __TRIMA(comlyn, comlen)
       if (__INDX(comlyn, comlen, 'SELE', 4).eq.1) then ! next word is select
!ccccccccccccc process atom selection
#ifdef __CHARMM
!
        imode=0
        CALL SELRPN(COMLYN,COMLEN,ISELCT,NATOM,1,IMODE,                  &
     &       .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,         &
     &       .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
        IF(IMODE.NE.0) THEN
         CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
         RETURN
        ENDIF
!
        NSLCT=NSELCT(NATOM,ISELCT)
!
#elif defined(__DMOL)
#include "dmol_select_macro.def"
      if (associated(__INDEX)) then ; nslct=size(__INDEX) ; else ; nslct=0 ; endif
#endif
!
        IF(NSLCT.EQ.0) THEN
         __WRN(whoami,'ZERO ATOMS SELECTED. ABORTING.')
#ifdef __DMOL
         __FREE(__INDEX)
#endif
         return
        endif
!
#ifdef __CHARMM
        do i=1,natom ! loop over all atoms
         if (iselct(i).eq.1) then
          j=int_vector_add(atom_list(ipt),i)
          if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
         endif
        enddo
#elif defined(__DMOL)
       do i=1,size(__INDEX)
        j=int_vector_add(atom_list(ipt),__INDEX (i))
        if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
       enddo
       __FREE(__INDEX)
#endif
!
       else ! specify point manually
        do i=1,3;  p(ipt,i)=__NEXTF(comlyn, comlen); enddo
       endif
      enddo
!    check that all four points have been added
      if (.not.(qp1.and.qp2.and.qp3.and.qp4)) then
       __WRN(whoami,'SOME POINTS WERE NOT DEFINED. NOTHING DONE')
       return
      endif
!
!     print short summary
      if (qroot) then
       if (w.lt.zero) then
        write(_MSGBUF, __FMTNOW) whoami,cv_name,k,gam
       else
        write(_MSGBUF, __FMTW) whoami,cv_name,k,w,gam
       endif
       __PRINT(_MSGBUF)
      endif
!
!       now attempt to add CV
      ind=cv_anglvec_add(atom_list,p,f1,f2,k,gam,w) ! no mass weighting
      if (ind.le.0) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate lists
      do i=1,4; call int_vector_done(atom_list(i)); enddo
!     done!
      end function smcv_anglvec_add
!cccccccccccccccccccccccccccccccccccccccccccccccccccccc
!    'frame' is not really a CV but processed here for convenience
      function smcv_frame_add(comlyn, comlen) result(ind)
      use cv_frames
!
      character(len=*) :: comlyn
      int :: comlen
!    locals
#ifdef __CHARMM
      int :: imode, iselct(natom)
#elif defined(__DMOL)
 __DECLARE_DMOL_SELECT
#endif
      int :: i, j, nslct, ind
      type (int_vector) :: frame_list ! for storing atom indices
!
      __IAM(SMCV_FRAME_ADD)
!
__SETQROOT
!     process atom selections;
!     specify atom group
#ifdef __CHARMM
!
      imode=0
      CALL SELRPN(COMLYN,COMLEN,ISELCT,NATOM,1,IMODE,                    &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
      IF(IMODE.NE.0) THEN
       CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
       RETURN
      ENDIF
!
      NSLCT=NSELCT(NATOM,ISELCT)
!
#elif defined(__DMOL)
#include "dmol_select_macro.def"
      if (associated(__INDEX)) then ; nslct=size(__INDEX) ; else ; nslct=0 ; endif
#endif
!
      if (nslct.lt.4) then ! require at least four atoms, otherwise, can never define frame uniquely
       __WRN(whoami,' FEWER THAN FOUR ATOMS SELECTED. ABORTING.')
#ifdef __DMOL
       __FREE(__INDEX)
#endif
       return
      endif
!
      call int_vector_init(frame_list)
#ifdef __CHARMM
      do i=1,natom ! loop over all atoms
       if (iselct(i).eq.1) then
         j=int_vector_add(frame_list,i)
         if (j.le.0) then 
          __WRN(whoami,'COULD NOT ADD ATOM INDEX TO FRAME LIST.')
         endif
       endif
      enddo
#elif defined(__DMOL)
      do i=1,size(__INDEX)
       j=int_vector_add(frame_list,__INDEX (i))
       if (j.le.0) then 
        __WRN(whoami,'COULD NOT ADD ATOM INDEX TO FRAME LIST.')
       endif
      enddo
      __FREE(__INDEX)
#endif
!
!     print short summary
      if (qroot) then
       write(_MSGBUF, __IFMTW) whoami ; __PRINT(_MSGBUF)
      endif
!
  __IFMTW format(/A,' WILL ADD NEW REFERENCE FRAME')
!       now attempt to add frame
      ind=frames_add(frame_list)
      if (ind.le.0) then
       __WRN(whoami,'COULD NOT ADD FRAME.')
      endif
!     deallocate lists
      call int_vector_done(frame_list)
!     done!
      end function smcv_frame_add
!cccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function smcv_quaternion_add(comlyn, comlen) result(ind)
      use cv_qcomp
!
      character(len=*) :: comlyn
      int :: comlen
!    locals
      __STRING_PAR(cv_name,QUATERNION)
      int :: f1, f2, ind
!
      __IAM(SMCV_QUATERNION_ADD)
!
__SETQROOT
!     first check for frame spec.
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      f1=0;__GET(f1,F1,I,0)
      else __GET(f1,FR1,I,0)
      else __GET(f1,FRA1,I,0)
      else __GET(f1,FRAM1,I,0)
      else __GET(f1,FRAME1,I,0)
      endif
      f2=0;__GET(f2,F2,I,0)
      else __GET(f2,FR2,I,0)
      else __GET(f2,FRA2,I,0)
      else __GET(f2,FRAM2,I,0)
      else __GET(f2,FRAME2,I,0)
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      ind=0
!     print short summary
      if (qroot) then
!
       if (w.lt.zero) then
        write(_MSGBUF, __FMTNOW) whoami,cv_name,k,gam
       else
        write(_MSGBUF, __FMTW) whoami,cv_name,k,w,gam
       endif
!
       if (f1.ge.1) then
        write(_MSGBUF(2),'(A,I3)') whoami//' FRAME1: LOCAL FRAME #',f1
       else
        write(_MSGBUF(2),'(A)') whoami//' FRAME1: ABSOLUTE FRAME'
       endif
!
       if (f2.ge.1) then
        write(_MSGBUF(3),'(A,I3)') whoami//' FRAME2: LOCAL FRAME #',f2
       else
        write(_MSGBUF(3),'(A)') whoami//' FRAME2: ABSOLUTE FRAME'
       endif
       __PRINT(_MSGBUF)
!
      endif
!
!       now attempt to add quaternion components, one by one:
      ind=min(cv_qcomp_add(qcomp_1, f1, f2, k, gam, w),                  &
     &        cv_qcomp_add(qcomp_2, f1, f2, k, gam, w),                  &
     &        cv_qcomp_add(qcomp_3, f1, f2, k, gam, w),                  &
     &        cv_qcomp_add(qcomp_4, f1, f2, k, gam, w))
!
      if (ind.le.0) then
       __WRN(whoami,'COULD NOT ADD QUATERNION CV')
      endif
!     done!
      end function smcv_quaternion_add
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function smcv_cvrms_add(comlyn, comlen) result(ind)
!     this CV is an RMS combination of existing CV; experimental and not fully implemented (intented for steered dynamics)
      use cv_cvrms
      use parselist
!
      character(len=*) :: comlyn
      int :: comlen
!    locals
      __STRING_PAR(cv_name, CVRMS)
      int :: ind
      type (int_vector) :: cv_list ! for storing cv indices used to calculate RMS
!
      __IAM(SMCV_CVRMS_ADD)
!
__SETQROOT
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!(none)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      ind=0
! specify cv to use in the RMS definition
      call ilist_parse(cv_list, comlyn) ! will return allocated cv_list with the indices
!
!     print short summary
      if (qroot) then
       if (w.lt.zero) then
        write(_MSGBUF, __FMTNOW) whoami,cv_name,k,gam
       else
        write(_MSGBUF, __FMTW) whoami,cv_name,k,w,gam
       endif
       __PRINT(_MSGBUF)
      endif
!
!       now attempt to add CV
      ind=cv_cvrms_add(cv_list,k,gam,w) ! no mass weighting
      if (ind.le.0) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate list
      call int_vector_done(cv_list)
!     done!
      end function smcv_cvrms_add
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function smcv_rmsd_add(comlyn, comlen, cvtype) result(ind)
!     much of the code taken from RTMD sources in ../misc
      use cv_rmsd, only : cv_rmsd_add
      use cv_drmsd, only : cv_drmsd_add
      use cv_proj, only : cv_proj_add
      __DEP_CONST
!
      character(len=*) :: comlyn
      int :: comlen
      int :: cvtype
!    locals
      character(len=5) :: cv_name, keyword
      bool :: qorient, qtrans, qrota, qrms
      float :: rtarget_com(3)
!
      float, pointer :: rtarget_o(:,:), rtarget_f(:,:),                &
     &                  rtarget1_o(:,:), rtarget1_f(:,:),              &
     &                  orientWeights(:), forcedWeights(:)
      int, pointer :: iatom_o(:), iatom_f(:)
      int :: norient, nforced, ind
!
#ifdef __CHARMM
      int :: iselct(natom), jselct(natom)
      int :: imode
#elif defined (__DMOL)
 __DECLARE_DMOL_SELECT
 int, pointer :: iselct(:), jselct(:)
#endif
!
      int :: i, j, n
      float :: a, b
!
      bool :: use_main, use_comp, qroot, qmass, qtwo ! qtwo: true if using two target structures
!
      __IAM(SMCV_RMSD_ADD)
!
__SETQROOT
      ind=0
!
      select case (cvtype)
       case(rmsd ); cv_name='RMSD '; qtwo=.false.
       case(drmsd); cv_name='DRMSD'; qtwo=.true.
       case(proj ); cv_name='PROJ '; qtwo=.true.
       case default
        __WRN( whoami, 'UNKNOWN CV REQUESTED. NOTHING DONE.');
        return
      end select
!
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!(none)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     process atom selections
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#ifdef __CHARMM
      iselct=0
      jselct=0
#elif defined(__DMOL)
      nullify(iselct, jselct)
#endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     look for forcing atom selection
      if (__INDX(comlyn, comlen, 'RMS',3).gt.0) then
       keyword='RMS'
      elseif (__INDX(comlyn, comlen, 'FORCED',6).gt.0) then
       keyword='FORC'
      endif
!
      i=__INDX_RM(comlyn,comlen,trim(keyword))
      qrms=(i.gt.0)
!     first determine whether a selection keyword follows
      if (qrms) then
       n=comlen-i+1
       j=__INDX(comlyn(i:comlen), n, 'SELE', 4)
       if (j.le.0) then ! only if the ORIE directive exists
         __WRN(whoami,'ATOM SELECTION MUST BE SPECIFIED AFTER '//trim(keyword)//'.')
         return
        endif
!
! process forcing atom selection
!
#ifdef __CHARMM
        IMODE=0
        CALL SELRPN(COMLYN(i+j-1:comlen),n-j+1,jselct,NATOM,1,IMODE,                 &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
        IF(IMODE.NE.0) THEN
         CALL WRNDIE(0,whoami,'FORCED/RMSD ATOMS SELECTION ERROR')
         RETURN
        ENDIF
        nforced=count( jselct(1:natom).gt.0 )
#elif defined(__DMOL)
#undef  __INDEX
#define __INDEX jselct
#include "dmol_select_macro.def"
       if (associated(jselct)) then ; nforced=size(jselct) ; else ; nforced=0 ; endif
#endif
      else
       nforced=0
      endif ! qrms
!=======================================================================
      if (nforced.eq.0) then
       __WRN(whoami, ' FORCED/RMSD ATOMS NOT SPECIFIED. NOTHING DONE.')
       return
      endif
!=======================================================================
!     look for orientation atom selection
      i=__INDX_RM(comlyn,comlen,'ORIE')
      qorient=(i.gt.0)
!     first determine whether a selection keyword follows orie
      if (qorient) then
       n=comlen-i+1
       j=__INDX(comlyn(i:comlen), n, 'SELE', 4)
       if (j.le.0) then ! only if the ORIE directive exists
        __WRN(whoami,'ATOM SELECTION MUST BE SPECIFIED AFTER ORIE.')
        return
       endif
!
! process orientation selection
!
#ifdef __CHARMM
       IMODE=0
       CALL SELRPN(COMLYN(i+j-1:comlen),n-j+1,iselct,NATOM,1,IMODE,                 &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,         &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
       IF(IMODE.NE.0) THEN
         CALL WRNDIE(0,whoami,'ORIENTATION ATOMS SELECTION ERROR')
         RETURN
       ENDIF
       norient=count( iselct(1:natom).gt.0 )
#elif defined(__DMOL)
#undef __INDEX
#define __INDEX iselct
#include "dmol_select_macro.def"
       if (associated(iselct)) then ; norient=size(iselct) ; else ; norient=0 ; endif
#endif
! check for no-rotation and no-translation options in the orientation
       qtrans=(__INDX_RM(comlyn, comlen,'NOTR').eq.0)
       qrota=(__INDX_RM(comlyn, comlen,'NORO').eq.0)
       if (.not.(qtrans.or.qrota)) then
        __WRN(whoami, 'ORIENTATION WILL BE DISABLED BECAUSE TRANSLATIONAL AND ROTATIONAL FITTING ARE BOTH OFF.')
        qorient=.false.
        norient=0
       endif
      else
       norient=0
       qrota=.false.
       qtrans=.false.
      endif ! qorie
!
! check to make sure we have at least two orientation atoms
!
      if (qorient.and.norient.lt.2) then
       __WRN(whoami,' FEWER THAN TWO ATOMS SELECTED FOR ORIENTATION. ABORT.')
       return
      endif
!
      qmass=(__INDX_RM(comlyn, comlen, 'MASS').gt.0) ! mass-weighting flag
!
!============================================================== done with selections
      allocate(iatom_o(norient),                                        &
     &  iatom_f(nforced),                                               &
     &  rtarget_o(norient,3),                                           &
     &  rtarget_f(nforced,3),                                           &
     &  orientWeights(norient),                                         &
     &  forcedWeights(nforced))
      if (qtwo) allocate(rtarget1_o(norient,3),rtarget1_f(nforced,3))
!
!     initialize arrays
      iatom_o=0; iatom_f=0;
      rtarget_o=zero;  rtarget_f=zero;
      if (qtwo) then ; rtarget1_o=zero;  rtarget1_f=zero; endif ! second structure
      orientWeights=one; forcedWeights=one
!
!    build index arrays
#ifdef __CHARMM
      norient=0
      nforced=0
!
      if (qorient) then
       do i=1,natom
        if (iselct(i).gt.0) then
         norient=norient+1
         iatom_o(norient)=i
        endif
       enddo
      endif
!
      do i=1,natom
       if (jselct(i).gt.0) then
        nforced=nforced+1
        iatom_f(nforced)=i
       endif
      enddo
!      enddo
#elif defined(__DMOL)
! NOTE that in DMOL, iselct has a different meaning: it stores the atom indices, rather than flags
      if (associated(iselct)) then ; iatom_o=iselct ; deallocate(iselct) ; endif
      if (associated(jselct)) then ; iatom_f=jselct ; deallocate(jselct) ; endif
#endif
!========== mass-weighting
      if (qmass) then
        do i=1,norient
         orientWeights(i)=                                              &
     &    __MASS(iatom_o(i))*orientWeights(i)
        enddo
!
        do i=1, nforced
         forcedWeights(i)=                                              &
     &    __MASS(iatom_f(i))*forcedWeights(i)
        enddo
!
      endif
!========================================================
!     load and save coordinates of the target structure
      use_main=((__INDX_RM(comlyn,comlen,'MAIN')).gt.0)
      use_comp=((__INDX_RM(comlyn,comlen,'COMP')).gt.0)
      if (use_comp) then
        if (use_main) then
         __WRN(whoami,'MAIN AND COMP CANNOT BOTH BE SPECIFIED. USING MAIN.')
         use_comp=.false.
        endif
      else
        use_main=.true. ! default
      endif
!
      if (use_comp) then
! orient
        do i=1,norient
         rtarget_o(i,1)=__XXCOMP(iatom_o(i))
         rtarget_o(i,2)=__YYCOMP(iatom_o(i))
         rtarget_o(i,3)=__ZZCOMP(iatom_o(i))
        enddo
! forced
        do i=1,nforced
         rtarget_f(i,1)=__XXCOMP(iatom_f(i))
         rtarget_f(i,2)=__YYCOMP(iatom_f(i))
         rtarget_f(i,3)=__ZZCOMP(iatom_f(i))
        enddo
! second reference structure:
        if (qtwo) then
         do i=1,norient
          rtarget1_o(i,1)=__XX(iatom_o(i))
          rtarget1_o(i,2)=__YY(iatom_o(i))
          rtarget1_o(i,3)=__ZZ(iatom_o(i))
         enddo
!
         do i=1,nforced
          rtarget1_f(i,1)=__XX(iatom_f(i))
          rtarget1_f(i,2)=__YY(iatom_f(i))
          rtarget1_f(i,3)=__ZZ(iatom_f(i))
         enddo
        endif ! qtwo
!
      else ! use main coordinates
! orient
        do i=1,norient
         rtarget_o(i,1)=__XX(iatom_o(i))
         rtarget_o(i,2)=__YY(iatom_o(i))
         rtarget_o(i,3)=__ZZ(iatom_o(i))
        enddo
! forced
        do i=1,nforced
         rtarget_f(i,1)=__XX(iatom_f(i))
         rtarget_f(i,2)=__YY(iatom_f(i))
         rtarget_f(i,3)=__ZZ(iatom_f(i))
        enddo
! second reference structure:
        if (qtwo) then
         do i=1,norient
          rtarget1_o(i,1)=__XXCOMP(iatom_o(i))
          rtarget1_o(i,2)=__YYCOMP(iatom_o(i))
          rtarget1_o(i,3)=__ZZCOMP(iatom_o(i))
         enddo
!
         do i=1,nforced
          rtarget1_f(i,1)=__XXCOMP(iatom_f(i))
          rtarget1_f(i,2)=__YYCOMP(iatom_f(i))
          rtarget1_f(i,3)=__ZZCOMP(iatom_f(i))
         enddo
        endif ! qtwo
!
      endif ! use_comp
!
!      check for undefined values
!      allow undefined values for plugins (i.e. unless CHARMM is defined)
!      this is a hack to make sure that the plugin survives the initialization
!      call from the host code, which might not contain coordinates
      if ( (qorient.and.any(rtarget_o.eq.__NAN)).or.any(rtarget_f.eq.__NAN)) then
        __WRN(whoami,'FIRST TARGET STRUCTURE HAS UNDEFINED COORDINATES. QUITTING.')
__CHARMM_ONLY   return
      elseif (qtwo) then
       if ( (qorient.and.any(rtarget1_o.eq.__NAN)).or.any(rtarget1_f.eq.__NAN)) then
        __WRN(whoami,'SECOND TARGET STRUCTURE HAS UNDEFINED COORDINATES. QUITTING.')
__CHARMM_ONLY   return
       endif
      endif
!
! normalize weighting coefficients
! note: routines in rtmd_aux do _not_ perform normalization; result affects FP precision, analytically, there is no difference
!
      if (qorient) then
       a=sum(orientWeights)
       if (abs(a).gt.__ERRTOL) then
        a=one/a
        orientWeights=a*orientWeights
       endif
      endif
!
      b=sum(forcedWeights)
      if (abs(b).gt.__ERRTOL) then
       b=one/b
       forcedWeights=b*forcedWeights
      endif
!
! translate target structure so that its centroid is at the origin
      if (qorient .and. qtrans) then ! only if orientation and translational fitting are enabled (otherwise we need the absolute position of com)
                                     ! however, this is to be removed after all rms-based cvs support no translation with rotation
       rtarget_com=matmul(transpose(rtarget_o),orientWeights)
!
       rtarget_o(:,1)=rtarget_o(:,1)-rtarget_com(1)
       rtarget_o(:,2)=rtarget_o(:,2)-rtarget_com(2)
       rtarget_o(:,3)=rtarget_o(:,3)-rtarget_com(3)
!
       rtarget_f(:,1)=rtarget_f(:,1)-rtarget_com(1)
       rtarget_f(:,2)=rtarget_f(:,2)-rtarget_com(2)
       rtarget_f(:,3)=rtarget_f(:,3)-rtarget_com(3)
!
       if (qtwo) then ! repeat for second structure
        rtarget_com=matmul(transpose(rtarget1_o),orientWeights)
!
        rtarget1_o(:,1)=rtarget1_o(:,1)-rtarget_com(1)
        rtarget1_o(:,2)=rtarget1_o(:,2)-rtarget_com(2)
        rtarget1_o(:,3)=rtarget1_o(:,3)-rtarget_com(3)
!
        rtarget1_f(:,1)=rtarget1_f(:,1)-rtarget_com(1)
        rtarget1_f(:,2)=rtarget1_f(:,2)-rtarget_com(2)
        rtarget1_f(:,3)=rtarget1_f(:,3)-rtarget_com(3)
       endif ! qtwo
      endif ! qorient
!
!    print summary
      if (qroot) then
!
       if (w.lt.zero) then
        write(_MSGBUF, __FMTNOW) whoami,cv_name,k,gam
       else
        write(_MSGBUF, __FMTW) whoami,cv_name,k,w,gam
       endif
!
       i=1;
       __INC(i);write(_MSGBUF(i),103) whoami, nforced

       if (qorient) then
        __INC(i);write(_MSGBUF(i),100) whoami, norient
        if (.not.qrota) then
         __INC(i);write(_MSGBUF(i),'(2A)') whoami, ' BEST-FIT SUPERPOSITION WILL NOT INCLUDE ROTATIONAL FITTING'
        endif
        if (.not.qtrans) then
         __INC(i);write(_MSGBUF(i),'(2A)') whoami, ' BEST-FIT SUPERPOSITION WILL NOT INCLUDE TRANSLATIONAL FITTING'
        endif
!
       else ! no orientation
        __INC(i);write(_MSGBUF(i),'(2A)') whoami,' WILL NOT USE BEST-FIT SUPERPOSITION IN RMSD COMPUTATION'
       endif
       if (qmass) then 
        __INC(i);write(_MSGBUF(i),102) whoami
       endif
       if (qtwo) then
        if (use_comp) then
         __INC(i);write(_MSGBUF(i),105) whoami, 'COMP'
        else
         __INC(i);write(_MSGBUF(i),105) whoami, 'MAIN'
        endif
       else
        if (use_comp) then
         __INC(i);write(_MSGBUF(i),104) whoami, 'COMP'
        else
         __INC(i);write(_MSGBUF(i),104) whoami, 'MAIN'
        endif
       endif
       __PRINT(_MSGBUF)
!
 100  format(A,' WILL SUPERPOSE TARGET STRUCTURE(S) BASED ON ',i5,' (ORIENTATION) ATOMS')
 102  format(A,' WILL USE MASS-WEIGHTING.')
 103  format(A,' ',i5,' FORCED/RMSD ATOMS FOUND.')
 104  format(A,' TARGET STRUCTURE TAKEN FROM ',A,' SET.')
 105  format(A,' FIRST TARGET STRUCTURE TAKEN FROM ',A,' SET.')
!
      endif ! qroot
!       now attempt to add CV
      ind=0
      select case(cvtype)
       case(rmsd);
        ind=cv_rmsd_add(iatom_o, iatom_f, rtarget_o, rtarget_f,         &
     &               orientWeights, forcedWeights,                      &
     &               k, gam, w, qrota, qtrans)
       case(drmsd);
        ind=cv_drmsd_add(iatom_o, iatom_f, rtarget_o, rtarget_f,        &
     &               rtarget1_o, rtarget1_f,                            &
     &               orientWeights, forcedWeights,                      &
     &               k, gam, w)
       case(proj);
        ind=cv_proj_add(iatom_o, iatom_f, rtarget_o, rtarget_f,         &
     &               rtarget1_o, rtarget1_f,                            &
     &               orientWeights, forcedWeights,                      &
     &               k, gam, w)
      end select
!
      if (ind.le.0) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate variables
      deallocate(iatom_o, iatom_f, rtarget_o, rtarget_f,                &
     &           orientWeights, forcedWeights)
      if (qtwo) deallocate(rtarget1_o, rtarget1_f)
!
      end function smcv_rmsd_add
!
__CHARMM_ONLY##ENDIF
      end module smcv_add
