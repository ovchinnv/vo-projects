!
! THIS FILE CONTAINS ROUTINES FOR ADDING NEW CV
! THERE IS A SEPARATE ROUTINE FOR EACH CV TYPE
!
#if (defined(__CHARMM) || defined(__PARALLEL) )
__CHARMM_ONLY##IF STRINGM
!cccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_add(COMLYN,COMLEN)
      use cv_types
      use cv_common
      use cv_quaternion, only: quat_initialized, quat, quat_init
      use sm_config, only: qt_send_displ, qt_send_count,                &
     &                     imap_displ, imap_count
!
      __DEP_OUTPUT
      __DEP_PARSER
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __IMPNONE
!
 __DECLARE_MSGBUF
!
      character(len=*) :: COMLYN
      int :: COMLEN
!    local
      int i, j, k
      character(len=20) :: keyword
      __IAM(SMCV_ADD)
!
      keyword=__NEXTLONGA(comlyn,comlen)  ! directive
!     COM positions
      if (__STRNCMP(keyword,'POSI_COM_X',10)) then
       call smcv_posi_com_add(comlyn, comlen, posi_com_x) ! note: the same routine for all position coordinates
      else if (__STRNCMP(keyword,'POSI_COM_Y',10)) then
       call smcv_posi_com_add(comlyn, comlen, posi_com_y)
      else if (__STRNCMP(keyword,'POSI_COM_Z',10)) then
       call smcv_posi_com_add(comlyn, comlen, posi_com_z)
!     dihedral_COM
      else if (__STRNCMP(keyword,'DIHE_COM',8)) then
       call smcv_dihe_com_add(comlyn, comlen)
!     angle_COM
      else if (__STRNCMP(keyword,'ANGLE_COM',9)) then
       call smcv_angle_com_add(comlyn, comlen)
!     anglvec
      else if (__STRNCMP(keyword,'ANGLVEC',7)) then
       call smcv_anglvec_add(comlyn, comlen)
!     distance_COM
      else if (__STRNCMP(keyword,'DIST_COM',8)) then
       call smcv_dist_com_add(comlyn, comlen)
!     reference frame (not really a CV, but processed here)
      else if (__STRNCMP(keyword,'FRAME',5)) then
       call smcv_frame_add(comlyn, comlen)
!     orientation quaternion
      else if (__STRNCMP(keyword,'QUATERNION',10)) then
       call smcv_quaternion_add(comlyn, comlen)
!
!     (re)compute quaternion index limits (for parallelization) after each addition
!
       if (SIZE_LOCAL.gt.0) then
        if (.not.quat_initialized) call quat_init() ! make sure frames%num_frames is defined
        j=ceiling(1.0d0*quat%num_quat/SIZE_LOCAL) ! max. number of frames assigned to slave node
        k=ceiling(1.0d0*cv%amap%last/SIZE_LOCAL) ! max. number of amap indices assigned to slave node
!
        do i=1,SIZE_LOCAL
         qt_send_displ(i)=min((i-1)*j,quat%num_quat-1) ! cannot exceed num_cv
         qt_send_count(i)=max(0,min(j,quat%num_quat-j*(i-1))) ! how many CV I will send to CPU i
! atom map partitioning (for parallel computation of M
!
         imap_displ(i)=min((i-1)*k,cv%amap%last-1)
         imap_count(i)=max(0,min(k,cv%amap%last-k*(i-1)))
        enddo
       endif ! SIZE
!     rmsd from a target structure
      else if (__STRNCMP(keyword,'RMSD',4)) then
       call smcv_rmsd_add(comlyn, comlen, rmsd)
!     difference in the rmsd from two target structure (same routine!)
      else if (__STRNCMP(keyword,'DRMSD',5)) then
       call smcv_rmsd_add(comlyn, comlen, drmsd)
!     normalized projection onto the vector connecting two structures aligned with the simulation structure
      else if (__STRNCMP(keyword,'PROJ',4)) then
       call smcv_rmsd_add(comlyn, comlen, proj)
!     rms sum of CVs
      else if (__STRNCMP(keyword,'CVRMS',5)) then
       call smcv_cvrms_add(comlyn, comlen) ! rtmd-like variable (compatibility limited to steered dynamics as of 7.2010):
!                                           z=sqrt( 1/N sum^N_i (z_i - z^0_i)^2 )
      else
        __WARN(whoami,'UNRECOGNIZED CV TYPE: ',keyword)
      endif
!
      end subroutine smcv_add
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccc CV-SPECIFIC CODE ccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_posi_com_add(comlyn, comlen, cvtype)
      use cv_posi_com
      use cv_types
      use ivector
      __DEP_OUTPUT
      __DEP_SIZE
      __DEP_COORDINATES
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __DEP_SELECT
!
      __IMPNONE
 __DECLARE_MSGBUF
!
      character(len=*) comlyn
      int :: comlen
      int :: cvtype
!    locals
      character(len=11) :: cv_name
!
#ifdef __CHARMM
      int :: imode, iselct(natom)
#elif defined(__DMOL)
 __DECLARE_DMOL_SELECT
#endif
!
      int :: i, j, nslct
      bool :: ok
      float :: k, gam, w
      int :: frame
      type (int_vector) :: posi_com_list ! for storing atom indices
!
      __IAM(SMCV_POSI_COM_ADD)
      data cv_name/'POSI_COM'/
!
      select case (cvtype)
       case (posi_com_x); cv_name=' POSI_COM_X'
       case (posi_com_y); cv_name=' POSI_COM_Y'
       case (posi_com_z); cv_name=' POSI_COM_Z'
       case default;
        __WRN( whoami, 'UNKNOWN CV TYPE. NOTHING DONE.')
        return
      end select
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      k=__GET_RM_F(comlyn, comlen, 'FORC', 0.0d0)   ! can specify force constant manually
      w=__GET_RM_F(comlyn, comlen, 'WEIG', -1.0d0)  ! can specify weight manually
      gam=__GET_RM_F(comlyn, comlen, 'GAMM', 1.0d0) ! friction coefficient
      frame=__GET_RM_I(comlyn, comlen, 'FRAM', 0) ! coordinate frame index for this position variable
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     now process atom selections;
!     expecting 1 atom group
#ifdef __CHARMM
      imode=0
      CALL SELRPN(COMLYN,COMLEN,ISELCT,NATOM,1,IMODE,                    &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
      IF(IMODE.NE.0) THEN
       CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
       RETURN
      ENDIF
      NSLCT=NSELCT(NATOM,ISELCT)
!
#elif defined(__DMOL)
#include "dmol_select_macro.def"
      if (associated(__INDEX)) then ; nslct=size(__INDEX) ; else ; nslct=0 ; endif
#endif
!
      if(nslct.eq.0) then
       __WRN(whoami,'ZERO ATOMS SELECTED. ABORTING.')
#ifdef __DMOL
       __FREE(__INDEX)
#endif
       return
      endif
!
      call int_vector_init(posi_com_list)
#ifdef __CHARMM
      do i=1,natom ! loop over all atoms
       if (iselct(i).eq.1) then
        j=int_vector_add(posi_com_list,i)
        if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
       endif
      enddo
#elif defined (__DMOL)
      do i=1,size(__INDEX)
       j=int_vector_add(posi_com_list,__INDEX (i))
       if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
      enddo
      __FREE(__INDEX)
#endif
!
!     print short summary
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0) then
       if (w.lt.0d0) then
        write(_MSGBUF, 664) whoami,cv_name,k,gam
       else
        write(_MSGBUF, 665) whoami,cv_name,k,w,gam
       endif
       __PRINT(_MSGBUF)
!
       if (frame.ge.1) then
        write(_MSGBUF,'(A,I3)') whoami//' RELATIVE TO LOCAL FRAME ',frame
       else
        write(_MSGBUF,'(A)') whoami//' RELATIVE TO THE ABSOLUTE FRAME'
       endif
       __PRINT(_MSGBUF)
!
      endif
!
  664 format(/A,' WILL ADD ',A,' CV WITH K =',F7.3,                     &
     & ' AND GAMMA =',F7.3,'.')
  665 format(/A,' WILL ADD ',A,' CV WITH K =',F7.3,                     &
     & ' WEIGHT =',F7.3,' AND GAMMA =',F7.3)
!
!       now attempt to add CV
      ok=cv_posi_com_add(cvtype,posi_com_list,k,gam,w,max(frame,0)) ! no mass weighting; disallow negative frame indices
      if (.not.ok) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate lists
      call int_vector_done(posi_com_list)
!     done!
      end subroutine smcv_posi_com_add
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_dihe_com_add(comlyn, comlen)
      use cv_dihe_com
      use ivector
!
      __DEP_OUTPUT
      __DEP_COORDINATES
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __DEP_SELECT
!
      __IMPNONE
!
      character(len=*) :: comlyn
      int :: comlen
!    locals
      __STRING_PAR(cv_name, DIHE_COM)
!
#ifdef __CHARMM
      int :: imode, iselct(natom)
#elif defined (__DMOL)
 __DECLARE_DMOL_SELECT
#endif
 __DECLARE_MSGBUF
!
      int :: i, j, atom_group, nslct
      bool :: ok
      float :: k, gam, w
      type (int_vector), dimension(4) :: dihe_com_list ! for storing atom indices
!
      __IAM(SMCV_DIHE_COM_ADD)
!
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      k=__GET_RM_F(comlyn, comlen, 'FORC', 0.0d0)   ! can specify force constant manually
      w=__GET_RM_F(comlyn, comlen, 'WEIG', -1.0d0)  ! can specify weight manually
      gam=__GET_RM_F(comlyn, comlen, 'GAMM', 1.0d0) ! friction coeff.
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     now process atom selections;
!     expecting 4 atom selections that specify each atom group in succession;
!     process each selection sequentially
      do atom_group=1,4
!
#ifdef __CHARMM
!
       imode=0
       CALL SELRPN(COMLYN,COMLEN,ISELCT,NATOM,1,IMODE,                   &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
       IF(IMODE.NE.0) THEN
        CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
        RETURN
       ENDIF
!
       NSLCT=NSELCT(NATOM,ISELCT)
!
#elif defined(__DMOL)
#include "dmol_select_macro.def"
      if (associated(__INDEX)) then ; nslct=size(__INDEX) ; else ; nslct=0 ; endif
#endif
!
       IF(NSLCT.EQ.0) THEN
       __WRN(whoami,'ZERO ATOMS SELECTED. ABORTING.')
#ifdef __DMOL
       __FREE(__INDEX)
#endif
       return
       endif
!
       call int_vector_init(dihe_com_list(atom_group))
#ifdef __CHARMM
       do i=1,natom ! loop over all atoms
        if (iselct(i).eq.1) then
         j=int_vector_add(dihe_com_list(atom_group),i)
         if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
        endif
       enddo
!
#elif defined (__DMOL)
       do i=1,size(__INDEX)
        j=int_vector_add(dihe_com_list(atom_group),__INDEX(i))
        if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
       enddo
       __FREE(__INDEX)
#endif
      enddo ! loop over dihe_com selections
!
!     print short summary
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0) then
       if (w.lt.0d0) then
        write(_MSGBUF, 664) whoami,cv_name,k,gam
       else
        write(_MSGBUF, 665) whoami,cv_name,k,w,gam
       endif
       __PRINT(_MSGBUF)
      endif
!
  664 format(/A,' WILL ADD ',A,' CV WITH K =',F7.3,                     &
     & ' AND GAMMA =',F7.3,'.')
  665 format(/A,' WILL ADD ',A,' CV WITH K =',F7.3,                     &
     & ' WEIGHT =',F7.3,' AND GAMMA =',F7.3)
!
!       now attempt to add CV
      ok=cv_dihe_com_add(dihe_com_list,k,gam,w) ! no mass weighting
      if (.not.ok) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate lists
      do i=1,4; call int_vector_done(dihe_com_list(i)); enddo
!     done!
      end subroutine smcv_dihe_com_add
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_angle_com_add(comlyn, comlen)
      use cv_angle_com
      use ivector
      __DEP_OUTPUT
      __DEP_SIZE 
      __DEP_COORDINATES 
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __DEP_SELECT
      __IMPNONE
!
 __DECLARE_MSGBUF
!
      character(len=*) :: comlyn
      int :: comlen
!    locals
      __STRING_PAR(cv_name, ANGLE_COM)
!
#ifdef __CHARMM
      int :: imode, iselct(natom)
#elif defined (__DMOL)
 __DECLARE_DMOL_SELECT
#endif
!
      int :: i, j, atom_group, nslct
      bool :: ok
      float :: k, gam, w
      type (int_vector), dimension(3) :: angle_com_list ! for storing atom indices
!
      __IAM(SMCV_ANGLE_COM_ADD)
!
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      k=__GET_RM_F(comlyn, comlen, 'FORC', 0.0d0)   ! can specify force constant manually
      w=__GET_RM_F(comlyn, comlen, 'WEIG', -1.0d0)  ! can specify weight manually
      gam=__GET_RM_F(comlyn, comlen, 'GAMM', 1.0d0) ! friction
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     now process atom selections;
!     expecting 3 atom selections that specify each atom group in succession;
!     process each selection sequentially
      do atom_group=1,3
#ifdef __CHARMM
       imode=0
       CALL SELRPN(COMLYN,COMLEN,ISELCT,NATOM,1,IMODE,                   &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
       IF(IMODE.NE.0) THEN
        CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
        RETURN
       ENDIF
!
       NSLCT=NSELCT(NATOM,ISELCT)
#elif defined(__DMOL)
#include "dmol_select_macro.def"
      if (associated(__INDEX)) then ; nslct=size(__INDEX) ; else ; nslct=0 ; endif
#endif
!
       if (nslct.eq.0) then
        __WRN(whoami,'ZERO ATOMS SELECTED. ABORTING.')
#ifdef __DMOL
        __FREE(__INDEX)
#endif
        return
       endif
!
       call int_vector_init(angle_com_list(atom_group))
#ifdef __CHARMM
       do i=1,natom ! loop over all atoms
        if (iselct(i).eq.1) then
         j=int_vector_add(angle_com_list(atom_group),i)
         if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
        endif
       enddo
#elif defined(__DMOL)
       do i=1,size(__INDEX)
        j=int_vector_add(angle_com_list(atom_group),__INDEX (i))
        if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
       enddo
       __FREE(__INDEX)
#endif
      enddo ! loop over angle_com selections
!
!     print short summary
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0) then
       if (w.lt.0d0) then
        write(_MSGBUF, 664) whoami,cv_name,k,gam
       else
        write(_MSGBUF, 665) whoami,cv_name,k,w,gam
       endif
      endif
      __PRINT(_MSGBUF)
!
  664 format(/A,' WILL ADD ',A,' CV WITH K =',F7.3,                     &
     & ' AND GAMMA =',F7.3,'.')
  665 format(/A,' WILL ADD ',A,' CV WITH K =',F7.3,                     &
     & ' WEIGHT =',F7.3,' AND GAMMA =',F7.3)
!
!       now attempt to add CV
      ok=cv_angle_com_add(angle_com_list,k,gam,w) ! no mass weighting
      if (.not.ok) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate lists
      do i=1,3; call int_vector_done(angle_com_list(i)); enddo
!     done!
      end subroutine smcv_angle_com_add
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_dist_com_add(comlyn, comlen)
      use cv_dist_com
      use ivector
      __DEP_OUTPUT
      __DEP_SIZE 
      __DEP_COORDINATES 
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __DEP_SELECT
!
      __IMPNONE
!
      character(len=*) comlyn
      int :: comlen
!    locals
      __STRING_PAR(cv_name, DIST_COM)
!
 __DECLARE_MSGBUF
#ifdef __CHARMM
      int :: imode, iselct(natom)
#elif defined (__DMOL)
 __DECLARE_DMOL_SELECT
#endif
!
      int :: i, j, atom_group, nslct
      bool :: ok
      float :: k, gam, w
      type (int_vector), dimension(2) :: dist_com_list ! for storing atom indices
!
      __IAM(SMCV_DIST_COM_ADD)
!
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      k=__GET_RM_F(comlyn, comlen, 'FORC', 0.0d0)   ! can specify force constant manually
      w=__GET_RM_F(comlyn, comlen, 'WEIG', -1.0d0)  ! can specify weight manually
      gam=__GET_RM_F(comlyn, comlen, 'GAMM', 1.0d0) ! friction coeff.
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     now process atom selections;
!     expecting 2 atom selections that specify each atom group in succession;
!     process each selection sequentially
      do atom_group=1,2
!
#ifdef __CHARMM
!
       imode=0
       CALL SELRPN(COMLYN,COMLEN,ISELCT,NATOM,1,IMODE,                   &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
       IF(IMODE.NE.0) THEN
        CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
        RETURN
       ENDIF
!
       NSLCT=NSELCT(NATOM,ISELCT)
!
#elif defined (__DMOL)
#include "dmol_select_macro.def"
      if (associated(__INDEX)) then ; nslct=size(__INDEX) ; else ; nslct=0 ; endif
#endif
!
       if (nslct.eq.0) then
        __WRN(whoami,'ZERO ATOMS SELECTED. ABORTING.')
#ifdef __DMOL
        __FREE(__INDEX)
#endif
        return
       endif
!
       call int_vector_init(dist_com_list(atom_group))
#ifdef __CHARMM
       do i=1,natom ! loop over all atoms
        if (iselct(i).eq.1) then
         j=int_vector_add(dist_com_list(atom_group),i)
         if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
        endif
       enddo
#elif defined (__DMOL)
       do i=1,size(__INDEX)
        j=int_vector_add(dist_com_list(atom_group),__INDEX (i))
        if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
       enddo
       __FREE(__INDEX)
#endif
      enddo ! loop over dist_com selections
!
!     print short summary
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0) then
       if (w.lt.0d0) then
        write(_MSGBUF, 664) whoami,cv_name,k,gam
       else
        write(_MSGBUF, 665) whoami,cv_name,k,w,gam
       endif
       __PRINT(_MSGBUF)
      endif
!
  664 format(/A,' WILL ADD ',A,' CV WITH K =',F7.3,                     &
     & ' AND GAMMA =',F7.3,'.')
  665 format(/A,' WILL ADD ',A,' CV WITH K =',F7.3,                     &
     & ' WEIGHT =',F7.3,' AND GAMMA =',F7.3)
!
!       now attempt to add CV
      ok=cv_dist_com_add(dist_com_list,k,gam,w) ! no mass weighting
      if (.not.ok) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate lists
      do i=1,2; call int_vector_done(dist_com_list(i)); enddo
!     done!
      end subroutine smcv_dist_com_add
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_anglvec_add(comlyn, comlen)
      use cv_anglvec
      use ivector
      __DEP_OUTPUT
      __DEP_SIZE 
      __DEP_COORDINATES 
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __DEP_SELECT
!
      __IMPNONE
!
      character(len=*) :: comlyn
      int :: comlen
!    locals
      __STRING_PAR(cv_name, ANGLVEC)
      character(len=8) :: key
!
 __DECLARE_MSGBUF
!
#ifdef __CHARMM
      int ::  imode, iselct(natom)
#elif defined (__DMOL)
 __DECLARE_DMOL_SELECT
#endif
!
      int :: i, ipt, j, l, nslct
      bool :: ok
      float :: k, gam, w
      type (int_vector), dimension(4) :: atom_list ! for storing atom indices
      int :: f1, f2
      float :: p(4,3) ! for point definition
      bool :: qp1=.false., qp2=.false., qp3=.false., qp4=.false.
!
      __IAM(SMCV_ANGLVEC_ADD)
!
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      k=__GET_RM_F(comlyn, comlen, 'FORC', 0.0d0)   ! can specify force constant manually
      w=__GET_RM_F(comlyn, comlen, 'WEIG', -1.0d0)  ! can specify weight manually
      gam=__GET_RM_F(comlyn, comlen, 'GAMM', 1.0d0) ! friction
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!    check for frame specification, so that comlyn is cleaned up
      f1=__GET_RM_I(comlyn, comlen,'FR1',0)
      f2=__GET_RM_I(comlyn, comlen,'FR2',0)
!
!    initialize atom arrays
      do i=1,4; call int_vector_init(atom_list(i)); enddo
!
      p=0d0 ! initialize points
      do l=1,4
!     now process vector specifications (expecting four points)
       key=__NEXTA(comlyn, comlen)
       if (__STRNCMP(key,'P1',2)) then
        ipt=1 ;        qp1=.true.
       elseif (__STRNCMP(key,'P2',2)) then
        ipt=2 ;        qp2=.true.
       elseif (__STRNCMP(key,'P3',2)) then
        ipt=3 ;        qp3=.true.
       elseif (__STRNCMP(key,'P4',2)) then
        ipt=4 ;        qp4=.true.
       else
        __WARN(whoami,'VECTOR DEFINITION ERROR. EXPECTED "P[1-4]", GOT "',key,'"')
       endif
!
       __TRIMA(comlyn, comlen)
       if (__INDX(comlyn, comlen, 'SELE', 4).eq.1) then ! next word is select
!ccccccccccccc process atom selection
#ifdef __CHARMM
!
        imode=0
        CALL SELRPN(COMLYN,COMLEN,ISELCT,NATOM,1,IMODE,                  &
     &       .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,         &
     &       .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
        IF(IMODE.NE.0) THEN
         CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
         RETURN
        ENDIF
!
        NSLCT=NSELCT(NATOM,ISELCT)
!
#elif defined(__DMOL)
#include "dmol_select_macro.def"
      if (associated(__INDEX)) then ; nslct=size(__INDEX) ; else ; nslct=0 ; endif
#endif
!
        IF(NSLCT.EQ.0) THEN
         __WRN(whoami,'ZERO ATOMS SELECTED. ABORTING.')
#ifdef __DMOL
         __FREE(__INDEX)
#endif
         return
        endif
!
#ifdef __CHARMM
        do i=1,natom ! loop over all atoms
         if (iselct(i).eq.1) then
          j=int_vector_add(atom_list(ipt),i)
          if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
         endif
        enddo
#elif defined(__DMOL)
       do i=1,size(__INDEX)
        j=int_vector_add(atom_list(ipt),__INDEX (i))
        if (j.le.0) then ; __WRN(whoami,'COULD NOT ADD ATOM INDEX TO COM LIST') ; endif
       enddo
       __FREE(__INDEX)
#endif
!
       else ! specify point manually
        do i=1,3;  p(ipt,i)=__NEXTF(comlyn, comlen); enddo
       endif
      enddo
!    check that all four points have been added
      if (.not.(qp1.and.qp2.and.qp3.and.qp4)) then
       __WRN(whoami,'SOME POINTS WERE NOT DEFINED. NOTHING DONE')
       return
      endif
!
!     print short summary
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0) then
       if (w.lt.0d0) then
        write(_MSGBUF, 664) whoami,cv_name,k,gam
       else
        write(_MSGBUF, 665) whoami,cv_name,k,w,gam
       endif
       __PRINT(_MSGBUF)
      endif
!
  664 format(/A,' WILL ADD ',A,' CV WITH K =',F7.3,                     &
     & ' AND GAMMA =',F7.3,'.')
  665 format(/A,' WILL ADD ',A,' CV WITH K =',F7.3,                     &
     & ' WEIGHT =',F7.3,' AND GAMMA =',F7.3)
!
!       now attempt to add CV
      ok=cv_anglvec_add(atom_list,p,f1,f2,k,gam,w) ! no mass weighting
      if (.not.ok) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate lists
      do i=1,4; call int_vector_done(atom_list(i)); enddo
!     done!
      end subroutine smcv_anglvec_add
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccc
!    'frame' is not really a CV but processed here for convenience
      subroutine smcv_frame_add(comlyn, comlen)
      use cv_frames
      use ivector
      __DEP_OUTPUT
      __DEP_SIZE 
      __DEP_COORDINATES 
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __DEP_SELECT
!
      __IMPNONE
 __DECLARE_MSGBUF
!
      character(len=*) :: comlyn
      int :: comlen
!    locals
#ifdef __CHARMM
      int :: imode, iselct(natom)
#elif defined(__DMOL)
 __DECLARE_DMOL_SELECT
#endif
      int :: i, j, nslct
      bool :: ok
      type (int_vector) :: frame_list ! for storing atom indices
!
      __IAM(SMCV_FRAME_ADD)
!
!     process atom selections;
!     specify atom group
#ifdef __CHARMM
!
      imode=0
      CALL SELRPN(COMLYN,COMLEN,ISELCT,NATOM,1,IMODE,                    &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
      IF(IMODE.NE.0) THEN
       CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
       RETURN
      ENDIF
!
      NSLCT=NSELCT(NATOM,ISELCT)
!
#elif defined(__DMOL)
#include "dmol_select_macro.def"
      if (associated(__INDEX)) then ; nslct=size(__INDEX) ; else ; nslct=0 ; endif
#endif
!
      if (nslct.lt.4) then ! require at least four atoms, otherwise, can never define frame uniquely
       __WRN(whoami,' FEWER THAN FOUR ATOMS SELECTED. ABORTING.')
#ifdef __DMOL
       __FREE(__INDEX)
#endif
       return
      endif
!
      call int_vector_init(frame_list)
#ifdef __CHARMM
      do i=1,natom ! loop over all atoms
       if (iselct(i).eq.1) then
         j=int_vector_add(frame_list,i)
         if (j.le.0) then 
          __WRN(whoami,'COULD NOT ADD ATOM INDEX TO FRAME LIST.')
         endif
       endif
      enddo
#elif defined(__DMOL)
      do i=1,size(__INDEX)
       j=int_vector_add(frame_list,__INDEX (i))
       if (j.le.0) then 
        __WRN(whoami,'COULD NOT ADD ATOM INDEX TO FRAME LIST.')
       endif
      enddo
      __FREE(__INDEX)
#endif
!
!     print short summary
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0) then
       write(_MSGBUF, 665) whoami ; __PRINT(_MSGBUF)
      endif
!
  665 format(/A,' WILL ADD NEW REFERENCE FRAME')
!       now attempt to add frame
      ok=(frames_add(frame_list).gt.0) !
      if (.not.ok) then
       __WRN(whoami,'COULD NOT ADD FRAME.')
      endif
!     deallocate lists
      call int_vector_done(frame_list)
!     done!
      end subroutine smcv_frame_add
!cccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_quaternion_add(comlyn, comlen)
      use cv_qcomp
      use cv_types
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __DEP_SELECT
      __IMPNONE
!
 __DECLARE_MSGBUF
!
      character(len=*) :: comlyn
      int :: comlen
!    locals
      __STRING_PAR(cv_name,QUATERNION)
      bool :: ok
      float :: k, gam, w
      int :: f1, f2
!
      __IAM(SMCV_QUATERNION_ADD)
!
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      k=__GET_RM_F(comlyn, comlen, 'FORC', 0.0d0)   ! can specify force constant manually
      w=__GET_RM_F(comlyn, comlen, 'WEIG', -1.0d0)  ! can specify weight manually
      gam=__GET_RM_F(comlyn, comlen, 'GAMM', 1.0d0) ! friction
      f1=__GET_RM_I(comlyn, comlen, 'FRA1', 0) ! coordinate frame index 1
      f2=__GET_RM_I(comlyn, comlen, 'FRA2', 0) ! coordinate frame index 2
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     print short summary
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0) then
!
       if (w.lt.0d0) then
        write(_MSGBUF, 664) whoami,cv_name,k,gam
       else
        write(_MSGBUF, 665) whoami,cv_name,k,w,gam
       endif
       __PRINT(_MSGBUF)
!
       if (f1.ge.1) then
        write(_MSGBUF,'(A,I3)') whoami//' FRAME1: LOCAL FRAME #',f1
       else
        write(_MSGBUF,'(A)') whoami//' FRAME1: ABSOLUTE FRAME'
       endif
       __PRINT(_MSGBUF)
!
       if (f2.ge.1) then
        write(_MSGBUF,'(A,I3)') whoami//' FRAME2: LOCAL FRAME #',f2
       else
        write(_MSGBUF,'(A)') whoami//' FRAME2: ABSOLUTE FRAME'
       endif
       __PRINT(_MSGBUF)
!
      endif
!
  664 format(/A,' WILL ADD ',A,' CV WITH K =',F7.3,                     &
     & ' AND GAMMA =',F7.3,'.')
  665 format(/A,' WILL ADD ',A,' CV WITH K =',F7.3,                     &
     & ' WEIGHT =',F7.3,' AND GAMMA =',F7.3)
!
!       now attempt to add quaternion components, one by one:
      ok=   cv_qcomp_add(qcomp_1, f1, f2, k, gam, w)                    &
     & .and.cv_qcomp_add(qcomp_2, f1, f2, k, gam, w)                    &
     & .and.cv_qcomp_add(qcomp_3, f1, f2, k, gam, w)                    &
     & .and.cv_qcomp_add(qcomp_4, f1, f2, k, gam, w)
!
      if (.not.ok) then
       __WRN(whoami,'COULD NOT ADD QUATERNION CV')
      endif
!     done!
      end subroutine smcv_quaternion_add
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_cvrms_add(comlyn, comlen)
!     this CV is an RMS combination of existing CV; experimental and not fully implemented (intented for steered dynamics)
      use cv_cvrms
      use parselist
      use ivector
      __DEP_OUTPUT
      __DEP_PARSER
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI
      __IMPNONE
      __DECLARE_MSGBUF
!
      character(len=*) :: comlyn
      int :: comlen
!    locals
      __STRING_PAR(cv_name, CVRMS)
      bool :: ok
      float :: k, gam, w
      type (int_vector) :: cv_list ! for storing cv indices used to calculate RMS
!
      __IAM(SMCV_CVRMS_ADD)
!
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      k=__GET_RM_F(comlyn, comlen, 'FORC', 0.0d0)   ! can specify force constant manually
      w=__GET_RM_F(comlyn, comlen, 'WEIG', -1.0d0)  ! can specify weight manually
      gam=__GET_RM_F(comlyn, comlen, 'GAMM', 1.0d0) ! friction coeff.
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! specify cv to use in the RMS definition
      call ilist_parse(cv_list, comlyn) ! will return allocated cv_list with the indices
!
!     print short summary
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0) then
       if (w.lt.0d0) then
        write(_MSGBUF, 664) whoami,cv_name,k,gam
       else
        write(_MSGBUF, 665) whoami,cv_name,k,w,gam
       endif
      endif
      __PRINT(_MSGBUF)
!
  664 format(/A,' WILL ADD ',A,' CV WITH K =',F8.3,                     &
     & ' AND GAMMA =',F8.3,'.')
  665 format(/A,' WILL ADD ',A,' CV WITH K =',F8.3,                     &
     & ' WEIGHT =',F8.3,' AND GAMMA =',F8.3)
!
!       now attempt to add CV
      ok=cv_cvrms_add(cv_list,k,gam,w) ! no mass weighting
      if (.not.ok) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate list
      call int_vector_done(cv_list)
!     done!
      end subroutine smcv_cvrms_add
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_rmsd_add(comlyn, comlen, cvtype)
!     much of the code taken from RTMD sources in ../misc
      use cv_rmsd, only : cv_rmsd_add
      use cv_drmsd, only : cv_drmsd_add
      use cv_proj, only : cv_proj_add
      use cv_types
      __DEP_OUTPUT
      __DEP_SIZE 
      __DEP_COORDINATES 
      __DEP_PARSER 
      __DEP_NUMBER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __DEP_SELECT
!
      __IMPNONE
      character(len=*) :: comlyn
      int :: comlen
      int :: cvtype
!    locals
      character(len=5) :: cv_name
      bool :: ok, oset
      float :: k, gam, w, rtarget_com(3)
!
      float, pointer :: rtarget_o(:,:), rtarget_f(:,:),                &
     &                  rtarget1_o(:,:), rtarget1_f(:,:),              &
     &                  orientWeights(:), forcedWeights(:)
      int, pointer :: iatom_o(:), iatom_f(:)
      int :: norient, nforced
!
#ifdef __CHARMM
      int :: iselct(natom), jselct(natom)
      int :: imode
#elif defined (__DMOL)
 __DECLARE_DMOL_SELECT
 int, pointer :: iselct(:), jselct(:)
#endif
 __DECLARE_MSGBUF
!
      int :: i, j, n
      float :: a, b
!
      bool :: use_main, use_comp, qroot, qmass, qtwo ! qtwo: true if using two target structures
!
      __IAM(SMCV_RMSD_ADD)
!
      select case (cvtype)
       case(rmsd ); cv_name='RMSD '; qtwo=.false.
       case(drmsd); cv_name='DRMSD'; qtwo=.true.
       case(proj ); cv_name='PROJ '; qtwo=.true.
       case default
        __WRN( whoami, 'UNKNOWN CV REQUESTED. NOTHING DONE.');
        return
      end select
!
      qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0)
!
!     first check for CV options
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      k=__GET_RM_F(comlyn, comlen, 'FORC', 0.0d0)   ! can specify force constant manually
      w=__GET_RM_F(comlyn, comlen, 'WEIG', -1.0d0)  ! can specify weight manually
      gam=__GET_RM_F(comlyn, comlen, 'GAMM', 1.0d0) ! friction coeff.
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     process atom selections
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#ifdef __CHARMM
      iselct=0
      jselct=0
#elif defined(__DMOL)
      nullify(iselct, jselct)
#endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     look for orientation atom selection
      oset=.false. ! is there a separate orientation specification?
      i=__INDX_RM(comlyn,comlen,'ORIE') ! find the position of `ORIE`
      oset=(i.gt.0)
!     first determine whether a selection keyword follows orie
      if (oset) then
       n=comlen-i+1
       j=__INDX(comlyn(i:comlen), n, 'SELE', 4)
       if (j.le.0) then ! only if the ORIE directive exists
         __WRN(whoami,'ATOM SELECTION MUST BE SPECIFIED AFTER ORIE.')
         return
        endif
      endif
!*************************************************************************************
!     look for the first selection
!*************************************************************************************
      j=__INDX(comlyn, comlen, 'SELE', 4)
      if (j.eq.0) then ! sele keyword does not exist
       __WRN(whoami, 'RMSD ATOMS NOT SPECIFIED. NOTHING DONE.');
       return
      elseif (j.le.i.or..not.oset) then ! no 'orie', or first occurrence of sele before orie (deleted by __INDXa above)
!     assume that this is the forcing set selection
#ifdef __CHARMM
       IMODE=0
       CALL SELRPN(COMLYN,COMLEN,jselct,NATOM,1,IMODE,                  &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
       IF(IMODE.NE.0) THEN
          CALL WRNDIE(0,whoami,'RMSD ATOMS SELECTION ERROR')
          RETURN
       ENDIF
#elif defined(__DMOL)
#define __INDEX jselct
#include "dmol_select_macro.def"
#endif
! orientation selection
       if (oset) then
#ifdef __CHARMM
        IMODE=0
        CALL SELRPN(COMLYN,COMLEN,iselct,NATOM,1,IMODE,                 &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
        IF(IMODE.NE.0) THEN
         CALL WRNDIE(0,whoami,'ORIENTATION ATOMS SELECTION ERROR')
         RETURN
        ENDIF
#elif defined(__DMOL)
#define __INDEX iselct
#include "dmol_select_macro.def"
#endif
       endif
!
      else ! first selection after orie
#ifdef __CHARMM
       IMODE=0
       CALL SELRPN(COMLYN,COMLEN,iselct,NATOM,1,IMODE,                  &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
       IF(IMODE.NE.0) THEN
        CALL WRNDIE(0,whoami,'ORIENTATION ATOMS SELECTION ERROR')
        RETURN
       ENDIF
!     forcing set selection
       IMODE=0
       CALL SELRPN(COMLYN,COMLEN,jselct,NATOM,1,IMODE,                  &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
       IF(IMODE.NE.0) THEN
          CALL WRNDIE(0,whoami,'RMSD ATOMS SELECTION ERROR')
          RETURN
       ENDIF
!   number of atoms
       norient=count( iselct(1:natom).gt.0 )
       nforced=count( jselct(1:natom).gt.0 )
!
#elif defined(__DMOL)
! first selection (orientation atoms)
#define __INDEX iselct
#include "dmol_select_macro.def"
! second selection (forcing atoms)
#define __INDEX jselct
#include "dmol_select_macro.def"
!
      if (associated(iselct)) then ; norient=size(iselct) ; else ; norient=0 ; endif
      if (associated(jselct)) then ; nforced=size(jselct) ; else ; nforced=0 ; endif
#endif
!
      endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if (nforced.eq.0) then
       __WRN(whoami, 'RMSD ATOMS NOT SPECIFIED. NOTHING DONE.')
       return
      endif
!
      if (.not.oset) then ! use forced atoms for orientation too
       norient=nforced
#ifdef __CHARMM
       iselct=jselct
#elif defined (__DMOL)
       iselct=>jselct
#endif
      endif
!
! currently we require at least three atoms for orientation
!
      if (norient.lt.3) then
        __WRN(whoami,' FEWER THAN THREE ATOMS SELECTED FOR ORIENTATION. ABORT.')
        return
      endif
!
      qmass=(__INDX_RM(comlyn, comlen, 'MASS').gt.0) ! mass-weighting flag
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! done with selections
      allocate(iatom_o(norient),                                        &
     &  iatom_f(nforced),                                               &
     &  rtarget_o(norient,3),                                           &
     &  rtarget_f(nforced,3),                                           &
     &  orientWeights(norient),                                         &
     &  forcedWeights(nforced))
      if (qtwo) allocate(rtarget1_o(norient,3),rtarget1_f(nforced,3))
!
!     initialize arrays
      iatom_o=0; iatom_f=0;
      rtarget_o=0.0d0;  rtarget_f=0.0d0;
      if (qtwo) then ; rtarget1_o=0.0d0;  rtarget1_f=0.0d0; endif ! second structure
      orientWeights=1d0; forcedWeights=1d0
!
!    build index arrays
#ifdef __CHARMM
      norient=0
      nforced=0
!
      do i=1,natom
        if (iselct(i).gt.0) then
         norient=norient+1
         iatom_o(norient)=i
        endif
!
        if (jselct(i).gt.0) then
         nforced=nforced+1
         iatom_f(nforced)=i
        endif
!
      enddo
#elif defined(__DMOL)
! NOTE that in DMOL, iselct has a different meaning: it stores the atom indices, rather than flags
      if (associated(iselct)) then ; iatom_o=iselct ; deallocate(iselct) ; endif
      if (associated(jselct)) then ; iatom_f=jselct ; deallocate(jselct) ; endif
#endif
!!!!!!!!! mass-weighting
      if (qmass) then
        do i=1,norient
         orientWeights(i)=                                              &
     &    __MASS(iatom_o(i))*orientWeights(i)
        enddo
!
        do i=1, nforced
         forcedWeights(i)=                                              &
     &    __MASS(iatom_f(i))*forcedWeights(i)
        enddo
!
      endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!     load and save coordinates of the target structure
      use_main=((__INDX_RM(comlyn,comlen,'MAIN')).gt.0)
      use_comp=((__INDX_RM(comlyn,comlen,'COMP')).gt.0)
      if (use_comp) then
        if (use_main) then
         __WRN(whoami,'MAIN AND COMP CANNOT BOTH BE SPECIFIED. USING MAIN.')
         use_comp=.false.
        endif
      else
        use_main=.true. ! default
      endif
!
      if (use_comp) then
! orient
        do i=1,norient
         rtarget_o(i,1)=__XXCOMP(iatom_o(i))
         rtarget_o(i,2)=__YYCOMP(iatom_o(i))
         rtarget_o(i,3)=__ZZCOMP(iatom_o(i))
        enddo
! forced
        do i=1,nforced
         rtarget_f(i,1)=__XXCOMP(iatom_f(i))
         rtarget_f(i,2)=__YYCOMP(iatom_f(i))
         rtarget_f(i,3)=__ZZCOMP(iatom_f(i))
        enddo
! second reference structure:
        if (qtwo) then
         do i=1,norient
          rtarget1_o(i,1)=__XX(iatom_o(i))
          rtarget1_o(i,2)=__YY(iatom_o(i))
          rtarget1_o(i,3)=__ZZ(iatom_o(i))
         enddo
!
         do i=1,nforced
          rtarget1_f(i,1)=__XX(iatom_f(i))
          rtarget1_f(i,2)=__YY(iatom_f(i))
          rtarget1_f(i,3)=__ZZ(iatom_f(i))
         enddo
        endif ! qtwo
!
      else ! use main coordinates
! orient
        do i=1,norient
         rtarget_o(i,1)=__XX(iatom_o(i))
         rtarget_o(i,2)=__YY(iatom_o(i))
         rtarget_o(i,3)=__ZZ(iatom_o(i))
        enddo
! forced
        do i=1,nforced
         rtarget_f(i,1)=__XX(iatom_f(i))
         rtarget_f(i,2)=__YY(iatom_f(i))
         rtarget_f(i,3)=__ZZ(iatom_f(i))
        enddo
! second reference structure:
        if (qtwo) then
         do i=1,norient
          rtarget1_o(i,1)=__XXCOMP(iatom_o(i))
          rtarget1_o(i,2)=__YYCOMP(iatom_o(i))
          rtarget1_o(i,3)=__ZZCOMP(iatom_o(i))
         enddo
!
         do i=1,nforced
          rtarget1_f(i,1)=__XXCOMP(iatom_f(i))
          rtarget1_f(i,2)=__YYCOMP(iatom_f(i))
          rtarget1_f(i,3)=__ZZCOMP(iatom_f(i))
         enddo
        endif ! qtwo
!
      endif ! use_comp
!
!      check for undefined values
      if (any(rtarget_o.eq.__NAN).or.any(rtarget_f.eq.__NAN)) then
        __WRN(whoami,'FIRST TARGET STRUCTURE HAS UNDEFINED COORDINATES. QUITTING.')
        return
      elseif (qtwo) then
       if (any(rtarget1_o.eq.__NAN).or.any(rtarget1_f.eq.__NAN)) then
        __WRN(whoami,'SECOND TARGET STRUCTURE HAS UNDEFINED COORDINATES. QUITTING.')
        return
       endif
      endif
!
! normalize weighting coefficients
! note: routines in rtmd_aux do _not_ perform normalization; result affects FP precision, analytically, there is no difference
!
      a=sum(orientWeights)
      b=sum(forcedWeights)
      if (abs(a).gt.__ERRTOL) then
        a=1d0/a
        orientWeights=a*orientWeights
      endif
!
      if (abs(b).gt.__ERRTOL) then
        b=1d0/b
        forcedWeights=b*forcedWeights
      endif
!
! translate target structure so that its centroid is at the origin
      rtarget_com=matmul(transpose(rtarget_o),orientWeights)
!
      rtarget_o(:,1)=rtarget_o(:,1)-rtarget_com(1)
      rtarget_o(:,2)=rtarget_o(:,2)-rtarget_com(2)
      rtarget_o(:,3)=rtarget_o(:,3)-rtarget_com(3)
!
      rtarget_f(:,1)=rtarget_f(:,1)-rtarget_com(1)
      rtarget_f(:,2)=rtarget_f(:,2)-rtarget_com(2)
      rtarget_f(:,3)=rtarget_f(:,3)-rtarget_com(3)
!
      if (qtwo) then ! repeat for second structure
       rtarget_com=matmul(transpose(rtarget1_o),orientWeights)
!
       rtarget1_o(:,1)=rtarget1_o(:,1)-rtarget_com(1)
       rtarget1_o(:,2)=rtarget1_o(:,2)-rtarget_com(2)
       rtarget1_o(:,3)=rtarget1_o(:,3)-rtarget_com(3)
!
       rtarget1_f(:,1)=rtarget1_f(:,1)-rtarget_com(1)
       rtarget1_f(:,2)=rtarget1_f(:,2)-rtarget_com(2)
       rtarget1_f(:,3)=rtarget1_f(:,3)-rtarget_com(3)
      endif
!
!    print summary
      if (qroot) then
!
       if (w.lt.0d0) then
        write(_MSGBUF, 664) whoami,cv_name,k,gam
       else
        write(_MSGBUF, 665) whoami,cv_name,k,w,gam
       endif
       __PRINT(_MSGBUF)
!
       write(_MSGBUF,103) whoami, nforced ; __PRINT(_MSGBUF)
       write(_MSGBUF,100) whoami, norient ; __PRINT(_MSGBUF)
       if (qmass) then ; write(_MSGBUF,102) whoami ; __PRINT(_MSGBUF) ; endif
       if (qtwo) then
        if (use_comp) then
         write(_MSGBUF,105) whoami, 'COMP'
        else
         write(_MSGBUF,105) whoami, 'MAIN'
        endif
       else
        if (use_comp) then
         write(_MSGBUF,104) whoami, 'COMP'
        else
         write(_MSGBUF,104) whoami, 'MAIN'
        endif
       endif
       __PRINT(_MSGBUF)!
  664 format(/A,' WILL ADD ',A,' CV WITH K =',F8.3,                     &
     & ' AND GAMMA =',F8.3,'.')
  665 format(/A,' WILL ADD ',A,' CV WITH K =',F8.3,                     &
     & ' WEIGHT =',F8.3,' AND GAMMA =',F8.3)
!
 100  format(A,' WILL ORIENT TARGET STRUCTURE(S) BASED ON ',i5,         &
     & ' ATOMS')
 102  format(A,' WILL USE MASS-WEIGHTING.')
 103  format(A,' ',i5,' FORCED ATOMS FOUND.')
 104  format(A,' TARGET STRUCTURE TAKEN FROM ',A,' SET.')
 105  format(A,' FIRST TARGET STRUCTURE TAKEN FROM ',A,' SET.')
!
      endif ! qroot
!       now attempt to add CV
      ok=.false.
      select case(cvtype)
       case(rmsd);
        ok=cv_rmsd_add(iatom_o, iatom_f, rtarget_o, rtarget_f,          &
     &               orientWeights, forcedWeights,                      &
     &               k, gam, w)
       case(drmsd);
        ok=cv_drmsd_add(iatom_o, iatom_f, rtarget_o, rtarget_f,         &
     &               rtarget1_o, rtarget1_f,                            &
     &               orientWeights, forcedWeights,                      &
     &               k, gam, w)
       case(proj);
        ok=cv_proj_add(iatom_o, iatom_f, rtarget_o, rtarget_f,          &
     &               rtarget1_o, rtarget1_f,                            &
     &               orientWeights, forcedWeights,                      &
     &               k, gam, w)
      end select
!
      if (.not.ok) then
       __WRN(whoami,'COULD NOT ADD CV')
      endif
!     deallocate variables
      deallocate(iatom_o, iatom_f, rtarget_o, rtarget_f,                &
     &           orientWeights, forcedWeights)
      if (qtwo) deallocate(rtarget1_o, rtarget1_f)
!
      end subroutine smcv_rmsd_add
!
__CHARMM_ONLY##ENDIF
#endif
