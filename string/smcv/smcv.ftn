!CHARMM Element source/stringm/smcv.src $Revision: 1.4 $
!
! string code
!
__CHARMM_ONLY##IF STRINGM
!
#if (defined(__ACEMD) || defined(__NAMD))
#define __CONTEXT __SMCVCTX
#define __COMM MPI_COMM_NULL
#ifdef __NULL_COMM_STOP
#undef __NULL_COMM_STOP
#define __NULL_COMM_STOP
#define __NOUPPER /* do not convert executable statements to upper case */
!#define __NOEMPTY
#endif
#define __DEP_EXEC use sm_var, only : smcv_initialized;/*\*/
! interface;\
! subroutine smcv_init(maxcv);\
!    int, optional :: maxcv;\
! end subroutine smcv_init;\
! end interface
!=====execute context stack===========================================================
#define __DEFAULTDO call smcv(command,l)
!#define __MUSTINIT
#include "exec.def"
#endif /*acemd, namd*/
!=====================================================================================
      subroutine smcv(COMLYN,COMLEN)
!----------------------------------------------------------------------
! command parser for the string method
!----------------------------------------------------------------------
      use sm_var
#ifdef __CHARMM
      use cv_common, only : cv !##PGI ! strange and ugly fix for PGI compilation
#endif
      use cv_common
      use cv_frames, only: frames_init, frames_list, frames_done,       &
     &                     frames_read_local, frames_read_global,       &
     &                     frames_print_local, frames_print_global,     &
     &                     frames_calc, frames, frames_initialized,     &
     &                     frames_reset_calculate,                      &
     &                     frames_calc_align_comp, frames_print_local,  &
     &                     frames_print_global
      use cv_quaternion, only: quat_reset_calculate, quat_done
!
      use sm_config
      use smcv_stats, only: smcv_stat, smcv_stat_init
      use smcv_master, only: smcv_fill, smcv_compute_wgt, smcv_add_hist,&
     &    smcv_list, smcv_compute_M, smcv_voronoi_whereami,             &
     &    smcv_test_grad_fd, smcv_test_parallel, smcv_test_Minv
      use ftsm_var, only : ftsm_initialized
      use smcv_add
      use smcv_check_set
!
      __DEP_OUTPUT
      __DEP_SIZE
      __DEP_PARSER 
      __DEP_COORDINATES
      __DEP_PSF
      __DEP_NUMBER 
#ifdef __CHARMM
      use ctitla 
#ifdef __CHARMM_VER
#if (__CHARMM_VER >=38 )
        use dcntrl_mod, only : dynopt
#endif
#endif
#endif
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_CONST
      __DEP_MPI
      __DEP_COORIO
__CHARMM_ONLY use coorio_mod ! dependency hack
      __DEP_FILES
      __DEP_RANDOM
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      __IMPNONE
!
      CHARACTER(len=*) :: COMLYN
      int :: comlen
!
! local variables
!
      character(len=8) :: keyword
!
#ifdef __CHARMM
      int :: ivver, ivv2, iorig, ileap ! for dynamics
      int :: islct(natom)
      int :: ifreea(natom)
      int :: oldiol
!     compatibility variables for coordinate reading/writing
      float :: xdum(natom+1), ydum(natom+1), zdum(natom+1),            &
     &          wdum(natom+1)
      int :: icntrl(20)
#endif
!
      int :: ifile
      int :: i,j,n
      int4mpi :: ierror, impi, jmpi, kmpi
      float :: k,w,gam,step,expo_memory,zval
      int :: num_ave_samples, irep
      int :: c1, c2, klen, delta, nskip, scol=0, totcol
      int :: ind, qall, ibeg, iend
      character(len=80) :: fname
      int :: flen
      bool :: ok
      character(len=20) :: fixbc
!      int4mpi, pointer, dimension(:) :: temp1, temp2 ! for MPI_GRAD_TYPE (alt)
      int :: me, maxcv
!
! for interpolation
!
      character(len=20) :: methods(5), method, form
      character(len=80) :: name_cv_in, name_cv_out, name_cor_in, name_cor_out
      character(len=80) :: dummy
      character(len=80), pointer :: fname_cor_in(:), fname_cor_out(:)
      data methods/ 'LINEAR','CUBIC SPLINE','B-SPLINE','DST','LINEAR_EXACT'/
!
      int :: int_method, length, num_rep_in, num_rep_out,               &
     &           len_cv_in, len_cv_out, len_cor_in, len_cor_out, ofile
#ifdef __CHARMM
      int :: moder, modew
      bool :: lresid
#elif defined (__DMOL)
      int :: ifmt
#endif
!
#ifndef __CHARMM
      int, pointer :: random_seeds(:,:)=>NULL() ! random seeds for seamless BD evolution for TAMD
#endif
!
      bool :: interp_cv, inte_get_coor, qcomp
      float, pointer :: inte_rmsd(:,:), rtemp(:,:)
      float :: voro_cut, repl_x_temp
      bool :: min_rmsd, voronoi_check_map
      int :: which(1)
      bool :: qroot, qslave __CHARMM_ONLY, qprint
      bool :: qrest ! whether to read/write restart file flag
!     tests
      float, pointer :: fd_error(:,:) ! FD gradient computation
!
      integer(kind=MPI_ADDRESS_KIND) :: lb, extent
!
__CHARMM_ONLY __DECLARE_MSGBUF
!
#include "mpitype.def"
!
#ifdef __CHARMM
#include "smcv_interface.ch"
#else
#include "smcv_interface.h"
#endif
!
      __IAM(SMCV)
!
      keyword=__NEXTA(comlyn,comlen)
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qslave=((MPI_COMM_LOCAL.ne.MPI_COMM_NULL).and.SIZE_LOCAL.gt.1)
      qprint=qroot.and.ME_STRNG.eq.0
!
! check for ftsm initialization; quit if initialized
!
      if (ftsm_initialized) then
       __WRN(whoami,' FTSM IS ON AND CANNOT BE USED WITH SMCV. NOTHING DONE.')
       return
      endif
!
      if (SIZE_STRNG.gt.1) call MPI_BARRIER(MPI_COMM_STRNG,ierror)    !__CHARMM_ONLY##MPI
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (__STRNCMP(keyword,'INIT',4)) then
        maxcv=__GET_RM_I(comlyn, comlen, 'MAXCV',-999)
        if (maxcv.eq.-999 ) then ;  call smcv_init() ; else ; call smcv_init(maxcv) ; endif
        return
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (.not.smcv_initialized) then
        call smcv_init()
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (__STRNCMP(keyword,'DONE',4)) then
        call smcv_done()
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'REPA',4)) then
       if (comlen.gt.0) then ! this is an initialization call!
        call smcv_repa_init(comlyn, comlen)
       else
        call smcv_repa()
       endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'STAT',4)) then
       if (comlen.gt.0) then ! this is an initialization call!
        call smcv_stat_init(comlyn, comlen)
       else
        call smcv_stat()
       endif ! call statistics
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'DYNA',4)) then
#ifdef __CHARMM
       ivver=__INDX_RM(comlyn, comlen, 'VVER')
       ivv2=__INDX_RM(comlyn, comlen, 'VV2')
       iorig=__INDX_RM(comlyn, comlen, 'ORIG')
       ileap=__INDX_RM(comlyn, comlen, 'LEAP')
       if ((ivver+ivv2+iorig).gt.0) then
        __WRN( whoami,'ONLY LEAP-FROG DYNAMICS ARE SUPPORTED. NOTHING DONE')
        return
       endif
!      force LEAP DYNAMICS
       call joinwd(comlyn, mxcmsz, comlen, 'LEAP ', 5)
#endif
!ccccccccccccccc PARSE OTHER DYNAMICS OPTIONS
       voronoi_hist_on=(__INDX_RM(comlyn,comlen,'VORO').gt.0)
       if (voronoi_hist_on) then
        voronoi_allow_cross=(__INDX_RM(comlyn,comlen, 'VCRS').gt.0)
        if (voronoi_allow_cross) then
         voronoi_update_freq=__GET_RM_I(comlyn,comlen,'VCRF',0)
         if (voronoi_update_freq.le.0) then
          __WRN(whoami,'MUST SPECIFY POSITIVE VCRF. VORONOI CELL CROSSING DISABLED.')
          voronoi_allow_cross=.false.
         elseif (__INDX(comlyn, comlen, 'VINI',4).gt.0) then ! if vini is present
          voronoi_nocross_ini=__GET_RM_I(comlyn,comlen,'VINI',0) ! get it
          if (voronoi_nocross_ini.le.0) then
           __WRN(whoami,'NONPOSITIVE VINI SPECIFIED. WILL SET TO ZERO.')
           voronoi_nocross_ini=0
          endif ! voronoi_nocross_ini>0
         else
          voronoi_nocross_ini=0
         endif ! voronoi_nocross_ini present
        endif ! voronoi_allow_cross
!
!    initialize Voronoi data
        if (.not.cv_common_voronoi_initialized)                           &
     &    call cv_common_voronoi_init()
!    standard V. calculation case -- no crossing
        compute_whereami=.false.
        if (.not.voronoi_allow_cross) then
!    create standard map (unless map is present)
         if (all(cv%voronoi_map.eq.-1)) then     ! no valid entries ( > 0 ); formerly .not.any(cv%voronoi_map.ne.-1)
          cv%voronoi_map=(/ (i, i=1, nstring) /)
          compute_whereami=.true. ! will be computed by dynamc routine
         endif
        endif
!
        voronoi_check_map=(__INDX_RM(comlyn,comlen, 'CHCK').gt.0)
!
!    compute whereami
!
        if (voronoi_check_map) then
         if (qprint) then
          write(_MSGBUF, 660) whoami ; __PRINT(_MSGBUF)
         endif
 660  FORMAT(A,' CHECKING VORONOI MAP AGAINST CURRENT COORDINATES.')
!
         compute_whereami=.false.
         call smcv_voronoi_whereami(__X,__Y,__Z,__MASS)
!
         if (all(cv%voronoi_map.ne.-1)) then ! if all entries are valid
           me=cv%voronoi_map(mestring+1)
!    compare me and whereami:
           if (qroot) then
            if(SIZE_STRNG.gt.1) then
__MPI_ONLY             call MPI_ALLREDUCE(me.eq.cv%voronoi_whereami, ok,          &
__MPI_ONLY     &         1, MPI_LOGICAL, MPI_LAND, MPI_COMM_STRNG, ierror)
            else
             ok=me.eq.cv%voronoi_whereami
            endif
           endif ! qroot
           if (qslave) then 
            __BROADCAST_LOCAL_4B(ok,1)
           endif
           if (.not.ok) then
            __WRN(whoami,'VORONOI MAP INCONSISTENT WITH CURRENT COORDINATES. ABORTING.')
            return
           endif ! .not. ok
         else ! voronoi map invalid (or was not read); proceed anyway using current whereami
          __WRN( whoami,'VORONOI MAP CONTAINS INVALID ENTRIES.')
         endif ! voronoi_map.ne.-1
!
        else
         cv%voronoi_whereami=cv%voronoi_map(mestring+1)
        endif ! voronoi_check_map
!
       endif ! voronoi_hist_on
!      reset internal interation counter for smcv_master
       olditeration=0
!
       repa_on=(__INDX_RM(comlyn,comlen,'REPA').gt.0)
       if (repa_on) repa_freq=__GET_RM_I(comlyn,comlen,'REPF',0)
!
       if (__INDX(comlyn, comlen, 'HISF', 4).gt.0) then
        hist_freq=__GET_RM_I(comlyn,comlen,'HISF',0)
        hist_calc_M = .not.( __INDX_RM(comlyn, comlen, 'SKIPM') .gt. 0 ) ! unless skipm present, calculate average of M
       endif
!
       stat_on=(__INDX_RM(comlyn,comlen, 'STAT').gt.0)
       if (stat_on) stat_freq=__GET_RM_I(comlyn,comlen,'STAF',0)
!
       evolve_cv_on=(__INDX_RM(comlyn,comlen, 'EVOL').gt.0)
       if (evolve_cv_on) then
        evolve_smcv_on=(__INDX_RM(comlyn,comlen,'SMCV').gt.0) ! this the standard SMCV evolution (optional to specify b/c it is default)
        evolve_freq=__GET_RM_I(comlyn,comlen,'EVOF',0)
        evolve_nskip=__GET_RM_I(comlyn,comlen,'EVOS',0) ! to skip updating averages during the first evolve_nskip MD steps after evolution
!
!       express in terms of history frequency
        if (hist_freq.gt.0) evolve_nskip=evolve_nskip/hist_freq
!
        evolve_step=__GET_RM_F(comlyn,comlen,'EVST',zero) ! evolution step ! this option not relevant for all types of dynamics
! ----- types of evolution
        evolve_smooth_on=(__INDX_RM(comlyn,comlen,'SMOO').gt.0) ! smooth trajectory
        if (evolve_smooth_on) then
         if (output_cv_hist) then
          __WRN(whoami, 'CV TRAJECTORY SMOOTHING CONFLICTS WITH CV HISTORY OUTPUT (BECAUSE BOTH ERASE HISTORY). YOU HAVE BEEN WARNED.') 
         endif
         evolve_smooth_d=__GET_RM_I(comlyn,comlen,'EVOD',1)   ! smoothing filter
        endif
!
        evolve_expo_on=(__INDX_RM(comlyn,comlen,'EXPO').gt.0) ! use exponential convolution
        if (evolve_expo_on) then
         evolve_expo_mem=__GET_RM_F(comlyn,comlen,'MEMO',0.99*one)
        endif
!
        evolve_bd_on=(__INDX_RM(comlyn,comlen,'BD').gt.0) ! use brownian dynamics (M not used); for T-accelerated sampling
#ifndef __CHARMM
! initialize RNG
        if (qroot .and. .not.random_initialized) call random_init() ! only roots perform evolution
#endif
!
        evolve_aver_on=(__INDX_RM(comlyn,comlen,'AVER').gt.0) ! z=mean(theta)
        if (evolve_aver_on) then
         num_ave_cv_samples=__GET_RM_I(comlyn,comlen,'NAVE',0) ! initial number of samples in the averages                                                          setting this large will dampen initial fluctuations
        endif
!
!======== check for multiple inputs
        i=0;
        if (evolve_expo_on)   __INC(i)
        if (evolve_bd_on)     __INC(i)
        if (evolve_aver_on)   __INC(i)
        if (evolve_smooth_on) __INC(i)
        if (evolve_smcv_on)   __INC(i)
!
        if (i.ne.1) then
         if (i.gt.1) then
          __WRN(whoami,'MORE THAN ONE EVOLUTION SCHEME REQUESTED. WILL USE SMCV.')
          evolve_expo_on=.false.
          evolve_aver_on=.false.
          evolve_smooth_on=.false.
          evolve_bd_on=.false.
         endif ! i
         evolve_smcv_on=.true. ! also default option
        endif ! i
!
       endif ! evolve_cv_on
!
       restrained_on=(__INDX_RM(comlyn,comlen, 'RSTR').gt.0)
       if (restrained_on) then
!
        steering_on=( (__INDX_RM(comlyn, comlen, 'SMD').gt.0) .or. (__INDX_RM(comlyn, comlen, 'STEE').gt.0) )
        if (.not.steering_on) call cv_common_copy(main, comp)
!       also copy comp to zcur (current restraint value, combination of main and comp)
!       otherwise, neq work calculation is wrong
        call cv_common_copy(comp, zcur) ! perhaps there is a better place for this copy
!
        restrained_eq_steps=__GET_RM_I(comlyn,comlen,'REEQ',0)
        restrained_eq0=0
!       for off-path sampling
        planar_on=(__INDX_RM(comlyn,comlen, 'PLAN').gt.0) ! restraint applied parallel to the path (this is obsolete)
       endif
!
       unrestrained_on=(__INDX_RM(comlyn,comlen, 'URES').gt.0)
       if (unrestrained_on) then
        unrestrained_eq_steps=__GET_RM_I(comlyn,comlen,'UREQ',0)
        unrestrained_eq0=0
        restrained_eq0=0
! currently unrestrained dynamics works as a preliminary step for restrained dynamics, therefore :
        if (.not.restrained_on) then
         __WRN(whoami, 'UNRESTRAINED (EXPLORATION) DYNAMICS REQUIRES EQUILIBRATION WITH RESTRAINTS ("RSTR"). TURNING OFF.');
         unrestrained_on=.false.
        endif
       endif
       repl_x_on=(__INDX_RM(comlyn,comlen,'REX').gt.0)
       if (repl_x_on) then
        repl_x_freq=__GET_RM_I(comlyn,comlen,'REXF',0)
        repl_x_temp=__GET_RM_F(comlyn,comlen,'REXT',zero)
!
        if (repl_x_freq.le.0) then
          __WRN(whoami,'MUST SPECIFY POSITIVE REXF. REPLICA EXCHANGE IS OFF.')
          repl_x_on=.false.
!
        elseif (repl_x_temp.le.0) then
          __WRN(whoami,'MUST SPECIFY POSITIVE REXT. REPLICA EXCHANGE IS OFF.')
          repl_x_on=.false.
        elseif (voronoi_hist_on) then
          __WRN(whoami,'REPLICA EXCHANGE INCOMPATIBLE WITH V. TESSELATION. REX IS OFF.')
          repl_x_on=.false.
        elseif (evolve_cv_on.and.mod(repl_x_freq,evolve_freq).gt.0) then
          __WRN(whoami,'REPLICA SWAP ATTEMPT FREQ. NOT A MULTIPLE OF EVOLUTION FREQ.')
        elseif (repa_on.and.mod(repl_x_freq,repa_freq).gt.0) then
          __WRN(whoami,'REPLICA SWAP ATTEMPT FREQ. NOT A MULTIPLE OF REPA. FREQ.')
        else ! OK
          call cv_common_rex_set_temp(repl_x_temp)
        endif
       endif ! repl_x_on
!
       if (repa_on.or.evolve_cv_on.or.repl_x_on) then ! decrease output
         string_noprint=(__INDX_RM(comlyn,comlen,'NOPR').gt.0)
       endif
!--------------- DONE PARSING DYNAMICS OPTIONS -----
!    print summary
!cccccccccccccccccc STRING METHOD OPTIONS cccccccccccccccccccccc
       if (qprint) then
        WRITE (_MSGBUF,'(2A)')                                             &
     &      whoami, ' STRING METHOD ENABLED.' ; __PRINT(_MSGBUF)
        if (evolve_cv_on) then
            WRITE (_MSGBUF,'(/,2A,/,2A,I7,A)')                             &
     &      whoami, ' STRING EVOLUTION ENABLED.',                       &
     &      whoami, ' WILL EVOLVE AFTER EVERY ',                        &
     &      evolve_freq,' ITERATIONS.'  ; __PRINT(_MSGBUF)
            WRITE (_MSGBUF,'(2A,I7,A)')                                    &
     &      whoami, ' THE FIRST', evolve_nskip,                         &
     &      ' ITERATIONS AFTER STRING EVOLUTION WILL NOT CONTRIBUTE TO AVERAGES.' ; __PRINT(_MSGBUF)
!       type of evolution
            if (evolve_expo_on) then
               write(_MSGBUF,671) whoami, whoami, evolve_expo_mem ; __PRINT(_MSGBUF)
 671  format(A,' CV EVOLUTION WILL BE OF THE FORM:',/,                  &
     &       A,' Z(N+1)=A*Z(N)+(1-A)*<THETA>, A=',F9.5,'.')
            elseif (evolve_aver_on) then
               write(_MSGBUF,6710) whoami, whoami, num_ave_cv_samples ; __PRINT(_MSGBUF)
 6710 format(A,' CV EVOLUTION WILL BE OF THE FORM:',/,                  &
     &A,' Z(N+1)=AVERAGE_1^N(THETA).  INITIAL NUMBER OF SAMPLES IS ',I5,'.')
            elseif (evolve_smooth_on) then
               write(_MSGBUF,672) whoami, whoami, evolve_smooth_d ; __PRINT(_MSGBUF)
 672  format(A,' WILL EVOLVE CV BY SMOOTHING MD TRAJECTORY',/,          &
     &       A,' USING FILTER WIDTH D=',F8.3)
            elseif (evolve_bd_on) then
               write(_MSGBUF,6720) whoami, evolve_step ; __PRINT(_MSGBUF)
 6720 format(A,' WILL EVOLVE CV USING BD ADVANCEMENT WITH STEP=',F11.5, &
     &       A,' AT THE EVOLUTION TEMPERATURES SPECIFIED FOR EACH CV.' )
            elseif (evolve_smcv_on) then
               write(_MSGBUF,673) whoami, whoami, evolve_step ; __PRINT(_MSGBUF)
 673  format(A,' WILL EVOLVE CV USING SMCV ADVANCEMENT ',/,             &
     &       A,' WITH STEP=',F11.5)
            endif ! evolve_expo
        endif ! evolve_cv_on
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (repa_on) then
          WRITE (_MSGBUF,666) whoami, repa_freq ; __PRINT(_MSGBUF)
 666  format(A,' WILL REPARAMETRIZE STRING AFTER EVERY ',I7,            &
     & ' ITERATIONS.')
        endif ! repa_on
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (hist_freq.gt.0) then
         write(_MSGBUF,667) whoami, hist_freq
         if (.not.hist_calc_M) then
          if (evolve_cv_on.and.evolve_smcv_on) then
           __WRN(whoami, 'SMCV EVOLUTION REQUIRES CALCULATING M TENSOR. WILL ENABLE.')
           hist_calc_M=.true.
          else
           write(_MSGBUF(2),'(2A)') whoami, ' **** M TENSOR UPDATES ARE DISABLED ****'
          endif ! evolve_cv_on
         endif ! hist_calc_M
          __PRINT(_MSGBUF)
        endif
 667  format(A,' WILL SAVE CV VALUES AFTER EVERY ', I7, ' ITERATIONS.')
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (restrained_on) then
            WRITE (_MSGBUF,'(2A)')                                         &
     &      whoami, ' WILL USE RESTRAINED DYNAMICS.' ; __PRINT(_MSGBUF)
!
            if (steering_on) then
             write(_MSGBUF(1), '(2A)') &
             whoami, ' WILL NOT INITIALIZE DYNAMICS CV SET TO SIMULATE STEERED DYNAMICS (SMD).'
             write(_MSGBUF(2), '(2A)') &
             whoami, ' USER MUST INITIALIZE MAIN SET TO FINAL CV VALUES'
             write(_MSGBUF(3), '(2A)') &
             whoami, ' AND DYNAMICS SET TO INITIAL CV VALUES'
             write(_MSGBUF(4), '(2A,I7,A)') &
             whoami, ' STEERING SPEED IS GOVERNED BY "REEQ"(=',restrained_eq_steps,')'
             __PRINT(_MSGBUF)
            endif
!
            if (unrestrained_on) then
             WRITE (_MSGBUF,'(2A)')                                         &
     &       whoami, ' WILL USE UNRESTRAINED (EXPLORATION) DYNAMICS.' ; __PRINT(_MSGBUF)
             unrestrained_eq0=0
             WRITE (_MSGBUF,669) whoami, unrestrained_eq_steps ; __PRINT(_MSGBUF)
 669  format(A,' WILL EQUILIBRATE UNDER CV RESTRAINTS FOR ', I7, ' STEPS.')
            endif ! unrestrained_on
!
            write(_MSGBUF,665) whoami, restrained_eq_steps ; __PRINT(_MSGBUF)
            restrained_eq0=0
 665  format(A, ' WILL ADJUST TO NEW RESTRAINTS OVER ', I7, ' STEPS.')
        endif ! restrained
!
!
        if (planar_on) then
            write (_MSGBUF,'(2A)') whoami,                                 &
     & ' WILL RESTRAIN SYSTEM IN PLANE PERPENDICULAR TO PATH.' ; __PRINT(_MSGBUF)
        endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (stat_on) then
            write(_MSGBUF,668) whoami, stat_freq ; __PRINT(_MSGBUF)
 668  format(A, ' WILL OUTPUT STRING STATISTICS EVERY ',                &
     & I7, ' STEPS.')
        endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (repl_x_on) then
            write(_MSGBUF,691) whoami, whoami, repl_x_freq, repl_x_temp ; __PRINT(_MSGBUF)
 691  format(A, ' WILL ATTEMPT TO EXCHANGE NEIGHBORING REPLICAS ',/     &
     &       A, ' ONCE IN EVERY ',I6,' ITERATIONS AT ',F8.3, ' K.')
        endif ! repl_x_on
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (voronoi_hist_on) then
            write(_MSGBUF,670) whoami ; __PRINT(_MSGBUF)
 670  format(A, ' WILL COMPUTE FREE ENERGY ALONG STRING ',              &
     & 'USING VORONOI TESSELLATION.' )
         if (voronoi_allow_cross) then
          write(_MSGBUF,601) whoami ; __PRINT(_MSGBUF)
          write(_MSGBUF,602) whoami, whoami, voronoi_update_freq ; __PRINT(_MSGBUF)
          if (voronoi_nocross_ini.gt.0) then
           write(_MSGBUF, 603) whoami, whoami, voronoi_nocross_ini ; __PRINT(_MSGBUF)
          endif
 601  format(A, ' WILL ALLOW REPLICAS TO CROSS BETWEEN V. CELLS.')
 602  format(A, ' WILL UPDATE CROSSING STATISTICS ONCE IN EVERY',/,     &
     &      A, I6, ' ITERATIONS.')
 603  format(A, ' WILL DISALLOW CROSSING DURING THE INITIAL ',/,A,I6,   &
     &       ' ITERATIONS.')
         endif
         if (restrained_on) then 
          write(_MSGBUF,'(2A,/2A)')   &
     &      whoami, ' STRING DYNAMICS SHOULD BE USED WITH CAUTION',     &
     &      whoami, ' DURING VORONOI FE COMPUTATION.' ; __PRINT(_MSGBUF)
         endif
         if (evolve_cv_on.or.repa_on) then
          if (.not.voronoi_allow_cross) then
           write(_MSGBUF,'(2A,/2A)')                                       &
     &    whoami, ' PERFORMING STRING EVOLUTION / REPARAMETRIZATION ',     &
     &    whoami, ' DURING VORONOI FE TESSELLATION IS AN EXTENSION ' ,     &
     &    whoami, ' TO THE STRING METHOD BECAUSE THE M TENSOR IS NOT ',    &
     &    whoami, ' COMPUTED AT THE STRING IMAGE. YOU HAVE BEEN WARNED.'    ; __PRINT(_MSGBUF)
          else
           write(_MSGBUF,'(2A,/2A,/2A)')                                   &
     &    whoami, ' STRING EVOLUTION AND REPARAMETRIZATION CANNOT',     &
     &    whoami, ' BE USED IF VORONOI CELL CROSSING IS ALLOWED.',      &
     &    whoami, ' VORONOI CELL CROSSING WILL BE OFF.' ; __PRINT(_MSGBUF)
           voronoi_allow_cross=.false.
          endif ! voronoi_allow_cross
         endif ! evolve_cv_on
        endif ! voronoi_hist_on
       endif ! root writes
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! check cv values for NAN
!
       if (restrained_on) then
        if (any(cv%r(1:cv%num_cv,main).eq.__NAN)) then
         __WARN(whoami, 'MAIN CV SET APPEARS TO BE UNDEFINED ON GLOBAL RANK ',ME_GLOBAL,'. BEWARE.');
        elseif (any(cv%r(1:cv%num_cv,comp).eq.__NAN)) then
         __WARN(whoami, 'DYNAMICS/OLD CV SET APPEARS TO BE UNDEFINED ON GLOBAL RANK ',ME_GLOBAL,'. BEWARE.');
        endif
       endif ! restrained on
!
!      turn on string for dynamics
       smcv_on=.true.
#ifdef __CHARMM
!      call dynamics parser
       call dynopt(comlyn, comlen)
!cccccc turn off string for regular dynamics ccccccc
       smcv_on=.false.
       repa_on=.false. ! turn off after dynamics because SM0K also uses this flag; therefore a subsequent minimization would call reparametrization
#endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'ADD ',4)) then ! add CV
!         call MPI_COMM_RANK(MPI_COMM_WORLD, i,ierror)  ! aa
!        write(600+ME_GLOBAL,*) i,ME_GLOBAL, MPI_COMM_LOCAL,
!     &  ME_LOCAL, SIZE_LOCAL
!         call MPI_BARRIER(MPI_COMM_GLOBAL, ierror)
!                stop
!
       call smcv_add_cv(comlyn, comlen) ! this routine deals with the various CV
!
!     (re)compute cv index limits (for parallelization) after each addition,
!     because cv%num_cv changes
!
       if (SIZE_LOCAL.gt.0) then
        if (.not. cv_common_initialized) call cv_common_init() ! make sure cv%num_cv is defined
!
        j=ceiling(one*cv%num_cv/SIZE_LOCAL) ! max. number of CV assigned to slave node
        n=ceiling(one*cv%amap%last/SIZE_LOCAL) ! max. number of amap indices assigned to slave node
!
        do i=1,SIZE_LOCAL
         cv_send_displ(i)=min((i-1)*j,cv%num_cv-1) ! cannot exceed num_cv
         cv_send_count(i)=max(0,min(j,cv%num_cv-j*(i-1))) ! how many CV I will send to CPU i
! atom map partitioning (for parallel computation of M
!
         imap_displ(i)=min((i-1)*n,cv%amap%last-1)
         imap_count(i)=max(0,min(n,cv%amap%last-n*(i-1)))
        enddo
       endif ! SIZE
! IGNORE COMMENTS BELOW; kept for historical reasons
!  have to do some cheating: in order to communicate, I assume that the (local) number of CV is the
!  same on each processor (to that some cpus might be sending "zeros" -- cv%r that is outside of the used bounds)
!  this also means that j*SIZE_LOCAL has to be less than or equal to than max_cv_common.
!  basically, I only use cv_send_count(1)=j from the above array
!       if (SIZE_LOCAL*j.gt.max_cv_common) then
!        if (qroot) then
!         if (ME_STRNG.eq.0)
!     &     write(_MSGBUF,'(2A,I5,1A,/,2A,I5,A)' ) whoami,
!          ' CV STORAGE SPACE EXCEEDED. PARALLELIZATION REQUIRES ',
!     &    SIZE_LOCAL*j, ' ELEMENTS', whoami, ', BUT ONLY ', max_cv_common,
!     &    ' ARE ALLOCATED.'
!        endif
!        call wrndie(-4, whoami, ' CV STORAGE SPACE EXCEEDED.')
!       endif
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccc
! this type will change when the auxiliary atom array is resized
! I could define the type in grad_init (only once would be required)
! but I don`t want to contaminate cv_common module (it would need to know sm_config)
__MPI_ONLY       if (MPI_GRAD_TYPE.ne.MPI_DATATYPE_NULL) call mpi_type_free(MPI_GRAD_TYPE, ierror)
__MPI_ONLY       if (MPI_GRAD_TYPE_.ne.MPI_DATATYPE_NULL) call mpi_type_free(MPI_GRAD_TYPE_, ierror)
!
       impi=6*cv%amap%last
       jmpi=1
       kmpi=6*cv%num_cv
__MPI_ONLY       call mpi_type_vector(impi,jmpi,kmpi, & ! impi=6 because we are taking 3 gradients and both grad arrays (see cv_common)
__MPI_ONLY     &  mpifloat,MPI_GRAD_TYPE_,ierror)
!
!      indexed version
!       i=6*cv%amap%last
!       allocate(temp1(i), temp2(i))
!       temp1=(/ (1, j=1, i) /)  ! block sizes
!       temp2=(/ ( (j-1)*cv%num_cv, j=1, i) /) ! offsets from zero
!       call mpi_type_indexed(i, temp1, temp2,
!     & mpifloat, MPI_GRAD_TYPE_, ierror)
!       deallocate(temp1, temp2)
!
       lb=0
       extent=sizeofreal
__MPI_ONLY       call mpi_type_create_resized(MPI_GRAD_TYPE_,lb,extent,MPI_GRAD_TYPE,ierror)
__MPI_ONLY       call mpi_type_commit(MPI_GRAD_TYPE, ierror)
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'CLEA',4)) then ! initialize
       if (qprint) then ; write(_MSGBUF,6666) whoami ; __PRINT(_MSGBUF) ; endif
 6666 format(A,' WILL REMOVE ALL CV, FRAMES, AND QUATERNIONS.')
       call quat_done()
       call cv_common_done()
       call frames_done() ! frames rely on cv%amap, so must also be initialized
       call cv_common_init()
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccc ADDITIONAL VORONOI OPTIONS (nowhere else to put them)
      elseif (__STRNCMP(keyword,'VORO',4)) then
!*****************************************************************************************
       if (__INDX(comlyn, comlen, 'VCUT', 4).gt.0) then
        voro_cut=__GET_RM_F(comlyn, comlen, 'VCUT', zero)
! replica spec
        irep=__GET_RM_I(comlyn, comlen, 'REP', -1)
        if (voro_cut.le.zero) then
          __WRN(whoami, 'VCUT MUST BE POSITIVE. NOT SET.')
        else
         if (irep.lt.0.or.irep.ge.nstring) then
          if (qprint) then ; write(_MSGBUF, 6779) whoami, whoami, voro_cut ; __PRINT(_MSGBUF) ; endif
          call cv_common_voronoi_set_cutoff(voro_cut)
         else
          if (qprint) then ; write(_MSGBUF, 6780) whoami, irep, voro_cut ; __PRINT(_MSGBUF) ; endif
          if (mestring.eq.irep) call cv_common_voronoi_set_cutoff(voro_cut)
         endif ! irep
         if (qprint) then 
          write(_MSGBUF,'(2A,/2A,F11.7,A)')                                                        &
     &     whoami,' STRING WILL BE RESTRICTED TO STAY WITHIN THE WEIGHTED',                        &
     &     whoami,' DISTANCE ',voro_cut,' OF THE CELL CENTERS DURING DYNAMICS.' ; __PRINT(_MSGBUF)
         endif
!
 6779 format(A,' REPLICA NUMBER INVALID OR UNSPECIFIED.',/A,' WILL SET VORONOI TUBE CUTOFF ', &
     & '  TO ',F7.3,' ON ALL REPLICAS.')
 6780 format(A,' WILL SET VORONOI TUBE CUTOFF ON REPLICA ',I5,' TO ',F7.3,'.')
        endif ! voro_cut > 0
!
       endif ! VCUT
! process other voronoi commands
! get command
       if (comlen .ge. 4) then ! process additional commands
        keyword=__NEXTA(comlyn,comlen)
!    voronoi map commands cccccccccccccccccccccccccccccccccccccccccccccccccc
        if (__STRNCMP(keyword,'VMAP',4)) then
         if (__INDX_RM(comlyn, comlen, 'CALC').gt.0) then
          if (qprint) then ; write(_MSGBUF,6010) whoami ; __PRINT(_MSGBUF) ; endif
 6010 format(A,' WILL CALCULATE VORONOI MAP FROM MAIN COORDINATES.')
          call smcv_voronoi_whereami(__X,__Y,__Z,__MASS)
!    put 'whereami' into the map
          if (qroot) then 
           if (SIZE_STRNG.gt.1) then
__MPI_ONLY            call MPI_ALLGATHER(cv%voronoi_whereami, 1, mpiint,       &
__MPI_ONLY     &       cv%voronoi_map, 1, mpiint, MPI_COMM_STRNG, ierror)
           else
            cv%voronoi_map(mestring+1)=cv%voronoi_whereami
           endif ! size
          endif ! root
          if (qslave) then
#ifdef __CHARMM
          __BROADCAST_LOCAL_4B(cv%voronoi_map,nstring)  !__CHARMM_ONLY##.not.INTEGER8
          __BROADCAST_LOCAL_8B(cv%voronoi_map,nstring)  !__CHARMM_ONLY##INTEGER8
#elif defined (__DMOL)
          __BROADCAST_LOCAL(cv%voronoi_map,nstring,mpiint)
#endif
!
          endif
!    print map cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         elseif ((__INDX_RM(comlyn, comlen, 'PRIN').gt.0) .or. (__INDX_RM(comlyn, comlen, 'WRIT').gt.0)) then
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
          if (qroot) then
           if (flen.gt.0) then
            if (qprint) then 
#ifdef __CHARMM
             oldiol=iolev
             iolev=1
#endif
             __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
             write(_MSGBUF,6011) whoami, fname(1:flen) ; __PRINT(_MSGBUF)
            endif
 6011 format(A,' WRITING VORONOI MAP TO FILE ',A,'.')
            call cv_common_print_voro_map(ifile)
            if (qprint) then 
             __CLOSE_FILE(ifile,'KEEP',ierror) 
#ifdef __CHARMM
             iolev=oldiol
#endif
            endif
           else
            __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
           endif ! flen
          endif ! qroot
!    read map ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         elseif (__INDX_RM(comlyn, comlen, 'READ').gt.0) then
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
          if (flen.GT.0) then
            if (qprint) then 
#ifdef __CHARMM
             oldiol=iolev
             iolev=1
#endif
             __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
             write(_MSGBUF,6013) whoami, fname(1:flen) ; __PRINT(_MSGBUF)
            endif
!
 6013 format(A,' READING VORONOI MAP FROM FILE ',A,'.')
            call cv_common_read_voro_map(ifile)
            if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
             iolev=oldiol
#endif
            endif
          else
            __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
          endif ! flen
!ccc reset map cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         elseif (__INDX_RM(comlyn, comlen, 'CLEA').gt.0) then
          if (associated(cv%voronoi_map)) cv%voronoi_map=-ione
         endif ! 'CALC'
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        elseif (__STRNCMP(keyword,'READ',4)) then
!    read "restart" file that contains (1) crossing_attempt (2) crossing_accepts (3) occupancy
         ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
         __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
         if (flen.GT.0) then
          if (qprint) then
#ifdef __CHARMM
           oldiol=iolev
           iolev=1
#endif
           __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
           write(_MSGBUF,6014) whoami, fname(1:flen) ; __PRINT(_MSGBUF) 
          endif
 6014 format(A,' READING VORONOI CROSSING DATA FROM FILE ',A,'.')
          call cv_common_read_voro_data(ifile)
          if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
           iolev=oldiol
#endif
          endif
         else
          __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
         endif ! flen
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        elseif ((__STRNCMP(keyword,'PRIN',4)) .or. (__STRNCMP(keyword,'WRIT',4))) then
         ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
         __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
         if (flen.gt.0) then
           if (qprint) then
#ifdef __CHARMM
            oldiol=iolev
            iolev=1
#endif
            __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
            write(_MSGBUF,6015) whoami, fname(1:flen) ; __PRINT(_MSGBUF)
 6015 format(A,' WRITING VORONOI CROSSING DATA TO FILE ',A,'.')
           endif
           call cv_common_print_voro_data(ifile)
           if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
            iolev=oldiol
#endif
           endif
         else
            __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
         endif ! flen
        endif ! VMAP
       endif ! VCUT
! for now, it is unclear how to best provide seamless RNG series in CHARMM
#ifndef __CHARMM
!============================ SEEDS FOR RNG =============================
      elseif (__STRNCMP(keyword,'RSEE',4)) then ! RNG parser
       keyword=__NEXTA(comlyn,comlen)
       if (__STRNCMP(keyword, 'READ',4)) then
        qall = max( __INDX_RM(comlyn,comlen,'ALL'),__INDX_RM(comlyn,comlen,'LOCAL')) ! whether to read on all nodes
!
!      prepare file
        ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
        __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: flen will be UPPER CASE
        if (qroot) then
!cccccccccccccccccccccccccccc OPEN FILE ccccccccccccccccccccccc
         if (qall.gt.0.or.qprint) then
          if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','READ') ; endif
         endif
         if(ifile .eq. -1) then
          __WRN(whoami, 'CANNOT OPEN FILE "'//trim(fname)//'". NOTHING DONE')
          return
         endif
!cccccccccccccccccccccccccccc ^OPEN FILE^ cccccccccccccccccccccc
         if (qprint) then ; write(_MSGBUF,'(2A)') whoami, ' READING RANDOM NUMBER SEEDS FROM FILE" '//trim(fname)//'"' ; __PRINT(_MSGBUF) ; endif
         __FREE(random_seeds)
         allocate(random_seeds(4,nstring)) ! allocate enough space for all roots
         if (qall.gt.0) then ! local read on all string roots
          read(ifile,*) random_seeds(:,mestring+1)
         else ! string root reads and scatters to other roots
          if (qprint) then
           do i=1,nstring
            read(ifile,*) random_seeds(:,i)
           enddo
          endif ! string root
! scatter to other roots
          if (nstring.gt.1) then
           if (mestring.eq.0) then
 __MPI_ONLY         call MPI_SCATTER(random_seeds, 4, mpifloat,      &
 __MPI_ONLY     &    MPI_IN_PLACE,4,mpifloat,0,MPI_COMM_STRNG,   &
 __MPI_ONLY     &    ierror)
           else
 __MPI_ONLY         call MPI_SCATTER(random_seeds, 4, mpifloat,      &
 __MPI_ONLY     &    random_seeds(1,mestring+1),4,mpifloat,0,MPI_COMM_STRNG,   &
 __MPI_ONLY     &    ierror)
           endif
          endif ! nstring > 1
         endif ! qall
!    close file
         if (qprint.or.qall.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
!    assign seeds
         call random_init(random_seeds(:,mestring+1))
         __FREE(random_seeds)
        endif ! qroot
!======================================================================================
       elseif ((__STRNCMP(keyword, 'WRIT',4)).or.(__STRNCMP(keyword, 'PRIN',4))) then
        qall = max( __INDX_RM(comlyn,comlen,'ALL'),__INDX_RM(comlyn,comlen,'LOCAL')) ! whether to read on all nodes
!
!      prepare file
        ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
        __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: flen will be UPPER CASE
        if (qroot) then
!cccccccccccccccccccccccccccc OPEN FILE ccccccccccccccccccccccc
         if (qall.gt.0.or.qprint) then
          if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','WRITE') ; endif
         endif
         if(ifile .eq. -1) then
          __WRN(whoami, 'CANNOT OPEN FILE "'//trim(fname)//'". NOTHING DONE')
          return
         endif
!cccccccccccccccccccccccccccc ^OPEN FILE^ cccccccccccccccccccccc
         if (qprint) then ; write(_MSGBUF,'(2A)') whoami, ' WRITING RANDOM NUMBER SEEDS TO FILE" '//trim(fname)//'"' ; __PRINT(_MSGBUF) ; endif
         __FREE(random_seeds)
         allocate(random_seeds(4,nstring)) ! allocate enough space for all roots
         random_seeds(:,mestring+1)=random_get_seeds()
         if (qall.gt.0) then ! local write on all string roots
          write(ifile,*) random_seeds(:,mestring+1)
         else ! string root gathers from all roots and writes
! scatter to other roots
          if (nstring.gt.1) then
           if (mestring.eq.0) then
 __MPI_ONLY         call MPI_GATHER(MPI_IN_PLACE, 4, mpifloat,   &
 __MPI_ONLY     &    random_seeds,4,mpifloat,0,MPI_COMM_STRNG,   &
 __MPI_ONLY     &    ierror)
           else
 __MPI_ONLY         call MPI_GATHER(random_seeds(:,mestring+1), 4, mpifloat,   &
 __MPI_ONLY     &    random_seeds,4,mpifloat,0,MPI_COMM_STRNG,                 &
 __MPI_ONLY     &    ierror)
           endif
          endif ! nstring > 1
!
          if (qprint) then
           do i=1,nstring
            write(ifile,*) random_seeds(:,i)
           enddo
          endif ! string root
!
         endif ! qall
!    close file
         if (qprint.or.qall.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
         __FREE(random_seeds)
        endif ! qroot
!
       endif
#endif
!cccccccccccccccccccc FRAMES PARSER ccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'FRAM',4)) then ! frames parser
!    get frames command
       keyword=__NEXTA(comlyn,comlen)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       if (__STRNCMP(keyword,'CLEA',4)) then ! initialize
        if (qprint) then ; write(_MSGBUF,6667) whoami ; __PRINT(_MSGBUF) ; endif
 6667 format(A,' WILL REMOVE ALL LOCAL FRAMES.')
        call frames_done()
        call frames_init()
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'RESE',4)) then ! initialize
        if (qprint) then ; write(_MSGBUF,6650) whoami ; __PRINT(_MSGBUF) ; endif
 6650 format(A,' WILL FORCE RECALCULATION OF FRAME AXES.')
        call frames_reset_calculate(.true.)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif ( (__STRNCMP(keyword,'FILL',4)).or.(__STRNCMP(keyword,'CALC',4)) ) then ! compute frame axes values from current coordinates
!
        qcomp=(__INDX_RM(comlyn, comlen, 'COMP').gt.0) ! compute CV from comp set?
!
        if (frames%num_frames.lt.1) then
         __WRN(whoami,'NO FRAMES DEFINED. NOTHING DONE.')
        else
!       first process special option: ALIGn
!       frame axes will be calculated based on the main set, but `consistently` with the comparison set;
!       specifically: the frame axes are permuted such that the rotation matrix associated with transforming one frame into another is the closest
!       to the best-fit-RMSD rotation matrix
         if (__INDX_RM(comlyn, comlen, 'ALIG').gt.0) then
          if (any(__XCOMP.eq.__NAN)) then
           __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
          elseif (any(__X.eq.__NAN)) then
           __WRN(whoami,'COMPARISON X SET HAS UNDEFINED VALUES. NOTHING DONE.')
          else
           if (qcomp) then
            if (qprint) then ; write(_MSGBUF,6651) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 6651 format(A,' WILL CALCULATE FRAME AXES FROM',                      &
     &          ' COMPARISON COORDINATES USING',                        &
     &       /A,' BEST-FIT ALIGNMENT WITH MAIN COORDINATES.')
            do i=1, frames%num_frames
             call frames_calc_align_comp(                               &
     &                  i,__XCOMP,__YCOMP,__ZCOMP,__X,__Y,__Z,__MASS,.true.)
            enddo
           else ! qcomp
            if (qprint) then ; write(_MSGBUF,6652) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 6652 format(A,' WILL CALCULATE FRAME AXES FROM',                      &
     &          ' MAIN COORDINATES USING BEST-FIT',                     &
     &       /A,' ALIGNMENT WITH COMPARISON COORDINATES.')
            do i=1, frames%num_frames
             call frames_calc_align_comp(                               &
     &                   i,__X,__Y,__Z,__XCOMP,__YCOMP,__ZCOMP,__MASS,.true.)
            enddo
           endif ! qcomp
           call frames_reset_calculate(.true.) ! make sure that next time frames_calc is called we recalculate axes (to be safe)
          endif ! xcomp
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!        process regular fill
         elseif (qcomp) then
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
          if (any(__XCOMP.eq.__NAN)) then
           __WRN(whoami,'COMPARISON X SET HAS UNDEFINED VALUES. NOTHING DONE.')
          else
           if (qprint) then ; write(_MSGBUF,6656) whoami ; __PRINT(_MSGBUF) ; endif
 6656 format(A,' WILL CALCULATE FRAME AXES FROM COMPARISON COORDINATES.')
           do i=1, frames%num_frames
            call frames_calc(i,__XCOMP,__YCOMP,__ZCOMP,__MASS,.true.)
           enddo
           call frames_reset_calculate(.true.) ! make sure that next time frames_calc is called we recalculate axes (to be safe)
          endif ! xcomp.eq.__NAN
         else ! qcomp false -- use main coords
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
          if (any(__X.eq.__NAN)) then
           __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
          else
           if (qprint) then ; write(_MSGBUF,6668) whoami ; __PRINT(_MSGBUF) ; endif
 6668 format(A,' WILL CALCULATE FRAME AXES FROM MAIN COORDINATES.')
           do i=1, frames%num_frames
            call frames_calc(i,__X,__Y,__Z,__MASS,.true.)
           enddo
           call frames_reset_calculate(.true.) ! make sure that next time frames_calc is called we recalculate axes (to be safe)
          endif ! x.eq.__NAN
         endif ! qcomp
        endif ! num_frames < 1
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif ((__STRNCMP(keyword,'PRIN',4)).or.(__STRNCMP(keyword,'WRIT',4))) then
!      can write both a local and a global file
!      local is specified with 'ALL'; global is the default
        qall = max( __INDX_RM(comlyn,comlen,'ALL'),__INDX_RM(comlyn,comlen,'LOCAL'))
        qrest=(__INDX_RM(comlyn,comlen,'REST')).gt.0 ! human-readable restart file format
!      prepare file
!-----------------------------------------------------------------------------
        ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
        __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
!---------------------------------- OPEN FILE --------------------------------
        if (qroot) then
         if (qall.gt.0.or.qprint) then
#ifdef __CHARMM
          oldiol=iolev
          iolev=0 ! trick to open file on all nodes
#endif
          if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','WRITE') ; endif
          if (ifile .eq. -1) ifile=__OSTREAM ! write to output stream
         endif
!---------------------------- assume file is open, write -------------------------
         if (qprint) then ; write(_MSGBUF,6669) whoami ; __PRINT(_MSGBUF) ; endif
 6669 format(A,' WRITING LOCAL FRAME AXES.')
         if (qall.eq.0) then ; call frames_print_global(ifile, qraw_=.not.qrest, qhead_=.true.) ;
         else ; call frames_print_local(ifile, qraw_=.not.qrest, qhead_=.true.) ; endif
         if (qall.gt.0.or.qprint) then
          if (flen.gt.0) __CLOSE_FILE(ifile,'KEEP',ierror)
#ifdef __CHARMM
          iolev=oldiol
#endif
         endif
        endif ! qroot
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'READ',4)) then
!      can read from both a local and a global file
!      local is specified with 'ALL'; default is global
        qall = max( __INDX_RM(comlyn,comlen,'ALL'),__INDX_RM(comlyn,comlen,'LOCAL'))
        qrest=(__INDX_RM(comlyn,comlen,'REST')).gt.0 ! human-readable restart file format
!      prepare file
        ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
        __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: flen will be UPPER CASE
        if (qroot) then
!cccccccccccccccccccccccccccc OPEN FILE ccccccccccccccccccccccc
         if (qall.gt.0.or.qprint) then
#ifdef __CHARMM
          oldiol=iolev
          iolev=0 ! open file on all processors
#endif
          if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','READ') ; endif
         endif
         if (ifile .eq. -1) then ! this is a possible bug because, if __OPEN_FILE causes ifile=-1, b/c e.g. missing file, then we expect a read from command prompt
          Ifile=__ISTREAM ! read from input file
#ifdef __CHARMM
          call rdtitl(titleb,ntitlb,ifile,0) ! 0 = card format
#else
! if not using CHARMM, do not want to read from stream
          __WRN(whoami, 'CANNOT OPEN FILE WITH FRAME AXES.')
          return
#endif
         elseif (ifile.lt.0) then ! invalid handle
          __WRN(whoami, 'CANNOT OPEN FILE WITH FRAME AXES.') ! NOTE: Possibly a bug because _WRN should be called on all processors if the code is synchronous
          return
         endif
!cccccccccccccccccc assume file is open, read ccccccccccccccccccc
         if (qprint) then ; write(_MSGBUF,6670) whoami ; __PRINT(_MSGBUF) ; endif
 6670 format(A,' READING LOCAL FRAME AXES.')
         if (qall.gt.0) then ; call frames_read_local(-ifile, qraw_=.not.qrest) ;
         else ; call frames_read_global(-ifile, qraw_=.not.qrest) ; endif
         if (qall.gt.0.or.qprint) then
          if (flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
#ifdef __CHARMM
          iolev=oldiol
#endif
         endif
        endif ! qroot
! send to slaves
        if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1)                        &
     &    __BROADCAST_LOCAL(frames%r(:,:,:), frames%num_frames*9,mpifloat)
!     &   call MPI_BCAST(frames%r(:,:,:), frames%num_frames*9,mpifloat, 0, MPI_COMM_LOCAL, ierror)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'ADD',3)) then
        i=smcv_frame_add(comlyn, comlen)
!
!     (re)compute frame index limits (for parallelization) after each addition
!
        if (SIZE_LOCAL.gt.0) then
         if (.not.frames_initialized) call frames_init() ! make sure frames%num_frames is defined
!
         j=ceiling(one*frames%num_frames/SIZE_LOCAL) ! max. number of frames assigned to slave node
         n=ceiling(one*cv%amap%last/SIZE_LOCAL) ! max. number of amap indices assigned to slave node
!
         do i=1,SIZE_LOCAL
          fr_send_displ(i)=min((i-1)*j,frames%num_frames-1) ! cannot exceed num_cv
          fr_send_count(i)=max(0,min(j,frames%num_frames-j*(i-1))) ! how many CV I will send to CPU i
! atom map partitioning (for parallel computation of M
!
          imap_displ(i)=min((i-1)*n,cv%amap%last-1)
          imap_count(i)=max(0,min(n,cv%amap%last-n*(i-1)))
         enddo
        endif
!cccc !aa
!
!        write(0,*) ME_LOCAL, fr_send_displ(ME_LOCAL+1),
!     &      fr_send_count(ME_LOCAL+1),frames%num_frames
!            stop
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'LIST',4)) then ! list frames
        if (qprint) then ; write(_MSGBUF,6671) whoami ; __PRINT(_MSGBUF) ; endif
 6671 format(A,' WILL LIST LOCAL FRAMES.')
       call frames_list() ! list local frames
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'ALIG',4)) then ! iteratively invert frame vectors (v -> -v)
!                                                      to guess the best alignment along string &
!                                                      (optional) to mimimize DIST(z,theta(x))
        min_rmsd=(__INDX_RM(comlyn,comlen,'RMSD').gt.0) ! look for optimal RMSD alignment : i.e. minimize DIST(z,theta(x)) ?
!
        if (qprint) then ; write(_MSGBUF,6672) whoami ; __PRINT(_MSGBUF) ; endif
 6672 format(A,' WILL ALIGN LOCAL FRAMES.')
        if (__INDX_RM(comlyn,comlen,'VORO').gt.0) then
          if (qprint) then ; write(_MSGBUF,6673) whoami ; __PRINT(_MSGBUF) ; endif
 6673 format(A,' WILL FIT THE VORONOI MAP.')
          call frame_align_voro(__X,__Y,__Z,__MASS)
        else
          if (min_rmsd.and.qprint) then ; write(_MSGBUF,6674) whoami ; __PRINT(_MSGBUF) ; endif
 6674 format(A,' WILL CHECK RMSD(Z,THETA[X]).')
          call frames_align_string(__X,__Y,__Z,__MASS,min_rmsd) ! subroutine moved to sm_util to resolve dependency problems
        endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       else
            __WARN(whoami,'UNRECOGNIZED SUBCOMMAND: ',keyword)
       endif ! frames parser
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif ( (__STRNCMP(keyword,'FILL',4)).or.(__STRNCMP(keyword,'CALC',4)) ) then ! fill CV values from current coordinates
!
       qcomp=(__INDX_RM(comlyn, comlen, 'COMP').gt.0)
!
! force recalculation of quaternions before and after fill
       call quat_reset_calculate(.true.)
       call frames_reset_calculate(.true.)
!
       if (qcomp) then
        if (any(__XCOMP.eq.__NAN)) then
         __WRN(whoami,'COMPARISON X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         if (qprint) then ; write(_MSGBUF,6657) whoami ; __PRINT(_MSGBUF) ; endif
 6657 format(A,' WILL COMPUTE CV VALUES FROM COMPARISON COORDINATES.')
!     check for column spec
         c1=sm_get_column(comlyn, comlen, qcoltag=.true., missing=-1)
!
         if (c1.gt.0) then
          if (qprint) then ; write(_MSGBUF,6661) whoami, c1 ; __PRINT(_MSGBUF) ; endif
          call smcv_fill(__XCOMP,__YCOMP,__ZCOMP,__MASS,c1)
          call cv_common_unwrap_angles(c1) ! in case they are present
         else
          if (qprint) then ; write(_MSGBUF,6662) whoami ; __PRINT(_MSGBUF) ; endif
          call smcv_fill(__XCOMP,__YCOMP,__ZCOMP,__MASS)
          call cv_common_unwrap_angles() ! in case they are present
         endif ! c1
        endif ! x.eq.__NAN
       else ! ~qcomp -- use main coirdinates
        if (any(__X.eq.__NAN)) then
         __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         if (qprint) then ; write(_MSGBUF,6660) whoami ; __PRINT(_MSGBUF) ; endif
 6660 format(A,' WILL COMPUTE CV VALUES FROM MAIN COORDINATES.')
!     check for column spec
         c1=sm_get_column(comlyn, comlen, qcoltag=.true., missing=-1)
         if (c1.gt.0) then
          if (qprint) then ; write(_MSGBUF,6661) whoami, c1 ; __PRINT(_MSGBUF) ; endif
 6661  format(A,' WILL FILL COLUMN ',I3,'.')
          call smcv_fill(__X,__Y,__Z,__MASS,c1)
          call cv_common_unwrap_angles(c1) ! in case they are present
         else
          if (qprint) then ; write(_MSGBUF,6662) whoami ; __PRINT(_MSGBUF) ; endif
 6662  format(A,' WILL FILL DEFAULT COLUMN.')
          call smcv_fill(__X,__Y,__Z,__MASS)
          call cv_common_unwrap_angles() ! in case they are present
         endif ! c1
        endif ! x.eq.__NAN
       endif ! qcomp
! force recalculation of quaternions before and after fill
       call quat_reset_calculate(.true.)
       call frames_reset_calculate(.true.)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'TEST',4)) then !
       if (__INDX_RM(comlyn,comlen,'GRAD').gt.0) then ! finite-difference gradient test
! check fd spec
        if (__INDX(comlyn, comlen, 'STEP', 4).gt.0) then
         step=__GET_RM_F(comlyn, comlen, 'STEP', finite_difference_d)
        else
         step=finite_difference_d
        endif
        if (qprint) then ; write(_MSGBUF, 7001) whoami,whoami,step,whoami,whoami ; __PRINT(_MSGBUF) ; endif
 7001  format(A,' WILL TEST GRADIENTS USING FINITE DIFFERENCES',       &
     &        /A,' USING DX = DY = DZ = ',F15.9,'.',                    &
     &        /A,' MAIN COORDINATE SET MUST BE DEFINED.',               &
     &        /A,' !!! WARNING !!! THIS TEST WILL OVERWRITE "MAIN", "ZCUR", AND "OLD/DYNA" CV ARRAYS')
        if (cv%num_cv.lt.1) then
         __WRN(whoami,'NO CV DEFINED. NOTHING DONE.')
        elseif (any(__X.eq.__NAN)) then
         __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         fd_error=>smcv_test_grad_fd(__X,__Y,__Z,__MASS,step)
         if (qprint) then
          write(_MSGBUF,7002) whoami, whoami ; __PRINT(_MSGBUF)
 7002  format(A,' CV#, DGRAD_X_MAX, DGRAD_Y_MAX, DGRAD_Z_MAX',         &
     &        /A,' ==========================================')
          do i=1, cv%num_cv
         write(_MSGBUF,'(A," ",I5," ",3(F15.9," "))')whoami,i,fd_error(i,:) ; __PRINT(_MSGBUF)
!          write(_MSGBUF,*), i, fd_error(i,:)
          enddo
         endif ! qprint
!     decide whether the test was passed
         zval=abs(maxval(fd_error))
         if (zval.lt.abs(step)*one) then
          write(_MSGBUF,7003) whoami, zval, whoami ; __PRINT(_MSGBUF)
         else
          write(_MSGBUF,7004) whoami, zval, whoami ; __PRINT(_MSGBUF)
          __WRN(whoami,'FINITE DERIVATIVE TEST FAILED.')
         endif ! report test result
 7003 format(A, ' THE MAXIMUM GRADIENT ERROR IS ',F15.9,', ',          &
     &       /A, ' WHICH IS SMALLER THAN STEP. TEST PASSED.')
 7004 format(A, ' THE MAXIMUM GRADIENT ERROR IS ',F15.9,', ',          &
     &       /A, ' WHICH IS NO SMALLER THAN STEP. TEST FAILED.')
         deallocate(fd_error) ! smcv_test_grad returns a pointer to an array of abs errors
        endif
       endif ! grad
!
       if (__INDX_RM(comlyn,comlen,'PARA').gt.0) then ! parallel communication test
        if (qprint) then ; write(_MSGBUF, 7005) whoami,whoami,whoami ; __PRINT(_MSGBUF) ; endif
 7005  format(A,' WILL COMPARE PARALLEL AND SERIAL CV COMPUTATION',    &
     &        /A,' MAIN COORDINATE SET MUST BE DEFINED.',               &
     &        /A,' WILL OVERWRITE "ZCUR" CV ARRAY')
        if (any(__X.eq.__NAN)) then
         __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         fd_error=>smcv_test_parallel(__X,__Y,__Z,__MASS) ! use the same array as above
         if (qprint) then
          write(_MSGBUF,7006) whoami, whoami ; __PRINT(_MSGBUF)
 7006  format(A,' CV#, DCV, DGRAD_X_MAX, DGRAD_Y_MAX, DGRAD_Z_MAX',    &
     &        /A,' ===============================================')
          do i=1, cv%num_cv
         write(_MSGBUF,'(A," ",I5," ",4(F15.9," "))')whoami,i,fd_error(i,:) ; __PRINT(_MSGBUF)
!          write(_MSGBUF,*), i, fd_error(i,:)
          enddo
         endif ! qprint
!     decide whether the test was passed
         zval=abs(maxval(fd_error))
         if (zval.lt.parallel_tolerance) then
          write(_MSGBUF,7007) whoami, zval, whoami, parallel_tolerance ; __PRINT(_MSGBUF)
         else
          write(_MSGBUF,7008) whoami, zval, whoami, parallel_tolerance ; __PRINT(_MSGBUF)
          __WRN(whoami,'PARALLEL COMPUTATION TEST FAILED.')
         endif ! report test result
 7007 format(A, ' THE MAXIMUM ierror IS ',E12.5,', ',                   &
     &       /A, ' WHICH IS SMALLER THAN ',E12.5,'. TEST PASSED.')
 7008 format(A, ' THE MAXIMUM ierror IS ',E12.5,', ',                   &
     &       /A, ' WHICH IS NO SMALLER THAN ',E12.5,'. TEST FAILED.')
         deallocate(fd_error) ! smcv_test_grad returns a pointer to an array of abs errors
        endif
       endif ! para
!
       if (__INDX_RM(comlyn,comlen,'MINV').gt.0) then ! finite-difference gradient test
        if (qprint) then ; write(_MSGBUF, 7010) whoami,whoami,whoami, whoami ; __PRINT(_MSGBUF) ; endif
 7010  format(A,' WILL COMPARE M TENSOR INVERSE COMPUTATION',          &
     &        /A,' USING LU DECOMPOSITION AND MULTIDIAGONAL',           &
     &        /A,' MATRIX INVERSION.'                                   &
     &        /A,' MAIN COORDINATE SET MUST BE DEFINED.')
        if (any(__X.eq.__NAN)) then
         __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         zval=smcv_test_Minv(__X,__Y,__Z,__MASS)
         if (zval.lt.parallel_tolerance) then
          write(_MSGBUF,7011) whoami, zval, whoami, parallel_tolerance ;  __PRINT(_MSGBUF)
         else
          write(_MSGBUF,7012) whoami, zval, whoami, parallel_tolerance ;  __PRINT(_MSGBUF)
          __WRN(whoami,'M INVERSE TEST FAILED.')
         endif ! report test result
!
 7011 format(A, ' THE MAXIMUM DIFFERENCE IS ',E12.5,', ',              &
     &       /A, ' WHICH IS SMALLER THAN ',E12.5,'. TEST PASSED.')
 7012 format(A, ' THE MAXIMUM DIFFERENCE IS ',E12.5,', ',              &
     &       /A, ' WHICH IS NO SMALLER THAN ',E12.5,'. TEST FAILED.')
        endif
       endif
! other tests will go below this line
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! specify parallel CV calculation options
      elseif (__STRNCMP(keyword,'PARA',4)) then
       do while (comlen .gt. 1)
        keyword=__NEXTA(comlyn, comlen)
        select case(keyword)
         case('QUAT');
          keyword=__NEXTA(comlyn, comlen)
          select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_qt_para=.true.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'QUATERNIONS', keyword ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_qt_para=.false.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'QUATERNIONS', keyword ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED FOR "QUAT"')
          end select
         case('FRAM');
          keyword=__NEXTA(comlyn, comlen)
          select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_fr_para=.true.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'FRAMES', keyword ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_fr_para=.false.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'FRAMES', keyword ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED FOR "FRAM"')
          end select
         case('COLV');
          keyword=__NEXTA(comlyn, comlen)
          select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_cv_para=.true.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'CV', keyword ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_cv_para=.false.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'CV', keyword ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED FOR "COLV"')
          end select
         case('MMAT');
          keyword=__NEXTA(comlyn, comlen)
          select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_Mtensor_para=.true.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'M TENSOR', keyword ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_Mtensor_para=.false.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'M TENSOR', keyword ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED FOR "MMAT"')
          end select
         case('VORO');
          keyword=__NEXTA(comlyn, comlen)
          select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_voronoi_para=.true.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'VORONOI NORM', keyword ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_voronoi_para=.false.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'VORONOI NORM', keyword ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED FOR "VORO"')
          end select
         case default
          __WRN( whoami,'UNKNOWN OPTION SPECIFIED FOR "PARA"')
        end select
       enddo ! comlen
 7009  format(A, ' PARALLEL COMPUTATION OF ',A,' ',A)
!
      elseif (__STRNCMP(keyword,'MINV',4)) then
       keyword=__NEXTA(comlyn, comlen)
       select case(keyword)
        case('LU','lu')
          keyword='LU'; inverse_LU=.true.
          if (qprint) then ; write(_MSGBUF,7013) whoami, keyword ; __PRINT(_MSGBUF) ; endif
        case('DIAG','diag')
          keyword='MULTDIAG' ; inverse_LU=.false.
          if (qprint) then ; write(_MSGBUF,7013) whoami, keyword ; __PRINT(_MSGBUF) ; endif
        case default
          __WRN(whoami,'UNKNOWN MATRIX INVERSION OPTION SPECIFIED.')
       end select
 7013  format(A, ' MATRIX INVERSION WILL USE ',A,' ROUTINES.')
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'FIX',3)) then ! tell cv_posi about fixed "virtual" replicas
       if (qprint) then ; write(_MSGBUF, 6665) whoami, whoami ; __PRINT(_MSGBUF) ; endif
       fixed_bc_0=(__INDX_RM(comlyn,comlen,'FIRS').gt.0)
       fixed_bc_1=(__INDX_RM(comlyn,comlen,'LAST').gt.0)
       if (fixed_bc_0) then
         fixbc=' '
         flen=1
       else
         fixbc=' NOT '
         flen=5
       endif
       if (qprint) then ; write(_MSGBUF,6663) whoami, fixbc(1:flen) ; __PRINT(_MSGBUF) ; endif
       if (fixed_bc_1) then
         fixbc=' '
         flen=1
       else
         fixbc=' NOT '
         flen=5
       endif
       if (qprint) then ; write(_MSGBUF,6664) whoami, fixbc(1:flen) ; __PRINT(_MSGBUF) ; endif
       call cv_common_set_bc(fixed_bc_0, fixed_bc_1)
 6663 format(A,' FIRST REPLICA OF STRING WILL',A,'BE FIXED.')
 6664 format(A,' LAST REPLICA OF STRING WILL',A,'BE FIXED.'/)
 6665 format(A,' WARNING: SETTING BC REQUIRES REINITIALIZATION.',/,     &
     &       A,' ALL CV DATA WILL BE ERASED.')
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif ((__STRNCMP(keyword,'PRIN',4)) .or. (__STRNCMP(keyword,'WRIT',4))) then
!      can write both a local and a global file
!      local is specified with 'LOCAL'; global is the default
       qall = max( __INDX_RM(comlyn,comlen,'ALL'),__INDX_RM(comlyn,comlen,'LOCAL'))
       qrest=(__INDX_RM(comlyn,comlen,'REST')).gt.0 ! whether to print a (complete) restart file
!      prepare file
!-----------------------------------------------------------------------------
       ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
       __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
!---------------------------------- OPEN FILE --------------------------------
       if (qroot) then
        if (qall.gt.0.or.qprint) then
#ifdef __CHARMM
         oldiol=iolev
         iolev=0 ! trick to open file on all nodes
#endif
         if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','WRITE') ; endif
        endif
        if (ifile .eq. -1) ifile=__OSTREAM ! write to output stream
!
        if (qrest.and.qprint) then ; write(_MSGBUF,*) whoami, ' WILL USE SMCV RESTART FORMAT';__PRINT(_MSGBUF);endif
!---------------------------- assume file is open, write -------------------------
!     check for column spec
        c1=sm_get_column(comlyn, comlen, qcoltag=.true., missing=-1)
        if (c1.gt.0) then
         if (qprint) then ; write(_MSGBUF,6679) whoami, c1 ; __PRINT(_MSGBUF) ; endif
 6679 format(A,' WRITING COORDINATES FROM COLUMN ',I3)
         if (qall.eq.0) then ; call cv_common_print_global(iunit=ifile,col=c1,qraw_=.not.qrest) ;
         else ; call cv_common_print_local(ifile,c1,qraw_=.not.qrest) ; endif
        else
         if (qprint) then ; write(_MSGBUF,6689) whoami ; __PRINT(_MSGBUF) ; endif
 6689 format(A,' WRITING COORDINATES FROM DEFAULT COLUMN.')
         if (qall.eq.0) then ; call cv_common_print_global(iunit=ifile,qraw_=.not.qrest) ;
         else ; call cv_common_print_local(ifile,qraw_=.not.qrest) ; endif
        endif ! c1
!    if restart file, output additional data
        if (qrest) then
#define __PAR ifile, qraw_=.false., qhead_=.false.
         if (qall.eq.0) then ! global
          call cv_common_print_M_global(__PAR) ! output default M array (long-term average)
          call frames_print_global(__PAR) ! output frames
         else
! nothing yet
          call cv_common_print_M_local(__PAR) ! output default M array (long-term average)
          call frames_print_local(__PAR) ! output frames
         endif
         if (qall.gt.0.or.qprint) call cv_common_print_wgt(__PAR)
#undef __PAR
        endif ! qrest
!
        if (qall.gt.0.or.qprint) then
         if (flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
#ifdef __CHARMM
         iolev=oldiol
#endif
        endif
       endif ! qroot
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'READ',4)) then
!      can read from both a local and a global file
!      local is specified with 'LOCAL'; default is global
!      can also read a specific column: specify SCOL x
       qall = max( __INDX_RM(comlyn,comlen,'ALL'),__INDX_RM(comlyn,comlen,'LOCAL'))
       qrest=(__INDX_RM(comlyn,comlen,'REST')).gt.0 ! whether to read a (complete, human-readable) restart file
!
! multiple ways to specify which replica to read
       scol=__INAN
       if (__INDX(comlyn, comlen, 'FROM',4).gt.0) then
        scol=__GET_RM_I(comlyn, comlen, 'FROM', -1)
       elseif (__INDX(comlyn, comlen, 'SREP',4).gt.0) then
        scol=__GET_RM_I(comlyn, comlen, 'SREP', -1)
       elseif (__INDX(comlyn, comlen, 'SCOL',4).gt.0) then
        scol=__GET_RM_I(comlyn, comlen, 'SCOL', -1)
       elseif (__INDX(comlyn, comlen, 'REPL',4).gt.0) then
        scol=__GET_RM_I(comlyn, comlen, 'REPL', -1)
       endif
!
       totcol=__INAN ! needed so that slave routines will ignore this in some (valid) cases

       if (scol.ne.__INAN) then ! if specified
        if (scol.ge.0) then
          if (.not.qrest.and.qall.gt.0) then 
           __WRN(whoami,'ALL AND SCOL CANNOT BOTH BE SPECIFIED.')
           return
          endif
!
          if (__INDX(comlyn, comlen, 'NREP',4).gt.0) then
           totcol=__GET_RM_I(comlyn, comlen, 'NREP', 0)
          elseif (__INDX(comlyn, comlen, 'TCOL',4).gt.0) then
           totcol=__GET_RM_I(comlyn, comlen, 'TCOL', 0)
          endif
          if (totcol.eq.0) then 
            __WRN(whoami,' NUMBER OF STRING REPLICAS MUST BE POSITIVE.')
            return
          elseif (.not.qrest.and.totcol.eq.__INAN) then ! need to have number of columns in raw formar
           __WRN(whoami,'MUST PROVIDE TOTAL NUMBER OF COLUMNS IN CV DATA FILE.')
           return
          endif
        else ! scol.ge.0
          __WRN(whoami,'SCOL MUST BE A NONNEGATIVE INTEGER.')
         return
        endif ! scol >= 0
       endif ! scol .ne. NAN
!
!      prepare file
       ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
       __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: flen will be UPPER CASE
!     check for column spec
       c1=sm_get_column(comlyn, comlen, qcoltag=.true., missing=-1)
       if (qroot) then
!cccccccccccccccccccccccccccc OPEN FILE ccccccccccccccccccccccc
        if (qall.gt.0.or.qprint) then
#ifdef __CHARMM
         oldiol=iolev
         iolev=0 ! open file on all processors
#endif
         if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','READ') ; endif
        endif
        if(ifile .eq. -1) then
#ifdef __CHARMM
         ifile=__ISTREAM ! read from input file
         call rdtitl(titleb,ntitlb,ifile,0) ! 0 = card format
#else
         __WRN(whoami, 'CANNOT OPEN FILE "'//trim(fname)//'". NOTHING DONE')
         return
#endif
        elseif (ifile.lt.0) then
         __WRN(whoami, 'CANNOT OPEN FILE "'//trim(fname)//'". NOTHING DONE') ! Possible bug if run in parallel
         return
        endif
!
        if (qrest.and.qprint) then ; write(_MSGBUF,*) whoami, ' WILL USE SMCV RESTART FORMAT';__PRINT(_MSGBUF);endif
!cccccccccccccccccc assume file is open, read ccccccccccccccccccc
        if (c1.gt.0) then ! column spec
         if (qprint) then ; write(_MSGBUF,6699) whoami, c1 ; __PRINT(_MSGBUF) ; endif
 6699 format(A,' READING COORDINATES INTO COLUMN ',I3)
         if (qall.gt.0) then ! local read on all cores
          call cv_common_read_local(ifile, col=c1, replica_=scol, qraw_=.not.qrest)
         else ! qall
          if (scol.ne.__INAN.or.qrest) then ! restart file format processed in (more bulky) routine
           call cv_common_read_local_from_global(ifile, replica_=scol, col=c1, numrep_=totcol, qraw_=.not.qrest)
          else ! scol
           call cv_common_read_global(ifile,c1) ! simple global read of raw text data
          endif ! scol
         endif ! qall
        else ! col spec
         if (qprint) then ; write(_MSGBUF,6709) whoami ; __PRINT(_MSGBUF) ; endif
 6709 format(A,' READING COORDINATES INTO DEFAULT COLUMN.')
         if (qall.gt.0) then
          call cv_common_read_local(ifile, replica_=scol, qraw_=.not.qrest) ;
         elseif (scol.ne.__INAN.or.qrest) then
          call cv_common_read_local_from_global(ifile, replica_=scol, col=c1, numrep_=totcol, qraw_=.not.qrest)
         else
          call cv_common_read_global(ifile) ;
         endif ! qall
        endif ! col spec
        if (qall.gt.0.or.qprint) then
         if (flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
#ifdef __CHARMM
         iolev=oldiol
#endif
        endif ! qall
       endif ! qroot
! if restarting then also read M tensor, weights and frames
! to compute M and wgt all cores enter
       if (qrest) then
        if (qall.gt.0) then
         call frames_read_local(qraw_=.false., replica_=scol)
        else
         call frames_read_global(qraw_=.false., replica_=scol, numrep_=totcol)
        endif
        call cv_common_read_M( qraw_=.false., qlocal_=qall.gt.0, replica_=scol, numrep_=totcol )
        call cv_common_read_wgt( qraw_=.false., qlocal_=qall.gt.0 )
        call cv_common_parser_done()
       endif
!
!     broadcast to slaves
       if (c1.lt.0) c1=main ! guess what the "default column" is
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
!        call MPI_BCAST(cv%r(1,c1), cv%num_cv, mpifloat,
!     &   0, MPI_COMM_LOCAL, ierror)
!        __BROADCAST_LOCAL_8B(cv%r(1,c1), cv%num_cv)
        __BROADCAST_LOCAL(cv%r(1,c1), cv%num_cv, mpifloat) ! what if have single precision ?
!    broadcast BC
        if (cv_common_fixed_0_bc.eq.1) then 
#ifdef __CHARMM
         __BROADCAST_LOCAL_4B(cv%r_bc_0, cv%num_cv) !##SINGLE
         __BROADCAST_LOCAL_8B(cv%r_bc_0, cv%num_cv) !##.not.SINGLE
#elif defined (__DMOL)
         __BROADCAST_LOCAL(cv%r_bc_0, cv%num_cv, mpifloat)
#endif
        endif
        if (cv_common_fixed_1_bc.eq.1) then
#ifdef __CHARMM
         __BROADCAST_LOCAL_4B(cv%r_bc_1, cv%num_cv) !##SINGLE
         __BROADCAST_LOCAL_8B(cv%r_bc_1, cv%num_cv) !##.not.SINGLE
#elif defined (__DMOL)
         __BROADCAST_LOCAL(cv%r_bc_1, cv%num_cv, mpifloat)
#endif
        endif
       endif
!    unwrap angles if present
       call cv_common_unwrap_angles(c1)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'SWAP',4)) then ! swap two columns
!       read column spec
        c1=sm_get_column(comlyn, comlen, qcoltag=.false., missing=-1)
        c2=sm_get_column(comlyn, comlen, qcoltag=.false., missing=-1)
        if (qprint) then ; write(_MSGBUF,6729) whoami, c1, c2 ; __PRINT(_MSGBUF) ; endif
 6729 format(A,' WILL SWAP COLUMNS ',I3,' AND ',I3,' ')
        call cv_common_swap(c1,c2)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'COPY',4)) then ! copy form c1 to c2
!       read column spec
        c1=sm_get_column(comlyn, comlen, qcoltag=.false., missing=-1)
        c2=sm_get_column(comlyn, comlen, qcoltag=.false., missing=-1)
        if (qprint) then ; write(_MSGBUF,6739) whoami, c1, c2 ; __PRINT(_MSGBUF) ; endif
 6739 format(A,' WILL COPY COLUMN ',I3,' TO ',I3,' ')
        call cv_common_copy(c1,c2)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'HIST',4)) then ! parse history commands
        keyword=__NEXTA(comlyn,comlen)
        if (__STRNCMP(keyword,'ADD',3)) then ! save current CV values to history
         if (any(__X.eq.__NAN)) then
          __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
         else
          if (qprint) then ; write(_MSGBUF,674) whoami ; __PRINT(_MSGBUF) ; endif
 674  format(A,' WILL ADD CV VALUES FROM MAIN COORDINATE SET INTO HISTORY.')
! last argument tells routine to add the calculated cv/derivative values to the history
          restraint_force_on=.false. ! turn off in case it was on after dynamics (to force recalc of cvs)
! force recalculation of quaternions and frames
          call quat_reset_calculate(.true.)
          call frames_reset_calculate(.true.)
!
          call smcv_add_hist(__X,__Y,__Z,__MASS,.true.)
         endif
        elseif ((__STRNCMP(keyword,'PRIN',4)).or.(__STRNCMP(keyword,'WRIT',4))) then ! print history
!        can write both a local and a global file
!        local is specified with 'ALL'; global is the default
         qall = max( __INDX_RM(comlyn,comlen,'ALL'),__INDX_RM(comlyn,comlen,'LOCAL'))
!        prepare file
!-----------------------------------------------------------------------------
         ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
         __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
!     check for other spec
         nskip=__GET_RM_I(comlyn, comlen, 'SKIP',0) ! number of entries to skip
!---------------------------------- OPEN FILE --------------------------------
         if (qroot) then
#ifdef __CHARMM
          oldiol=iolev
          if (qall.gt.0) iolev=0 ! trick to open file on all nodes
#endif
!
          if (flen.gt.0) then ;  __OPEN_FILE(ifile,fname,'FORMATTED','WRITE') ; endif
          if (ifile .eq. -1) ifile=__OSTREAM ! write to output stream
!---------------------------- assume file is open, write -------------------------
          if (qprint) then ; write(_MSGBUF,676) whoami, nskip ; __PRINT(_MSGBUF) ; endif
 676  format(A,' WRITING CV HISTORY. SKIPPING ',I5,' ENTRIES.')
          if (qall.eq.0) then;call cv_common_print_hist_global(ifile,nskip)
          else ; call cv_common_print_hist_local(ifile,nskip) ; endif
          if (flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
#ifdef __CHARMM
          iolev=oldiol
#endif
         endif ! qroot
        elseif (__STRNCMP(keyword,'SMOO',4)) then ! smooth history
!      look for other spec.
         delta=__GET_RM_I(comlyn, comlen, 'DELT',10) ! filter width
         nskip=__GET_RM_I(comlyn, comlen, 'SKIP',0) ! number of entries to skip
!
         if (qprint) then ; write(_MSGBUF,675) whoami, delta, nskip ; __PRINT(_MSGBUF) ; endif
 675  format(A,' SMOOTHING CV HISTORY. FILTER WIDTH =',I5,'.',          &
     & / ,' SKIPPING ',I5,' ENTRIES.')
! warn if output_cv_hist is on, which destroys hist so that the stat. output is null
         if (output_cv_hist) then
          __WRN(whoami, 'CV HISTORY WILL BE ERASED (OUTPUT_CV_HIST CONFLICTS WITH SMOOTHING)')
         endif
!
         call cv_common_smooth_hist(delta,nskip)
        elseif (__STRNCMP(keyword,'EXPO',4)) then ! CONVOLUTION W/ EXPONENTIAL
!      look for other spec.
         expo_memory=__GET_RM_F(comlyn, comlen, 'MEMO',0.999*one) ! memory in the exp. conv. kernel
         nskip=__GET_RM_I(comlyn, comlen, 'SKIP',0) ! number of entries to skip
!
         if (qprint) then ; write(_MSGBUF,701) whoami, expo_memory, nskip ; __PRINT(_MSGBUF) ; endif
 701  format(A,' EVOLVING CV: Z(N+1)=A*Z(N)+(1-A)*<THETA>, A=',F7.3,'.',&
     & / ,' SKIPPING ',I5,' ENTRIES.')
         call cv_common_evolve_expo(expo_memory,nskip)
        endif
!        done parsing 'HIST'
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'EVOL',4)) then ! evolve string using average force (SMCV)
!      look for other spec: dt and
        step=__GET_RM_F(comlyn, comlen, 'STEP',-one) ! evolution step
        if (qprint) then
         if (step.lt.zero) then
          __WRN(whoami,'CV EVOLUTION STEP NEGATIVE OR UNSPECIFIED.')
         endif
         write(_MSGBUF,677) whoami, step ; __PRINT(_MSGBUF)
 677  format(A,' EVOLVING CV USING AVERAGE FORCE. STEP =',F7.3,'.')
        endif ! qprint
        call cv_common_evolve_smcv(step)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'SET',3)) then ! modify k,w,g,dt
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!      first check for global options: num_ave_samples
        if (__INDX(comlyn,comlen,'NAVE',4).gt.0) then
          num_ave_samples=__GET_RM_I(comlyn,comlen,'NAVE',-1)
          if (num_ave_samples.ge.0) then
           call cv_common_set_ave_samples(num_ave_samples)
           if (qprint) then ; write(_MSGBUF,6748) whoami, num_ave_samples ; __PRINT(_MSGBUF) ; endif
 6748 format(A,' SETTING NUMBER OF SAMPLES IN THE AVERAGE SET TO ',I7)
          else
           if (qprint) then ; write(_MSGBUF,6749) whoami, num_ave_samples; __PRINT(_MSGBUF) ; endif
 6749 format(A,' INVALID NUMBER OF SAMPLES SPECIFIED: ',I7)
          endif
!      set k parallel to path (for off-path dynamics)
        elseif (__INDX(comlyn,comlen,'KPAR',4).gt.0) then
          k=__GET_RM_F(comlyn,comlen,'KPAR',-one)
          if (k.ge.zero) then
           call cv_common_set_kpara(k)
           if (qprint) then ; write(_MSGBUF,6756) whoami, k; __PRINT(_MSGBUF) ; endif
 6756 format(A,' SETTING PARALLEL FORCE CONSTANT TO ',F11.5)
          else
           if (qprint) then ; write(_MSGBUF,6757) whoami, k; __PRINT(_MSGBUF) ; endif
 6757 format(A,' INVALID FORCE CONSTANT SPECIFIED: ',F11.5)
          endif
!      set k perpendicular to path (for off-path dynamics)
        elseif (__INDX(comlyn,comlen,'KPRP',4).gt.0) then
          k=__GET_RM_F(comlyn,comlen,'KPRP',-one)
          if (k.ge.zero) then
           call cv_common_set_kperp(k)
           if (qprint) then ; write(_MSGBUF,6746) whoami, k; __PRINT(_MSGBUF) ; endif
 6746 format(A,' SETTING PERPENDICULAR FORCE CONSTANT TO ',F11.5)
          else
           if (qprint) then ; write(_MSGBUF,6747) whoami, k; __PRINT(_MSGBUF) ; endif
 6747 format(A,' INVALID FORCE CONSTANT SPECIFIED: ',F11.5)
          endif
        else ! nave/kpar/kperp
!
!      to set k,w,g can specify atom index, or ' ALL ' to apply to all CV
!     process CV selection
        ind=__GET_RM_I(comlyn,comlen,'IND',0)
        qall = max( __INDX_RM(comlyn,comlen,'ALL'),__INDX_RM(comlyn,comlen,'LOCAL'))
        if (qall.gt.0) then ! will loop over all cv
         ibeg=1
         iend=cv%num_cv
         if (qprint) then ; write(_MSGBUF,6750) whoami ; __PRINT(_MSGBUF) ; endif
 6750 format(A,' ALL CV INDICES SELECTED.')
        elseif (ind.gt.0.and.ind.le.cv%num_cv) then
         ibeg=ind
         iend=ind
         if (qprint) then ; write(_MSGBUF,6751) whoami, ind ; __PRINT(_MSGBUF) ; endif
 6751 format(A,' CV INDEX ',I5,' SELECTED.')
        else ! no indices specified
         __WRN(whoami,' INVALID CV INDEX SPECIFIED')
         ibeg=0
         iend=-1
        endif
!
        if (iend.gt.0) then ! skip this for invalid indices
         call smcv_check_set_k(comlyn, comlen, ibeg, iend, zero)
         call smcv_check_set_g(comlyn, comlen, ibeg, iend, one)
         call smcv_check_set_w(comlyn, comlen, ibeg, iend, -one)
         call smcv_check_set_fbwidth(comlyn, comlen, ibeg, iend, zero)
         call smcv_check_set_temp(comlyn, comlen, ibeg, iend, zero)
!
         zval=abs(__NAN)
         if (__INDX(comlyn,comlen,'ZVAL',4).gt.0) then ! set cv value
          zval=__GET_RM_F(comlyn, comlen, 'ZVAL', -zval)
         elseif (__INDX(comlyn,comlen,'CVVAL',5).gt.0) then
          zval=__GET_RM_F(comlyn, comlen, 'CVVAL', -zval)
         elseif (__INDX(comlyn,comlen,'CVX',3).gt.0) then
          zval=__GET_RM_F(comlyn, comlen, 'CVX', -zval)
         elseif (__INDX(comlyn,comlen,'CVZ',3).gt.0) then
          zval=__GET_RM_F(comlyn, comlen, 'CVZ', -zval)
         endif
         if (zval.eq.-abs(__NAN)) then
           __WRN(whoami,'CV VALUE INVALID OR UNSPECIFIED.')
         elseif (zval.ne.abs(__NAN)) then ! ok -- proceed to assignment
!    check replica spec
          if (SIZE_STRNG.eq.1) then
           if (__INDX(comlyn, comlen, 'REP', 3).gt.0) then ! check only if present since there is only one possibility
            irep=__GET_RM_I(comlyn, comlen, 'REP', -1) ; else ; irep=0
           endif
          else
           irep=__GET_RM_I(comlyn, comlen, 'REP', -1)
          endif
!
          if (irep.lt.0.or.irep.ge.nstring) then
           __WRN(whoami,'REPLICA NUMBER INVALID OR UNSPECIFIED.')
          else
!    check column spec
           c1=sm_get_column(comlyn, comlen, qcoltag=.true., missing=-1)
           if (c1.gt.0) then
            if (qprint) then 
             write(_MSGBUF,6774) whoami, irep,c1, zval
             __PRINT(_MSGBUF)
            endif
 6774 format(A,' WILL SET REPLICA ',I5,' CV VALUE IN COLUMN ',          &
     &       I3, ' TO ',F7.3,'.')
            if (mestring.eq.irep) then ;do i=ibeg,iend
                                       call cv_common_set_r(i,zval,c1)
                                      enddo; endif
           else
            if (qprint) then ; write(_MSGBUF,6773) whoami, irep, zval ; __PRINT(_MSGBUF) ; endif
 6773 format(A,' WILL SET REPLICA ',I5,' CV VALUE IN DEFAULT COLUMN TO '&
     &       ,F7.3,'.')
            if (mestring.eq.irep) then ;do i=ibeg,iend
                                       call cv_common_set_r(i,zval)
                                      enddo; endif
           endif ! colspec
          endif ! irep
         endif ! zval
!
        endif ! iend.gt.0
        endif ! options that take cv indices
!      done with 'SET' parsing
!cccccccccccccccccccccccccccccccccccc M matrix cccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'MMAT',4)) then
        if (__INDX_RM(comlyn, comlen, 'CALC').gt.0) then
          if (qprint) then ; write(_MSGBUF,6854) whoami ; __PRINT(_MSGBUF) ; endif
 6854 format(A,' COMPUTING INSTANTANEOUS M(X) FROM ATOMIC COORDINATES.')
          call smcv_compute_M(__X,__Y,__Z,__MASS,.true.) ! compute M and M inverse
!    print
        elseif ((__INDX_RM(comlyn, comlen, 'PRIN').gt.0) .or. (__INDX_RM(comlyn, comlen, 'WRIT').gt.0)) then
! NOTE : not sure how to best implement this: finally, decided to keep a correct version of M outside of PRINT
!    if running in parallel, combine partial M entries
!          if (qslave) then
!       call MPI_ALLREDUCE(cv%M(1,1,1),cv%M(1,1,2),max_cv_common*cv%num_cv, ! will broadcast all rows, but only num_cv columns
!     &          mpifloat, MPI_SUM, MPI_COMM_LOCAL, ierror)
!          else ! qslave
!         cv%M(1:cv%num_cv,1:cv%num_cv,2)=cv%M(1:cv%num_cv,1:cv%num_cv,1)
!          endif ! qslave
!    check whether to print locally
          qall = max( __INDX_RM(comlyn,comlen,'ALL'),__INDX_RM(comlyn,comlen,'LOCAL'))
!    check for restart format
          qrest=(__INDX_RM(comlyn,comlen,'REST')).gt.0
!    check for inverse spec (inverse stored in 3)
          if (__INDX_RM(comlyn, comlen, 'INV').gt.0) then
            ind=3
            keyword='INVERSE '; klen=8
            call cv_common_compute_Minv(inverse_LU)
          else
            ind=4 ! long-term average 
            keyword=' '; klen=0
          endif
!
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
          if (qroot) then
           if (flen.gt.0) then
            if (qprint.or.qall.gt.0) then 
#ifdef __CHARMM
             oldiol=iolev
             iolev=1
#endif
             __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
!
             if (qprint) then
              write(_MSGBUF,6859) whoami, keyword(1:klen), fname(1:flen)
              __PRINT(_MSGBUF)
              if (qrest) then;write(_MSGBUF,*) whoami, ' WILL USE SMCV RESTART FORMAT';__PRINT(_MSGBUF);endif
             endif
            endif
 6859 format(A,' WRITING M TENSOR (LONG-TERM AVERAGE) ',A,'TO FILE ',A,'.')
            if (qall.gt.0) then
             call cv_common_print_M_local(ifile, IND=ind, qraw_=.not.qrest, qhead_=.true.)
            else
             call cv_common_print_M_global(ifile, IND=ind, qraw_=.not.qrest, qhead_=.true.)
            endif
            if (qprint.or.qall.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
             iolev=oldiol
#endif
            endif
           else
            __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
           endif ! flen
          endif ! qroot
!    read cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        elseif (__INDX_RM(comlyn, comlen, 'READ').gt.0) then
!    check whether to read locally
          qall = max( __INDX_RM(comlyn,comlen,'ALL'),__INDX_RM(comlyn,comlen,'LOCAL'))
!    check for restart format
          qrest=(__INDX_RM(comlyn,comlen,'REST')).gt.0
!    check for inverse spec (inverse stored in 3)
          if (__INDX_RM(comlyn, comlen, 'INV').gt.0) then
            ind=3
            keyword='INVERSE '; klen=8
          else
            ind=4 ! long-term average
            keyword=' '; klen=0
          endif
!
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
          if (flen.gt.0) then
           if (qroot) then
            if (qprint.or.qall.gt.0) then 
#ifdef __CHARMM
             oldiol=iolev
             iolev=1
#endif
             __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
             if (qprint) then
              write(_MSGBUF,6858) whoami, keyword(1:klen), fname(1:flen)
              __PRINT(_MSGBUF)
              if (qrest) then ; write(_MSGBUF,*) whoami, ' WILL USE SMCV RESTART FORMAT';__PRINT(_MSGBUF);endif
             endif ! qprint
            endif
 6858 format(A,' READING M TENSOR (LONG- & SHORT-TERM AVERAGE) ',A,'FROM FILE ',A,'.')
            call cv_common_read_M(-ifile, ind, qraw_=.not.qrest, qlocal_=qall.gt.0)
            if (qprint.or.qall.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
             iolev=oldiol
#endif
            endif
           endif ! qroot
          else
            __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
          endif ! flen
!    change calculation algorithm ccccccccccccccccccccccccccccccccccccc
        elseif (__INDX_RM(comlyn, comlen, 'FAST').gt.0) then
          keyword=__NEXTA(comlyn, comlen)
          select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_Mtensor_fast=.true.
            if (qprint) then ; write(_MSGBUF,7014) whoami, keyword ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_Mtensor_fast=.false.
            if (qprint) then ; write(_MSGBUF,7014) whoami, keyword ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED FOR "FAST"')
          end select
 7014 format(A,' SPARSE MATRIX ROUTINE FOR M TENSOR COMPUTATION ',A)
        endif
!cccccccccccccccccccccccccccccccccccc CV WEIGHTS cccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'WEIG',4)) then
        if (__INDX_RM(comlyn, comlen, 'CALC').gt.0) then
          if (qprint) then ; write(_MSGBUF,6754) whoami ; __PRINT(_MSGBUF) ; endif
 6754 format(A,' COMPUTING CV WEIGHTS FROM METRIC TENSOR M(X).')
          call smcv_compute_wgt(__X,__Y,__Z,__MASS)
!    print
        elseif ((__INDX_RM(comlyn, comlen, 'PRIN').gt.0).or.(__INDX_RM(comlyn, comlen, 'WRIT').gt.0)) then
!    process output options
!    check for restart format
          qrest=(__INDX_RM(comlyn,comlen,'REST')).gt.0
!
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
          if (qprint) then
            if (flen.gt.0) then
             write(_MSGBUF,6759) whoami, fname(1:flen) ; __PRINT(_MSGBUF)
 6759 format(A,' WRITING CV WEIGHTS TO FILE ',A,'.')
#ifdef __CHARMM
             oldiol=iolev
             iolev=1
#endif
             __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
            else
             if (ifile .eq. -1) ifile=__OSTREAM ! write to output stream
             write(_MSGBUF,6758) whoami, ifile; __PRINT(_MSGBUF)
 6758 format(A,' WRITING CV WEIGHTS TO UNIT ',I5)
            endif
            if (qrest) then ; write(_MSGBUF,*) whoami, ' WILL USE SMCV RESTART FORMAT';__PRINT(_MSGBUF);endif
            call cv_common_print_wgt(ifile, qraw_=.not.qrest, qhead_=.true.) ! only root node writes
            if (flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
             iolev=oldiol
#endif
            endif
          endif ! qprint
!    read
        elseif (__INDX_RM(comlyn, comlen, 'READ').gt.0) then
!    check for restart format
          qrest=(__INDX_RM(comlyn,comlen,'REST')).gt.0
!    prepare file
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!    note: flen will be UPPER CASE
          if (qprint) then
           if (flen.gt.0) then 
            write(_MSGBUF,6761) whoami, fname(1:flen) ; __PRINT(_MSGBUF)
 6761 format(A,' READING CV WEIGHTS FROM FILE ',A,'.')
#ifdef __CHARMM
            oldiol=iolev
            iolev=1
#endif
            __OPEN_FILE(ifile,fname,'FORMATTED','READ')
           else
            if (ifile .eq. -1) ifile=__ISTREAM ! read from input
            write(_MSGBUF,6760) whoami, ifile ; __PRINT(_MSGBUF)
 6760 format(A,' READING CV WEIGHTS FROM UNIT ',I5)
#ifdef __CHARMM
             if (ifile.eq.__ISTREAM) call rdtitl(titleb,ntitlb,ifile,0) ! 0 = card format
#endif
           endif ! flen
          endif ! qprint
          if (qprint.and.qrest) then ; write(_MSGBUF,*) whoami, ' WILL USE SMCV RESTART FORMAT';__PRINT(_MSGBUF);endif
          call cv_common_read_wgt(-ifile, qraw_=.not.qrest) ! root and slave nodes enter
          if (qprint.and.flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
           iolev=oldiol
#endif
          endif
        endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'KPAR',4)) then
       if (__INDX(comlyn,comlen,'SET',3).gt.0) then
         k=__GET_RM_F(comlyn,comlen,'SET',-one)
         if (k.ge.zero) then
          call cv_common_set_kpara(k)
          if (qprint) then ; write(_MSGBUF,6763) whoami, k ; __PRINT(_MSGBUF) ; endif
 6763 format(A,' SETTING PARALLEL FORCE CONSTANT TO ',F11.5)
         else
          if (qprint) then ; write(_MSGBUF,6764) whoami, k ; __PRINT(_MSGBUF) ; endif
 6764 format(A,' INVALID FORCE CONSTANT SPECIFIED: ',F11.5)
         endif
       endif ! set
!
       if (__INDX_RM(comlyn, comlen, 'CALC').gt.0) then
        if (qprint) then ; write(_MSGBUF, 6765) whoami, whoami, whoami ; __PRINT(_MSGBUF) ; endif
 6765 format(A, ' COMPUTING FORCE CONSTANTS FOR RESTRAINED ',/,        &
     &        A, ' DYNAMICS BY SCALING KPAR WITH CV WEIGHTS.',/,        &
     &        A, ' OVERWRITING PREVIOUSLY DEFINED FORCE CONSTANTS.')
        call cv_common_compute_k()
       endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'TANV',4)) then ! print/read/compute tangent to path
       if (__INDX_RM(comlyn, comlen, 'CALC').gt.0) then ! calculate
        if (qprint) then ; write(_MSGBUF,6766) whoami ; __PRINT(_MSGBUF) ; endif
 6766 format(A,' WILL COMPUTE TANGENT TO PATH.')
        call cv_common_compute_dr()
!
       elseif (__INDX_RM(comlyn, comlen, 'READ').gt.0) then ! read from file
!      prepare file
        ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
        __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: flen will be UPPER CASE
!cccccccccccccccccccccccccccc OPEN FILE ccccccccccccccccccccccc
        if (qprint) then
         if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','READ') ;
#ifdef __CHARMM
          oldiol=iolev
          iolev=1
#endif
         endif
         if(ifile .eq. -1) then
          ifile=__ISTREAM ! read from input file
#ifdef __CHARMM
          call rdtitl(titleb,ntitlb,ifile,0) ! 0 = card format
#endif
         endif ! ifile
!cccccccccccccccccc assume file is open, read ccccccccccccccccccc
         write(_MSGBUF,6767) whoami
 6767 format(A,' READING VECTORS TANGENT TO PATH.')
        endif ! qprint
!
        call cv_common_read_dr(ifile) ! roots and slaves
!
        if (qprint.and.flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
         iolev=oldiol
#endif
        endif
!
       elseif ((__INDX_RM(comlyn, comlen, 'PRIN').gt.0).or.(__INDX_RM(comlyn, comlen, 'WRIT').gt.0)) then ! print to file
!      prepare file
        ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
        __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
        if (qprint) then
!---------------------------------- OPEN FILE --------------------------------
         if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','WRITE') 
#ifdef __CHARMM
          oldiol=iolev
          iolev=1
#endif
         endif
         if (ifile .eq. -1) ifile=__OSTREAM ! write to output stream
!---------------------------- assume file is open, write -------------------------
         write(_MSGBUF,6768) whoami ; __PRINT(_MSGBUF)
 6768 format(A,' WRITING VECTORS TANGENT TO PATH.')
        endif ! qprint
        if (qroot) call cv_common_print_dr(ifile)
        if (qprint.and.flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) 
#ifdef __CHARMM
         iolev=oldiol
#endif
        endif
       endif ! TANV
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'LIST',4)) then ! list CV
       if (qprint) then ; write(_MSGBUF,6762) whoami ; __PRINT(_MSGBUF) ; endif
 6762 format(A,' WILL LIST CV.')
       if (cv%num_cv.gt.0) then
        call smcv_list() ! this routine deals with the various CV
       else
        __WRN(whoami, 'NO CV DEFINED.')
       endif
!       write(0,*) 'ME_LOCAL: ',ME_LOCAL, 'SIZE_LOCAL:', SIZE_LOCAL
!       write(600+ME_LOCAL, *) cv%r(1:cv%num_cv,1:main_offset)
!       close(600+ME_LOCAL)
!       write(700+ME_LOCAL, *) frames%r(3,3,1:frames%num_frames)
!       close(700+ME_LOCAL)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#if !(defined(__ACEMD) || defined(__NAMD))
! CV interpolation
      elseif (__STRNCMP(keyword,'INTE',4)) then
! note: this is done serially
! get specifications
#ifdef __CHARMM
        if (qprint) then ; oldiol=iolev ; iolev=1 ; endif
#endif
!ccccccccccccc should the new cv file be interpolated from the CV old file?
        interp_cv=(__INDX_RM(comlyn,comlen,'INTERPCV').gt.0)
        if (qprint) then
         if (interp_cv) then
          write(_MSGBUF, 6801) whoami
         else
          write(_MSGBUF, 6802) whoami
         endif
         __PRINT(_MSGBUF)
        endif
!
 6801 format(A,' WILL OBTAIN NEW CV VALUES BY INTERPOLATION.')
 6802 format(A,' NEW CV VALUES WILL BE READ FROM FILE.')
! interpolation type
        if (interp_cv) then
         int_method=0
         method=__GET_RM_AFUN(comlyn, comlen, 'METH')
         length=len(method)
         __TRIMA(method, length)
         if (length.ge.4) then
           if (__STRNCMP(method,'LINE',4)) then
             int_method=linear
           elseif (__STRNCMP(method,'BSPL',4)) then
             int_method=bspline
           elseif (__STRNCMP(method,'SPLI',4)) then
             int_method=spline
           elseif (__STRNCMP(method,'LIN2',4)) then
             int_method=linear_exact
           endif
         endif
!     print summary
         if (qprint) then
           if (int_method.gt.0) then
             length=len(methods(int_method))
             __TRIMA(methods(int_method),length)
             write(_MSGBUF,6770) whoami, methods(int_method)(1:length)
 6770  format(A,' WILL INTERPOLATE CV USING ',A,' INTERPOLATION')
           else
             if (length.gt.0) then
               write(_MSGBUF,6771) whoami, method(1:length), whoami
 6771 format(A,' UNRECOGNIZED INTERPOLATION METHOD: ',A,'.',/,         &
     &       A, ' WILL INTERPOLATE CV USING LINEAR INTERPOLATION')
             else
              write(_MSGBUF,6772) whoami, whoami
 6772 format(A,' UNSPECIFIED INTERPOLATION METHOD.',/,                 &
     &       A, ' WILL INTERPOLATE CV USING LINEAR INTERPOLATION')
             endif ! length
             __PRINT(_MSGBUF)
           endif ! int_method
         endif ! prnlev
         if (int_method.eq.0) int_method=linear ! choose linear interpolation as default
        endif ! interp_cv
! process other options ccccccccccccccccccccccccccccccccccccccccccccccc
!
        if (__INDX(comlyn,comlen,'NIN',3).gt.0) then
          num_rep_in=__GET_RM_I(comlyn, comlen, 'NIN', 0)
          if (num_rep_in.le.0) then
            if (qprint) then ; write(_MSGBUF, 6781) whoami ; __PRINT(_MSGBUF) ; endif
 6781 format(A,' NUMBER OF INPUT REPLICAS MUST BE > 0. ',/,             &
     & ' NOTHING DONE.')
#ifdef __CHARMM
            iolev=oldiol
#endif
            return
          else
            __GET_RM_A(comlyn, comlen, 'CVIN', 4, name_cv_in, 80, len_cv_in)
            if (len_cv_in.le.0) then
              if (qprint) then ; write(_MSGBUF, 6782) whoami ; __PRINT(_MSGBUF) ; endif
 6782 format(A,' INPUT CV FILE NAME UNSPECIFIED.',/,                    &
     & ' NOTHING DONE.')
#ifdef __CHARMM
              iolev=oldiol
#endif
              return
            else
              if (qprint) then ; write(_MSGBUF,6783)                    &
     &          whoami, num_rep_in, whoami, name_cv_in(1:len_cv_in) ; __PRINT(_MSGBUF) ; endif
 6783 format(A,' INITIAL STRING RESOLUTION: ', I5, ' REPLICAS.',/,      &
     &       A,' INPUT CV FILE IS ', A)
            endif ! len_cv_in<=0
          endif ! num_rep_in<=0
        else
          if (qprint) then ; write(_MSGBUF, 6784) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 6784 format(A,' NUMBER OF INPUT REPLICAS UNSPECIFIED',/,               &
     & A,' NOTHING DONE.')
#ifdef __CHARMM
          iolev=oldiol
#endif
          return
        endif ! indx('NIN')
!cccccccccccccccccccccccccccccccccccccccccccccccccccc
!  process output CV specification
        if (__INDX(comlyn,comlen,'NOUT',4).gt.0) then
          num_rep_out=__GET_RM_I(comlyn, comlen, 'NOUT', 0)
          if (num_rep_out.le.0) then
            if (qprint) then ; write(_MSGBUF, 6785) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 6785 format(A,' NUMBER OF OUTPUT REPLICAS MUST BE > 0. ',/,A,          &
     & ' NOTHING DONE.')
#ifdef __CHARMM
            iolev=oldiol
#endif
            return
          else
            __GET_RM_A(comlyn, comlen, 'CVOUT', 5, name_cv_out, 80, len_cv_out)
            if (len_cv_out.le.0) then
              if (qprint) then ; write(_MSGBUF, 6786) whoami, whoami ; __PRINT(_MSGBUF) ; endif 
 6786 format(A,' OUTPUT CV FILE NAME UNSPECIFIED.',/,A,                 &
     & ' NOTHING DONE.')
#ifdef __CHARMM
              iolev=oldiol
#endif
              return
            else
              if (qprint) then 
               write(_MSGBUF,6787) whoami, num_rep_out, whoami, name_cv_out(1:len_cv_out)
               __PRINT(_MSGBUF)
              endif
 6787 format(A,' OUTPUT STRING RESOLUTION: ', I5, ' REPLICAS.',/,       &
     &       A,' OUPUT CV FILE IS ', A)
            endif ! len_cv_out
          endif ! num_rep_out
        else ! num_rep_out
          if (qprint) then ; write(_MSGBUF, 6788) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 6788 format(A,' NUMBER OF OUTPUT REPLICAS UNSPECIFIED',/,              &
     & A,' NOTHING DONE.')
#ifdef __CHARMM
          iolev=oldiol
#endif
          return
        endif ! indx('NOUT')
!ccccccccccccc coordinate file specification
        inte_get_coor=(__INDX_RM(comlyn,comlen,'COOR').gt.0)
        if (inte_get_coor) then ! look for input and output coordinate files
          if (qprint) then ; write(_MSGBUF,6800) whoami ; __PRINT(_MSGBUF) ; endif
 6800 format(A,' WILL GENERATE REPLICA COORDINATE SETS.')
          inte_get_coor=.true.
! will also interpolate coordinates
          __GET_RM_A(comlyn, comlen, 'CRIN', 4, name_cor_in, 80, len_cor_in) ! text file which contains a list of file names (6/20/2011)
          if (len_cor_in.le.0) then
            if (qprint) then ; write(_MSGBUF, 6789) whoami ; __PRINT(_MSGBUF) ; endif
 6789 format(A,' INPUT COORDINATES FILE NAME UNSPECIFIED.',/,           &
     & '  NOTHING DONE.')
#ifdef __CHARMM
            iolev=oldiol
#endif
            return
          endif
!
          __GET_RM_A(comlyn, comlen, 'CROUT', 5, name_cor_out, 80, len_cor_out)
          if (len_cor_out.le.0) then
            if (qprint) then ; write(_MSGBUF, 6790) whoami ; __PRINT(_MSGBUF) ; endif
 6790 format(A,' OUTPUT COORDINATES FILE NAME UNSPECIFIED.',/,          &
     & ' NOTHING DONE.')
#ifdef __CHARMM
            iolev=oldiol
#endif
            return
          endif ! len_cor_out
!        parse file format spec. (same for both input/output)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#ifdef __CHARMM
          lresid=.false.
#endif
          if (__INDX_RM(comlyn,comlen,'PDB').gt.0) then
#ifdef __CHARMM
            moder=-1
            modew=4
            if (__INDX_RM(comlyn,comlen,'RESI').gt.0) lresid=.true.
#elif defined(__DMOL)
            ifmt=pdb
#endif
            form='FORMATTED'
#ifdef __CHARMM
          elseif ( (__INDX_RM(comlyn,comlen,'FILE').gt.0).or.               &
     &  (__INDX_RM(comlyn,comlen,'UNFO').gt.0)) then
            moder=0
            modew=1
            form='UNFORMATTED'
#endif
          elseif ( (__INDX_RM(comlyn,comlen,'CARD').gt.0).or.               &
     &  (__INDX_RM(comlyn,comlen,'FORM').gt.0)) then
#ifdef __CHARMM
            moder=1
            modew=2
#elif defined(__DMOL)
            ifmt=charmm
#endif
            form='FORMATTED'
          else ! default
#ifdef __CHARMM
            moder=1
            modew=2
#elif defined(__DMOL)
            ifmt=charmm
#endif
            form='FORMATTED'
          endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!       write summary
          if (qprint) then ! note: using qprint as a root node flag, too (should change this)
!ccccc   get coordinate file names
           ifile=-1 ! a valid unit number will be assigned by __OPEN_FILE
           ofile=-1
           __OPEN_FILE(ifile,name_cor_in(1:len_cor_in),'FORMATTED','READ')
           allocate(fname_cor_in(num_rep_in))
!
           do j=1, num_rep_in
            read(ifile,*) fname_cor_in(j)
           enddo
           __CLOSE_FILE(ifile,'KEEP',ierror)
!
           write(_MSGBUF,6791) whoami ; __PRINT(_MSGBUF)
 6791 format(A,' COORDINATE SETS WILL BE READ FROM',                    &
     & ' THE FOLLOWING FILES:' )
!
           do j=1, num_rep_in
            write(_MSGBUF,'(A1,I5," ",A80)') char(9), j, fname_cor_in(j) ; __PRINT(_MSGBUF)
           enddo
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
           __OPEN_FILE(ofile,name_cor_out(1:len_cor_out),'FORMATTED','READ')
!
           allocate(fname_cor_out(num_rep_out))
!
           do j=1, num_rep_out
            read(ifile,'(A80)') fname_cor_out(j)
           enddo
           __CLOSE_FILE(ofile,'KEEP',ierror)
!
           write(_MSGBUF,6793) whoami ; __PRINT(_MSGBUF)
 6793 format(A,' COORDINATE SETS WILL BE WRITTEN TO THE FOLLOWING FILES:' )
!
           do j=1, num_rep_out
            write(_MSGBUF,'(A1,I5," ",A80)') char(9), j, fname_cor_out(j) ; __PRINT(_MSGBUF)
           enddo
!
          endif ! qprint
        endif ! 'COOR'
!
        if (.not.(interp_cv.or.inte_get_coor)) then ! nothing to do
         write(_MSGBUF,'(A," NOTHING TO DO")') whoami
         __PRINT(_MSGBUF)
#ifdef __CHARMM
         iolev=oldiol
#endif
         return
        endif
!ccccccccccccccccccccccccc do work
! interpolate CV first
! compute cv weights, if needed
        if (.not.cv_common_weights_initialized) then
         __WRN( whoami,'CV WEIGHTS NOT INITIALIZED. WILL COMPUTE FROM M^-1(X)')
         call smcv_compute_wgt(__X,__Y,__Z,__MASS)
        endif
!
        if (interp_cv) then
         if (qprint) then ! only the head node does this
!    open CV files
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     now prepare cv units and call interpolation routine
          ifile=-1 ! a valid unit number will be assigned by __OPEN_FILE
          ofile=-1
          __OPEN_FILE(ifile,name_cv_in,'FORMATTED','READ')
          __OPEN_FILE(ofile,name_cv_out,'FORMATTED','WRITE')
!
          call cv_common_interpolate(ifile, ofile, num_rep_in, num_rep_out,&
     &                           int_method)
!
          __CLOSE_FILE(ifile,'KEEP',ierror)
          __CLOSE_FILE(ofile,'KEEP',ierror)
         endif ! qprint
        endif ! interp_cv
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! process coordinate files, if requested
! this code is fairly slow; things are complicated by providing compatibility with frames, which means that
! every distance computation, essentially, required an 'optimal' rearrengement of frame vectors
! this is provided by routine `frame_align_rmsd`
        if (inte_get_coor) then
!   rmsd array
         __FREE(inte_rmsd)
         allocate(inte_rmsd(num_rep_out,num_rep_in))
!   cv array
         __FREE(rtemp)
         allocate(rtemp(max_cv_common,num_rep_out))
!
!        (re-)load new cv file and store cv in rtemp
         do j=1, num_rep_out
           if (qprint) then
            __OPEN_FILE(ifile,name_cv_out,'FORMATTED','READ')
           endif
           call cv_common_read_local_from_global(ifile, num_rep_out,      &
     &      j, comp) ! this needs to be run in parallel
           rtemp(:,j)=cv%r(:,comp)
         enddo
!
         if (qprint) then ; write(_MSGBUF,6974) whoami ; __PRINT(_MSGBUF) ; endif
 6974 format(A,' READING COORDINATE FILES')
!
#ifdef __CHARMM
         islct=1.
#endif
         do j=1, num_rep_in
!     open file
            length=len_trim(fname_cor_in(j))
            dummy=fname_cor_in(j)(1:length)
!
            if (qroot) then ; __OPEN_FILE(ifile,dummy,form,'READ') ; endif
            dummy=''
            if (mestring.eq.0) then ! need a whole group to read correctly
#ifdef __CHARMM
             call cread(ifile, titleb, ntitlb, icntrl, xcomp, ycomp,    &
#ifndef __CHMOCCU
     &         zcomp, wcomp, natom, moder, islct,     &
#else
     &         zcomp, wcomp, wcomp, natom, moder, islct,     &
#endif
     &         0, res, nres, atype, ibase, 1, ifreea,              &
     &         segid, resid, nictot, nseg, lresid, .false.,             &
     &         dummy, 80, 0, .false.)
#elif defined(__DMOL)
             select case(ifmt)
              case(charmm) ; call ch_coor_read(ifile, rcomp)
              case(pdb)    ; call pdb_read(ifile, rcomp)
             end select
#endif
             if (qroot) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
!    compute "distance" to cv values
             do i=1, num_rep_out
              cv%r(:,main)=rtemp(:,i) ! CV into main set
              if (frames_initialized)                                   &
     &         call frame_align_rmsd(__XCOMP, __YCOMP, __ZCOMP, __MASS) ! calculate optimal frame axes in the sense of minimal rmsd
!         compute the instantaneous CV realizations
              call smcv_fill(__XCOMP, __YCOMP, __ZCOMP, __MASS, comp) ! works in series or parallel
!         compute RMSD:
              inte_rmsd(i,j)=cv_common_rmsd(comp,main)
             enddo
            endif ! mestring
!           write(600,*) inte_rmsd(:,j)
         enddo ! j=1,num_rep_in
!
!         reload new cv file
         do j=1, num_rep_out
           which=minloc(inte_rmsd(j,:)) ! which index corresponds to the smallest rmsd (ds)
!        open the corresponding file and save under new file name
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     open file
           length=len_trim(fname_cor_in(which(1)))
           dummy=fname_cor_in(which(1))(1:length)
!
           if (mestring.eq.0) then
            if (qroot) then ; __OPEN_FILE(ifile,dummy,form,'READ') ; endif
#ifdef __CHARMM
            dummy=''
            call cread(ifile, titleb, ntitlb, icntrl, xcomp, ycomp,     &
#ifndef __CHMOCCU
     &         zcomp, wcomp, natom, moder, islct,     &
#else
     &         zcomp, wcomp, wcomp, natom, moder, islct,     &
#endif
     &         0, res, nres, atype, ibase, 1, ifreea,              &
     &         segid, resid, nictot, nseg, lresid, .false.,             &
     &         dummy, 80, 0, .false.)
            if (ntitla+1 .lt. maxtit)                                   &
     &       write(titlea(ntitla+1),'(A,I5,A,I5)')                      &
     &       '* REPLICA ',j,' OF ',num_rep_out
#elif defined(__DMOL)
            select case(ifmt)
             case(charmm) ; call ch_coor_read(ifile, rcomp)
             case(pdb)    ; call pdb_read(ifile, rcomp)
            end select
#endif
            if (qroot) then ; __CLOSE_FILE(ifile, 'KEEP',ierror) ; endif
!cccccccccccc now write the same file cccccccccccccccccccccccc
!     open file
            length=len_trim(fname_cor_out(j))
            dummy=fname_cor_out(j)(1:length)
!
            if (qroot) then ; __OPEN_FILE(ofile,dummy,form,'WRITE') ; endif
!
#ifdef __CHARMM
            call CWRITE(ofile,TITLEA,min(NTITLA+1,maxtit),ICNTRL,       &
#ifndef __CHMOCCU
     &              xcomp,ycomp,zcomp,wcomp,res,atype,ibase,            &
#else
     &              xcomp,ycomp,zcomp,wcomp,wcomp,res,atype,ibase,      &
#endif
     &               NRES,NATOM,islct,modew,0,0,.false.)
#elif defined (__DMOL)
            select case(ifmt)
             case(charmm) ; ok=ch_coor_write(ofile, rcomp, bfactor)
             case(pdb)    ; ok=pdb_write(ofile, rcomp, occupancy, bfactor)
            end select
#endif
            if (qroot) then ; __CLOSE_FILE(ofile, 'KEEP', ierror) ; endif
!
           endif ! mestring
         enddo ! loop over new coordinate sets
         __FREE(fname_cor_in)
         __FREE(fname_cor_out)
        endif ! inte_get_coor
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#ifdef __CHARMM
        iolev=oldiol
#endif
#endif /* __ACEMD, __NAMD*/
      else
            __WARN(whoami,'UNRECOGNIZED SUBCOMMAND: ',keyword)
      endif
      end subroutine smcv
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_init(maxcv)
      use sm_var
      use sm_config
      use cv_common, only: cv_common_initialized, cv_common_init, main,       &
     &  comp, zcur, instant, frunave, forces2, max_cv_common
!      , only:smcv_initialized, nstring, mestring,
!     &   cv_send_displ,cv_send_count
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI
      __DEP_NUMBER
!
      __IMPNONE
!
   __DECLARE_MSGBUF
!
#include "mpitype.def"
!
      int4mpi :: ierror
      bool :: qroot, qslave
      int4mpi :: temp1(3), temp2(3) ! for communication
      int, optional :: maxcv
!
      integer(kind=MPI_ADDRESS_KIND) :: lb, extent
!
      __IAM(SMCV_INIT)
!
!      do a basic communicator check:
      if (ME_LOCAL.eq.0.and.ME_STRNG.eq.MPI_UNDEFINED) then
        write(_MSGBUF, 111) whoami, ME_GLOBAL, whoami
 111  FORMAT(A, ' WORLD REPLICA ',I5, ' HAS ZERO GROUP ID',             &
     & /,A,' BUT INVALID STRING ID (MAY BE OK).')
        __PRINT(_MSGBUF)
      elseif (ME_STRNG.ne.MPI_UNDEFINED.and.                            &
     &  (ME_LOCAL.ne.0.or.(SIZE_LOCAL.gt.1.and.MPI_COMM_LOCAL.eq.MPI_COMM_NULL))) then
        write(_MSGBUF, 112) whoami, ME_GLOBAL, whoami
 112  FORMAT(A, ' WORLD REPLICA ',I5, ' HAS A VALID STRING ID',         &
     & /,A,' BUT A NONZERO GROUP ID. ABORTING.')
        __PRINT(_MSGBUF)
       return
      endif
!
      qroot=ME_STRNG.ne.MPI_UNDEFINED
      qslave=ME_LOCAL.ne.MPI_UNDEFINED ! (also includes roots)
!
      if (smcv_initialized) then
       if (qroot) then
        if (ME_STRNG.eq.0) then
          write(_MSGBUF,'(2A)')                                            &
     &    whoami, ' SMCV ALREADY INITIALIZED. CALL "DONE" TO CLEAN UP.'
          __PRINT(_MSGBUF)
        endif ! ME_STRNG
       endif ! qroot
       return
      endif
!
      nstring=1 ! safe (hopefully) default
      mestring=-1 ! safe (hopefully) default
!
      if (qroot) then
        nstring=SIZE_STRNG
        mestring=ME_STRNG
      endif
!      broadcast string size to all slave nodes
#ifdef __CHARMM
      __BROADCAST_LOCAL_4B(nstring,  1)      !##.not.INTEGER8
      __BROADCAST_LOCAL_4B(mestring, 1)      !##.not.INTEGER8
      __BROADCAST_LOCAL_8B(nstring,  1)      !##INTEGER8
      __BROADCAST_LOCAL_8B(mestring, 1)      !##INTEGER8
!      set envorinment variables
      call setmsi('NSTRING',nstring)
      call setmsi('MESTRING',mestring)
#else
      __BROADCAST_LOCAL(nstring,  1, mpiint)
      __BROADCAST_LOCAL(mestring, 1, mpiint)
#endif
!
      if (qroot) then
        if (ME_STRNG.eq.0) then
          write(_MSGBUF,'(2A,I5, A)')                                      &
     &    whoami, ' FOUND ',nstring,' REPLICAS.'
          __PRINT(_MSGBUF)
        endif
      endif
!
      smcv_initialized=.true.
!
      if (.not.cv_common_initialized) then 
       if (present(maxcv)) then
        if (maxcv.gt.0) then
         if (qroot.and.ME_STRNG.eq.0) then
          write(_MSGBUF,'(2A,I5, A)') &
     &     whoami, ' WILL INITIALIZE SMCV WITH STORAGE FOR AT MOST ',maxcv,' CV.' 
          __PRINT(_MSGBUF)
         endif ! root prints
         call cv_common_init(maxcv)
        else
         __WRN(whoami, 'NEGATIVE NUMBER OF CV REQUESTED, USING PREVIOUS VALUE (OR DEFAULTS).')
         call cv_common_init() ! default
        endif
       else ! present maxcv
        call cv_common_init() ! default
       endif
      endif
!    allocate index arrays for cv index limits (parallelization)
      allocate(cv_send_displ(SIZE_LOCAL),                               & ! cv
     &         cv_send_count(SIZE_LOCAL))
      allocate(fr_send_displ(SIZE_LOCAL),                               & ! frames
     &         fr_send_count(SIZE_LOCAL))
      allocate(qt_send_displ(SIZE_LOCAL),                               & ! quat
     &         qt_send_count(SIZE_LOCAL))
      allocate(imap_displ(SIZE_LOCAL),                                  & ! imap
     &         imap_count(SIZE_LOCAL))
!    initialize
      cv_send_displ=0
      cv_send_count=0
      fr_send_displ=0
      fr_send_count=0
      qt_send_displ=0
      qt_send_count=0
      imap_displ=0
      imap_count=0
!
!     define/update derived MPI types:
!     these special types are for communicating CV;
!     I chose to index cv%r in a way that is not really
!     suitable for communication/parallelization, hence the special
!     types with custom blocks/strides/extents
!ccccccccccccccccc two cv values (main+comp) ccccccccccccccccc
!
!       call mpi_type_indexed(2,(/1,1/),
!     &  (/max_cv_common*(main-1),
!     &    max_cv_common*(comp-1)/),
!     &  mpifloat, MPI_CV_TYPE2_, ierror)

      temp1=(/ione,ione,izero/)
      temp2=(/max_cv_common*(main-1),max_cv_common*(comp-1),izero/)
__MPI_ONLY      call mpi_type_indexed(2, temp1, temp2, mpifloat, MPI_CV_TYPE2_, ierror)

! corresponding resized type (modified extent)
      lb=0
      extent=sizeofreal
__MPI_ONLY      call mpi_type_create_resized(MPI_CV_TYPE2_,lb,extent,MPI_CV_TYPE2, ierror)
__MPI_ONLY      call mpi_type_commit(MPI_CV_TYPE2, ierror)
!ccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccc three cv values cccccccccccccc
!       call mpi_type_indexed(3,(/1,1,1/),
!     &  (/max_cv_common*(zcur-1),
!     &    max_cv_common*(instant-1),
!     &    max_cv_common*(forces2-1)/), ! strides: i.e. take 1 element from zcur, 1 from inst., 1 from forces2
!     &  mpifloat, MPI_CV_TYPE3_, ierror)

      temp1=(/1,1,1/)
      temp2=(/max_cv_common*(zcur-1),                                     &
     &        max_cv_common*(instant-1),                                  &
     &        max_cv_common*(forces2-1)/)
__MPI_ONLY    call mpi_type_indexed(3, temp1, temp2, mpifloat, MPI_CV_TYPE3_, ierror)

! corresponding resized type
      lb=0
      extent=sizeofreal
__MPI_ONLY    call mpi_type_create_resized(MPI_CV_TYPE3_,lb,extent,MPI_CV_TYPE3,ierror)
__MPI_ONLY    call mpi_type_commit(MPI_CV_TYPE3, ierror)
!ccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccc three cv values (different from above) cccccccccccccc
!       call mpi_type_indexed(3,(/1,1,1/),
!     &  (/max_cv_common*(frunave-1),
!     &    max_cv_common*(instant-1),
!     &    max_cv_common*(forces2-1)/),
!     &  mpifloat, MPI_CV_TYPE3I_, ierror)

      temp1=(/1,1,1/)
      temp2=(/max_cv_common*(frunave-1),                                  &
     &        max_cv_common*(instant-1),                                  &
     &        max_cv_common*(forces2-1)/)
__MPI_ONLY    call mpi_type_indexed(3, temp1, temp2, mpifloat, MPI_CV_TYPE3I_, ierror)

! corresponding resized type (note change of extent)
      lb=0
      extent=sizeofreal
__MPI_ONLY    call mpi_type_create_resized(MPI_CV_TYPE3I_,lb,extent,MPI_CV_TYPE3I,ierror)
__MPI_ONLY    call mpi_type_commit(MPI_CV_TYPE3I, ierror)
!
      MPI_GRAD_TYPE =MPI_DATATYPE_NULL
      MPI_GRAD_TYPE_=MPI_DATATYPE_NULL
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccc
      end subroutine smcv_init
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_done()
      use cv_common, only: cv_common_done
      use sm_var,only: smcv_initialized, nstring, mestring
      use sm_config,only:  cv_send_displ, cv_send_count,                &
     &                     fr_send_displ,fr_send_count,                 &
     &                     imap_displ,imap_count,                       &
     &                     qt_send_displ,qt_send_count,                 &
     &  MPI_CV_TYPE2, MPI_CV_TYPE2_,                                    &
     &  MPI_CV_TYPE3, MPI_CV_TYPE3_,                                    &
     &  MPI_CV_TYPE3I, MPI_CV_TYPE3I_,                                  &
     &  MPI_GRAD_TYPE, MPI_GRAD_TYPE_
!
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
!
      __IMPNONE
!
 __DECLARE_MSGBUF
!
      int4mpi :: ierror
!
      __IAM(SMCV_DONE)
!
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0) then
        write(_MSGBUF,'(2A,I5, A)') whoami, ' CLEANING UP.' ; __PRINT(_MSGBUF)
      endif
!
      call cv_common_done()
      nstring=-1
      mestring=-1
!
#ifdef __CHARMM
!      set envorinment variable
      call setmsi('NSTRING',nstring)
      call setmsi('MESTRING',mestring)
#endif
!
!    deallocate index arrays for cv index limits (parallelization)
      if (smcv_initialized) then
       deallocate(cv_send_displ,cv_send_count,                          &
     &           fr_send_displ,fr_send_count,                           &
     &           imap_displ,imap_count,                                 &
     &           qt_send_displ,qt_send_count)
!    free MPI_TYPES
__MPI_ONLY       if (MPI_CV_TYPE2.ne.MPI_DATATYPE_NULL)  call mpi_type_free(MPI_CV_TYPE2,ierror);
__MPI_ONLY       if (MPI_CV_TYPE2_.ne.MPI_DATATYPE_NULL) call mpi_type_free(MPI_CV_TYPE2_,ierror);
!
__MPI_ONLY       if (MPI_CV_TYPE3.ne.MPI_DATATYPE_NULL)  call mpi_type_free(MPI_CV_TYPE3,ierror);
__MPI_ONLY       if (MPI_CV_TYPE3_.ne.MPI_DATATYPE_NULL) call mpi_type_free(MPI_CV_TYPE3_,ierror);
!
__MPI_ONLY       if (MPI_CV_TYPE3I.ne.MPI_DATATYPE_NULL) call mpi_type_free(MPI_CV_TYPE3I,ierror);
__MPI_ONLY       if (MPI_CV_TYPE3I_.ne.MPI_DATATYPE_NULL)call mpi_type_free(MPI_CV_TYPE3I_,ierror);
!
__MPI_ONLY       if (MPI_GRAD_TYPE.ne.MPI_DATATYPE_NULL) call mpi_type_free(MPI_GRAD_TYPE,ierror);
__MPI_ONLY       if (MPI_GRAD_TYPE_.ne.MPI_DATATYPE_NULL)call mpi_type_free(MPI_GRAD_TYPE_,ierror);
      endif
!
!  what else ?
!
      smcv_initialized=.false.
!
      end subroutine smcv_done
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_repa_init(COMLYN, COMLEN)
!     initialize string reparametrization
!
      use sm_var
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __DEP_NUMBER
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      __IMPNONE
!
      character(len=*) :: comlyn
      int :: comlen
!
      character(len=20) :: methods(5)
      data methods/ 'LINEAR','CUBIC SPLINE','B-SPLINE','DST','LINEAR_EXACT'/
!     selection array
      int :: qlinear, qspline, qbspline, qdst, qlinear_exact
      int :: mlen
!
!     declare functions here
!
      bool :: qroot, qprint
!
 __DECLARE_MSGBUF
!
      __IAM(SMCV_REPA_INIT)
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qprint=qroot.and.ME_STRNG.eq.0
!     begin
!     reset variables
      qspline=0
      qbspline=0
      qlinear=0
      qdst=0
      qlinear_exact=0
      dst_cutoff=zero
      interp_method=0
      repa_initialized=.false.
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (__INDX_RM(comlyn,comlen,'LINE').gt.0) then
       qlinear=1
       interp_method=linear
      endif
      if ((__INDX_RM(comlyn,comlen,'CSPL').gt.0).or.                        &
     &    (__INDX_RM(comlyn,comlen,'SPLI').gt.0)) then
       qspline=1
       interp_method=spline
      endif
      if (__INDX_RM(comlyn,comlen,'BSPL').gt.0) then
       qbspline=1
       interp_method=bspline
      endif
      if (__INDX_RM(comlyn,comlen,'DST').gt.0) then
       qdst=1
       interp_method=dst
!      did the user specify filter cutoff?
       dst_cutoff=__GET_RM_F(comlyn, comlen, 'WNCT', -one)
       if (dst_cutoff.lt.zero) then
        if (qprint) then ; write(_MSGBUF,664) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 664   FORMAT(A,' DST REQUESTED BUT FILTER CUTOFF',                     &
     &  A, ' NOT SPECIFIED.',/,' WILL USE 0.500')
        dst_cutoff=half
       endif
      endif
      if (__INDX_RM(comlyn,comlen,'LIN2').gt.0) then
       qlinear_exact=1
       interp_method=linear_exact
      endif
!ccccccc CHECK FOR MULTIPLE OPTIONS
      if ((qspline+qlinear+qbspline+qdst+qlinear_exact) .eq. 0) then
       if (qprint) then  ; write(_MSGBUF,665) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 665   FORMAT(A,' INTERPOLATION METHOD NOT SPECIFIED.',/,               &
     & A,' WILL USE LINEAR INTERPOLATION.')
       interp_method=linear
      elseif ((qspline+qlinear+qbspline+qdst+qlinear_exact) .gt. 1) then
       __WRN(whoami,'TOO MANY INTERPOLATION OPTIONS.')
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     did the user specify a tolerance?
      if (interp_method.ne.linear_exact) then ! options below are invalid for exact interpolation
       def=__GET_RM_F(comlyn, comlen, 'DEFI', 1.1*one)
       if (def.lt.one) then
         __WRN(whoami,'INTERPOLATION TOLERANCE MUST BE >= 1.')
!         return
       endif
!     did the user specify a maximum number of iterations?
       iterations=__GET_RM_I(comlyn, comlen, 'ITER',10)
      else
       def=zero
       iterations=0
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     print summary
      if (qprint) then
       mlen=len(methods(interp_method))
       if (interp_method.eq.linear_exact) then
        write(_MSGBUF,666) whoami,methods(interp_method)(1:mlen)
       else
        write(_MSGBUF,667) whoami,methods(interp_method)(1:mlen),whoami,&
     &  def
       endif
       __PRINT(_MSGBUF)
 666  format(A,' WILL REPARAMETRIZE STRING USING ',A,' INTERPOLATION')
 667  format(A,' WILL REPARAMETRIZE STRING USING ',A,/,                 &
     &A,' INTERPOLATION TO WITHIN MAX(DS)/MIN(DS) < ',F7.3,' TOLERANCE')
       if (iterations.gt.0) then ; write(_MSGBUF,668) whoami, iterations ; __PRINT(_MSGBUF) ; endif
 668  format(A,' WITH A MAXIMUM OF ',I5,' ITERATIONS')
       if(interp_method.eq.dst) then ; write(_MSGBUF,6680) whoami,dst_cutoff*100.0 ; __PRINT(_MSGBUF) ; endif
 6680 format(A,' DST INTERPOLATION WILL USE THE LOWER ',F8.4,           &
     & '% OF WAVENUMBERS')
      endif
!
!     initialize arclength array
      if (.not.associated(ds)) then
       allocate(ds(nstring-1))
       ds=0.0
      endif
!     initialize curvature array
      if (.not.associated(curv)) then
       allocate(curv(nstring-2))
       curv=0.0
      endif
!
      repa_initialized=.true.
!
      end subroutine smcv_repa_init
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_repa()
!     this is routine is just a wrapper, so that any subroutine can call a "default" repa.
      use sm_var,only: interp_method, iterations, def, dst_cutoff,    &
     &                   repa_initialized
      use cv_common,only: cv_common_repa
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
!
      __IMPNONE
 __DECLARE_MSGBUF
! local variables
      __IAM(SMCV_REPA)
      bool :: qprint
! check if the user has made an initialization call
!
      qprint=(MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0)
!
      if (.not.repa_initialized) then
       __WRN( whoami,'NO REPARAMETRIZATION OPTIONS SELECTED. NOTHING DONE.')
       return
      endif
      if (qprint) then ; write(_MSGBUF,690) whoami ; __PRINTL(_MSGBUF,5) ; endif
 690  format(A,' CALLING STRING REPARAMETRIZATION.')
      call cv_common_repa(interp_method,def,iterations,dst_cutoff)
!
      end subroutine smcv_repa
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine cv_set_ave_samples(n)
      use cv_common,only: cv_common_set_ave_samples
      __DEP_OUTPUT
      __IMPNONE
      int :: n
      call cv_common_set_ave_samples(n)
      end subroutine cv_set_ave_samples
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
__CHARMM_ONLY##ENDIF
