!CHARMM Element source/stringm/smcv.src $Revision: 1.4 $
!
! string code
!
#if (defined(__CHARMM) || defined(__PARALLEL) )
__CHARMM_ONLY##IF STRINGM
!
      SUBROUTINE smcv(COMLYN,COMLEN)
!----------------------------------------------------------------------
! command parser for the string method
!----------------------------------------------------------------------
      use sm_var
      use cv_common
      use cv_frames, only: frames_init, frames_list, frames_done,       &
     &                     frames_read_local, frames_read_global,       &
     &                     frames_print_local, frames_print_global,     &
     &                     frames_calc, frames, frames_initialized,     &
     &                     frames_reset_calculate,                      &
     &                     frames_calc_align_comp
      use cv_quaternion, only: quat_reset_calculate, quat_done
!
      use sm_config
      use smcv_master, only: smcv_fill, smcv_compute_wgt, smcv_add_hist,&
     &    smcv_list, smcv_compute_M, smcv_voronoi_whereami,             &
     &    smcv_test_grad_fd, smcv_test_parallel, smcv_test_Minv
      use ftsm_var, only : ftsm_initialized
!
      __DEP_OUTPUT
      __DEP_SIZE
      __DEP_PARSER 
      __DEP_COORDINATES
      __DEP_PSF
      __DEP_NUMBER 
#ifdef __CHARMM
      use ctitla 
#ifdef __CHARMM_VER
#if (__CHARMM_VER >=38 )
        use dcntrl_mod, only : dynopt
#endif
#endif
#endif
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_CONST 
      __DEP_MPI 
      __DEP_COORIO
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      __IMPNONE
!
      CHARACTER(len=*) :: COMLYN
      int :: comlen
!
! local variables
!
      character(len=8) :: keyword
!
#ifdef __CHARMM
      int :: ivver, ivv2, iorig, ileap ! for dynamics
      int :: islct(natom)
      int :: ifreea(natom)
      int :: oldiol
!     compatibility variables for coordinate reading/writing
      float :: xdum(natom+1), ydum(natom+1), zdum(natom+1),            &
     &          wdum(natom+1)
      int :: icntrl(20)
#endif
!
      int :: ifile
      int :: i,j,n
      int4mpi :: ierror, impi, jmpi, kmpi
      float :: k,w,gam,step,expo_memory,zval
      int :: num_ave_samples, irep
      int :: c1, c2, klen, delta, nskip, scol=0, totcol
      int :: ind, all, ibeg, iend
      character(len=80) :: fname
      int :: flen
      bool :: ok
      character(len=20) :: fixbc
!      int4mpi, allocatable, dimension(:) :: temp1, temp2 ! for MPI_GRAD_TYPE (alt)
      int :: me, maxcv
!
! for interpolation
!
      character(len=20) :: methods(5), method, form
      character(len=80) :: name_cv_in, name_cv_out, name_cor_in, name_cor_out
      character(len=80) :: dummy
      character(len=80), allocatable :: fname_cor_in(:), fname_cor_out(:)
      data methods/ 'LINEAR','CUBIC SPLINE','B-SPLINE','DST','LINEAR_EXACT'/
!
      int :: int_method, length, num_rep_in, num_rep_out,               &
     &           len_cv_in, len_cv_out, len_cor_in, len_cor_out, ofile
#ifdef __CHARMM
      int :: moder, modew
      bool :: lresid
#elif defined (__DMOL)
      int :: ifmt
#endif
!
      bool :: interp_cv, inte_get_coor, qcomp
      float, allocatable :: inte_rmsd(:,:), rtemp(:,:)
      float :: voro_cut, repl_x_temp
      bool :: min_rmsd, voronoi_check_map
      int :: which(1)
      bool :: qroot, qslave __CHARMM_ONLY, qprint
!     tests
      float, pointer :: fd_error(:,:) ! FD gradient computation
!
      integer(kind=MPI_ADDRESS_KIND) :: lb, extent
!
      __DECLARE_MSGBUF
!
#include "mpitype.def"
!
!     interface to frames_align_string routine (needed since routine is not in a module and I use optional args
      interface
       subroutine frames_align_string(x,y,z,mass,min_rmsd,ind)
        __DEP_OUTPUT
        __IMPNONE
        float :: x(:), y(:), z(:), mass(:)
        bool, optional :: min_rmsd
        int, optional :: ind ! frame index
       end subroutine frames_align_string
!
       subroutine frame_align_rmsd(x,y,z,mass,ind)
        __DEP_OUTPUT
        __IMPNONE
        float :: x(:), y(:), z(:), mass(:)
        int, optional :: ind ! frame index
       end subroutine frame_align_rmsd
!
       subroutine frame_align_voro(x,y,z,mass,ind)
        __DEP_OUTPUT
        __IMPNONE
        float :: x(:), y(:), z(:), mass(:)
        int, optional :: ind ! frame index
       end subroutine frame_align_voro
!
       subroutine smcv_init(maxcv)
        __IMPNONE
        int, optional :: maxcv
       end subroutine smcv_init
!
       function sm_get_column(cmd_, l, qcoltag, missing) result(C)
        __IMPNONE
        character(len=*) :: cmd_
        int :: l, missing
        bool :: qcoltag
        int :: C
       end function sm_get_column
!
      end interface
!
      __IAM(SMCV)
!
      keyword=__NEXTA(comlyn,comlen)
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qslave=((MPI_COMM_LOCAL.ne.MPI_COMM_NULL).and.SIZE_LOCAL.gt.1)
      qprint=qroot.and.ME_STRNG.eq.0
!
! check for ftsm initialization; quit if initialized
!
      if (ftsm_initialized) then
       __WRN(whoami,' FTSM IS ON AND CANNOT BE USED WITH SMCV. NOTHING DONE.')
       return
      endif
!
      if (SIZE_STRNG.gt.1) call MPI_BARRIER(MPI_COMM_STRNG,ierror)    !__CHARMM_ONLY##MPI
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (__STRNCMP(keyword,'INIT',4)) then
        maxcv=__GET_RM_I(comlyn, comlen, 'MAXCV',-999)
        if (maxcv.eq.-999 ) then ;  call smcv_init() ; else ; call smcv_init(maxcv) ; endif
        return
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (.not.smcv_initialized) then
        call smcv_init()
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (__STRNCMP(keyword,'DONE',4)) then
        call smcv_done()
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'REPA',4)) then
       if (comlen.gt.0) then ! this is an initialization call!
        call smcv_repa_init(comlyn, comlen)
       else
        call smcv_repa()
       endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'STAT',4)) then
       if (comlen.gt.0) then ! this is an initialization call!
        call smcv_stat_init(comlyn, comlen)
       else
        call smcv_stat()
       endif ! call statistics
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'DYNA',4)) then
#ifdef __CHARMM
       ivver=__INDX_RM(comlyn, comlen, 'VVER')
       ivv2=__INDX_RM(comlyn, comlen, 'VV2')
       iorig=__INDX_RM(comlyn, comlen, 'ORIG')
       ileap=__INDX_RM(comlyn, comlen, 'LEAP')
       if ((ivver+ivv2+iorig).gt.0) then
        __WRN( whoami,'ONLY LEAP-FROG DYNAMICS ARE SUPPORTED. NOTHING DONE')
        return
       endif
!      force LEAP DYNAMICS
       call joinwd(comlyn, mxcmsz, comlen, 'LEAP ', 5)
#endif
!ccccccccccccccc PARSE OTHER DYNAMICS OPTIONS
       voronoi_hist_on=(__INDX_RM(comlyn,comlen,'VORO').gt.0)
       if (voronoi_hist_on) then
        voronoi_allow_cross=(__INDX_RM(comlyn,comlen, 'VCRS').gt.0)
        if (voronoi_allow_cross) then
         voronoi_update_freq=__GET_RM_I(comlyn,comlen,'VCRF',0)
         if (voronoi_update_freq.le.0) then
          __WRN(whoami,'MUST SPECIFY POSITIVE VCRF. VORONOI CELL CROSSING DISABLED.')
          voronoi_allow_cross=.false.
         elseif (__INDX(comlyn, comlen, 'VINI',4).gt.0) then ! if vini is present
          voronoi_nocross_ini=__GET_RM_I(comlyn,comlen,'VINI',0) ! get it
          if (voronoi_nocross_ini.le.0) then
           __WRN(whoami,'NONPOSITIVE VINI SPECIFIED. WILL SET TO ZERO.')
           voronoi_nocross_ini=0
          endif ! voronoi_nocross_ini>0
         else
          voronoi_nocross_ini=0
         endif ! voronoi_nocross_ini present
        endif ! voronoi_allow_cross
!
!    initialize Voronoi data
        if (.not.cv_common_voronoi_initialized)                           &
     &    call cv_common_voronoi_init()
!    standard V. calculation case -- no crossing
        compute_whereami=.false.
        if (.not.voronoi_allow_cross) then
!    create standard map (unless map is present)
         if (.not.any(cv%voronoi_map.ne.-1)) then
          cv%voronoi_map=(/ (i, i=1, nstring) /)
          compute_whereami=.true. ! will be computed by dynamc routine
         endif
        endif
!
        voronoi_check_map=(__INDX_RM(comlyn,comlen, 'CHCK').gt.0)
!
!    compute whereami
!
        if (voronoi_check_map) then
         if (qprint) then
          write(_MSGBUF, 660) whoami ; __PRINT(_MSGBUF)
         endif
 660  FORMAT(A,' CHECKING VORONOI MAP AGAINST CURRENT COORDINATES.')
!
         compute_whereami=.false.
         call smcv_voronoi_whereami(__X,__Y,__Z,__MASS)
!
         if (any(cv%voronoi_map.ne.-1)) then
           me=cv%voronoi_map(mestring+1)
!    compare me and whereami:
           if (qroot) then
            if(SIZE_STRNG.gt.1) then
             call MPI_ALLREDUCE(me.eq.cv%voronoi_whereami, ok,          &
     &         1, MPI_LOGICAL, MPI_LAND, MPI_COMM_STRNG, ierror)
            else
             ok=me.eq.cv%voronoi_whereami
            endif
           endif ! qroot
           if (qslave) then 
            __BROADCAST_LOCAL_4B(ok,1)
           endif
           if (.not.ok) then
            __WRN(whoami,'VORONOI MAP INCONSISTENT WITH CURRENT COORDINATES. ABORTING.')
            return
           endif ! .not. ok
         else ! voronoi map invalid (or was not read); proceed anyway using current whereami
          __WRN( whoami,'VORONOI MAP CONTAINS INVALID ENTRIES.')
         endif ! voronoi_map.ne.-1
!
        else
         cv%voronoi_whereami=cv%voronoi_map(mestring+1)
        endif ! voronoi_check_map
!
       endif ! voronoi_hist_on
!      reset internal interation counter for smcv_master
       olditeration=0
!
       repa_on=(__INDX_RM(comlyn,comlen, 'REPA').gt.0)
       if (repa_on) repa_freq=__GET_RM_I(comlyn,comlen,'REPF',0)
!
       hist_freq=__GET_RM_I(comlyn,comlen,'HISF',0)
!
       stat_on=(__INDX_RM(comlyn,comlen, 'STAT').gt.0)
       if (stat_on) stat_freq=__GET_RM_I(comlyn,comlen,'STAF',0)
!
       evolve_cv_on=(__INDX_RM(comlyn,comlen, 'EVOL').gt.0)
       if (evolve_cv_on) then
        evolve_freq=__GET_RM_I(comlyn,comlen,'EVOF',0)
        evolve_nskip=__GET_RM_I(comlyn,comlen,'EVOS',0)
!       express in terms of history frequency
        if (hist_freq.gt.0) evolve_nskip=evolve_nskip/hist_freq
!
        evolve_step=__GET_RM_F(comlyn,comlen,'EVST',0.0d0) ! evolution step
! ----- types of evolution
        evolve_smooth_on=(__INDX_RM(comlyn,comlen,'SMOO').gt.0) ! smooth trajectory
        if (evolve_smooth_on) then
         evolve_smooth_d=__GET_RM_I(comlyn,comlen,'EVOD',1)   ! smoothing filter
        endif
!
        evolve_expo_on=(__INDX_RM(comlyn,comlen,'EXPO').gt.0) ! use exponential convolution
        if (evolve_expo_on) then
         evolve_expo_mem=__GET_RM_F(comlyn,comlen,'MEMO',0.99d0)
        endif
!
        evolve_bd_on=(__INDX_RM(comlyn,comlen,'BD').gt.0) ! use brownian dynamics (M not used); for T-accelerated sampling
        if (evolve_bd_on) then
!       evolve step specified above (will modify this section later)
         evolve_bd_T=__GET_RM_F(comlyn,comlen,'TEMP',0d0)
        endif
!
        evolve_aver_on=(__INDX_RM(comlyn,comlen,'AVER').gt.0) ! z=mean(theta)
        if (evolve_aver_on) then
         num_ave_cv_samples=__GET_RM_I(comlyn,comlen,'NAVE',0) ! initial number of samples in the averages
!                                                           setting this large will dampen initial fluctuations
        endif
       endif
!
       restrained_on=(__INDX_RM(comlyn,comlen, 'RSTR').gt.0)
       if (restrained_on) then
!
        steering_on=( (__INDX_RM(comlyn, comlen, 'SMD').gt.0) .or. (__INDX_RM(comlyn, comlen, 'STEE').gt.0) )
        if (.not.steering_on) call cv_common_copy(main, comp)
!
        restrained_eq_steps=__GET_RM_I(comlyn,comlen,'REEQ',0)
        restrained_eq0=0
!       for off-path sampling
        planar_on=(__INDX_RM(comlyn,comlen, 'PLAN').gt.0) ! restraint applied parallel to the path (this is obsolete)
       endif
!
       unrestrained_on=(__INDX_RM(comlyn,comlen, 'URES').gt.0)
       if (unrestrained_on) then
        unrestrained_eq_steps=__GET_RM_I(comlyn,comlen,'UREQ',0)
        unrestrained_eq0=0
        restrained_eq0=0
! currently unrestrained dynamics works as a preliminary step for restrained dynamics, therefore :
        if (.not.restrained_on) then
         __WRN(whoami, 'UNRESTRAINED (EXPLORATION) DYNAMICS REQUIRES EQUILIBRATION WITH RESTRAINTS ("RSTR"). TURNING OFF.');
         unrestrained_on=.false.
        endif
       endif
       repl_x_on=(__INDX_RM(comlyn,comlen,'REX').gt.0)
       if (repl_x_on) then
        repl_x_freq=__GET_RM_I(comlyn,comlen,'REXF',0)
        repl_x_temp=__GET_RM_F(comlyn,comlen,'REXT',0d0)
!
        if (repl_x_freq.le.0) then
          __WRN(whoami,'MUST SPECIFY POSITIVE REXF. REPLICA EXCHANGE IS OFF.')
          repl_x_on=.false.
!
        elseif (repl_x_temp.le.0) then
          __WRN(whoami,'MUST SPECIFY POSITIVE REXT. REPLICA EXCHANGE IS OFF.')
          repl_x_on=.false.
        elseif (voronoi_hist_on) then
          __WRN(whoami,'REPLICA EXCHANGE INCOMPATIBLE WITH V. TESSELATION. REX IS OFF.')
          repl_x_on=.false.
        elseif (evolve_cv_on.and.mod(repl_x_freq,evolve_freq).gt.0) then
          __WRN(whoami,'REPLICA SWAP ATTEMPT FREQ. NOT A MULTIPLE OF EVOLUTION FREQ.')
        elseif (repa_on.and.mod(repl_x_freq,repa_freq).gt.0) then
          __WRN(whoami,'REPLICA SWAP ATTEMPT FREQ. NOT A MULTIPLE OF REPA. FREQ.')
        else ! OK
          call cv_common_rex_set_temp(repl_x_temp)
        endif
       endif ! repl_x_on
!
       if (repa_on.or.evolve_cv_on.or.repl_x_on) then ! decrease output
         string_noprint=(__INDX_RM(comlyn,comlen,'NOPR').gt.0)
       endif
!--------------- DONE PARSING DYNAMICS OPTIONS -----
!    print summary
!cccccccccccccccccc STRING METHOD OPTIONS cccccccccccccccccccccc
       if (qprint) then
        WRITE (_MSGBUF,'(2A)')                                             &
     &      whoami, ' STRING METHOD ENABLED.' ; __PRINT(_MSGBUF)
        if (evolve_cv_on) then
            WRITE (_MSGBUF,'(/,2A,/,2A,I7,A)')                             &
     &      whoami, ' STRING EVOLUTION ENABLED.',                       &
     &      whoami, ' WILL EVOLVE AFTER EVERY ',                        &
     &      evolve_freq,' ITERATIONS.'  ; __PRINT(_MSGBUF)
            WRITE (_MSGBUF,'(2A,I7,A)')                                    &
     &      whoami, ' THE FIRST', evolve_nskip,                         &
     &      ' ITERATIONS AFTER STRING EVOLUTION WILL NOT CONTRIBUTE TO AVERAGES.' ; __PRINT(_MSGBUF)
!       type of evolution
            i=0;
            if (evolve_expo_on)   i=i+1
            if (evolve_bd_on)     i=i+1
            if (evolve_aver_on)   i=i+1
            if (evolve_smooth_on) i=i+1
!
            if (i.gt.1) then
             __WRN(whoami,'MORE THAN ONE EVOLUTION SCHEME REQUESTED. WILL USE SMCV.')
             evolve_expo_on=.false.
             evolve_aver_on=.false.
             evolve_smooth_on=.false.
             evolve_bd_on=.false.
            endif
!
            if (evolve_expo_on) then
               write(_MSGBUF,671) whoami, whoami, evolve_expo_mem ; __PRINT(_MSGBUF)
 671  format(A,' CV EVOLUTION WILL BE OF THE FORM:',/,                  &
     &       A,' Z(N+1)=A*Z(N)+(1-A)*<THETA>, A=',F9.5,'.')
            elseif (evolve_aver_on) then
               write(_MSGBUF,6710) whoami, whoami, num_ave_cv_samples ; __PRINT(_MSGBUF)
 6710 format(A,' CV EVOLUTION WILL BE OF THE FORM:',/,                  &
     &A,' Z(N+1)=AVERAGE_1^N(THETA).  INITIAL NUMBER OF SAMPLES IS ',I5,'.')
            elseif (evolve_smooth_on) then
               write(_MSGBUF,672) whoami, whoami, evolve_smooth_d ; __PRINT(_MSGBUF)
 672  format(A,' WILL EVOLVE CV BY SMOOTHING MD TRAJECTORY',/,          &
     &       A,' USING FILTER WIDTH D=',F8.3)
            elseif (evolve_bd_on) then
               write(_MSGBUF,6720) whoami, whoami, evolve_step, evolve_bd_T ; __PRINT(_MSGBUF)
 6720 format(A,' WILL EVOLVE CV USING BD ADVANCEMENT',/,                &
     &       A,' AT T=',F8.3,' WITH STEP=',F11.5)
            else
               write(_MSGBUF,673) whoami, whoami, evolve_step ; __PRINT(_MSGBUF)
 673  format(A,' WILL EVOLVE CV USING SMCV ADVANCEMENT ',/,             &
     &       A,' WITH STEP=',F11.5)
            endif ! evolve_expo
        endif ! evolve_cv_on
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (repa_on) then
          WRITE (_MSGBUF,666) whoami, repa_freq ; __PRINT(_MSGBUF)
 666  format(A,' WILL REPARAMETRIZE STRING AFTER EVERY ',I7,            &
     & ' ITERATIONS.')
        endif ! repa_on
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (hist_freq.gt.0) then ; write(_MSGBUF,667) whoami, hist_freq ; __PRINT(_MSGBUF) ; endif
 667  format(A,' WILL SAVE CV VALUES AFTER EVERY ', I7, ' ITERATIONS.')
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (restrained_on) then
            WRITE (_MSGBUF,'(2A)')                                         &
     &      whoami, ' WILL USE RESTRAINED DYNAMICS.' ; __PRINT(_MSGBUF)
!
            if (steering_on) then
             write(_MSGBUF(1), '(2A)') &
             whoami, ' WILL NOT INITIALIZE COMPARISON CV SET TO SIMULATE STEERED DYNAMICS (SMD).'
             write(_MSGBUF(2), '(2A)') &
             whoami, ' USER MUST INITIALIZE MAIN SET TO FINAL CV VALUES'
             write(_MSGBUF(3), '(2A)') &
             whoami, ' AND COMPARISON SET TO INITIAL CV VALUES'
             write(_MSGBUF(4), '(2A,I7,A)') &
             whoami, ' STEERING SPEED IS GOVERNED BY "REEQ"(=',restrained_eq_steps,')'
             __PRINT(_MSGBUF)
            endif
!
            if (unrestrained_on) then
             WRITE (_MSGBUF,'(2A)')                                         &
     &       whoami, ' WILL USE UNRESTRAINED (EXPLORATION) DYNAMICS.' ; __PRINT(_MSGBUF)
             unrestrained_eq0=0
             WRITE (_MSGBUF,669) whoami, unrestrained_eq_steps ; __PRINT(_MSGBUF)
 669  format(A,' WILL EQUILIBRATE UNDER CV RESTRAINTS FOR ', I7, ' STEPS.')
            endif ! unrestrained_on
!
            write(_MSGBUF,665) whoami, restrained_eq_steps ; __PRINT(_MSGBUF)
            restrained_eq0=0
 665  format(A, ' WILL ADJUST TO NEW RESTRAINTS OVER ', I7, ' STEPS.')
        endif ! restrained
!
!
        if (planar_on) then
            write (_MSGBUF,'(2A)') whoami,                                 &
     & ' WILL RESTRAIN SYSTEM IN PLANE PERPENDICULAR TO PATH.' ; __PRINT(_MSGBUF)
        endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (stat_on) then
            write(_MSGBUF,668) whoami, stat_freq ; __PRINT(_MSGBUF)
 668  format(A, ' WILL OUTPUT STRING STATISTICS EVERY ',                &
     & I7, ' STEPS.')
        endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (repl_x_on) then
            write(_MSGBUF,691) whoami, whoami, repl_x_freq, repl_x_temp ; __PRINT(_MSGBUF)
 691  format(A, ' WILL ATTEMPT TO EXCHANGE NEIGHBORING REPLICAS ',/     &
     &       A, ' ONCE IN EVERY ',I6,' ITERATIONS AT ',F8.3, ' K.')
        endif ! repl_x_on
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (voronoi_hist_on) then
            write(_MSGBUF,670) whoami ; __PRINT(_MSGBUF)
 670  format(A, ' WILL COMPUTE FREE ENERGY ALONG STRING ',              &
     & 'USING VORONOI TESSELLATION.' )
         if (voronoi_allow_cross) then
          write(_MSGBUF,601) whoami ; __PRINT(_MSGBUF)
          write(_MSGBUF,602) whoami, whoami, voronoi_update_freq ; __PRINT(_MSGBUF)
          if (voronoi_nocross_ini.gt.0) then
           write(_MSGBUF, 603) whoami, whoami, voronoi_nocross_ini ; __PRINT(_MSGBUF)
          endif
 601  format(A, ' WILL ALLOW REPLICAS TO CROSS BETWEEN V. CELLS.')
 602  format(A, ' WILL UPDATE CROSSING STATISTICS ONCE IN EVERY',/,     &
     &      A, I6, ' ITERATIONS.')
 603  format(A, ' WILL DISALLOW CROSSING DURING THE INITIAL ',/,A,I6,   &
     &       ' ITERATIONS.')
         endif
         if (restrained_on) then 
          write(_MSGBUF,'(2A,/2A)')   &
     &      whoami, ' STRING DYNAMICS SHOULD BE USED WITH CAUTION',     &
     &      whoami, ' DURING VORONOI FE COMPUTATION.' ; __PRINT(_MSGBUF)
         endif
         if (evolve_cv_on.or.repa_on) then
          if (.not.voronoi_allow_cross) then
           write(_MSGBUF,'(2A,/2A)')                                       &
     &    whoami, ' PERFORMING STRING EVOLUTION / REPARAMETRIZATION ',     &
     &    whoami, ' DURING VORONOI FE TESSELLATION IS AN EXTENSION ' ,     &
     &    whoami, ' TO THE STRING METHOD BECAUSE THE M TENSOR IS NOT ',    &
     &    whoami, ' COMPUTED AT THE STRING IMAGE. YOU HAVE BEEN WARNED.'    ; __PRINT(_MSGBUF)
          else
           write(_MSGBUF,'(2A,/2A,/2A)')                                   &
     &    whoami, ' STRING EVOLUTION AND REPARAMETRIZATION CANNOT',     &
     &    whoami, ' BE USED IF VORONOI CELL CROSSING IS ALLOWED.',      &
     &    whoami, ' VORONOI CELL CROSSING WILL BE OFF.' ; __PRINT(_MSGBUF)
           voronoi_allow_cross=.false.
          endif ! voronoi_allow_cross
         endif ! evolve_cv_on
        endif ! voronoi_hist_on
       endif ! root writes
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! check cv values for NAN
!
       if (restrained_on) then
        if (any(cv%r(1:cv%num_cv,main).eq.__NAN)) then
         __WARN(whoami, 'MAIN CV SET APPEARS TO BE UNDEFINED ON GLOBAL RANK ',ME_GLOBAL,'. BEWARE.');
        elseif (any(cv%r(1:cv%num_cv,comp).eq.__NAN)) then
         __WARN(whoami, 'COMPARISON/OLD CV SET APPEARS TO BE UNDEFINED ON GLOBAL RANK ',ME_GLOBAL,'. BEWARE.');
        endif
       endif ! restrained on
!
!      turn on string for dynamics
       smcv_on=.true.
#ifdef __CHARMM
!      call dynamics parser
       call dynopt(comlyn, comlen)
!cccccc turn off string for regular dynamics ccccccc
       smcv_on=.false.
       repa_on=.false. ! turn off after dynamics because SM0K also uses this flag; therefore a subsequent minimization would call reparametrization
#endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'ADD ',4)) then ! add CV
!         call MPI_COMM_RANK(MPI_COMM_WORLD, i,ierror)  ! aa
!        write(600+ME_GLOBAL,*) i,ME_GLOBAL, MPI_COMM_LOCAL,
!     &  ME_LOCAL, SIZE_LOCAL
!         call MPI_BARRIER(MPI_COMM_GLOBAL, ierror)
!                stop
!
       call smcv_add(comlyn, comlen) ! this routine deals with the various CV
!
!     (re)compute cv index limits (for parallelization) after each addition,
!     because cv%num_cv changes
!
       if (SIZE_LOCAL.gt.0) then
        if (.not. cv_common_initialized) call cv_common_init() ! make sure cv%num_cv is defined
!
        j=ceiling(1.0d0*cv%num_cv/SIZE_LOCAL) ! max. number of CV assigned to slave node
        n=ceiling(1.0d0*cv%amap%last/SIZE_LOCAL) ! max. number of amap indices assigned to slave node
!
        do i=1,SIZE_LOCAL
         cv_send_displ(i)=min((i-1)*j,cv%num_cv-1) ! cannot exceed num_cv
         cv_send_count(i)=max(0,min(j,cv%num_cv-j*(i-1))) ! how many CV I will send to CPU i
! atom map partitioning (for parallel computation of M
!
         imap_displ(i)=min((i-1)*n,cv%amap%last-1)
         imap_count(i)=max(0,min(n,cv%amap%last-n*(i-1)))
        enddo
       endif ! SIZE
! IGNORE COMMENTS BELOW
!  have to do some cheating: in order to communicate, namely, I assume that the (local) number of CV is the
!  same on each processor (to that some cpus might be sending "zeros" -- cv%r that is outside of the used bounds)
!  this also means that j*SIZE_LOCAL has to be less than or equal to than max_cv_common.
!  basically, I only use cv_send_count(1)=j from the above array
!       if (SIZE_LOCAL*j.gt.max_cv_common) then
!        if (qroot) then
!         if (ME_STRNG.eq.0)
!     &     write(_MSGBUF,'(2A,I5,1A,/,2A,I5,A)' ) whoami,
!          ' CV STORAGE SPACE EXCEEDED. PARALLELIZATION REQUIRES ',
!     &    SIZE_LOCAL*j, ' ELEMENTS', whoami, ', BUT ONLY ', max_cv_common,
!     &    ' ARE ALLOCATED.'
!        endif
!        call wrndie(-4, whoami, ' CV STORAGE SPACE EXCEEDED.')
!       endif
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccc
! this type will change when the auxiliary atom array is resized
! I could define the type in grad_init (only once would be required)
! but I don`t want to contaminate cv_common module (it would need to know sm_config)
       if (MPI_GRAD_TYPE.ne.MPI_DATATYPE_NULL)                          &
     &  call mpi_type_free(MPI_GRAD_TYPE, ierror)
       if (MPI_GRAD_TYPE_.ne.MPI_DATATYPE_NULL)                         &
     &  call mpi_type_free(MPI_GRAD_TYPE_, ierror)
!
       impi=6*cv%amap%last
       jmpi=1
       kmpi=6*cv%num_cv
       call mpi_type_vector(impi,jmpi,kmpi, & ! impi=6 because we are taking 3 gradients and both grad arrays (see cv_common)
     &  mpifloat,MPI_GRAD_TYPE_,ierror)
!
!      indexed version
!       i=6*cv%amap%last
!       allocate(temp1(i), temp2(i))
!       temp1=(/ (1, j=1, i) /)  ! block sizes
!       temp2=(/ ( (j-1)*cv%num_cv, j=1, i) /) ! offsets from zero
!       call mpi_type_indexed(i, temp1, temp2,
!     & mpifloat, MPI_GRAD_TYPE_, ierror)
!       deallocate(temp1, temp2)
!
       lb=0
       extent=sizeofreal
       call mpi_type_create_resized(MPI_GRAD_TYPE_,lb,extent,           &
     &  MPI_GRAD_TYPE, ierror)
       call mpi_type_commit(MPI_GRAD_TYPE, ierror)
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'CLEA',4)) then ! initialize
       if (qprint) then ; write(_MSGBUF,6666) whoami ; __PRINT(_MSGBUF) ; endif
 6666 format(/A,' WILL REMOVE ALL CV, FRAMES, AND QUATERNIONS.')
       call quat_done()
       call cv_common_done()
       call frames_done() ! frames rely on cv%amap, so must also be initialized
       call cv_common_init()
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccc ADDITIONAL VORONOI OPTIONS (nowhere else to put them)
      elseif (__STRNCMP(keyword,'VORO',4)) then
!*****************************************************************************************
       if (__INDX(comlyn, comlen, 'VCUT', 4).gt.0) then
        voro_cut=__GET_RM_F(comlyn, comlen, 'VCUT', zero)
! replica spec
        irep=__GET_RM_I(comlyn, comlen, 'REP', -1)
        if (voro_cut.le.zero) then
          __WRN(whoami, 'VCUT MUST BE POSITIVE. NOT SET.')
        else
         if (irep.lt.0.or.irep.ge.nstring) then
          if (qprint) then ; write(_MSGBUF, 6779) whoami, whoami, voro_cut ; __PRINT(_MSGBUF) ; endif
          call cv_common_voronoi_set_cutoff(voro_cut)
         else
          if (qprint) then ; write(_MSGBUF, 6780) whoami, irep, voro_cut ; __PRINT(_MSGBUF) ; endif
          if (mestring.eq.irep) call cv_common_voronoi_set_cutoff(voro_cut)
         endif ! irep
         if (qprint) then 
          write(_MSGBUF,'(2A,/2A,F11.7,A)')                                                        &
     &     whoami,' STRING WILL BE RESTRICTED TO STAY WITHIN THE WEIGHTED',                        &
     &     whoami,' DISTANCE ',voro_cut,' OF THE CELL CENTERS DURING DYNAMICS.' ; __PRINT(_MSGBUF)
         endif
!
 6779 format(A,' REPLICA NUMBER INVALID OR UNSPECIFIED.',/A,' WILL SET VORONOI TUBE CUTOFF ', &
     & '  TO ',F7.3,' ON ALL REPLICAS.')
 6780 format(A,' WILL SET VORONOI TUBE CUTOFF ON REPLICA ',I5,' TO ',F7.3,'.')
        endif ! voro_cut > 0
!
       endif ! VCUT
! process other voronoi commands
! get command
       if (comlen .ge. 4) then ! process additional commands
        keyword=__NEXTA(comlyn,comlen)
!    voronoi map commands cccccccccccccccccccccccccccccccccccccccccccccccccc
        if (__STRNCMP(keyword,'VMAP',4)) then
         if (__INDX_RM(comlyn, comlen, 'CALC').gt.0) then
          if (qprint) then ; write(_MSGBUF,6010) whoami ; __PRINT(_MSGBUF) ; endif
 6010 format(A,' WILL CALCULATE VORONOI MAP FROM MAIN COORDINATES.')
          call smcv_voronoi_whereami(__X,__Y,__Z,__MASS)
!    put 'whereami' into the map
          if (qroot.and.SIZE_STRNG.gt.1) then
           call MPI_ALLGATHER(cv%voronoi_whereami, 1, mpiint,       &
     &      cv%voronoi_map, 1, mpiint, MPI_COMM_STRNG, ierror)
          else
           cv%voronoi_map(mestring+1)=cv%voronoi_whereami
          endif
          if (qslave) then
#ifdef __CHARMM
          __BROADCAST_LOCAL_4B(cv%voronoi_map,nstring)  !__CHARMM_ONLY##.not.INTEGER8
          __BROADCAST_LOCAL_8B(cv%voronoi_map,nstring)  !__CHARMM_ONLY##INTEGER8
#elif defined (__DMOL)
          __BROADCAST_LOCAL(cv%voronoi_map,nstring,mpiint)
#endif
!
          endif
!    print map cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         elseif (__INDX_RM(comlyn, comlen, 'PRIN').gt.0) then
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
          if (qroot) then
           if (flen.gt.0) then
            if (qprint) then 
#ifdef __CHARMM
             oldiol=iolev
             iolev=1
#endif
             __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
             write(_MSGBUF,6011) whoami, fname(1:flen) ; __PRINT(_MSGBUF)
            endif
 6011 format(A,' WRITING VORONOI MAP TO FILE ',A,'.')
            call cv_common_print_voro_map(ifile)
            if (qprint) then 
             __CLOSE_FILE(ifile,'KEEP',ierror) 
#ifdef __CHARMM
             iolev=oldiol
#endif
            endif
           else
            __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
           endif ! flen
          endif ! qroot
!    read map ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         elseif (__INDX_RM(comlyn, comlen, 'READ').gt.0) then
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
          if (flen.GT.0) then
            if (qprint) then 
#ifdef __CHARMM
             oldiol=iolev
             iolev=1
#endif
             __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
             write(_MSGBUF,6013) whoami, fname(1:flen) ; __PRINT(_MSGBUF)
            endif
!
 6013 format(A,' READING VORONOI MAP FROM FILE ',A,'.')
            call cv_common_read_voro_map(ifile)
            if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
             iolev=oldiol
#endif
            endif
          else
            __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
          endif ! flen
!ccc reset map cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         elseif (__INDX_RM(comlyn, comlen, 'CLEA').gt.0) then
          if (associated(cv%voronoi_map)) cv%voronoi_map=-ione
         endif ! 'CALC'
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        elseif (__STRNCMP(keyword,'READ',4)) then
!    read "restart" file that contains (1) crossing_attempt (2) crossing_accepts (3) occupancy
         ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
         __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
         if (flen.GT.0) then
          if (qprint) then
#ifdef __CHARMM
           oldiol=iolev
           iolev=1
#endif
           __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
           write(_MSGBUF,6014) whoami, fname(1:flen) ; __PRINT(_MSGBUF) 
          endif
 6014 format(A,' READING VORONOI CROSSING DATA FROM FILE ',A,'.')
          call cv_common_read_voro_data(ifile)
          if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
           iolev=oldiol
#endif
          endif
         else
          __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
         endif ! flen
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        elseif (__STRNCMP(keyword,'PRIN',4)) then
         ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
         __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
         if (flen.gt.0) then
           if (qprint) then
#ifdef __CHARMM
            oldiol=iolev
            iolev=1
#endif
            __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
            write(_MSGBUF,6015) whoami, fname(1:flen) ; __PRINT(_MSGBUF)
 6015 format(A,' WRITING VORONOI CROSSING DATA TO FILE ',A,'.')
           endif
           call cv_common_print_voro_data(ifile)
           if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
            iolev=oldiol
#endif
           endif
         else
            __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
         endif ! flen
        endif ! VMAP
       endif ! VCUT
!cccccccccccccccccccc FRAMES PARSER ccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'FRAM',4)) then ! frames parser
!    get frames command
       keyword=__NEXTA(comlyn,comlen)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       if (__STRNCMP(keyword,'CLEA',4)) then ! initialize
        if (qprint) then ; write(_MSGBUF,6667) whoami ; __PRINT(_MSGBUF) ; endif
 6667 format(/A,' WILL REMOVE ALL LOCAL FRAMES.')
        call frames_done()
        call frames_init()
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'RESE',4)) then ! initialize
        if (qprint) then ; write(_MSGBUF,6650) whoami ; __PRINT(_MSGBUF) ; endif
 6650 format(/A,' WILL FORCE RECALCULATION OF FRAME AXES.')
        call frames_reset_calculate(.true.)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'FILL',4)) then ! compute frame axes values from current coordinates
!
        qcomp=(__INDX_RM(comlyn, comlen, 'COMP').gt.0) ! compute CV from comp set?
!
        if (frames%num_frames.lt.1) then
         __WRN(whoami,'NO FRAMES DEFINED. NOTHING DONE.')
        else
!       first process special option: ALIGn
!       frame axes will be calculated based on the main set, but `consistently` with the comparison set;
!       specifically: the frame axes are permuted such that the rotation matrix associated with transforming one frame into another is the closest
!       to the best-fit-RMSD rotation matrix
         if (__INDX_RM(comlyn, comlen, 'ALIG').gt.0) then
          if (any(__XCOMP.eq.__NAN)) then
           __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
          elseif (any(__X.eq.__NAN)) then
           __WRN(whoami,'COMPARISON X SET HAS UNDEFINED VALUES. NOTHING DONE.')
          else
           if (qcomp) then
            if (qprint) then ; write(_MSGBUF,6651) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 6651 format(/A,' WILL CALCULATE FRAME AXES FROM',                      &
     &          ' COMPARISON COORDINATES USING',                        &
     &       /A,' BEST-FIT ALIGNMENT WITH MAIN COORDINATES.')
            do i=1, frames%num_frames
             call frames_calc_align_comp(                               &
     &                  i,__XCOMP,__YCOMP,__ZCOMP,__X,__Y,__Z,__MASS,.true.)
            enddo
           else ! qcomp
            if (qprint) then ; write(_MSGBUF,6652) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 6652 format(/A,' WILL CALCULATE FRAME AXES FROM',                      &
     &          ' MAIN COORDINATES USING BEST-FIT',                     &
     &       /A,' ALIGNMENT WITH COMPARISON COORDINATES.')
            do i=1, frames%num_frames
             call frames_calc_align_comp(                               &
     &                   i,__X,__Y,__Z,__XCOMP,__YCOMP,__ZCOMP,__MASS,.true.)
            enddo
           endif ! qcomp
           call frames_reset_calculate(.true.) ! make sure that next time frames_calc is called we recalculate axes (to be safe)
          endif ! xcomp
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!        process regular fill
         elseif (qcomp) then
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
          if (any(__XCOMP.eq.__NAN)) then
           __WRN(whoami,'COMPARISON X SET HAS UNDEFINED VALUES. NOTHING DONE.')
          else
           if (qprint) then ; write(_MSGBUF,6656) whoami ; __PRINT(_MSGBUF) ; endif
 6656 format(/A,' WILL CALCULATE FRAME AXES FROM COMPARISON COORDINATES.')
           do i=1, frames%num_frames
            call frames_calc(i,__XCOMP,__YCOMP,__ZCOMP,__MASS,.true.)
           enddo
           call frames_reset_calculate(.true.) ! make sure that next time frames_calc is called we recalculate axes (to be safe)
          endif ! xcomp.eq.__NAN
         else ! qcomp false -- use main coords
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
          if (any(__X.eq.__NAN)) then
           __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
          else
           if (qprint) then ; write(_MSGBUF,6668) whoami ; __PRINT(_MSGBUF) ; endif
 6668 format(/A,' WILL CALCULATE FRAME AXES FROM MAIN COORDINATES.')
           do i=1, frames%num_frames
            call frames_calc(i,__X,__Y,__Z,__MASS,.true.)
           enddo
           call frames_reset_calculate(.true.) ! make sure that next time frames_calc is called we recalculate axes (to be safe)
          endif ! x.eq.__NAN
         endif ! qcomp
        endif ! num_frames < 1
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'PRIN',4)) then
!      can write both a local and a global file
!      local is specified with 'ALL'; global is the default
        all=__INDX_RM(comlyn,comlen,'ALL') ! all replicas print
!      prepare file
!-----------------------------------------------------------------------------
        ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
        __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
!---------------------------------- OPEN FILE --------------------------------
        if (qroot) then
         if (all.gt.0.or.qprint) then
#ifdef __CHARMM
          oldiol=iolev
          iolev=0 ! trick to open file on all nodes
#endif
          if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','WRITE') ; endif
          if (ifile .eq. -1) ifile=__OSTREAM ! write to output stream
         endif
!---------------------------- assume file is open, write -------------------------
         if (qprint) then ; write(_MSGBUF,6669) whoami ; __PRINT(_MSGBUF) ; endif
 6669 format(/A,' WRITING LOCAL FRAME AXES.')
         if (all.eq.0) then ; call frames_print_global(ifile) ;
         else ; call frames_print_local(ifile) ; endif
         if (all.gt.0.or.qprint) then
          if (flen.gt.0) __CLOSE_FILE(ifile,'KEEP',ierror)
#ifdef __CHARMM
          iolev=oldiol
#endif
         endif
        endif ! qroot
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'READ',4)) then
!      can read from both a local and a global file
!      local is specified with 'ALL'; default is global
        all=__INDX_RM(comlyn,comlen,'ALL') ! all replicas read
!      prepare file
        ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
        __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: flen will be UPPER CASE
        if (qroot) then
!cccccccccccccccccccccccccccc OPEN FILE ccccccccccccccccccccccc
         if (all.gt.0.or.qprint) then
#ifdef __CHARMM
          oldiol=iolev
          iolev=0 ! open file on all processors
#endif
          if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','READ') ; endif
         endif
         if (ifile .eq. -1) then
          Ifile=__ISTREAM ! read from input file
#ifdef __CHARMM
          call rdtitl(titleb,ntitlb,ifile,0) ! 0 = card format
#endif
         endif
!cccccccccccccccccc assume file is open, read ccccccccccccccccccc
         if (qprint) then ; write(_MSGBUF,6670) whoami ; __PRINT(_MSGBUF) ; endif
 6670 format(A,' READING LOCAL FRAME AXES.')
         if (all.gt.0) then ; call frames_read_local(ifile) ;
         else ; call frames_read_global(ifile) ; endif
         if (all.gt.0.or.qprint) then
          if (flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
#ifdef __CHARMM
          iolev=oldiol
#endif
         endif
        endif ! qroot
! send to slaves
        if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.                        &
     &                          SIZE_LOCAL.gt.1)                        &
     &   call MPI_BCAST(frames%r(:,:,:), frames%num_frames*9,           &
     &   mpifloat, 0, MPI_COMM_LOCAL, ierror)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'ADD',3)) then
        call smcv_frame_add(comlyn, comlen)
!
!     (re)compute frame index limits (for parallelization) after each addition
!
        if (SIZE_LOCAL.gt.0) then
         if (.not.frames_initialized) call frames_init() ! make sure frames%num_frames is defined
!
         j=ceiling(1.0d0*frames%num_frames/SIZE_LOCAL) ! max. number of frames assigned to slave node
         n=ceiling(1.0d0*cv%amap%last/SIZE_LOCAL) ! max. number of amap indices assigned to slave node
!
         do i=1,SIZE_LOCAL
          fr_send_displ(i)=min((i-1)*j,frames%num_frames-1) ! cannot exceed num_cv
          fr_send_count(i)=max(0,min(j,frames%num_frames-j*(i-1))) ! how many CV I will send to CPU i
! atom map partitioning (for parallel computation of M
!
          imap_displ(i)=min((i-1)*n,cv%amap%last-1)
          imap_count(i)=max(0,min(n,cv%amap%last-n*(i-1)))
         enddo
        endif
!cccc !aa
!
!        write(0,*) ME_LOCAL, fr_send_displ(ME_LOCAL+1),
!     &      fr_send_count(ME_LOCAL+1),frames%num_frames
!            stop
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'LIST',4)) then ! list frames
        if (qprint) then ; write(_MSGBUF,6671) whoami ; __PRINT(_MSGBUF) ; endif
 6671 format(/A,' WILL LIST LOCAL FRAMES.')
       call frames_list() ! list local frames
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'ALIG',4)) then ! iteratively invert frame vectors (v -> -v)
!                                                      to guess the best alignment along string &
!                                                      (optional) to mimimize DIST(z,theta(x))
        min_rmsd=(__INDX_RM(comlyn,comlen,'RMSD').gt.0) ! look for optimal RMSD alignment : i.e. minimize DIST(z,theta(x)) ?
!
        if (qprint) then ; write(_MSGBUF,6672) whoami ; __PRINT(_MSGBUF) ; endif
 6672 format(/A,' WILL ALIGN LOCAL FRAMES.')
        if (__INDX_RM(comlyn,comlen,'VORO').gt.0) then
          if (qprint) then ; write(_MSGBUF,6673) whoami ; __PRINT(_MSGBUF) ; endif
 6673 format(A,' WILL FIT THE VORONOI MAP.')
          call frame_align_voro(__X,__Y,__Z,__MASS)
        else
          if (min_rmsd.and.qprint) then ; write(_MSGBUF,6674) whoami ; __PRINT(_MSGBUF) ; endif
 6674 format(A,' WILL CHECK RMSD(Z,THETA[X]).')
          call frames_align_string(__X,__Y,__Z,__MASS,min_rmsd) ! subroutine moved to sm_util to resolve dependency problems
        endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       else
            __WARN(whoami,'UNRECOGNIZED SUBCOMMAND: ',keyword)
       endif ! frames parser
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'FILL',4)) then ! fill CV values from current coordinates
!
       qcomp=(__INDX_RM(comlyn, comlen, 'COMP').gt.0)
!
       if (qcomp) then
        if (any(__XCOMP.eq.__NAN)) then
         __WRN(whoami,'COMPARISON X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         if (qprint) then ; write(_MSGBUF,6657) whoami ; __PRINT(_MSGBUF) ; endif
 6657 format(/A,' WILL OBTAIN CV VALUES FROM COMPARISON COORDINATES.')
!     check for column spec
         c1=sm_get_column(comlyn, comlen, qcoltag=.true., missing=-1)
         if (c1.gt.0) then
          if (qprint) then ; write(_MSGBUF,6661) whoami, c1 ; __PRINT(_MSGBUF) ; endif
          call smcv_fill(__XCOMP,__YCOMP,__ZCOMP,__MASS,c1)
          call quat_reset_calculate(.true.)
          call frames_reset_calculate(.true.)
          call cv_common_unwrap_angles(c1) ! in case they are present
         else
          if (qprint) then ; write(_MSGBUF,6662) whoami ; __PRINT(_MSGBUF) ; endif
          call smcv_fill(__XCOMP,__YCOMP,__ZCOMP,__MASS)
          call quat_reset_calculate(.true.)
          call frames_reset_calculate(.true.)
          call cv_common_unwrap_angles() ! in case they are present
         endif ! c1
        endif ! x.eq.__NAN
       else ! ~qcomp -- use main coirdinates
        if (any(__X.eq.__NAN)) then
         __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         if (qprint) then ; write(_MSGBUF,6660) whoami ; __PRINT(_MSGBUF) ; endif
 6660 format(/A,' WILL OBTAIN CV VALUES FROM MAIN COORDINATES.')
!     check for column spec
         c1=sm_get_column(comlyn, comlen, qcoltag=.true., missing=-1)
         if (c1.gt.0) then
          if (qprint) then ; write(_MSGBUF,6661) whoami, c1 ; __PRINT(_MSGBUF) ; endif
 6661  format(/A,' WILL FILL COLUMN ',I3,'.')
          call smcv_fill(__X,__Y,__Z,__MASS,c1)
          call quat_reset_calculate(.true.)
          call frames_reset_calculate(.true.)
          call cv_common_unwrap_angles(c1) ! in case they are present
         else
          if (qprint) then ; write(_MSGBUF,6662) whoami ; __PRINT(_MSGBUF) ; endif
 6662  format(/A,' WILL FILL DEFAULT COLUMN.')
          call smcv_fill(__X,__Y,__Z,__MASS)
          call quat_reset_calculate(.true.)
          call frames_reset_calculate(.true.)
          call cv_common_unwrap_angles() ! in case they are present
         endif ! c1
        endif ! x.eq.__NAN
       endif ! qcomp
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'TEST',4)) then !
       if (__INDX_RM(comlyn,comlen,'GRAD').gt.0) then ! finite-difference gradient test
! check fd spec
        step=__GET_RM_F(comlyn, comlen, 'STEP', finite_difference_d)
        if (qprint) then ; write(_MSGBUF, 7001) whoami,whoami,step,whoami,whoami ; __PRINT(_MSGBUF) ; endif
 7001  format(/A,' WILL TEST GRADIENTS USING FINITE DIFFERENCES',       &
     &        /A,' USING DX = DY = DZ = ',F15.9,'.',                    &
     &        /A,' MAIN COORDINATE SET MUST BE DEFINED.',               &
     &        /A,' WILL OVERWRITE "MAIN", "ZCUR", AND "ZOLD" CV ARRAYS')
        if (any(__X.eq.__NAN)) then
         __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         fd_error=>smcv_test_grad_fd(__X,__Y,__Z,__MASS,step)
         if (qprint) then
          write(_MSGBUF,7002) whoami, whoami ; __PRINT(_MSGBUF)
 7002  format(/A,' CV#, DGRAD_X_MAX, DGRAD_Y_MAX, DGRAD_Z_MAX',         &
     &        /A,' ==========================================')
          do i=1, cv%num_cv
         write(_MSGBUF,'(A," ",I5," ",3(F15.9," "))')whoami,i,fd_error(i,:) ; __PRINT(_MSGBUF)
!          write(_MSGBUF,*), i, fd_error(i,:)
          enddo
         endif ! qprint
!     decide whether the test was passed
         zval=abs(maxval(fd_error))
         if (zval.lt.abs(step)*1d0) then
          write(_MSGBUF,7003) whoami, zval, whoami ; __PRINT(_MSGBUF)
         else
          write(_MSGBUF,7004) whoami, zval, whoami ; __PRINT(_MSGBUF)
          __WRN(whoami,'FINITE DERIVATIVE TEST FAILED.')
         endif ! report test result
 7003 format(/A, ' THE MAXIMUM GRADIENT ierror IS ',F15.9,', ',          &
     &       /A, ' WHICH IS SMALLER THAN STEP. TEST PASSED.')
 7004 format(/A, ' THE MAXIMUM GRADIENT ierror IS ',F15.9,', ',          &
     &       /A, ' WHICH IS NO SMALLER THAN STEP. TEST FAILED.')
         deallocate(fd_error) ! smcv_test_grad returns a pointer to an array of abs errors
        endif
       endif ! grad
!
       if (__INDX_RM(comlyn,comlen,'PARA').gt.0) then ! parallel communication test
        if (qprint) then ; write(_MSGBUF, 7005) whoami,whoami,whoami ; __PRINT(_MSGBUF) ; endif
 7005  format(/A,' WILL COMPARE PARALLEL AND SERIAL CV COMPUTATION',    &
     &        /A,' MAIN COORDINATE SET MUST BE DEFINED.',               &
     &        /A,' WILL OVERWRITE "ZCUR" CV ARRAY')
        if (any(__X.eq.__NAN)) then
         __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         fd_error=>smcv_test_parallel(__X,__Y,__Z,__MASS) ! use the same array as above
         if (qprint) then
          write(_MSGBUF,7006) whoami, whoami ; __PRINT(_MSGBUF)
 7006  format(/A,' CV#, DCV, DGRAD_X_MAX, DGRAD_Y_MAX, DGRAD_Z_MAX',    &
     &        /A,' ===============================================')
          do i=1, cv%num_cv
         write(_MSGBUF,'(A," ",I5," ",4(F15.9," "))')whoami,i,fd_error(i,:) ; __PRINT(_MSGBUF)
!          write(_MSGBUF,*), i, fd_error(i,:)
          enddo
         endif ! qprint
!     decide whether the test was passed
         zval=abs(maxval(fd_error))
         if (zval.lt.parallel_tolerance) then
          write(_MSGBUF,7007) whoami, zval, whoami, parallel_tolerance ; __PRINT(_MSGBUF)
         else
          write(_MSGBUF,7008) whoami, zval, whoami, parallel_tolerance ; __PRINT(_MSGBUF)
          __WRN(whoami,'PARALLEL COMPUTATION TEST FAILED.')
         endif ! report test result
 7007 format(/A, ' THE MAXIMUM ierror IS ',E12.5,', ',                   &
     &       /A, ' WHICH IS SMALLER THAN ',E12.5,'. TEST PASSED.')
 7008 format(/A, ' THE MAXIMUM ierror IS ',E12.5,', ',                   &
     &       /A, ' WHICH IS NO SMALLER THAN ',E12.5,'. TEST FAILED.')
         deallocate(fd_error) ! smcv_test_grad returns a pointer to an array of abs errors
        endif
       endif ! para
!
       if (__INDX_RM(comlyn,comlen,'MINV').gt.0) then ! finite-difference gradient test
        if (qprint) then ; write(_MSGBUF, 7010) whoami,whoami,whoami, whoami ; __PRINT(_MSGBUF) ; endif
 7010  format(/A,' WILL COMPARE M TENSOR INVERSE COMPUTATION',          &
     &        /A,' USING LU DECOMPOSITION AND MULTIDIAGONAL',           &
     &        /A,' MATRIX INVERSION.'                                   &
     &        /A,' MAIN COORDINATE SET MUST BE DEFINED.')
        if (any(__X.eq.__NAN)) then
         __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         zval=smcv_test_Minv(__X,__Y,__Z,__MASS)
         if (zval.lt.parallel_tolerance) then
          write(_MSGBUF,7011) whoami, zval, whoami, parallel_tolerance ;  __PRINT(_MSGBUF)
         else
          write(_MSGBUF,7012) whoami, zval, whoami, parallel_tolerance ;  __PRINT(_MSGBUF)
          __WRN(whoami,'M INVERSE TEST FAILED.')
         endif ! report test result
!
 7011 format(/A, ' THE MAXIMUM DIFFERENCE IS ',E12.5,', ',              &
     &       /A, ' WHICH IS SMALLER THAN ',E12.5,'. TEST PASSED.')
 7012 format(/A, ' THE MAXIMUM DIFFERENCE IS ',E12.5,', ',              &
     &       /A, ' WHICH IS NO SMALLER THAN ',E12.5,'. TEST FAILED.')
        endif
       endif
! other tests will go below this line
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! specify parallel CV calculation options
      elseif (__STRNCMP(keyword,'PARA',4)) then
       do while (comlen .gt. 1)
        keyword=__NEXTA(comlyn, comlen)
        select case(keyword)
         case('QUAT');
          keyword=__NEXTA(comlyn, comlen)
          select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_qt_para=.true.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'QUATERNIONS', keyword ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_qt_para=.false.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'QUATERNIONS', keyword ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED FOR "QUAT"')
          end select
         case('FRAM');
          keyword=__NEXTA(comlyn, comlen)
          select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_fr_para=.true.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'FRAMES', keyword ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_fr_para=.false.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'FRAMES', keyword ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED FOR "FRAM"')
          end select
         case('COLV');
          keyword=__NEXTA(comlyn, comlen)
          select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_cv_para=.true.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'CV', keyword ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_cv_para=.false.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'CV', keyword ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED FOR "COLV"')
          end select
         case('MMAT');
          keyword=__NEXTA(comlyn, comlen)
          select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_Mtensor_para=.true.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'M TENSOR', keyword ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_Mtensor_para=.false.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'M TENSOR', keyword ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED FOR "MMAT"')
          end select
         case('VORO');
          keyword=__NEXTA(comlyn, comlen)
          select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_voronoi_para=.true.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'VORONOI NORM', keyword ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_voronoi_para=.false.
            if (qprint) then ; write(_MSGBUF,7009) whoami, 'VORONOI NORM', keyword ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED FOR "VORO"')
          end select
         case default
          __WRN( whoami,'UNKNOWN OPTION SPECIFIED FOR "PARA"')
        end select
       enddo ! comlen
 7009  format(/A, ' PARALLEL COMPUTATION OF ',A,' ',A)
!
      elseif (__STRNCMP(keyword,'MINV',4)) then
       keyword=__NEXTA(comlyn, comlen)
       select case(keyword)
        case('LU','lu')
          keyword='LU'; inverse_LU=.true.
          if (qprint) then ; write(_MSGBUF,7013) whoami, keyword ; __PRINT(_MSGBUF) ; endif
        case('DIAG','diag')
          keyword='MULTDIAG' ; inverse_LU=.false.
          if (qprint) then ; write(_MSGBUF,7013) whoami, keyword ; __PRINT(_MSGBUF) ; endif
        case default
          __WRN(whoami,'UNKNOWN MATRIX INVERSION OPTION SPECIFIED.')
       end select
 7013  format(/A, ' MATRIX INVERSION WILL USE ',A,' ROUTINES.')
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'FIX',3)) then ! tell cv_posi about fixed "virtual" replicas
       if (qprint) then ; write(_MSGBUF, 6665) whoami, whoami ; __PRINT(_MSGBUF) ; endif
       fixed_bc_0=(__INDX_RM(comlyn,comlen,'FIRS').gt.0)
       fixed_bc_1=(__INDX_RM(comlyn,comlen,'LAST').gt.0)
       if (fixed_bc_0) then
         fixbc=' '
         flen=1
       else
         fixbc=' NOT '
         flen=5
       endif
       if (qprint) then ; write(_MSGBUF,6663) whoami, fixbc(1:flen) ; __PRINT(_MSGBUF) ; endif
       if (fixed_bc_1) then
         fixbc=' '
         flen=1
       else
         fixbc=' NOT '
         flen=5
       endif
       if (qprint) then ; write(_MSGBUF,6664) whoami, fixbc(1:flen) ; __PRINT(_MSGBUF) ; endif
       call cv_common_set_bc(fixed_bc_0, fixed_bc_1)
 6663 format(/A,' FIRST REPLICA OF STRING WILL',A,'BE FIXED.')
 6664 format(A,' LAST REPLICA OF STRING WILL',A,'BE FIXED.'/)
 6665 format(A,' WARNING: SETTING BC REQUIRES REINITIALIZATION.',/,     &
     &       A,' ALL CV DATA WILL BE ERASED.')
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'PRIN',4)) then
!      can write both a local and a global file
!      local is specified with 'ALL'; global is the default
       all=__INDX_RM(comlyn,comlen,'ALL') ! all replicas print
!      prepare file
!-----------------------------------------------------------------------------
       ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
       __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
!---------------------------------- OPEN FILE --------------------------------
       if (qroot) then
        if (all.gt.0.or.qprint) then
#ifdef __CHARMM
         oldiol=iolev
         iolev=0 ! trick to open file on all nodes
#endif
         if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','WRITE') ; endif
        endif
        if (ifile .eq. -1) ifile=__OSTREAM ! write to output stream
!---------------------------- assume file is open, write -------------------------
!     check for column spec
        c1=sm_get_column(comlyn, comlen, qcoltag=.true., missing=-1)
        if (c1.gt.0) then
         if (qprint) then ; write(_MSGBUF,6679) whoami, c1 ; __PRINT(_MSGBUF) ; endif
 6679 format(/A,' WRITING COORDINATES FROM COLUMN ',I3)
         if (all.eq.0) then ; call cv_common_print_global(ifile, c1) ;
         else ; call cv_common_print_local(ifile,c1) ; endif
        else
         if (qprint) then ; write(_MSGBUF,6689) whoami ; __PRINT(_MSGBUF) ; endif
 6689 format(/A,' WRITING COORDINATES FROM DEFAULT COLUMN.')
         if (all.eq.0) then ; call cv_common_print_global(ifile) ;
         else ; call cv_common_print_local(ifile) ; endif
        endif ! c1
        if (all.gt.0.or.qprint) then
         if (flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
#ifdef __CHARMM
         iolev=oldiol
#endif
        endif
       endif ! qroot
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'READ',4)) then
!      can read from both a local and a global file
!      local is specified with 'ALL'; default is global
!      can also read a specific column: specify SCOL x
       all=__INDX_RM(comlyn,comlen,'ALL') ! all replicas read
       if (__INDX(comlyn, comlen, 'SCOL',4).gt.0) then
        scol=__GET_RM_I(comlyn, comlen, 'SCOL', 0)
        if (scol.ge.1) then ! need to know total number of replicas in CV file
         if (all.gt.0) then
          __WRN(whoami,'ALL AND SCOL CANNOT BOTH BE SPECIFIED.')
          return
         endif
         totcol=__GET_RM_I(comlyn, comlen, 'TCOL', 0)
         if (totcol.le.0) then
          __WRN(whoami,'MUST PROVIDE TOTAL NUMBER OF COLUMNS IN CV DATA FILE.')
          return
         endif
        else ! scol.ge.1
         __WRN(whoami,'SCOL MUST BE A POSITIVE INTEGER.')
         return
        endif
       endif ! SCOL present
!
!      prepare file
       ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
       __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: flen will be UPPER CASE
!     check for column spec
       c1=sm_get_column(comlyn, comlen, qcoltag=.true., missing=-1)
       if (qroot) then
!cccccccccccccccccccccccccccc OPEN FILE ccccccccccccccccccccccc
        if (all.gt.0.or.qprint) then
#ifdef __CHARMM
         oldiol=iolev
         iolev=0 ! open file on all processors
#endif
         if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','READ') ; endif
        endif
        if(ifile .eq. -1) then
         ifile=__ISTREAM ! read from input file
#ifdef __CHARMM
         call rdtitl(titleb,ntitlb,ifile,0) ! 0 = card format
#endif
        endif
!cccccccccccccccccc assume file is open, read ccccccccccccccccccc
        if (c1.gt.0) then ! column spec
         if (qprint) then ; write(_MSGBUF,6699) whoami, c1 ; __PRINT(_MSGBUF) ; endif
 6699 format(A,' READING COORDINATES INTO COLUMN ',I3)
         if (all.gt.0) then ; call cv_common_read_local(ifile, c1) ;
         elseif (scol.ge.1) then
          call cv_common_read_local_from_global(ifile, totcol, scol, c1)
         else; call cv_common_read_global(ifile,c1) ; endif
        else
         if (qprint) then ; write(_MSGBUF,6709) whoami ; __PRINT(_MSGBUF) ; endif
 6709 format(A,' READING COORDINATES INTO DEFAULT COLUMN.')
         if (all.gt.0) then ; call cv_common_read_local(ifile) ;
         elseif (scol.ge.1) then
          call cv_common_read_local_from_global(ifile, totcol, scol)
         else ; call cv_common_read_global(ifile) ; endif
        endif
        if (all.gt.0.or.qprint) then
         if (flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
#ifdef __CHARMM
         iolev=oldiol
#endif
        endif
       endif ! qroot
!
!     broadcast to slaves
       if (c1.lt.0) c1=main ! guess what the "default column" is
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
!        call MPI_BCAST(cv%r(1,c1), cv%num_cv, mpifloat,
!     &   0, MPI_COMM_LOCAL, ierror)
        __BROADCAST_LOCAL_8B(cv%r(1,c1), cv%num_cv)
!    broadcast BC
        if (cv_common_fixed_0_bc.eq.1) then 
#ifdef __CHARMM
         __BROADCAST_LOCAL_4B(cv%r_bc_0, cv%num_cv) !##SINGLE
         __BROADCAST_LOCAL_8B(cv%r_bc_0, cv%num_cv) !##.not.SINGLE
#elif defined (__DMOL)
         __BROADCAST_LOCAL(cv%r_bc_0, cv%num_cv, mpifloat)
#endif
        endif
        if (cv_common_fixed_1_bc.eq.1) then
#ifdef __CHARMM
         __BROADCAST_LOCAL_4B(cv%r_bc_1, cv%num_cv) !##SINGLE
         __BROADCAST_LOCAL_8B(cv%r_bc_1, cv%num_cv) !##.not.SINGLE
#elif defined (__DMOL)
         __BROADCAST_LOCAL(cv%r_bc_1, cv%num_cv, mpifloat)
#endif
        endif
       endif
!    unwrap angles if present
       call cv_common_unwrap_angles(c1)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'SWAP',4)) then ! swap two columns
!       read column spec
        c1=sm_get_column(comlyn, comlen, qcoltag=.false., missing=-1)
        c2=sm_get_column(comlyn, comlen, qcoltag=.false., missing=-1)
        if (qprint) then ; write(_MSGBUF,6729) whoami, c1, c2 ; __PRINT(_MSGBUF) ; endif
 6729 format(/A,' WILL SWAP COLUMNS ',I3,' AND ',I3,' ')
        call cv_common_swap(c1,c2)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'COPY',4)) then ! copy form c1 to c2
!       read column spec
        c1=sm_get_column(comlyn, comlen, qcoltag=.false., missing=-1)
        c2=sm_get_column(comlyn, comlen, qcoltag=.false., missing=-1)
        if (qprint) then ; write(_MSGBUF,6739) whoami, c1, c2 ; __PRINT(_MSGBUF) ; endif
 6739 format(/A,' WILL COPY COLUMN ',I3,' TO ',I3,' ')
        call cv_common_copy(c1,c2)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'HIST',4)) then ! parse history commands
        keyword=__NEXTA(comlyn,comlen)
        if (__STRNCMP(keyword,'ADD',3)) then ! save current CV values to history
         if (any(__X.eq.__NAN)) then
          __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
         else
          if (qprint) then ; write(_MSGBUF,674) whoami ; __PRINT(_MSGBUF) ; endif
 674  format(A,' WILL ADD CV VALUES FROM MAIN COOR. SET INTO HISTORY.')
! last argument tells routine to add the calculated cv/derivative values to the history
          call smcv_add_hist(__X,__Y,__Z,__MASS,.true.)
         endif
        elseif (__STRNCMP(keyword,'PRIN',4)) then ! print history
!        can write both a local and a global file
!        local is specified with 'ALL'; global is the default
         all=__INDX_RM(comlyn,comlen,'ALL') ! all replicas print
!        prepare file
!-----------------------------------------------------------------------------
         ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
         __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
!     check for other spec
         nskip=__GET_RM_I(comlyn, comlen, 'SKIP',0) ! number of entries to skip
!---------------------------------- OPEN FILE --------------------------------
         if (qroot) then
#ifdef __CHARMM
          oldiol=iolev
          if (all.gt.0) iolev=0 ! trick to open file on all nodes
#endif
!
          if (flen.gt.0) then ;  __OPEN_FILE(ifile,fname,'FORMATTED','WRITE') ; endif
          if (ifile .eq. -1) ifile=__OSTREAM ! write to output stream
!---------------------------- assume file is open, write -------------------------
          if (qprint) then ; write(_MSGBUF,676) whoami, nskip ; __PRINT(_MSGBUF) ; endif
 676  format(A,' WRITING CV HISTORY. SKIPPING ',I5,' ENTRIES.')
          if (all.eq.0) then;call cv_common_print_hist_global(ifile,nskip)
          else ; call cv_common_print_hist_local(ifile,nskip) ; endif
          if (flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
#ifdef __CHARMM
          iolev=oldiol
#endif
         endif ! qroot
        elseif (__STRNCMP(keyword,'SMOO',4)) then ! smooth history
!      look for other spec.
         delta=__GET_RM_I(comlyn, comlen, 'DELT',10) ! filter width
         nskip=__GET_RM_I(comlyn, comlen, 'SKIP',0) ! number of entries to skip
!
         if (qprint) then ; write(_MSGBUF,675) whoami, delta, nskip ; __PRINT(_MSGBUF) ; endif
 675  format(A,' SMOOTHING CV HISTORY. FILTER WIDTH =',I5,'.',          &
     & / ,' SKIPPING ',I5,' ENTRIES.')
         call cv_common_smooth_hist(delta,nskip)
        elseif (__STRNCMP(keyword,'EXPO',4)) then ! CONVOLUTION W/ EXPONENTIAL
!      look for other spec.
         expo_memory=__GET_RM_F(comlyn, comlen, 'MEMO',0.999d0) ! memory in the exp. conv. kernel
         nskip=__GET_RM_I(comlyn, comlen, 'SKIP',0) ! number of entries to skip
!
         if (qprint) then ; write(_MSGBUF,701) whoami, expo_memory, nskip ; __PRINT(_MSGBUF) ; endif
 701  format(A,' EVOLVING CV: Z(N+1)=A*Z(N)+(1-A)*<THETA>, A=',F7.3,'.',&
     & / ,' SKIPPING ',I5,' ENTRIES.')
         call cv_common_evolve_expo(expo_memory,nskip)
        endif
!        done parsing 'HIST'
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'EVOL',4)) then ! evolve string using average force (SMCV)
!      look for other spec: dt and
        step=__GET_RM_F(comlyn, comlen, 'STEP',0.0d0) ! evolution step
        if (qprint) then
         if (step.eq.0.0d0) then
          __WRN(whoami,'CV EVOLUTION STEP ZERO OR UNSPECIFIED.')
         endif
         write(_MSGBUF,677) whoami, step
 677  format(A,' EVOLVING CV USING AVERAGE FORCE. STEP =',F7.3,'.')
        endif ! qprint
        call cv_common_evolve_smcv(step)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'SET',3)) then ! modify k,w,g,dt
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!      first check for global options: num_ave_samples
        if (__INDX(comlyn,comlen,'NAVE',4).gt.0) then
          num_ave_samples=__GET_RM_I(comlyn,comlen,'NAVE',-1)
          if (num_ave_samples.gt.0) then
           call cv_common_set_ave_samples(num_ave_samples)
           if (qprint) then ; write(_MSGBUF,6748) whoami, num_ave_samples ; __PRINT(_MSGBUF) ; endif
 6748 format(A,' SETTING NUMBER OF SAMPLES IN THE AVERAGE SET TO ',I7)
          else
           if (qprint) then ; write(_MSGBUF,6749) whoami, num_ave_samples; __PRINT(_MSGBUF) ; endif
 6749 format(A,' INVALID NUMBER OF SAMPLES SPECIFIED: ',I7)
          endif
        endif
!      set k parallel to path (for off-path dynamics)
        if (__INDX(comlyn,comlen,'KPAR',4).gt.0) then
          k=__GET_RM_F(comlyn,comlen,'KPAR',-1d0)
          if (k.ge.0d0) then
           call cv_common_set_kpara(k)
           if (qprint) then ; write(_MSGBUF,6756) whoami, k; __PRINT(_MSGBUF) ; endif
 6756 format(A,' SETTING PARALLEL FORCE CONSTANT TO ',F11.5)
          else
           if (qprint) then ; write(_MSGBUF,6757) whoami, k; __PRINT(_MSGBUF) ; endif
 6757 format(A,' INVALID FORCE CONSTANT SPECIFIED: ',F11.5)
          endif
        endif ! kpara
!      set k perpendicular to path (for off-path dynamics)
        if (__INDX(comlyn,comlen,'KPRP',4).gt.0) then
          k=__GET_RM_F(comlyn,comlen,'KPRP',-1d0)
          if (k.ge.0d0) then
           call cv_common_set_kperp(k)
           if (qprint) then ; write(_MSGBUF,6746) whoami, k; __PRINT(_MSGBUF) ; endif
 6746 format(A,' SETTING PERPENDICULAR FORCE CONSTANT TO ',F11.5)
          else
           if (qprint) then ; write(_MSGBUF,6747) whoami, k; __PRINT(_MSGBUF) ; endif
 6747 format(A,' INVALID FORCE CONSTANT SPECIFIED: ',F11.5)
          endif
        endif ! kperp
!
!      to set k,w,g can specify atom index, or ' ALL ' to apply to all CV
!     process CV selection
        ind=__GET_RM_I(comlyn,comlen,'IND',0)
        all=__INDX_RM(comlyn,comlen,'ALL')
        if (all.gt.0) then ! will loop over all cv
         ibeg=1
         iend=cv%num_cv
         if (qprint) then ; write(_MSGBUF,6750) whoami ; __PRINT(_MSGBUF) ; endif
 6750 format(A,' ALL CV INDICES SELECTED.')
        elseif (ind.gt.0.and.ind.le.cv%num_cv) then
         ibeg=ind
         iend=ind
         if (qprint) then ; write(_MSGBUF,6751) whoami, ind ; __PRINT(_MSGBUF) ; endif
 6751 format(A,' CV INDEX ',I5,' SELECTED.')
        else ! no indices specified
         __WRN(whoami,' INVALID CV INDEX SPECIFIED')
         ibeg=0
         iend=-1
        endif
!
        if (iend.gt.0) then ! skip this for invalid indices
         if (__INDX(comlyn,comlen,'FORC',4).gt.0) then
          k=__GET_RM_F(comlyn, comlen, 'FORC', 0.0d0)
          if (qprint) then ; write(_MSGBUF,6752) whoami, k ; __PRINT(_MSGBUF) ; endif
 6752 format(A,' WILL SET K TO ',F11.5,'.')
          do i=ibeg,iend
           call cv_common_set_k(i,k)
          enddo
         endif
!
         if (__INDX(comlyn,comlen,'GAMM',4).gt.0) then
          gam=__GET_RM_F(comlyn, comlen, 'GAMM', 1.0d0)
          if (qprint) then ; write(_MSGBUF,6753) whoami, gam ; __PRINT(_MSGBUF) ; endif
 6753 format(A,' WILL SET GAMMA TO ',F7.3,'.')
          do i=ibeg,iend
           call cv_common_set_g(i,gam)
          enddo
         endif
!
         if (__INDX(comlyn,comlen,'WEIG',4).gt.0) then ! weighting by a real
          w=__GET_RM_F(comlyn, comlen, 'WEIG', -1.0d0)
          if (qprint) then ; write(_MSGBUF,6755) whoami,w ; __PRINT(_MSGBUF) ; endif
 6755 format(A,' WILL SET WEIGHT TO ',F7.3,'.')
          do i=ibeg,iend
           call cv_common_set_w(i,w)
          enddo
         endif
!
         if (__INDX(comlyn,comlen,'ZVAL',4).gt.0) then ! weighting by a real
          zval=__GET_RM_F(comlyn, comlen, 'ZVAL', -1.0d0)
!    check replica spec
          irep=__GET_RM_I(comlyn, comlen, 'REP', -1)
          if (irep.lt.0.or.irep.ge.nstring) then
           __WRN(whoami,'REPLICA NUMBER INVALID OR UNSPECIFIED.')
          else
!    check column spec
           c1=sm_get_column(comlyn, comlen, qcoltag=.true., missing=-1)
           if (c1.gt.0) then
            if (qprint) then 
             write(_MSGBUF,6774) whoami, irep,c1, zval
             __PRINT(_MSGBUF)
            endif
 6774 format(A,' WILL SET REPLICA ',I5,' CV VALUE IN COLUMN ',          &
     &       I3, ' TO ',F7.3,'.')
            if (mestring.eq.irep) then ;do i=ibeg,iend
                                       call cv_common_set_r(i,zval,c1)
                                      enddo; endif
           else
            if (qprint) then ; write(_MSGBUF,6773) whoami, irep, zval ; __PRINT(_MSGBUF) ; endif
 6773 format(A,' WILL SET REPLICA ',I5,' CV VALUE IN DEFAULT COLUMN TO '&
     &       ,F7.3,'.')
            if (mestring.eq.irep) then ;do i=ibeg,iend
                                       call cv_common_set_r(i,zval)
                                      enddo; endif
           endif ! colspec
          endif ! irep
         endif ! zval
!
        endif ! iend.gt.0
!      done with 'SET' parsing
!cccccccccccccccccccccccccccccccccccc M matrix cccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'MMAT',4)) then
        if (__INDX_RM(comlyn, comlen, 'CALC').gt.0) then
          if (qprint) then ; write(_MSGBUF,6854) whoami ; __PRINT(_MSGBUF) ; endif
 6854 format(A,' COMPUTING INSTANTANEOUS M(X) FROM ATOMIC COORDINATES.')
          call smcv_compute_M(__X,__Y,__Z,__MASS,.true.) ! compute M and M inverse
!    print
        elseif (__INDX_RM(comlyn, comlen, 'PRIN').gt.0) then
!    if running in parallel, combine partial M entries
          if (qslave) then
!       call MPI_ALLREDUCE(cv%M(1,1,1),cv%M(1,1,2),max_cv_common*cv%num_cv, ! will broadcast all rows, but only num_cv columns
!     &          mpifloat, MPI_SUM, MPI_COMM_LOCAL, ierror)
          else ! qslave
!         cv%M(1:cv%num_cv,1:cv%num_cv,2)=cv%M(1:cv%num_cv,1:cv%num_cv,1)
          endif ! qslave
!    check for inverse spec (inverse stored in 3)
          if (__INDX_RM(comlyn, comlen, 'INV').gt.0) then
            ind=3
            keyword='INVERSE '; klen=8
            call cv_common_compute_Minv(inverse_LU)
          else
            ind=4 ! long-term average 
            keyword=' '; klen=0
          endif
!
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
          if (qroot) then
           if (flen.gt.0) then
            if (qprint) then 
#ifdef __CHARMM
             oldiol=iolev
             iolev=1
#endif
             __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
             write(_MSGBUF,6859) whoami, keyword(1:klen), fname(1:flen)
             __PRINT(_MSGBUF)
            endif
 6859 format(A,' WRITING M TENSOR (LONG-TERM AVERAGE) ',A,'TO FILE ',A,'.')
            call cv_common_print_M_global(ifile, IND=ind)
            if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
             iolev=oldiol
#endif
            endif
           else
            __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
           endif ! flen
          endif ! qroot
!    read cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        elseif (__INDX_RM(comlyn, comlen, 'READ').gt.0) then
!    check for inverse spec (inverse stored in 3)
          if (__INDX_RM(comlyn, comlen, 'INV').gt.0) then
            ind=3
            keyword='INVERSE '; klen=8
          else
            ind=4 ! long-term average
            keyword=' '; klen=0
          endif
!
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
          if (flen.gt.0) then
            if (qprint) then 
#ifdef __CHARMM
             oldiol=iolev
             iolev=1
#endif
             __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
             write(_MSGBUF,6858) whoami, keyword(1:klen), fname(1:flen)
             __PRINT(_MSGBUF)
            endif
 6858 format(A,' READING M TENSOR (LONG- & SHORT-TERM AVERAGE) ',A,'FROM FILE ',A,'.')
            call cv_common_read_M_global(ifile, ind)
            if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
             iolev=oldiol
#endif
            endif
          else
            __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
          endif ! flen
!    change calculation algorithm ccccccccccccccccccccccccccccccccccccc
        elseif (__INDX_RM(comlyn, comlen, 'FAST').gt.0) then
          keyword=__NEXTA(comlyn, comlen)
          select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_Mtensor_fast=.true.
            if (qprint) then ; write(_MSGBUF,7014) whoami, keyword ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_Mtensor_fast=.false.
            if (qprint) then ; write(_MSGBUF,7014) whoami, keyword ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED FOR "FAST"')
          end select
 7014 format(/A,' SPARSE MATRIX ROUTINE FOR M TENSOR COMPUTATION ',A)
        endif
!cccccccccccccccccccccccccccccccccccc CV WEIGHTS cccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'WEIG',4)) then
        if (__INDX_RM(comlyn, comlen, 'CALC').gt.0) then
          if (qprint) then ; write(_MSGBUF,6754) whoami ; __PRINT(_MSGBUF) ; endif
 6754 format(A,' COMPUTING CV WEIGHTS FROM METRIC TENSOR M(X).')
          call smcv_compute_wgt(__X,__Y,__Z,__MASS)
!    print
        elseif (__INDX_RM(comlyn, comlen, 'PRIN').gt.0) then
!    process output options
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
          if (qprint) then
            if (flen.gt.0) then
             write(_MSGBUF,6759) whoami, fname(1:flen) ; __PRINT(_MSGBUF)
 6759 format(A,' WRITING CV WEIGHTS TO FILE ',A,'.')
#ifdef __CHARMM
             oldiol=iolev
             iolev=1
#endif
             __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
            else
             if (ifile .eq. -1) ifile=__OSTREAM ! write to output stream
             write(_MSGBUF,6758) whoami, ifile; __PRINT(_MSGBUF)
 6758 format(A,' WRITING CV WEIGHTS TO UNIT ',I5)
            endif
            call cv_common_print_wgt(ifile) ! only root node writes
            if (flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
             iolev=oldiol
#endif
            endif
          endif ! qprint
!    read
        elseif (__INDX_RM(comlyn, comlen, 'READ').gt.0) then
!    prepare file
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!    note: flen will be UPPER CASE
          if (qprint) then
           if (flen.gt.0) then 
            write(_MSGBUF,6761) whoami, fname(1:flen) ; __PRINT(_MSGBUF)
 6761 format(A,' READING CV WEIGHTS FROM FILE ',A,'.')
#ifdef __CHARMM
            oldiol=iolev
            iolev=1
#endif
            __OPEN_FILE(ifile,fname,'FORMATTED','READ')
           else
            if (ifile .eq. -1) ifile=__ISTREAM ! read from input
            write(_MSGBUF,6760) whoami, ifile ; __PRINT(_MSGBUF)
 6760 format(A,' READING CV WEIGHTS FROM UNIT ',I5)
#ifdef __CHARMM
             if (ifile.eq.__ISTREAM) call rdtitl(titleb,ntitlb,ifile,0) ! 0 = card format
#endif
           endif ! flen
          endif ! qprint
          call cv_common_read_wgt(ifile) ! root and slave nodes enter
          if (qprint.and.flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
           iolev=oldiol
#endif
          endif
        endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'KPAR',4)) then
       if (__INDX(comlyn,comlen,'SET',3).gt.0) then
         k=__GET_RM_F(comlyn,comlen,'SET',-1d0)
         if (k.ge.0d0) then
          call cv_common_set_kpara(k)
          if (qprint) then ; write(_MSGBUF,6763) whoami, k ; __PRINT(_MSGBUF) ; endif
 6763 format(A,' SETTING PARALLEL FORCE CONSTANT TO ',F11.5)
         else
          if (qprint) then ; write(_MSGBUF,6764) whoami, k ; __PRINT(_MSGBUF) ; endif
 6764 format(A,' INVALID FORCE CONSTANT SPECIFIED: ',F11.5)
         endif
       endif ! set
!
       if (__INDX_RM(comlyn, comlen, 'CALC').gt.0) then
        if (qprint) then ; write(_MSGBUF, 6765) whoami, whoami, whoami ; __PRINT(_MSGBUF) ; endif
 6765 format(/A, ' COMPUTING FORCE CONSTANTS FOR RESTRAINED ',/,        &
     &        A, ' DYNAMICS BY SCALING KPAR WITH CV WEIGHTS.',/,        &
     &        A, ' OVERWRITING PREVIOUSLY DEFINED FORCE CONSTANTS.')
        call cv_common_compute_k()
       endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'TANV',4)) then ! print/read/compute tangent to path
       if (__INDX_RM(comlyn, comlen, 'CALC').gt.0) then ! calculate
        if (qprint) then ; write(_MSGBUF,6766) whoami ; __PRINT(_MSGBUF) ; endif
 6766 format(/A,' WILL COMPUTE TANGENT TO PATH.')
        call cv_common_compute_dr()
!
       elseif (__INDX_RM(comlyn, comlen, 'READ').gt.0) then ! read from file
!      prepare file
        ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
        __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: flen will be UPPER CASE
!cccccccccccccccccccccccccccc OPEN FILE ccccccccccccccccccccccc
        if (qprint) then
         if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','READ') ;
#ifdef __CHARMM
          oldiol=iolev
          iolev=1
#endif
         endif
         if(ifile .eq. -1) then
          ifile=__ISTREAM ! read from input file
#ifdef __CHARMM
          call rdtitl(titleb,ntitlb,ifile,0) ! 0 = card format
#endif
         endif ! ifile
!cccccccccccccccccc assume file is open, read ccccccccccccccccccc
         write(_MSGBUF,6767) whoami
 6767 format(A,' READING VECTORS TANGENT TO PATH.')
        endif ! qprint
!
        call cv_common_read_dr(ifile) ! roots and slaves
!
        if (qprint.and.flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ;
#ifdef __CHARMM
         iolev=oldiol
#endif
        endif
!
       elseif (__INDX_RM(comlyn, comlen, 'PRIN').gt.0) then ! print to file
!      prepare file
        ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
        __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
        if (qprint) then
!---------------------------------- OPEN FILE --------------------------------
         if (flen.gt.0) then ; __OPEN_FILE(ifile,fname,'FORMATTED','WRITE') 
#ifdef __CHARMM
          oldiol=iolev
          iolev=1
#endif
         endif
         if (ifile .eq. -1) ifile=__OSTREAM ! write to output stream
!---------------------------- assume file is open, write -------------------------
         write(_MSGBUF,6768) whoami ; __PRINT(_MSGBUF)
 6768 format(/A,' WRITING VECTORS TANGENT TO PATH.')
        endif ! qprint
        if (qroot) call cv_common_print_dr(ifile)
        if (qprint.and.flen.gt.0) then ; __CLOSE_FILE(ifile,'KEEP',ierror) 
#ifdef __CHARMM
         iolev=oldiol
#endif
        endif
       endif ! TANV
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'LIST',4)) then ! list CV
       if (qprint) then ; write(_MSGBUF,6762) whoami ; __PRINT(_MSGBUF) ; endif
 6762 format(/A,' WILL LIST CV.')
       call smcv_list() ! this routine deals with the various CV
!       write(0,*) 'ME_LOCAL: ',ME_LOCAL, 'SIZE_LOCAL:', SIZE_LOCAL
!       write(600+ME_LOCAL, *) cv%r(1:cv%num_cv,1:main_offset)
!       close(600+ME_LOCAL)
!       write(700+ME_LOCAL, *) frames%r(3,3,1:frames%num_frames)
!       close(700+ME_LOCAL)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! CV interpolation
      elseif (__STRNCMP(keyword,'INTE',4)) then
! note: this is done serially
! get specifications
#ifdef __CHARMM
        if (qprint) then ; oldiol=iolev ; iolev=1 ; endif
#endif
!ccccccccccccc should the new cv file be interpolated from the CV old file?
        interp_cv=(__INDX_RM(comlyn,comlen,'INTERPCV').gt.0)
        if (qprint) then
         if (interp_cv) then
          write(_MSGBUF, 6801) whoami
         else
          write(_MSGBUF, 6802) whoami
         endif
         __PRINT(_MSGBUF)
        endif
!
 6801 format(A,' WILL OBTAIN NEW CV VALUES BY INTERPOLATION.')
 6802 format(A,' NEW CV VALUES WILL BE READ FROM FILE.')
! interpolation type
        if (interp_cv) then
         int_method=0
         method=__GET_RM_AFUN(comlyn, comlen, 'METH')
         length=len(method)
         __TRIMA(method, length)
         if (length.ge.4) then
           if (__STRNCMP(method,'LINE',4)) then
             int_method=linear
           elseif (__STRNCMP(method,'BSPL',4)) then
             int_method=bspline
           elseif (__STRNCMP(method,'SPLI',4)) then
             int_method=spline
           elseif (__STRNCMP(method,'LIN2',4)) then
             int_method=linear_exact
           endif
         endif
!     print summary
         if (qprint) then
           if (int_method.gt.0) then
             length=len(methods(int_method))
             __TRIMA(methods(int_method),length)
             write(_MSGBUF,6770) whoami, methods(int_method)(1:length)
 6770  format(/A,' WILL INTERPOLATE CV USING ',A,' INTERPOLATION')
           else
             if (length.gt.0) then
               write(_MSGBUF,6771) whoami, method(1:length), whoami
 6771 format(/A,' UNRECOGNIZED INTERPOLATION METHOD: ',A,'.',/,         &
     &       A, ' WILL INTERPOLATE CV USING LINEAR INTERPOLATION')
             else
              write(_MSGBUF,6772) whoami, whoami
 6772 format(/A,' UNSPECIFIED INTERPOLATION METHOD.',/,                 &
     &       A, ' WILL INTERPOLATE CV USING LINEAR INTERPOLATION')
             endif ! length
             __PRINT(_MSGBUF)
           endif ! int_method
         endif ! prnlev
         if (int_method.eq.0) int_method=linear ! choose linear interpolation as default
        endif ! interp_cv
! process other options ccccccccccccccccccccccccccccccccccccccccccccccc
!
        if (__INDX(comlyn,comlen,'NIN',3).gt.0) then
          num_rep_in=__GET_RM_I(comlyn, comlen, 'NIN', 0)
          if (num_rep_in.le.0) then
            if (qprint) then ; write(_MSGBUF, 6781) whoami ; __PRINT(_MSGBUF) ; endif
 6781 format(A,' NUMBER OF INPUT REPLICAS MUST BE > 0. ',/,             &
     & ' NOTHING DONE.')
#ifdef __CHARMM
            iolev=oldiol
#endif
            return
          else
            __GET_RM_A(comlyn, comlen, 'CVIN', 4, name_cv_in, 80, len_cv_in)
            if (len_cv_in.le.0) then
              if (qprint) then ; write(_MSGBUF, 6782) whoami ; __PRINT(_MSGBUF) ; endif
 6782 format(A,' INPUT CV FILE NAME UNSPECIFIED.',/,                    &
     & ' NOTHING DONE.')
#ifdef __CHARMM
              iolev=oldiol
#endif
              return
            else
              if (qprint) then ; write(_MSGBUF,6783)                    &
     &          whoami, num_rep_in, whoami, name_cv_in(1:len_cv_in) ; __PRINT(_MSGBUF) ; endif
 6783 format(A,' INITIAL STRING RESOLUTION: ', I5, ' REPLICAS.',/,      &
     &       A,' INPUT CV FILE IS ', A)
            endif ! len_cv_in<=0
          endif ! num_rep_in<=0
        else
          if (qprint) then ; write(_MSGBUF, 6784) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 6784 format(A,' NUMBER OF INPUT REPLICAS UNSPECIFIED',/,               &
     & A,' NOTHING DONE.')
#ifdef __CHARMM
          iolev=oldiol
#endif
          return
        endif ! indx('NIN')
!cccccccccccccccccccccccccccccccccccccccccccccccccccc
!  process output CV specification
        if (__INDX(comlyn,comlen,'NOUT',4).gt.0) then
          num_rep_out=__GET_RM_I(comlyn, comlen, 'NOUT', 0)
          if (num_rep_out.le.0) then
            if (qprint) then ; write(_MSGBUF, 6785) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 6785 format(A,' NUMBER OF OUTPUT REPLICAS MUST BE > 0. ',/,A,          &
     & ' NOTHING DONE.')
#ifdef __CHARMM
            iolev=oldiol
#endif
            return
          else
            __GET_RM_A(comlyn, comlen, 'CVOUT', 5, name_cv_out, 80, len_cv_out)
            if (len_cv_out.le.0) then
              if (qprint) then ; write(_MSGBUF, 6786) whoami, whoami ; __PRINT(_MSGBUF) ; endif 
 6786 format(A,' OUTPUT CV FILE NAME UNSPECIFIED.',/,A,                 &
     & ' NOTHING DONE.')
#ifdef __CHARMM
              iolev=oldiol
#endif
              return
            else
              if (qprint) then 
               write(_MSGBUF,6787) whoami, num_rep_out, whoami, name_cv_out(1:len_cv_out)
               __PRINT(_MSGBUF)
              endif
 6787 format(A,' OUTPUT STRING RESOLUTION: ', I5, ' REPLICAS.',/,       &
     &       A,' OUPUT CV FILE IS ', A)
            endif ! len_cv_out
          endif ! num_rep_out
        else ! num_rep_out
          if (qprint) then ; write(_MSGBUF, 6788) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 6788 format(A,' NUMBER OF OUTPUT REPLICAS UNSPECIFIED',/,              &
     & A,' NOTHING DONE.')
#ifdef __CHARMM
          iolev=oldiol
#endif
          return
        endif ! indx('NOUT')
!ccccccccccccc coordinate file specification
        inte_get_coor=(__INDX_RM(comlyn,comlen,'COOR').gt.0)
        if (inte_get_coor) then ! look for input and output coordinate files
          if (qprint) then ; write(_MSGBUF,6800) whoami ; __PRINT(_MSGBUF) ; endif
 6800 format(A,' WILL GENERATE REPLICA COORDINATE SETS.')
          inte_get_coor=.true.
! will also interpolate coordinates
          __GET_RM_A(comlyn, comlen, 'CRIN', 4, name_cor_in, 80, len_cor_in) ! text file which contains a list of file names (6/20/2011)
          if (len_cor_in.le.0) then
            if (qprint) then ; write(_MSGBUF, 6789) whoami ; __PRINT(_MSGBUF) ; endif
 6789 format(A,' INPUT COORDINATES FILE NAME UNSPECIFIED.',/,           &
     & '  NOTHING DONE.')
#ifdef __CHARMM
            iolev=oldiol
#endif
            return
          endif
!
          __GET_RM_A(comlyn, comlen, 'CROUT', 5, name_cor_out, 80, len_cor_out)
          if (len_cor_out.le.0) then
            if (qprint) then ; write(_MSGBUF, 6790) whoami ; __PRINT(_MSGBUF) ; endif
 6790 format(A,' OUTPUT COORDINATES FILE NAME UNSPECIFIED.',/,          &
     & ' NOTHING DONE.')
#ifdef __CHARMM
            iolev=oldiol
#endif
            return
          endif ! len_cor_out
!        parse file format spec. (same for both input/output)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#ifdef __CHARMM
          lresid=.false.
#endif
          if (__INDX_RM(comlyn,comlen,'PDB').gt.0) then
#ifdef __CHARMM
            moder=-1
            modew=4
            if (__INDX_RM(comlyn,comlen,'RESI').gt.0) lresid=.true.
#elif defined(__DMOL)
            ifmt=pdb
#endif
            form='FORMATTED'
#ifdef __CHARMM
          elseif ( (__INDX_RM(comlyn,comlen,'FILE').gt.0).or.               &
     &  (__INDX_RM(comlyn,comlen,'UNFO').gt.0)) then
            moder=0
            modew=1
            form='UNFORMATTED'
#endif
          elseif ( (__INDX_RM(comlyn,comlen,'CARD').gt.0).or.               &
     &  (__INDX_RM(comlyn,comlen,'FORM').gt.0)) then
#ifdef __CHARMM
            moder=1
            modew=2
#elif defined(__DMOL)
            ifmt=charmm
#endif
            form='FORMATTED'
          else ! default
#ifdef __CHARMM
            moder=1
            modew=2
#elif defined(__DMOL)
            ifmt=charmm
#endif
            form='FORMATTED'
          endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!       write summary
          if (qprint) then ! note: using qprint as a root node flag, too (should change this)
!ccccc   get coordinate file names
           ifile=-1 ! a valid unit number will be assigned by __OPEN_FILE
           ofile=-1
           __OPEN_FILE(ifile,name_cor_in(1:len_cor_in),'FORMATTED','READ')
           allocate(fname_cor_in(num_rep_in))
!
           do j=1, num_rep_in
            read(ifile,*) fname_cor_in(j)
           enddo
           __CLOSE_FILE(ifile,'KEEP',ierror)
!
           write(_MSGBUF,6791) whoami ; __PRINT(_MSGBUF)
 6791 format(A,' COORDINATE SETS WILL BE READ FROM',                    &
     & ' THE FOLLOWING FILES:' )
!
           do j=1, num_rep_in
            write(_MSGBUF,'(A1,I5," ",A80)') char(9), j, fname_cor_in(j) ; __PRINT(_MSGBUF)
           enddo
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
           __OPEN_FILE(ofile,name_cor_out(1:len_cor_out),'FORMATTED','READ')
!
           allocate(fname_cor_out(num_rep_out))
!
           do j=1, num_rep_out
            read(ifile,'(A80)') fname_cor_out(j)
           enddo
           __CLOSE_FILE(ofile,'KEEP',ierror)
!
           write(_MSGBUF,6793) whoami ; __PRINT(_MSGBUF)
 6793 format(A,' COORDINATE SETS WILL BE WRITTEN TO THE FOLLOWING FILES:' )
!
           do j=1, num_rep_out
            write(_MSGBUF,'(A1,I5," ",A80)') char(9), j, fname_cor_out(j) ; __PRINT(_MSGBUF)
           enddo
!
          endif ! qprint
        endif ! 'COOR'
!
        if (.not.(interp_cv.or.inte_get_coor)) then ! nothing to do
         write(_MSGBUF,'(A," NOTHING TO DO")') whoami
         __PRINT(_MSGBUF)
#ifdef __CHARMM
         iolev=oldiol
#endif
         return
        endif
!ccccccccccccccccccccccccc do work
! interpolate CV first
! compute cv weights, if needed
        if (.not.cv_common_weights_initialized) then
         __WRN( whoami,'CV WEIGHTS NOT INITIALIZED. WILL COMPUTE FROM M(X)')
         call smcv_compute_wgt(__X,__Y,__Z,__MASS)
        endif
!
        if (interp_cv) then
         if (qprint) then ! only the head node does this
!    open CV files
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     now prepare cv units and call interpolation routine
          ifile=-1 ! a valid unit number will be assigned by __OPEN_FILE
          ofile=-1
          __OPEN_FILE(ifile,name_cv_in,'FORMATTED','READ')
          __OPEN_FILE(ofile,name_cv_out,'FORMATTED','WRITE')
!
          call cv_common_interpolate(ifile, ofile, num_rep_in, num_rep_out,&
     &                           int_method)
!
          __CLOSE_FILE(ifile,'KEEP',ierror)
          __CLOSE_FILE(ofile,'KEEP',ierror)
         endif ! qprint
        endif ! interp_cv
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! process coordinate files, if requested
! this code is fairly slow; things are complicated by providing compatibility with frames, which means that
! every distance computation, essentially, required an 'optimal' rearrengement of frame vectors
! this is provided by routine `frame_align_rmsd`
        if (inte_get_coor) then
!   rmsd array
         if (allocated(inte_rmsd)) deallocate(inte_rmsd)
         allocate(inte_rmsd(num_rep_out,num_rep_in))
!   cv array
         if (allocated(rtemp)) deallocate(rtemp)
         allocate(rtemp(max_cv_common,num_rep_out))
!
!        (re-)load new cv file and store cv in rtemp
         do j=1, num_rep_out
           if (qprint) then
            __OPEN_FILE(ifile,name_cv_out,'FORMATTED','READ')
           endif
           call cv_common_read_local_from_global(ifile, num_rep_out,      &
     &      j, comp) ! this needs to be run in parallel
           rtemp(:,j)=cv%r(:,comp)
         enddo
!
         if (qprint) then ; write(_MSGBUF,6974) whoami ; __PRINT(_MSGBUF) ; endif
 6974 format(A,' READING COORDINATE FILES')
!
#ifdef __CHARMM
         islct=1.
#endif
         do j=1, num_rep_in
!     open file
            length=len_trim(fname_cor_in(j))
            dummy=fname_cor_in(j)(1:length)
!
            if (qroot) then ; __OPEN_FILE(ifile,dummy,form,'READ') ; endif
            dummy=''
            if (mestring.eq.0) then ! need a whole group to read correctly
#ifdef __CHARMM
             call cread(ifile, titleb, ntitlb, icntrl, xcomp, ycomp,    &
     &         zcomp, wcomp, natom, moder, islct,     &
     &         0, res, nres, atype, ibase, 1, ifreea,              &
     &         segid, resid, nictot, nseg, lresid, .false.,             &
     &         dummy, 80, 0, .false.)
#elif defined(__DMOL)
             select case(ifmt)
              case(charmm) ; call ch_coor_read(ifile, rcomp)
              case(pdb)    ; call pdb_read(ifile, rcomp)
             end select
#endif
             if (qroot) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
!    compute "distance" to cv values
             do i=1, num_rep_out
              cv%r(:,main)=rtemp(:,i) ! CV into main set
              if (frames_initialized)                                   &
     &         call frame_align_rmsd(__XCOMP, __YCOMP, __ZCOMP, __MASS) ! calculate optimal frame axes in the sense of minimal rmsd
!         compute the instantaneous CV realizations
              call smcv_fill(__XCOMP, __YCOMP, __ZCOMP, __MASS, comp) ! works in series or parallel
!         compute RMSD:
              inte_rmsd(i,j)=cv_common_rmsd(comp,main)
             enddo
            endif ! mestring
!           write(600,*) inte_rmsd(:,j)
         enddo ! j=1,num_rep_in
!
!         reload new cv file
         do j=1, num_rep_out
           which=minloc(inte_rmsd(j,:)) ! which index corresponds to the smallest rmsd (ds)
!        open the corresponding file and save under new file name
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     open file
           length=len_trim(fname_cor_in(which(1)))
           dummy=fname_cor_in(which(1))(1:length)
!
           if (mestring.eq.0) then
            if (qroot) then ; __OPEN_FILE(ifile,dummy,form,'READ') ; endif
#ifdef __CHARMM
            dummy=''
            call cread(ifile, titleb, ntitlb, icntrl, xcomp, ycomp,     &
     &         zcomp, wcomp, natom, moder, islct,     &
     &         0, res, nres, atype, ibase, 1, ifreea,              &
     &         segid, resid, nictot, nseg, lresid, .false.,             &
     &         dummy, 80, 0, .false.)
            if (ntitla+1 .lt. maxtit)                                   &
     &       write(titlea(ntitla+1),'(A,I5,A,I5)')                      &
     &       '* REPLICA ',j,' OF ',num_rep_out
#elif defined(__DMOL)
            select case(ifmt)
             case(charmm) ; call ch_coor_read(ifile, rcomp)
             case(pdb)    ; call pdb_read(ifile, rcomp)
            end select
#endif
            if (qroot) then ; __CLOSE_FILE(ifile, 'KEEP',ierror) ; endif
!cccccccccccc now write the same file cccccccccccccccccccccccc
!     open file
            length=len_trim(fname_cor_out(j))
            dummy=fname_cor_out(j)(1:length)
!
            if (qroot) then ; __OPEN_FILE(ofile,dummy,form,'WRITE') ; endif
!
#ifdef __CHARMM
            call CWRITE(ofile,TITLEA,min(NTITLA+1,maxtit),ICNTRL,       &
     &              xcomp,ycomp,zcomp,wcomp,res,atype,ibase,            &
     &               NRES,NATOM,islct,modew,0,0,.false.)
#elif defined (__DMOL)
            select case(ifmt)
             case(charmm) ; ok=ch_coor_write(ofile, rcomp, bfactor)
             case(pdb)    ; ok=pdb_write(ofile, rcomp, occupancy, bfactor)
            end select
#endif
            if (qroot) then ; __CLOSE_FILE(ofile, 'KEEP', ierror) ; endif
!
           endif ! mestring
         enddo ! loop over new coordinate sets
         __DEALL(fname_cor_in)
         __DEALL(fname_cor_out)
        endif ! inte_get_coor
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#ifdef __CHARMM
        iolev=oldiol
#endif
      else
            __WARN(whoami,'UNRECOGNIZED SUBCOMMAND: ',keyword)
      endif
      end subroutine smcv
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_init(maxcv)
      use sm_var
      use sm_config
      use cv_common, only: cv_common_initialized, cv_common_init, main,       &
     &  comp, zcur, instant, runave, forces2, max_cv_common
!      , only:smcv_initialized, nstring, mestring,
!     &   cv_send_displ,cv_send_count
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI
      __DEP_NUMBER
!
      __IMPNONE
!
   __DECLARE_MSGBUF
!
#include "mpitype.def"
!
      int4mpi :: ierror
      bool :: qroot, qslave
      int4mpi :: temp1(3), temp2(3) ! for communication
      int, optional :: maxcv
!
      integer(kind=MPI_ADDRESS_KIND) :: lb, extent
!
      __IAM(SMCV_INIT)
!
!      do a basic communicator check:
      if (ME_LOCAL.eq.0.and.ME_STRNG.eq.MPI_UNDEFINED) then
        write(_MSGBUF, 111) whoami, ME_GLOBAL, whoami
 111  FORMAT(A, ' WORLD REPLICA ',I5, ' HAS ZERO GROUP ID',             &
     & /,A,' BUT INVALID STRING ID (MAY BE OK).')
        __PRINT(_MSGBUF)
      elseif (ME_STRNG.ne.MPI_UNDEFINED.and.                            &
     &  (ME_LOCAL.ne.0.or.MPI_COMM_LOCAL.eq.MPI_COMM_NULL)) then
        write(_MSGBUF, 112) whoami, ME_GLOBAL, whoami
 112  FORMAT(A, ' WORLD REPLICA ',I5, ' HAS A VALID STRING ID',         &
     & /,A,' BUT A NONZERO GROUP ID. ABORTING.')
        __PRINT(_MSGBUF)
       return
      endif
!
      qroot=ME_STRNG.ne.MPI_UNDEFINED
      qslave=ME_LOCAL.ne.MPI_UNDEFINED ! (also includes roots)
!
      if (smcv_initialized) then
       if (qroot) then
        if (ME_STRNG.eq.0) then
          write(_MSGBUF,'(2A)')                                            &
     &    whoami, ' SMCV ALREADY INITIALIZED. CALL "DONE" TO CLEAN UP.'
          __PRINT(_MSGBUF)
        endif ! ME_STRNG
       endif ! qroot
       return
      endif
!
      nstring=1 ! safe (hopefully) default
      mestring=-1 ! safe (hopefully) default
!
      if (qroot) then
        nstring=SIZE_STRNG
        mestring=ME_STRNG
      endif
!      broadcast string size to all slave nodes
#ifdef __CHARMM
      __BROADCAST_LOCAL_4B(nstring,  1)      !##.not.INTEGER8
      __BROADCAST_LOCAL_4B(mestring, 1)      !##.not.INTEGER8
      __BROADCAST_LOCAL_8B(nstring,  1)      !##INTEGER8
      __BROADCAST_LOCAL_8B(mestring, 1)      !##INTEGER8
!      set envorinment variables
      call setmsi('NSTRING',nstring)
      call setmsi('MESTRING',mestring)
#else
      __BROADCAST_LOCAL(nstring,  1, mpiint)
      __BROADCAST_LOCAL(mestring, 1, mpiint)
#endif
!
      if (qroot) then
        if (ME_STRNG.eq.0) then
          write(_MSGBUF,'(2A,I5, A)')                                      &
     &    whoami, ' FOUND ',nstring,' REPLICAS.'
          __PRINT(_MSGBUF)
        endif
      endif
!
      smcv_initialized=.true.
!
      if (.not.cv_common_initialized) then 
       if (present(maxcv)) then
        if (maxcv.gt.0) then
         if (qroot.and.ME_STRNG.eq.0) then
          write(_MSGBUF,'(2A,I5, A)') &
     &     whoami, ' WILL INITIALIZE SMCV WITH STORAGE FOR AT MOST ',maxcv,' CV.' 
          __PRINT(_MSGBUF)
         endif ! root prints
         call cv_common_init(maxcv)
        else
         __WRN(whoami, 'NEGATIVE NUMBER OF CV REQUESTED, USING PREVIOUS VALUE (OR DEFAULTS).')
         call cv_common_init() ! default
        endif
       else ! present maxcv
        call cv_common_init() ! default
       endif
      endif
!    allocate index arrays for cv index limits (parallelization)
      allocate(cv_send_displ(SIZE_LOCAL),                               & ! cv
     &         cv_send_count(SIZE_LOCAL))
      allocate(fr_send_displ(SIZE_LOCAL),                               & ! frames
     &         fr_send_count(SIZE_LOCAL))
      allocate(qt_send_displ(SIZE_LOCAL),                               & ! quat
     &         qt_send_count(SIZE_LOCAL))
      allocate(imap_displ(SIZE_LOCAL),                                  & ! imap
     &         imap_count(SIZE_LOCAL))
!    initialize
      cv_send_displ=0
      cv_send_count=0
      fr_send_displ=0
      fr_send_count=0
      qt_send_displ=0
      qt_send_count=0
      imap_displ=0
      imap_count=0
!
!     define/update derived MPI types:
!     these special types are for communicating CV;
!     I chose to index cv%r in a way that is not really
!     suitable for communication/parallelization, hence the special
!     types with custom blocks/strides/extents
!ccccccccccccccccc two cv values (main+comp) ccccccccccccccccc
!
!       call mpi_type_indexed(2,(/1,1/),
!     &  (/max_cv_common*(main-1),
!     &    max_cv_common*(comp-1)/),
!     &  mpifloat, MPI_CV_TYPE2_, ierror)

      temp1=(/ione,ione,izero/)
      temp2=(/max_cv_common*(main-1),                                     &
     &    max_cv_common*(comp-1),izero/)
      call mpi_type_indexed(2, temp1, temp2,                            &
     &  mpifloat, MPI_CV_TYPE2_, ierror)

! corresponding resized type (modified extent)
      lb=0
      extent=sizeofreal
      call mpi_type_create_resized(MPI_CV_TYPE2_,lb,extent,             &
     &  MPI_CV_TYPE2, ierror)
      call mpi_type_commit(MPI_CV_TYPE2, ierror)
!ccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccc three cv values cccccccccccccc
!       call mpi_type_indexed(3,(/1,1,1/),
!     &  (/max_cv_common*(zcur-1),
!     &    max_cv_common*(instant-1),
!     &    max_cv_common*(forces2-1)/), ! strides: i.e. take 1 element from zcur, 1 from inst., 1 from forces2
!     &  mpifloat, MPI_CV_TYPE3_, ierror)

      temp1=(/1,1,1/)
      temp2=(/max_cv_common*(zcur-1),                                     &
     &        max_cv_common*(instant-1),                                  &
     &        max_cv_common*(forces2-1)/)
      call mpi_type_indexed(3, temp1, temp2,                            &
     &  mpifloat, MPI_CV_TYPE3_, ierror)

!        write(0,*) temp2 !aa
!          stop

! corresponding resized type
      lb=0
      extent=sizeofreal
      call mpi_type_create_resized(MPI_CV_TYPE3_,lb,extent,             &
     &  MPI_CV_TYPE3, ierror)
      call mpi_type_commit(MPI_CV_TYPE3, ierror)
!ccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccc three cv values (different from above) cccccccccccccc
!       call mpi_type_indexed(3,(/1,1,1/),
!     &  (/max_cv_common*(runave-1),
!     &    max_cv_common*(instant-1),
!     &    max_cv_common*(forces2-1)/),
!     &  mpifloat, MPI_CV_TYPE3I_, ierror)

      temp1=(/1,1,1/)
      temp2=(/max_cv_common*(runave-1),                                   &
     &        max_cv_common*(instant-1),                                  &
     &        max_cv_common*(forces2-1)/)
      call mpi_type_indexed(3, temp1, temp2,                            &
     &  mpifloat, MPI_CV_TYPE3I_, ierror)

! corresponding resized type (note change of extent)
      lb=0
      extent=sizeofreal
      call mpi_type_create_resized(MPI_CV_TYPE3I_,lb,extent,            &
     &  MPI_CV_TYPE3I, ierror)
      call mpi_type_commit(MPI_CV_TYPE3I, ierror)
!
      MPI_GRAD_TYPE =MPI_DATATYPE_NULL
      MPI_GRAD_TYPE_=MPI_DATATYPE_NULL
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccc
      end subroutine smcv_init
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_done()
      use cv_common, only: cv_common_done
      use sm_var,only: smcv_initialized, nstring, mestring
      use sm_config,only:  cv_send_displ, cv_send_count,                &
     &                     fr_send_displ,fr_send_count,                 &
     &                     imap_displ,imap_count,                       &
     &                     qt_send_displ,qt_send_count,                 &
     &  MPI_CV_TYPE2, MPI_CV_TYPE2_,                                    &
     &  MPI_CV_TYPE3, MPI_CV_TYPE3_,                                    &
     &  MPI_CV_TYPE3I, MPI_CV_TYPE3I_,                                  &
     &  MPI_GRAD_TYPE, MPI_GRAD_TYPE_
!
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
!
      __IMPNONE
!
 __DECLARE_MSGBUF
!
      int4mpi :: ierror
!
      __IAM(SMCV_DONE)
!
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0) then
        write(_MSGBUF,'(2A,I5, A)') whoami, ' CLEANING UP.' ; __PRINT(_MSGBUF)
      endif
!
      call cv_common_done()
      nstring=-1
      mestring=-1
!
#ifdef __CHARMM
!      set envorinment variable
      call setmsi('NSTRING',nstring)
      call setmsi('MESTRING',mestring)
#endif
!
!    deallocate index arrays for cv index limits (parallelization)
      if (smcv_initialized) then
       deallocate(cv_send_displ,cv_send_count,                          &
     &           fr_send_displ,fr_send_count,                           &
     &           imap_displ,imap_count,                                 &
     &           qt_send_displ,qt_send_count)
!    free MPI_TYPES
       if (MPI_CV_TYPE2.ne.MPI_DATATYPE_NULL)                           &
     &  call mpi_type_free(MPI_CV_TYPE2,ierror);
       if (MPI_CV_TYPE2_.ne.MPI_DATATYPE_NULL)                          &
     &  call mpi_type_free(MPI_CV_TYPE2_,ierror);
!
       if (MPI_CV_TYPE3.ne.MPI_DATATYPE_NULL)                           &
     &  call mpi_type_free(MPI_CV_TYPE3,ierror);
       if (MPI_CV_TYPE3_.ne.MPI_DATATYPE_NULL)                          &
     &  call mpi_type_free(MPI_CV_TYPE3_,ierror);
!
       if (MPI_CV_TYPE3I.ne.MPI_DATATYPE_NULL)                          &
     &  call mpi_type_free(MPI_CV_TYPE3I,ierror);
       if (MPI_CV_TYPE3I_.ne.MPI_DATATYPE_NULL)                         &
     &  call mpi_type_free(MPI_CV_TYPE3I_,ierror);
!
       if (MPI_GRAD_TYPE.ne.MPI_DATATYPE_NULL)                          &
     &  call mpi_type_free(MPI_GRAD_TYPE,ierror);
       if (MPI_GRAD_TYPE_.ne.MPI_DATATYPE_NULL)                         &
     &  call mpi_type_free(MPI_GRAD_TYPE_,ierror);
      endif
!
!  what else ?
!
      smcv_initialized=.false.
!
      end subroutine smcv_done
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_repa_init(COMLYN, COMLEN)
!     initialize string reparametrization
!
      use sm_var
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      __IMPNONE
!
      character(len=*) :: comlyn
      int :: comlen
!
      character(len=20) :: methods(5)
      data methods/ 'LINEAR','CUBIC SPLINE','B-SPLINE','DST','LINEAR_EXACT'/
!     selection array
      int :: qlinear, qspline, qbspline, qdst, qlinear_exact
      int :: mlen
!
!     declare functions here
!
      bool :: qroot, qprint
!
 __DECLARE_MSGBUF
!
      __IAM(SMCV_REPA_INIT)
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qprint=qroot.and.ME_STRNG.eq.0
!     begin
!     reset variables
      qspline=0
      qbspline=0
      qlinear=0
      qdst=0
      qlinear_exact=0
      dst_cutoff=0d0
      interp_method=0
      repa_initialized=.false.
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (__INDX_RM(comlyn,comlen,'LINE').gt.0) then
       qlinear=1
       interp_method=linear
      endif
      if ((__INDX_RM(comlyn,comlen,'CSPL').gt.0).or.                        &
     &    (__INDX_RM(comlyn,comlen,'SPLI').gt.0)) then
       qspline=1
       interp_method=spline
      endif
      if (__INDX_RM(comlyn,comlen,'BSPL').gt.0) then
       qbspline=1
       interp_method=bspline
      endif
      if (__INDX_RM(comlyn,comlen,'DST').gt.0) then
       qdst=1
       interp_method=dst
!      did the user specify filter cutoff?
       dst_cutoff=__GET_RM_F(comlyn, comlen, 'WNCT', -1.0d0)
       if (dst_cutoff.lt.0.0d0) then
        if (qprint) then ; write(_MSGBUF,664) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 664   FORMAT(A,' DST REQUESTED BUT FILTER CUTOFF',                     &
     &  A, ' NOT SPECIFIED.',/,' WILL USE 0.500')
        dst_cutoff=0.5d0
       endif
      endif
      if (__INDX_RM(comlyn,comlen,'LIN2').gt.0) then
       qlinear_exact=1
       interp_method=linear_exact
      endif
!ccccccc CHECK FOR MULTIPLE OPTIONS
      if ((qspline+qlinear+qbspline+qdst+qlinear_exact) .eq. 0) then
       if (qprint) then  ; write(_MSGBUF,665) whoami, whoami ; __PRINT(_MSGBUF) ; endif
 665   FORMAT(A,' INTERPOLATION METHOD NOT SPECIFIED.',/,               &
     & A,' WILL USE LINEAR INTERPOLATION.')
       interp_method=linear
      elseif ((qspline+qlinear+qbspline+qdst+qlinear_exact) .gt. 1) then
       __WRN(whoami,'TOO MANY INTERPOLATION OPTIONS.')
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     did the user specify a tolerance?
      if (interp_method.ne.linear_exact) then ! options below are invalid for exact interpolation
       def=__GET_RM_F(comlyn, comlen, 'DEFI', 1.1d0)
       if (def.lt.1.0d0) then
         __WRN(whoami,'INTERPOLATION TOLERANCE MUST BE >= 1.')
!         return
       endif
!     did the user specify a maximum number of iterations?
       iterations=__GET_RM_I(comlyn, comlen, 'ITER',10)
      else
       def=0d0
       iterations=0
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     print summary
      if (qprint) then
       mlen=len(methods(interp_method))
       if (interp_method.eq.linear_exact) then
        write(_MSGBUF,666) whoami,methods(interp_method)(1:mlen)
       else
        write(_MSGBUF,667) whoami,methods(interp_method)(1:mlen),whoami,&
     &  def
       endif
       __PRINT(_MSGBUF)
 666  format(A,' WILL REPARAMETRIZE STRING USING ',A,' INTERPOLATION')
 667  format(A,' WILL REPARAMETRIZE STRING USING ',A,/,                 &
     &A,' INTERPOLATION TO WITHIN MAX(DS)/MIN(DS) < ',F7.3,' TOLERANCE')
       if (iterations.gt.0) then ; write(_MSGBUF,668) whoami, iterations ; __PRINT(_MSGBUF) ; endif
 668  format(A,' WITH A MAXIMUM OF ',I5,' ITERATIONS')
       if(interp_method.eq.dst) then ; write(_MSGBUF,6680) whoami,dst_cutoff*100.0 ; __PRINT(_MSGBUF) ; endif
 6680 format(A,' DST INTERPOLATION WILL USE THE LOWER ',F8.4,           &
     & '% OF WAVENUMBERS')
      endif
!
!     initialize arclength array
      if (.not.allocated(ds)) then
       allocate(ds(nstring-1))
       ds=0.0
      endif
!     initialize curvature array
      if (.not.allocated(curv)) then
       allocate(curv(nstring-2))
       curv=0.0
      endif
!
      repa_initialized=.true.
!
      end subroutine smcv_repa_init
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_stat_init(comlyn, comlen)
!
      use sm_var
      use sm_config,only: vtime_offset, rextime_offset
      use cv_common,only:cv_common_neq_work_init, cv_common_rex_read_map
!
      __DEP_OUTPUT
      __DEP_SIZE
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __IMPNONE
!====================================================================
      CHARACTER(LEN=*) :: COMLYN
      int :: comlen
!
      int :: wtag_len, rex_flen_old __CHARMM_ONLY, ierror
#ifdef __CHARMM
      int :: oldiol
#endif
!
      character(len=80) :: rex_fname_old
      __IAM(SMCV_STAT_INIT)
!
      bool :: qroot, qprint
 __DECLARE_MSGBUF
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qprint=qroot.and.ME_STRNG.eq.0
#ifdef __CHARMM
      if (qprint) then; oldiol=iolev; iolev=0; endif
#endif
!     begin
!     reset iteration counter
!     did the user specify it?
      stat_iteration_counter=__GET_RM_I(comlyn, comlen, 'COUN', -1)
      stat_iteration_counter=max(stat_iteration_counter,0)
      if (stat_iteration_counter.gt.0) then
       if (qprint) then ; write(_MSGBUF,639) whoami, stat_iteration_counter ; __PRINT(_MSGBUF) ; endif
 639  format(A,' SETTING ITERATION COUNTER TO ',I7)
      endif
!
      cv_fname=''
      output_cv=.false.

      forces_fname=''
      output_forces=.false.
!
      voronoi_fname=''
      output_voronoi_hist=.false.
      output_voronoi_log=.false.
      output_voronoi_map=.false.
!
      rmsd_ave_fname=''
      output_rmsd_ave=.false.
!
      rmsd0_fname=''
      output_rmsd0=.false.

      dsdt_fname=''
      output_dsdt=.false.
!
      c_fname=''
      output_curvature=.false.
!
      s_fname=''
      output_arclength=.false.
!
      fe_fname=''
      output_fe=.false.
!
      work_fname=''
      work_tag=''
      output_work=.false.
!
      rex_fname_old=''
      rex_fname=''
      output_rex_log=.false.
      output_rex_map=.false.
!
      wgt_fname=''
      output_wgt=.false.
!
      M_fname=''
      output_M=.false.

!ccccccccccccccccc first process the RMSD-related commands
!!!!!!!!!!!!!! RMSD from static structure in comp (zts/fts)
      if (__INDX_RM(comlyn,comlen,'RMSD').gt.0) then ! request for RMSD
       output_rmsd0=.true.
       __GET_RM_A(COMLYN,COMLEN,'RNAM',4,rmsd0_fname,80,rmsd0_flen)
       if (rmsd0_flen.eq.0) then
         __WRN(whoami,'NO RMSD FILE NAME SPECIFIED. WILL WRITE TO STDOUT.')
         rmsd0_funit=__OSTREAM
       else
         if (__INDX_RM(comlyn,comlen,'RAPP').gt.0) then ! APPEND?
           rform='APPEND'
         else
           rform='WRITE'
         endif
       endif
!ccccccccccc print summary
       if (qprint) then
         if (rmsd0_flen.gt.0) then
          write(_MSGBUF,660 ) whoami,rmsd0_fname(1:rmsd0_flen)
         else
          write(_MSGBUF,661 ) whoami
         endif
         __PRINT(_MSGBUF)
       endif
 660  format(A,' WILL WRITE STRING RMSD TO FILE ',A)
 661  format(A,' WILL WRITE STRING RMSD TO STDOUT.')
!
      endif !! RMSD
!!!!!!!!!!!!!! RMSD from structure at the previous step (zts/fts)
      if (__INDX_RM(comlyn,comlen,'DELS').gt.0) then
        output_dsdt=.true.
        __GET_RM_A(COMLYN,COMLEN,'DNAM',4,dsdt_fname,80,dsdt_flen)
        if (dsdt_flen.eq.0) then
         __WRN(whoami,'NO DELS FILE NAME SPECIFIED. WILL WRITE TO STDOUT.')
         dsdt_funit=__OSTREAM
        else
         if (__INDX_RM(comlyn,comlen,'DAPP').gt.0) then ! APPEND?
           dform='APPEND'
         else
           dform='WRITE'
         endif
        endif
!ccccccccccc print summary
        if (qprint) then
         if (dsdt_flen.gt.0) then
          write(_MSGBUF,650 ) whoami,dsdt_fname(1:dsdt_flen)
         else
          write(_MSGBUF,651 ) whoami
         endif
         __PRINT(_MSGBUF)
        endif
 650  format(A,' WILL WRITE STRING RMSD(I,I+1) TO FILE ',A)
 651  format(A,' WILL WRITE STRING RMSD(I,I+1) TO STDOUT.')
!
      endif !
!!!!!!!!!!!!!! RMSD from average structure (zts/fts)
      if (__INDX_RM(comlyn,comlen,'RMSA').gt.0) then
        output_rmsd_ave=.true.
        __GET_RM_A(COMLYN,COMLEN,'RANM',4,rmsd_ave_fname,80,rmsd_ave_flen)
        if (rmsd_ave_flen.eq.0) then
         __WRN(whoami,'NO RMSA FILE NAME SPECIFIED. WILL WRITE TO STDOUT.')
         rmsd_ave_funit=__OSTREAM
        else
         if (__INDX_RM(comlyn,comlen,'RAAP').gt.0) then ! APPEND?
           raform='APPEND'
         else
           raform='WRITE'
         endif
        endif
!ccccccccccc print summary
        if (qprint) then
         if (rmsd_ave_flen.gt.0) then
          write(_MSGBUF,6500 ) whoami,rmsd_ave_fname(1:rmsd_ave_flen)
         else
          write(_MSGBUF,6510 ) whoami
         endif
         __PRINT(_MSGBUF)
        endif
 6500 format(A,' WILL WRITE STRING RMSD FROM AVERAGE STRUC. TO FILE ',A)
 6510 format(A,' WILL WRITE STRING RMSD FROM AVERAGE STRUC. TO STDOUT.')
!
!     set number of samples in the average ( to continue a calculation )
        num_average_samples=max(__GET_RM_I(comlyn,comlen,'NAVE',0),0)
!       same value for cv
        call cv_set_ave_samples(num_average_samples)
        if (qprint) then ; write(_MSGBUF,6511) whoami, num_average_samples ; __PRINT(_MSGBUF) ; endif
 6511 format(A,' SETTING NUMBER OF SAMPLES IN THE AVERAGE SET TO ',I7)
!
      endif !
!!!!!!!!!!!!!! ARCLENGTH
      if (__INDX_RM(comlyn,comlen,'ARCL').gt.0) then
        output_arclength=.true.
        __GET_RM_A(COMLYN,COMLEN,'ANAM',4,s_fname,80,s_flen)
        if (s_flen.eq.0) then
         __WRN(whoami,'STRING LENGTH FILE NAME NOT SPECIFIED. WILL WRITE TO STDOUT.')
         s_funit=__OSTREAM
        else
         if (__INDX_RM(comlyn,comlen,'AAPP').gt.0) then ! APPEND?
           sform='APPEND'
         else
           sform='WRITE'
         endif
        endif
!ccccccccccc print summary
        if (qprint) then
         if (s_flen.gt.0) then
          write(_MSGBUF,652) whoami,s_fname(1:s_flen)
         else
          write(_MSGBUF,653) whoami
         endif
         __PRINT(_MSGBUF)
        endif
 652  format(A,' WILL WRITE STRING LENGTH TO FILE ',A)
 653  format(A,' WILL WRITE STRING LENGTH TO STDOUT.')
!
      endif ! ARCLENGTH
!!!!!!!!!!!!!! CURVATURE
      if (__INDX_RM(comlyn,comlen,'CURV').gt.0) then
        output_curvature=.true.
        __GET_RM_A(COMLYN,COMLEN,'CVNM',4,c_fname,80,c_flen)
        if (c_flen.eq.0) then
         __WRN(whoami,'CURVATURE FILE NAME NOT SPECIFIED. WILL WRITE TO STDOUT.')
         c_funit=__OSTREAM
        else
         if (__INDX_RM(comlyn,comlen,'CAPP').gt.0) then ! APPEND?
           cform='APPEND'
         else
           cform='WRITE'
         endif
        endif
!ccccccccccc print summary
        if (qprint) then
         if (c_flen.gt.0) then
          write(_MSGBUF,6521) whoami,c_fname(1:c_flen)
         else
          write(_MSGBUF,6531) whoami
         endif
         __PRINT(_MSGBUF)
        endif
 6521 format(A,' WILL WRITE CURVATURE TO FILE ',A)
 6531 format(A,' WILL WRITE CURVATURE TO STDOUT.')
!
      endif ! CURVATURE
!!!!!!!!!!!!!! FREE ENERGY
      if (__INDX_RM(comlyn,comlen,'FREE').gt.0) then
        output_fe=.true.
        __GET_RM_A(COMLYN,COMLEN,'FENM',4,fe_fname,80,fe_flen)
        if (fe_flen.eq.0) then
         __WRN(whoami,'NO F.E. FILE NAME SPECIFIED. WILL WRITE TO STDOUT.')
         fe_funit=__OSTREAM
        else
         if (__INDX_RM(comlyn,comlen,'FAPP').gt.0) then ! APPEND?
           feform='APPEND'
         else
           feform='WRITE'
         endif
        endif
!ccccccccccc print summary cccccccccccccccccccccccccccccccccccccc
        if (qprint) then
         if (fe_flen.gt.0) then
          write(_MSGBUF,6520) whoami,fe_fname(1:fe_flen)
         else
          write(_MSGBUF,6530) whoami
         endif
         __PRINT(_MSGBUF)
        endif
 6520 format(A,' WILL WRITE FREE ENERGY TO FILE ',A)
 6530 format(A,' WILL WRITE FREE ENERGY TO STDOUT.')
!
      endif ! F.E.
!ccccccccccccccccccccccccccc NONEQ. WORK cccccccccccccccccccccccc
      if (__INDX_RM(comlyn,comlen,'WORK').gt.0) then
        output_work=.true.
        call cv_common_neq_work_init() ! initialize force and position arrays
        __GET_RM_A(COMLYN,COMLEN,'WKNM',4,work_fname,80,work_flen)
        if (work_flen.eq.0) then
         __WRN(whoami,'NO F.E. FILE NAME SPECIFIED. WILL WRITE TO STDOUT.')
         work_funit=__OSTREAM
        else
         if (__INDX_RM(comlyn,comlen,'WKAP').gt.0) then ! APPEND?
          wkform='APPEND'
         else
          wkform='WRITE'
         endif
        endif
! specify tag that identifies the work calculated with a particular process
        __GET_RM_A(COMLYN,COMLEN,'WTAG',4,work_tag,8,wtag_len)
        if (wtag_len.eq.0) then
         __WRN(whoami,'WORK TAG NOT SPECIFIED.')
        endif
!ccccccccccc print summary
        if (qprint) then
         if (work_flen.gt.0) then
          write(_MSGBUF,6523) whoami,work_fname(1:work_flen)
         else
          write(_MSGBUF,6533) whoami
         endif
         __PRINT(_MSGBUF)
        endif
 6523 format(A,' WILL WRITE NON-EQ. WORK TO FILE ',A)
 6533 format(A,' WILL WRITE NON-EQ. WORK TO STDOUT.')
!
      endif ! F.E.
!cccccccccc process CV output options ccccccccccccccccccccccc
      if (__INDX_RM(comlyn,comlen,'COLV').gt.0) then
!       get nergy file name
        __GET_RM_A(COMLYN,COMLEN,'CNAM',4,cv_fname,80,cv_flen)
!ccccccccccc print summary
        if (cv_flen.gt.0) then
         output_cv=.true.
         if (qprint) then
           write(_MSGBUF,6620 ) whoami,cv_fname(1:cv_flen)
           __PRINT(_MSGBUF)
         endif
         if (__INDX_RM(comlyn,comlen,'CVAP').gt.0) then ! APPEND?
           cvform='APPEND'
         else
           cvform='WRITE'
         endif
        else
          __WRN(whoami,'NO FILE NAME GIVEN. WILL NOT WRITE CV.')
        endif
 6620 format(A,' WILL WRITE CV TIME SERIES TO FILE ',A,'.')
!
      endif ! cv output
!ccccccccccccccccccccccc output weights cccccccccccccccccccccc
      if (__INDX_RM(comlyn,comlen,'WEIG').gt.0) then
!       get nergy file name
        __GET_RM_A(COMLYN,COMLEN,'WTNM',4,wgt_fname,80,wgt_flen)
!ccccccccccc print summary
        if (wgt_flen.gt.0) then
         output_wgt=.true.
         if (qprint) then
          write(_MSGBUF,6621) whoami,wgt_fname(1:wgt_flen)
          __PRINT(_MSGBUF)
         endif
         if (__INDX_RM(comlyn,comlen,'WTAP').gt.0) then ! APPEND?
           wgtform='APPEND'
         else
           wgtform='WRITE'
         endif
        else
          __WRN(whoami,'NO FILE NAME GIVEN. WILL NOT WRITE CV WEIGHTS.')
        endif
 6621 format(A,' WILL WRITE CV WEIGHTS TO FILE ',A,'.')
!
      endif ! cv output
!cccccccccccc process Voronoi histogram output options ccccccccccc
      voronoi_flen=0
      if (__INDX_RM(comlyn,comlen,'VORO').gt.0) then
!       get file name
        __GET_RM_A(COMLYN,COMLEN,'VNAM',4,voronoi_fname,80,voronoi_flen)
!ccccccccccc print summary
        if (voronoi_flen.gt.0) then
         output_voronoi_hist=.true.
         if (qprint) then
          write(_MSGBUF,6622) whoami,voronoi_fname(1:voronoi_flen)
         endif
        else
         __WRN(whoami,'NO FILE NAME GIVEN. WILL NOT WRITE VORONOI HISTOGRAMS.')
        endif
 6622 format(A,' WILL WRITE VORONOI HISTOGRAMS TO FILE ',A,'.DAT')
!
      endif ! voronoi histograms
!cccccccccccccc voronoi map cccccccccccccccccccccccccccccccccccccccc
      if (__INDX_RM(comlyn,comlen,'VMAP').gt.0) then
!       get file name
        if (voronoi_flen.eq.0) then
         __GET_RM_A(COMLYN,COMLEN,'VNAM',4,voronoi_fname,80,voronoi_flen)
        endif
!
        if (voronoi_flen.gt.0) then
         output_voronoi_map=.true.
         if (qprint) then
          write(_MSGBUF,6627) whoami,voronoi_fname(1:voronoi_flen)
          __PRINT(_MSGBUF)
         endif
        else
          __WRN(whoami,'NO FILE NAME GIVEN. WILL NOT WRITE VORONOI MAP.')
        endif
 6627 format(A,' WILL WRITE VORONOI MAP TO FILE ',A,'.MAP')
!
      endif ! voronoi map
!cccccccccccccc voronoi log cccccccccccccccccccccccccccccccccccccccc
      if (__INDX_RM(comlyn,comlen,'VLOG').gt.0) then
!       get file name
        if (voronoi_flen.eq.0) then
         __GET_RM_A(COMLYN,COMLEN,'VNAM',4,voronoi_fname,80,voronoi_flen)
        endif
!       check for timestep offset
        vtime_offset=__GET_RM_I(comlyn, comlen, 'VOFF', 0);
        if (vtime_offset.gt.0) then
         if (qprint) then ; write(_MSGBUF,6624) whoami, vtime_offset ; __PRINT(_MSGBUF) ; endif
 6624 format(A,' WILL OFFSET STEP COUNTER IN VORONOI LOG BY ',I10)
        endif
!
        if (voronoi_flen.gt.0) then
         output_voronoi_log=.true.
         if (qprint) then
          write(_MSGBUF,6623) whoami,voronoi_fname(1:voronoi_flen)
          __PRINT(_MSGBUF)
         endif
         if (__INDX_RM(comlyn,comlen,'VLAP').gt.0) then ! APPEND?
           vlform='APPEND'
         else
           vlform='WRITE'
         endif ! vlap
!
        else
          __WRN(whoami,'NO FILE NAME GIVEN. WILL NOT WRITE VORONOI LOG.')
        endif ! voronoi_flen.gt.0
 6623 format(A,' WILL WRITE VORONOI LOG TO BINARY FILE ',A,'.DAT')
!
      endif ! complete voronoi log
!cccccccccccc replica exchange map cccccccccccccc
      rex_flen=0
      if (__INDX_RM(comlyn,comlen,'REXM').gt.0) then
!       get file name
        __GET_RM_A(COMLYN,COMLEN,'RXNM',4,rex_fname,80,rex_flen)
!       check if user specified an custom map (e.g. from an older run)
        __GET_RM_A(COMLYN,COMLEN,'RXOL',4,rex_fname_old,80,rex_flen_old)
!
        if (rex_flen.gt.0) then
         output_rex_map=.true.
         if (qprint) then
          write(_MSGBUF,6721) whoami,rex_fname(1:rex_flen)
          __PRINT(_MSGBUF) 
         endif
         if (rex_flen_old.gt.0) then
          if (qprint) then
            write(_MSGBUF,6722) whoami,rex_fname_old(1:rex_flen_old) ; __PRINT(_MSGBUF)
            rex_funit=-1
            __OPEN_FILE(rex_funit,rex_fname_old(1:rex_flen_old),'FORMATTED','READ')
          endif
          call cv_common_rex_read_map(rex_funit)
          if (qprint) then ;__CLOSE_FILE(rex_funit, 'KEEP', ierror) ; endif
         endif
!
        else
          __WRN(whoami,'NO FILE NAME GIVEN. WILL NOT WRITE REPLICA EXCHANGE MAP.')
        endif
 6721 format(A,' WILL WRITE REPLICA EXCHANGE MAP TO FILE ',A,'.MAP')
 6722 format(A,' WILL RESTART FROM REPLICA EXCHANGE MAP IN FILE ',A)
!
      endif ! replica exchange map
!cccccccccccccc replica exchange log cccccccccccccccccccccccccccccccccccccccc
      if (__INDX_RM(comlyn,comlen,'REXL').gt.0) then
!       get file name
        if (rex_flen.eq.0) then
         __GET_RM_A(COMLYN,COMLEN,'RXNM',4,rex_fname,80,rex_flen)
        endif
!       check for timestep offset
        rextime_offset=__GET_RM_I(comlyn, comlen, 'ROFF', 0);
        if (rextime_offset.gt.0) then
         if (qprint) then ; write(_MSGBUF,6724) whoami, whoami,rextime_offset ;  __PRINT(_MSGBUF) ; endif
 6724 format(A,' WILL OFFSET STEP COUNTER IN REPLICA EXCHANGE LOG BY '  &
     &       /,A,' ',I10)
        endif
!
        if (rex_flen.gt.0) then
         output_rex_log=.true.
         if (qprint) then
           write(_MSGBUF,6723) whoami,whoami,rex_fname(1:rex_flen)
           __PRINT(_MSGBUF)
         endif
         if (__INDX_RM(comlyn,comlen,'RXAP').gt.0) then ! APPEND?
           rxlform='APPEND'
         else
           rxlform='WRITE'
         endif ! rxap
        else
          __WRN(whoami,'NO FILE NAME GIVEN. WILL NOT WRITE REPLICA EXCHANGE LOG.')
        endif ! rex_flen.gt.0
 6723 format(A,' WILL WRITE REPLICA EXCHANGE LOG TO FILE ',/,           &
     & A,' ',A,'.DAT')
!
      endif ! replica exchange log
!cccccccccccccccccc process forces output options cccccccccccccccccc
      if (__INDX_RM(comlyn,comlen,'FORC').gt.0) then
!       get nergy file name
        __GET_RM_A(COMLYN,COMLEN,'FCNM',4,forces_fname,80,forces_flen)
!ccccccccccc print summary
        if (forces_flen.gt.0) then
         output_forces=.true.
         if (qprint) then
          write(_MSGBUF,6625) whoami,forces_fname(1:forces_flen)
         __PRINT(_MSGBUF)
         endif
         if (__INDX_RM(comlyn,comlen,'FCAP').gt.0) then ! APPEND?
           fform='APPEND'
         else
           fform='WRITE'
         endif
        else
         __WRN(whoami,'NO FILE NAME GIVEN. WILL NOT WRITE AVERAGE FORCE.')
        endif
 6625 format(A,' WILL WRITE AVERAGE FORCE TO FILE ',A,'.')
      endif ! forces
!ccccccccccccccccc process M matrix output options ccccccccccccccccc
      if (__INDX_RM(comlyn, comlen, 'MMAT').gt.0) then
!
        __GET_RM_A(COMLYN,COMLEN,'MNAM',4,M_fname,80,M_flen)
        if (M_flen.gt.0) then
         output_M=.true.
         if (qprint) then ; write(_MSGBUF,6626) whoami,M_fname(1:M_flen) ; __PRINT(_MSGBUF) ; endif
        else
         __WRN(whoami,'NO FILE NAME GIVEN. WILL NOT WRITE M TENSOR.')
        endif
 6626 format(A,' WILL WRITE SHORT-TERM AVERAGED TENSOR M TO FILE ',A,'.')
      endif
!
#ifdef __CHARMM
      if (qprint) iolev=oldiol
#endif
!      if we got this far, we are probably OK
      stat_initialized=.true.
!
      end subroutine smcv_stat_init
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_stat()
!     output statistics for SMCV
      use sm_var
      use sm_config, only: calc_cv_para, calc_Mtensor_para __CHARMM_ONLY , izero, ione, itwo, ithree, ifour
      use cv_common
      __DEP_OUTPUT
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_PARSER 
      __DEP_MPI  ! deal with other platforms later (never)
      __DEP_NUMBER
!
      __IMPNONE
!
#include "mpitype.def"
!
      int :: ierror, i, ifile, fmt_r_len
      float :: rmsd0, rmsd0_all(nstring), dsdt, dsdt_all(nstring)
      float :: mywork, allwork(nstring)
      character(len=8) :: work_tags(nstring)
      character(len=80) :: fmt, fmt_real, fmt_int ! format strings for output
#ifdef __CHARMM
      int :: oldiol
#endif
      __IAM(SMCV_STAT)
!
      bool :: qroot, qprint, qgrp
!
      interface
       subroutine smcv_init(maxcv)
        __IMPNONE
        int, optional :: maxcv
       end subroutine smcv_init
      end interface
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qprint=qroot.and.ME_STRNG.eq.0
      qgrp=MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1
!
!     ad hoc fix for REX
#ifdef __CHARMM
      if (qprint) then ; oldiol=iolev; iolev=0; endif
#endif
!cccccccccccccccccccccc begin ccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! check if the user has made an initialization call
      if (.not.smcv_initialized) call smcv_init()
      if (.not.stat_initialized) then
       __WRN(whoami,'NO OUTPUT OPTIONS SELECTED. NOTHING DONE')
       return
      endif
!
      stat_iteration_counter=stat_iteration_counter+1
!     define number format string for output
!
      write(fmt_real,*) nstring
      fmt_r_len=len(fmt_real)
      __TRIMA(fmt_real,fmt_r_len)
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_rmsd0) then
!      weighting is taken care of in cv_common class
          rmsd0=cv_common_rmsd(ione,ithree) ! we will keep the initial reference coords in col. 3
          if (qroot) call mpi_gather(rmsd0,1,mpifloat       & ! heads communicate
     &                ,rmsd0_all,1,mpifloat,0,              &
     &                 MPI_COMM_STRNG, ierror)
          if (qprint) then ! root writes
           if (rmsd0_funit.eq.__OSTREAM) then
            fmt='("RMSD0> ",I5," ",'//fmt_real(1:fmt_r_len)//'F15.5)'
           else
            rmsd0_funit=-1
            __OPEN_FILE(rmsd0_funit, rmsd0_fname,'FORMATTED',rform)
            fmt='(I5," ",'//fmt_real(1:fmt_r_len)//'F15.5)'
           endif
           write(rmsd0_funit,fmt) stat_iteration_counter,               &
     &     (rmsd0_all(i),i=1,nstring)
!
           if (rmsd0_funit.ne.__OSTREAM) then
            __CLOSE_FILE(rmsd0_funit, 'KEEP', ierror)
           endif
          endif ! qprint
          rform='APPEND'
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_dsdt) then
!      weighting is taken care of in cv_common class
          dsdt=cv_common_rmsd(ione,itwo) ! we will keep the previous coords in col. 2
          if (qroot) call mpi_gather(dsdt,1,mpifloat        &
     &                ,dsdt_all,1,mpifloat,0,               &
     &                 MPI_COMM_STRNG, ierror)
          if (qprint) then ! root writes
           if (dsdt_funit.eq.__OSTREAM) then
            fmt='("DLEN> ",I5," ",'//fmt_real(1:fmt_r_len)//'F15.5)'
           else
            dsdt_funit=-1
            __OPEN_FILE(dsdt_funit, dsdt_fname,'FORMATTED',dform)
            fmt='(I5," ",'//fmt_real(1:fmt_r_len)//'F15.5)'
           endif
           write(dsdt_funit,fmt) stat_iteration_counter,                &
     &     (dsdt_all(i),i=1,nstring)
!     flush unit: close and reopen
           if (dsdt_funit.ne.__OSTREAM) then
            __CLOSE_FILE(dsdt_funit, 'KEEP', ierror)
           endif
          endif ! qprint
          dform='APPEND'
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_rmsd_ave) then ! rmsd with respect to the running average structure
!      weighting is taken care of in cv_common class
!      call to update running average
          call cv_common_update_ave()
          rmsd0=cv_common_rmsd(ione,ifour) ! we will keep the average coords in col. 4
          if (qroot) call mpi_gather(rmsd0,1,mpifloat       &
     &                ,rmsd0_all,1,mpifloat,0,              &
     &                 MPI_COMM_STRNG, ierror)
          if (qprint) then ! root writes
           if (rmsd_ave_funit.eq.__OSTREAM) then
            fmt='("RMSD_AVE> ",I5," ",'//fmt_real(1:fmt_r_len)//'F15.5)'
           else
            rmsd_ave_funit=-1
            __OPEN_FILE(rmsd_ave_funit, rmsd_ave_fname,'FORMATTED',raform)
            fmt='(I5," ",'//fmt_real(1:fmt_r_len)//'F15.5)'
           endif
           write(rmsd_ave_funit,fmt) stat_iteration_counter,            &
     &     (rmsd0_all(i),i=1,nstring)
!     flush unit: close and reopen
           if (rmsd_ave_funit.ne.__OSTREAM) then
            __CLOSE_FILE(rmsd_ave_funit, 'KEEP', ierror)
           endif
          endif ! qprint
          raform='APPEND'
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_arclength) then
       if (qprint) then
         write(fmt_int,'(I5)') stat_iteration_counter
         if (s_funit.eq.__OSTREAM) then
          fmt='("ARCL> '//fmt_int(1:5)//' ",'                           &
     &                  //fmt_real(1:fmt_r_len)//'F15.5)'
         else
          s_funit=-1
          __OPEN_FILE(s_funit, s_fname,'FORMATTED',sform)
          fmt='("'//fmt_int(1:5)//' ",'//fmt_real(1:fmt_r_len)//'F15.5)'
         endif
         call cv_common_print_ds(s_funit, fmt)
!     flush unit: close and reopen
         if (s_funit.ne.__OSTREAM) then
          __CLOSE_FILE(s_funit, 'KEEP', ierror)
         endif
!     done
       endif ! qprint
       sform='APPEND'
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_curvature) then
       if (qprint) then
         write(fmt_int,'(I5)') stat_iteration_counter
         if (c_funit.eq.__OSTREAM) then
          fmt='("CURV> '//fmt_int(1:5)//' ",'                           &
     &                  //fmt_real(1:fmt_r_len)//'F11.5)'
         else
          c_funit=-1
          __OPEN_FILE(c_funit, c_fname,'FORMATTED', cform)
          fmt='("'//fmt_int(1:5)//' ",'//fmt_real(1:fmt_r_len)//'F11.5)'
         endif
         call cv_common_print_curvature(c_funit, fmt)
!     flush unit: close and reopen
         if (c_funit.ne.__OSTREAM) then
          __CLOSE_FILE(c_funit, 'KEEP', ierror)
!     done
         endif
       endif ! qprint
       cform='APPEND'
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_fe) then
       if (qprint) then
         write(fmt_int,'(I5)') stat_iteration_counter
         if (fe_funit.eq.__OSTREAM) then
          fmt='("FE> '//fmt_int(1:5)//' ",'                             &
     &                //fmt_real(1:fmt_r_len)//'F15.5)'
         else
          fe_funit=-1
          __OPEN_FILE(fe_funit, fe_fname,'FORMATTED',feform)
          fmt='("'//fmt_int(1:5)//' ",'//fmt_real(1:fmt_r_len)//'F15.5)'
         endif
         call cv_common_print_feav(fe_funit, fmt)
!     flush unit: close and reopen
         if (fe_funit.ne.__OSTREAM) then
          __CLOSE_FILE(fe_funit, 'KEEP', ierror)
!     done
         endif
       endif ! qprint
       feform='APPEND'
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_work) then
!     gather work
       mywork=cv_common_neq_get_work()
!     if running in parallel, need to reduce work from slave nodes
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1          &
     & .and.calc_cv_para) then
        call MPI_REDUCE(mywork, allwork(1), 1, mpifloat,    &
     &   MPI_SUM, 0, MPI_COMM_LOCAL, ierror) ! reduce on all group roots
        mywork=allwork(1)
       endif
!    gather work from all nodes into one output buffer
       if (qroot) then
        call mpi_gather(mywork, 1, mpifloat,                &
     &                 allwork, 1, mpifloat,                &
     &                 0, MPI_COMM_STRNG, ierror)
        call mpi_gather(work_tag, 8, MPI_BYTE,                          &
     &                work_tags, 8, MPI_BYTE, 0, MPI_COMM_STRNG,        &
     &                ierror)
       endif
! write
       if (qprint) then
         write(fmt_int,'(I5)') stat_iteration_counter
         if (work_funit.eq.__OSTREAM) then
          fmt='("WORK> '//fmt_int(1:5)//' ",A8,F15.5)'
         else
          work_funit=-1
          __OPEN_FILE(work_funit, work_fname,'FORMATTED', wkform)
          fmt='("'//fmt_int(1:5)//' ",A8,F15.5)'
         endif
         do i=1,nstring
          write(work_funit,fmt) work_tags(i), allwork(i)
         enddo
!     flush unit: close and reopen
         if (work_funit.ne.__OSTREAM) then
          __CLOSE_FILE(work_funit, 'KEEP', ierror)
         endif
!     done
       endif ! qprint
       wkform='APPEND'
      endif ! output_work
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_voronoi_hist) then ! output voronoi data
        if (voronoi_flen.eq.0) then
         __WRN(whoami,'NO FILE NAME SPECIFIED. WILL NOT WRITE VORONOI DATA.')
        else
         if (qprint) then
          ifile=-1
          voronoi_fname(voronoi_flen+1:voronoi_flen+4)='.dat'
          __OPEN_FILE(ifile,voronoi_fname(1:voronoi_flen+4),'FORMATTED','WRITE')
          voronoi_fname(voronoi_flen+1:)=''
         endif
         call cv_common_print_voro_data(ifile) ! all root processes enter
         if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
        endif
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_voronoi_log) then
       if (voronoi_flen.eq.0) then
         __WRN(whoami,'NO FILE NAME SPECIFIED. WILL NOT WRITE VORONOI LOG.')
       else
         if (qprint) then
           vlog_funit=-1
           voronoi_fname(voronoi_flen+1:voronoi_flen+4)='.log'
           __OPEN_FILE(vlog_funit,voronoi_fname(1:voronoi_flen+4),'UNFORMATTED', vlform)
           voronoi_fname(voronoi_flen+1:)=''
         endif
         vlform='APPEND'
         if (qroot) call cv_common_voronoi_print_log(vlog_funit)
!    flush unit:
         if (qprint) then ; __CLOSE_FILE(vlog_funit,'KEEP',ierror) ; endif
       endif
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_voronoi_map) then ! output voronoi map
        if (voronoi_flen.eq.0) then
         __WRN(whoami,'NO FILE NAME SPECIFIED. WILL NOT WRITE VORONOI MAP.')
        else
!    put 'whereami' into the map
          if (qroot.and.SIZE_STRNG.gt.1) then
           call MPI_ALLGATHER(cv%voronoi_whereami, 1, mpiint,       &
     &      cv%voronoi_map, 1, mpiint, MPI_COMM_STRNG, ierror)
          else
           cv%voronoi_map(mestring+1)=cv%voronoi_whereami
          endif
          if (qgrp) then
#ifdef __CHARMM
           __BROADCAST_LOCAL_4B(cv%voronoi_map,nstring)  !__CHARMM_ONLY##.not.INTEGER8
           __BROADCAST_LOCAL_8B(cv%voronoi_map,nstring)  !__CHARMM_ONLY##INTEGER8
#elif defined (__DMOL)
           __BROADCAST_LOCAL(cv%voronoi_map,nstring,mpiint)
#endif
          endif ! qgrp
!
         if (qroot) then
          ifile=-1
          voronoi_fname(voronoi_flen+1:voronoi_flen+4)='.map'
          if (qprint) then 
           __OPEN_FILE(ifile,voronoi_fname(1:voronoi_flen+4), 'FORMATTED','WRITE')
           voronoi_fname(voronoi_flen+1:)=''
          endif
          call cv_common_print_voro_map(ifile)
          if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
         endif ! qroot
        endif
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_rex_map) then ! output replica exchange map
        if (rex_flen.eq.0) then
         __WRN(whoami,'NO FILE NAME SPECIFIED. WILL NOT WRITE REPLICA EXCHANGE MAP.')
        else
         if (qprint) then
          rex_funit=-1
          rex_fname(rex_flen+1:rex_flen+4)='.map'
          __OPEN_FILE(rex_funit,rex_fname(1:rex_flen+4), 'FORMATTED','WRITE')
          rex_fname(rex_flen+1:)=''
!
          call cv_common_rex_print_map(rex_funit)
!
          __CLOSE_FILE(rex_funit,'KEEP',ierror)
         endif ! qprint
        endif
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_rex_log) then
       if (rex_flen.eq.0) then
         __WRN(whoami,'NO FILE NAME SPECIFIED. WILL NOT WRITE REPLICA EXCHANGE LOG.')
       else
        if (qprint) then
         rex_funit=-1
         rex_fname(rex_flen+1:rex_flen+4)='.dat' ! append to name
         __OPEN_FILE(rex_funit,rex_fname(1:rex_flen+4),'FORMATTED', rxlform)
         rex_fname(rex_flen+1:)='' ! erase extension
        endif
        rxlform='APPEND'
!
        call cv_common_rex_print_log(rex_funit)
!    flush unit:
        if (qprint) then ; __CLOSE_FILE(rex_funit,'KEEP',ierror) ; endif
       endif
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_cv) then
        if (qprint) then
         cv_funit=-1
         __OPEN_FILE(cv_funit, cv_fname,'FORMATTED', cvform)
         write(cv_funit,'("% ",I8)') stat_iteration_counter ! % is a MATLAB comment
        endif
        cvform='APPEND'
        call cv_common_print_global(cv_funit)
!    flush unit:
        if (qprint) then ; __CLOSE_FILE(cv_funit, 'KEEP', ierror) ; endif
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_forces) then
       if (qprint) then
        forces_funit=-1
        __OPEN_FILE(forces_funit, forces_fname,'FORMATTED',fform);
        write(forces_funit,'("% ",I8)') stat_iteration_counter ! % is a MATLAB comment
       endif
       fform='APPEND'
       call cv_common_print_forces(forces_funit)
!    flush unit:
       if (qprint) then ; __CLOSE_FILE(forces_funit, 'KEEP', ierror) ; endif
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_wgt) then
       if (qprint) then
         wgt_funit=-1
         __OPEN_FILE(wgt_funit, wgt_fname,'FORMATTED', wgtform);
         write(wgt_funit,'("% ",I8)') stat_iteration_counter ! % is a MATLAB comment
         call cv_common_print_wgt(wgt_funit)
!    flush unit:
         __CLOSE_FILE(wgt_funit, 'KEEP', ierror)
       endif
       wgtform='APPEND'
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_M) then
!    if running in parallel, combine partial M entries
       if (qgrp.and.calc_Mtensor_para) then
!
! print the short-term average (gather on root)
! broadcast all rows, but only num_cv columns
        call MPI_REDUCE(cv%M(1,1,1),cv%M(1,1,2),max_cv_common*cv%num_cv, &
     &                  mpifloat, MPI_SUM, 0, MPI_COMM_LOCAL, ierror)
       else ! qgrp
        cv%M(1:cv%num_cv,1:cv%num_cv,2)=cv%M(1:cv%num_cv,1:cv%num_cv,1)
       endif ! qgrp
!
       if (qroot) then
        if (M_flen.eq.0) then
         __WRN(whoami,'NO FILE NAME SPECIFIED. WILL NOT WRITE M TENSOR.')
        else
         ifile=-1
         __OPEN_FILE(ifile, M_fname(1:M_flen), 'FORMATTED', 'WRITE')
         call cv_common_print_M_global(ifile,IND=2) ! print the short-term average (long-term average by default)
         __CLOSE_FILE(ifile,'KEEP',ierror)
        endif ! M_flen
       endif ! qroot
      endif ! output_M
!     ad hoc fix for REX
#ifdef __CHARMM
      if (qprint) iolev=oldiol
#endif
!
      end subroutine smcv_stat
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine smcv_repa()
!     this is routine is just a wrapper, so that any subroutine can call a "default" repa.
      use sm_var,only: interp_method, iterations, def, dst_cutoff,    &
     &                   repa_initialized
      use cv_common,only: cv_common_repa
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
!
      __IMPNONE
 __DECLARE_MSGBUF
! local variables
      __IAM(SMCV_REPA)
      bool :: qprint
! check if the user has made an initialization call
!
      qprint=(MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0)
!
      if (.not.repa_initialized) then
       __WRN( whoami,'NO REPARAMETRIZATION OPTIONS SELECTED. NOTHING DONE.')
       return
      endif
      if (qprint) then ; write(_MSGBUF,690) whoami ; __PRINTL(_MSGBUF,5) ; endif
 690  format(/A,' CALLING STRING REPARAMETRIZATION.')
      call cv_common_repa(interp_method,def,iterations,dst_cutoff)
!
      end subroutine smcv_repa
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine cv_set_ave_samples(n)
      use cv_common,only: cv_common_set_ave_samples
      __DEP_OUTPUT
      __IMPNONE
      int :: n
      call cv_common_set_ave_samples(n)
      end subroutine cv_set_ave_samples
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
__CHARMM_ONLY##ENDIF
#endif
