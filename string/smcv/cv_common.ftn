!
!     CV_COMMON.MOD
!
!     COMMON ROUTINES FOR COLLECTIVE VARIABLES
!     SPECIFIC CV USE THIS MODULE
!     ADDITIONAL STORAGE FOR CV TYPES SHOULD BE ALLOCATED IN CV%PRIV(I),
!     WHERE I IS THE CV INDEX
!
!
#define __GETPAR(__WHAT,__TYPE) __CONCAT(__WHAT,_) =__CONCAT(ato,__TYPE) (getval_nocase(__STRING(__WHAT),__MYCTX))
#define __COMPARE_PAR(__WHAT, __HOW, __NEG)\
if (__NEG(__CONCAT(__PRE,__WHAT) __HOW __CONCAT(__WHAT,_)))then;__WARN(whoami,'MISMATCH IN SMCV PARAMETER "',__STRING(__WHAT),'":',__CONCAT(__PRE,__WHAT),'(PROGRAM) vs.',__CONCAT(__WHAT,_),'(FILE)');qerror=.true.;endif
#define __MYCTX __STRING(smcv)
!
      module cv_common
!
__CHARMM_ONLY##IF STRINGM
!
      __CHARMM_ONLY __DEP_KINDS
!
      __DEP_NUMBER
      __DEP_OUTPUT
      use ivector_list
      use i8vector
      use unitcell
      use cv_types ! unfortunately, need to include this module because angle calculations require special treatment
!
      __IMPNONE
!
      private
!     declare pointer type (for arrays of pointer)
      type priv_ptr
       int, pointer :: p(:), amap_ptr(:) ! amap_ptr contains a unique list of indices in the amap that the cv depends on
       float,  pointer :: pr(:)
      end type priv_ptr
!****************************************************************************************************************************
      type cv_base
!
      float, dimension(:,:), pointer :: r ! cv coordinates
      float, dimension(:,:,:), pointer :: M ! mass matrix: (running average); two slots for M, (:,:,1) and (:,:,2); two slots for M^{-1} (:,:,3-4)
      float, dimension(:,:,:,:), pointer :: grad ! combined gradient array; introduced for parallelization (comm. efficiency)
      float, dimension(:,:,:), pointer :: gradx ! gradient vector of CV w.r.t. x ; (:,:,2) is mass-weighted to compute M
      float, dimension(:,:,:), pointer :: grady ! gradient vector of CV w.r.t. y ; (:,:,2) is mass-weighted to compute M
      float, dimension(:,:,:), pointer :: gradz ! gradient vector of CV w.r.t. z ; (:,:,2) is mass-weighted to compute M
      int, dimension(:), pointer :: type ! cv type (e.g. position, bond, angle, etc.)
      bool, dimension(:), pointer :: active ! if flag .false., cv will be computed, but force not added, unless this cv is a part of another function
!                                                e.g. RMSD ; experimental as of 7.2010; to make this compatible with all features, need to ignore cvs
!                                                that are "inactive" in reparametrization, df computation, etc.; currently used for SMD
      type (priv_ptr), dimension(:), pointer :: priv ! cv data that is 'private' to each cv
      type (int_vlist) :: amap ! maps local indices to psf atom indices; also contains an inverse map: which CV make use of an index
      float, dimension(:), pointer :: r_bc_0, r_bc_1 ! arrays for optional fixed b.c.
      float, dimension(:), pointer   :: k ! force constant
      float :: kpara ! force constant for forces parallel to string ; same for all CV (required for off-path sim.)
      float :: kperp ! force constant for forces perpendicular to string ; same for all CV
      float, dimension(:), pointer   :: gamma ! NOTE that this is ONE/GAMMA where GAMMA is the friction (U[GAMMA]=1/time in SMCV evol; =mass/time in BD evol)
      float, dimension(:), pointer   :: weight
      float, dimension(:), pointer   :: temperature ! temperature for BD evolution of this CV
      float, dimension(:), pointer   :: minval, maxval
      float :: wrss ! one over root-sum-square of the weight array
! 2016 : for flat-bottom potential
      float, dimension(:), pointer :: fbwidth ! HALF-width of flat-bottom (fb) region of harmonic potential
      int, dimension(:), pointer :: num_fb_ave ! number of averages in the fb region of the potential
      int :: num_cv=0 ! number of active collective vars
      int :: num_hist=0 ! number of snapshots in the history
      int :: beg_hist=1 ! index in the history that corresponds to the oldest snapshot (first)
      int :: end_hist=0 ! index in the history that corresponds to the newest snapshot (last)
      int :: num_run_ave=0 ! number of snapshots in the running average
      float  :: dt=0       ! timestep for string evolution
      int :: num_average_samples=0 ! number of samples in the accumulated CV average
      int :: num_fe_samples=0 ! number of samples in the fe running average
      float, dimension(:), pointer   :: ds, fe, curvature, feav ! arclength,FE,curvature, avg. FE
      float, dimension(:,:), pointer :: rall ! holds a complete set of CV for Voronoi T.
      float, dimension(:,:,:), pointer :: Mall ! holds a complete set of M matrices & inverses (Voronoi T.)
      float :: work ! nonequilibrium work
      int, dimension(:,:,:), pointer :: voronoi_data   ! holds the nine arrays listed below
! local
      int, dimension(:,:), pointer :: cross_attempt ! holds the history of crossing attempts in 1st column
      int, dimension(:,:), pointer :: cross_accept  ! history of successful crossing attempts in second column. For Voronoi Tessellation.
      int, dimension(:), pointer :: voro_occupancy ! total # iterations voronoi cells are populated (watch out for max int value !!!)
! global
      int, dimension(:,:), pointer :: cross_attemptG
      int, dimension(:,:), pointer :: cross_acceptG
      int, dimension(:), pointer :: voro_occupancyG
! old global (for restarting)
      int, dimension(:,:), pointer :: cross_attemptO
      int, dimension(:,:), pointer :: cross_acceptO
      int, dimension(:), pointer :: voro_occupancyO
!
      int, dimension(:), pointer :: voronoi_map ! holds map between process rank and voronoi cell
      type (int8_vector) :: voro_log ! logs the history of crossing attempts ( which cells and when ); local to each replica
      int :: voronoi_whereami       ! the voronoi cell this replica is inside
      float :: voronoi_cut         ! voronoi cell cutoff in path-perpendicular direction (beyond which MD replicas are not allowed)
      type (int8_vector) :: rex_log  ! logs the history of replica exchanges ( which replica and when ); local to each replica
      int, dimension(:), pointer :: rex_map ! holds the map between replica number and the process rank
      float :: rex_beta ! ensemble temperature in replica exchange (usually will be the same as the simulation temperature)
! unit cell data 10/2017
      type(cell) :: ucell
      end type cv_base
!
      public priv_ptr
      public cv_base
      ! subroutines
      public cv_common_init   ! initialize cv array
      public cv_common_done   ! destroy cv array
      public cv_common_add    ! add a CV
      public cv_common_fill   ! set z=theta(x)
      public cv_common_grad_init ! initialize cv%grad arrays
      public cv_common_set_bc ! set boundary conditions on string (fixed or free)
      public cv_common_repa   ! reparameterize
      public cv_common_print_header ! output basic string info
      public cv_common_print_local  ! print out cv values (i.e. z) to separate files
      public cv_common_print_global  ! print out cv values (i.e. z) to a combined file
      public cv_common_add_hist ! save an instance of theta(x)
      public cv_common_print_hist_local ! write history of computed cv values (i.e. theta(x)) to file
      public cv_common_print_hist_global ! write history of computed cv values (i.e. theta(x)) to file
      public cv_common_clear_hist ! clear history
      public cv_common_smooth_hist ! filter history & place in comp-set r(:,:,2)
      public cv_common_evolve_expo ! evolution using exponential averaging of history
      public cv_common_evolve_smcv ! evolve string using average force a la SMCV - DEFAULT
      public cv_common_evolve_sd ! evolve string using average force (SD+THERMOSTAT = BD)
      public cv_common_apply_bc ! apply (reflective) boundary conditions to CV
      public cv_common_swap   ! swap main-set and comp_set, i.e. r(:,:,1) and r(:,:,2)
      public cv_common_copy   ! swap main-set and comp_set, i.e. r(:,:,1) and r(:,:,2)
      public cv_common_read_global  ! read cv values from separate files
      public cv_common_read_local   ! read cv values from separate files
      public cv_common_read_local_from_global   ! read cv values from a particular column in a global file
      public cv_common_unwrap_angles ! make sure that along the string the angle does not change by more than 180 degrees
      public cv_common_rmsd   ! compute rmsd between two sets of CV
      public cv_common_set_kpara  ! set parallel force constant k
      public cv_common_set_kperp  ! set perpendicular force constant k
      public cv_common_set_k  ! set force constant k
      public cv_common_set_w  ! set weight
      public cv_common_set_active  ! set active flag
      public cv_common_set_g  ! set gamma
      public cv_common_set_temp ! set BD evolution temperature
      public cv_common_set_minval ! set lower boundary limit on CV
      public cv_common_set_maxval ! set upper boundary limit on CV
      public cv_common_set_fbwidth  ! set width of the flat-bottom region of potential
      public cv_common_set_dt  ! set default timestep
      public cv_common_set_r  ! set collective variable value
      public cv_common_print_curvature ! print out curvature
      public cv_common_print_ds ! print out ds
      public cv_common_print_fe ! print out fe
      public cv_common_print_feav ! print out fe averaged over the statistics interval
      public cv_common_print_forces ! write out forces on CV
      public cv_common_compute_fe_fd ! finite difference computation of free energy using integration
      public cv_common_update_ave ! update average CV set
      public cv_common_update_fe_ave ! update average work curve
      public cv_common_set_ave_samples ! change the number of samples associated with the average CV
      public cv_common_voronoi_compute ! determine which voronoi cell we are in
      public cv_common_voronoi_print_log ! print voronoi log
      public cv_common_voronoi_init ! initialize voronoi histogram matrix
      public cv_common_voronoi_update ! update voronoi cell centers
      public cv_common_voronoi_smart_update ! update vorohnoi cell centers sudh that the MD replicas remain inside their cells
      public cv_common_voronoi_done ! deallocate voronoi histogram matrix
      public cv_common_voronoi_set_cutoff ! set voronoi cell cutoff
      public cv_common_read_voro_map   ! read voronoi map from file
      public cv_common_print_voro_map   ! print voronoi map to file
      public cv_common_read_voro_data   ! read voronoi crossing data from file
      public cv_common_print_voro_data   ! print voronoi crossing to file
      public cv_common_neq_work_init ! initialize variables for computing work
      public cv_common_neq_get_work ! return work
      public cv_common_interpolate ! interpolate CV onto a different grid
      public cv_common_compute_wgt ! compute CV weights for interpolation and RMSD calculations
      public cv_common_print_wgt ! print CV weights
      public cv_common_read_wgt ! read in CV weights
      public cv_common_compute_dr ! compute tangent to the path
      public cv_common_print_dr ! print tangent to the path
      public cv_common_read_dr ! read tangent to the path
      public cv_common_compute_k ! calculate force constants using k_i=kpara*w_i^2
      public cv_common_print_M_global   ! print metric tensor
      public cv_common_print_M_local
      public cv_common_read_M          ! read metric tensor
      public cv_common_compute_Minv    ! compute inverse of metric tensor
      public cv_common_rex_init       ! initialize replica exchange variables
      public cv_common_rex_done
      public cv_common_rex_set_temp
      public cv_common_rex_compute_dE ! compute energy difference
      public cv_common_rex_read_map   ! read replica map from file
      public cv_common_rex_print_map  ! print replica map
      public cv_common_rex_print_log  ! print replica map
      public cv_common_parser_done

!    variables
 __DECL_MSGBUF
 private _MSGBUF
      type (cv_base), public, save :: cv
!
      int, public :: max_cv_common=5000
      int, parameter, public :: max_hist_base=1000
!
      bool, public, save ::     cv_common_initialized=.false.,            &
     &                          cv_common_voronoi_initialized=.false.,    &
     &                          cv_common_voronoi_wrong_cell=.false.,     &
     &                          cv_common_grad_initialized=.false.,       & ! have the cv%grad arrays been allocated
     &                          cv_common_weights_initialized=.false.,    & ! has the weight array been initialized, obsolescent
     &                          cv_common_Minv_initialized=.false.,       & ! has the M-1 tensor been initialized
     &                          cv_common_dz_initialized=.false.,         & ! has the weight array been initialized
     &                          cv_common_k_initialized=.false.,          & ! added for off_path sampling
     &                          cv_common_kpara_initialized=.false.,      & ! parallel force constant (off-path)
     &                          cv_common_kperp_initialized=.false.,      & ! perpendicular force constant (off-path)
     &                          cv_common_rex_initialized=.false.    ! exchange of adjacent replicas
!
      int, public, save ::  cv_common_fixed_0_bc=0,                   &  ! first point fixed (not simulated)
     &                      cv_common_fixed_1_bc=0                       ! last point fixed (not simulated)
!
      ! parameters
!     define indices into r array:
      int, parameter, public ::     main=1,                             & ! current z
     &                              comp=2,                             & ! previous z
     &                              ref=3,                              &  ! reference z (initial)
     &                              ref2=4,                             & ! reference z (average)
     &                              zcur=5,                             & ! z at current MD iteration (combination of main and comp)
     &                              zold=6,                             & ! z at previous MD iterations (combination of main and comp); currently not used
     &                              dz=7,                               & ! vector tangent to the path
     &                              frunave=8,                          & ! running average between string steps
     &                              instant=9,                          & ! (instantaneous) theta(x)
     &                              previnst=10,                        & ! previous value of (instantaneous) theta(x)
     &                              forces=11,                          & ! average forces on z (dF/dz) for evolution
     &                              forces2=12,                         & ! instantaneous forces (not used for evolution)
     &                              fbave=13,                           & ! average conditional on flat-bottom region of potential
     &                              fbave_count=14,                     & ! must follow fbave for fb-stats to output correctly
     &                              energy=15                             ! energy of this restraint
!
      int, parameter, public :: main_offset=15 ! num of parameters above
!
      character(len=8), parameter, public :: real_format='(E23.15)'
      character(len=5), parameter, public :: int_format='(I10)'
      int, save, public :: histcol=instant ! history column
!
      contains
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_init(max_cv)
       use sm_var, only: nstring, smcv_initialized
      __DEP_MULTICOM
!
       int, optional :: max_cv
       int :: nrep ! number of total replicas
       int :: i
!
       interface
        subroutine smcv_init(maxcv); int, optional :: maxcv ; end subroutine smcv_init
       end interface
!
       if (.not.smcv_initialized) call smcv_init() ! defines nstring
!
       if (.not.cv_common_initialized) then
        if (present(max_cv)) max_cv_common=max_cv
!
        nrep=nstring+cv_common_fixed_0_bc+cv_common_fixed_1_bc
        cv%num_cv=0
        call cv_common_clear_hist()
!
!======================================= ALLOCATIONS
        allocate(cv%r(max_cv_common, max_hist_base+main_offset))
!
        if (cv_common_fixed_0_bc.eq.1) then
         allocate(cv%r_bc_0(max_cv_common))
         cv%r_bc_0=__NAN
        endif
!
        if (cv_common_fixed_1_bc.eq.1) then
         allocate(cv%r_bc_1(max_cv_common))
         cv%r_bc_1=__NAN
        endif
!
! metric M tensor : 1 -- running average in current averaging window (i.e. a short-time average)
!                   2 -- reduced M from all slave processors (in parallel); think of as scratch
!                   3 -- inverse of M ; by default, computed from M(4) -- see below
!                   4 -- long-time average of M. In smcv evolution M(4)=M(1); expo evolution M(4) has long memory
        allocate(cv%M(max_cv_common,max_cv_common,4)) 
!
        allocate(cv%priv(max_cv_common)) ! allocate pointer array
        do i=1, max_cv_common
         nullify(cv%priv(i)%p) ! initialize pointer array
         nullify(cv%priv(i)%amap_ptr) ! nullify pointer to atom map (see above)
         nullify(cv%priv(i)%pr)
        enddo
        allocate(cv%type(max_cv_common))
        allocate(cv%active(max_cv_common))
        allocate(cv%k(max_cv_common))
        allocate(cv%gamma(max_cv_common))
        allocate(cv%temperature(max_cv_common))
        allocate(cv%minval(max_cv_common))
        allocate(cv%maxval(max_cv_common))
        allocate(cv%fbwidth(max_cv_common))
        allocate(cv%num_fb_ave(max_cv_common))
        allocate(cv%weight(max_cv_common))
        allocate(cv%ds(nrep-1))
        allocate(cv%curvature(nrep-2))
        allocate(cv%fe(nrep))
        allocate(cv%feav(nrep))
!=============================================== INITIALIZATION
        cv_common_initialized=.true.
        cv%r=__NAN
        cv%r(:,frunave)=zero    ! 8/2016 : displacement for force running average (formerly CV running average)
        cv%r(:,previnst)=zero  !
        cv%r(:,fbave)=zero  !
        cv%M=__NAN
        cv%type=-1
        cv%active=.true. ! all cv active by default (and for compatibility with previous code)
        cv%k=zero
        cv%kpara=zero
        cv%kperp=zero
        cv%gamma=zero
        cv%temperature=zero
        cv%minval=-__INF
        cv%maxval= __INF
        cv%fbwidth=zero
        cv%weight=zero ! need to be initialized by user
        cv%ds=zero
        cv%curvature=zero
        cv%fe=zero
        cv%feav=zero
        cv%dt=zero
        cv%work=zero
        cv%num_average_samples=0
        cv%num_fe_samples=0
        cv%num_fb_ave=0
       endif
       end subroutine cv_common_init
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_done()
!
       int :: i
       cv%num_cv=0
       call cv_common_clear_hist()
       cv%dt=zero
       if (cv_common_initialized) then
        deallocate(cv%r)
!
        if (cv_common_fixed_0_bc.eq.1) then
         deallocate(cv%r_bc_0)
        endif
!
        if (cv_common_fixed_1_bc.eq.1) then
         deallocate(cv%r_bc_1)
        endif
!
        do i=1, max_cv_common
         __FREE(cv%priv(i)%p)
         __FREE(cv%priv(i)%amap_ptr)
         __FREE(cv%priv(i)%pr)
        enddo
        call int_vlist_done(cv%amap) ! deallocate amap if necessasry
!
        deallocate(cv%M)
        __FREE(cv%grad)
        nullify(cv%gradx)
        nullify(cv%grady)
        nullify(cv%gradz)
!        if (associated(cv%gradx)) deallocate(cv%gradx)
!        if (associated(cv%grady)) deallocate(cv%grady)
!        if (associated(cv%gradz)) deallocate(cv%gradz)
        deallocate(cv%type)
        deallocate(cv%active)
        deallocate(cv%k)
        deallocate(cv%gamma)
        deallocate(cv%temperature)
        deallocate(cv%maxval)
        deallocate(cv%minval)
        deallocate(cv%weight)
        deallocate(cv%fbwidth)
        deallocate(cv%num_fb_ave)
        deallocate(cv%ds)
        deallocate(cv%curvature)
        deallocate(cv%fe)
        deallocate(cv%feav)
        cv_common_initialized=.false.
        cv_common_weights_initialized=.false.
        cv_common_Minv_initialized=.false.
        cv_common_voronoi_initialized=.false.
        cv_common_grad_initialized=.false.
        cv_common_dz_initialized=.false.
        cv_common_k_initialized=.false.
        cv_common_kpara_initialized=.false.
        cv_common_kperp_initialized=.false.
        cv_common_rex_initialized=.false.
       endif
       end subroutine cv_common_done
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       function cv_common_add(type,k,gamma,weight,fbwidth,temp,minv,maxv)
!
       int :: type
       float, optional :: k, gamma, weight, fbwidth, temp, minv, maxv
! k: 		force constant
! gamma:	friction for evolution
! weight:	weight factor for reparametrization
! fbwidth:	width of flat-bottom potential (0 recovers harmonic potential)
! temp:		temperature for BD evolution (0 means steepest descent; higher temp for TAMD)
! minv:	minimum allowed value for cv
! maxv:	maximum allowed value for cv
!      locals
       int j
       int cv_common_add ! returns index into cv array
       __IAM(CV_COMMON_ADD)
!      do work
       if (.not.cv_common_initialized) call cv_common_init()
       j=cv%num_cv + 1
       if  (j.le.max_cv_common) then
!       assign cv values
        cv%num_cv=j
        cv%r(j,:)=__NAN ! undefined value
        cv%r(j,frunave)=zero
        cv%r(j,previnst)=zero
        cv%r(j,fbave)=zero     ! needed when CVs include angles which need to be averaged (b/c existing values are sticky)
!
        cv%k(j)=zero
        if (present(k)) then
         if (k.ge.zero) then  ! negative k are ignored
          cv%k(j)=k
         else
          __WRN(whoami,'NEGATIVE FORCE CONSTANT SPECIFIED. WILL RESET TO ZERO.')
         endif
        endif
!
        if (present(gamma)) then
         if (gamma.gt.zero) then
          cv%gamma(j)=one/gamma; ! disallow zero
         else
          __WRN(whoami,'NONPOSITIVE GAMMA SPECIFIED. SETTING TO INFINITY (NO DIFFUSION).')
          cv%gamma(j)=zero;
         endif
        else
         cv%gamma(j)=one;
        endif
!
        if (present(fbwidth)) then
         if (fbwidth.ge.zero) then
          cv%fbwidth(j)=half*fbwidth ! NOTE THAT I AM STORING HALF-WIDTH FOR COMPUTATION EFFICIENCY
         else
          __WRN(whoami,'NEGATIVE WIDTH OF FLAT-BOTTOM POTENTIAL SPECIFIED. WILL SET TO ZERO.')
          cv%fbwidth(j)=zero;
         endif
        else
         cv%fbwidth(j)=zero;
        endif
! BD evolution temperature
        if (present(temp)) then
         if (temp.ge.zero) then
          cv%temperature(j)=temp
         else
          __WRN(whoami,'NEGATIVE BD EVOLUTION TEMPERATURE SPECIFIED. WILL SET TO ZERO.')
          cv%temperature(j)=zero;
         endif
        else
         cv%temperature(j)=zero;
        endif
! reparametrization weight
        if (present(weight)) then
         if (weight.gt.zero) then  ! negative weights are ignored
          cv%weight(j)=weight
         endif
        else
          __WRN(whoami,'NEGATIVE CV WEIGHT SPECIFIED. WILL SET TO ZERO.')
         cv%weight(j)=zero
        endif
! minimum and maximum values
        if (present(minv)) cv%minval(j)=minv
        if (present(maxv)) cv%maxval(j)=maxv
!==============================================================================
        cv%type(j)=type
        cv_common_add=j
!
        if (any(cv%weight(1:cv%num_cv).le.zero)) then
         cv_common_weights_initialized=.false.
        else
         cv_common_weights_initialized=.true.
        endif
        cv%wrss=1./sqrt( sum( cv%weight(1:cv%num_cv)**2) )
       else ! out of bounds
!       maximum storage space exceeded; for now complain and exit; in the future, can reallocate
        __WRN( whoami,'MAXIMUM NUMBER OF CV EXCEEDED. NOTHING DONE.')
        cv_common_add=0
        return
       endif
       end function cv_common_add
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_fill(i,val,c)
!
       int :: i
       float :: val
       int, optional :: c
       int :: c1
       __IAM(CV_COMMON_FILL)
!      do work:
       if (present(c)) then
        if (c.lt.1.or.c.gt.main_offset+max_hist_base) then
         __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
         return
        else ! c valid
         c1=c
        endif
       else ! c was not passed
        c1=main
       endif
       cv%r(i,c1)=val
       end subroutine cv_common_fill
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_grad_init()
!      initialize cv%grad arrays
       if (associated(cv%grad)) deallocate(cv%grad)
!       if (associated(cv%gradx)) deallocate(cv%gradx) !    delete old data if present
!       if (associated(cv%grady)) deallocate(cv%grady) !    delete old data if present
!       if (associated(cv%gradz)) deallocate(cv%gradz) !    delete old data if present
       allocate(cv%grad(cv%num_cv, cv%amap%last, 2, 3)) ! x,y,z components are indexed by last dimension
       cv%gradx=>cv%grad(:, :, :, 1);
       cv%grady=>cv%grad(:, :, :, 2);
       cv%gradz=>cv%grad(:, :, :, 3);
!       allocate(cv%gradx(cv%num_cv, cv%amap%last, 2))
!       allocate(cv%grady(cv%num_cv, cv%amap%last, 2))
!       allocate(cv%gradz(cv%num_cv, cv%amap%last, 2))
!       cv%gradx=zero; cv%grady=zero; cv%gradz=zero
       cv%grad=zero;
       cv_common_grad_initialized=.true.
       end subroutine cv_common_grad_init
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_compute_Minv(inverse_LU, ind)
       use lu, only: inv_lu  ! matrix inverse by LU decomposition
       use multidiag, only: inv_mdiag
!
       bool, optional, intent(in) :: inverse_LU
       int, optional, intent(in) :: ind
       bool :: qLU=.true.
       int :: bug, Mind
       if (present(inverse_LU)) then ; qLU=inverse_LU; endif
       if (present(ind)) then ; Mind=ind; else ; Mind=4 ; endif
!    assume matrix M is regular
!    if using multidiag, also assume it has nonzero diagonals
       if (qLU) then
        call inv_lu(cv%M(1:cv%num_cv,1:cv%num_cv,Mind),                    &
     &            cv%M(1:cv%num_cv,1:cv%num_cv,3), cv%num_cv, bug) ! M inverse in M(3)
       else
        call inv_mdiag(cv%M(1:cv%num_cv,1:cv%num_cv,Mind),                 &
     &            cv%M(1:cv%num_cv,1:cv%num_cv,3), cv%num_cv, bug)
       endif
!
       if (bug.eq.0) cv_common_Minv_initialized=.true.
!
       end subroutine cv_common_compute_Minv
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_compute_wgt()
!      compute weight array from M matrix
!      assume that M is valid on each node
      __DEP_MULTICOM
      __DEP_MPI
!
#include "mpitype.def"
!
       float :: s, sum
       int :: i, j, ierror
!    local
!
       bool :: qroot
!
       float :: Mave(max_cv_common, cv%num_cv)
       __IAM(CV_COMMON_COMPUTE_WGT)
!
       qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL)
       if (qroot) then
        if (SIZE_STRNG.gt.1) then
__MPI_ONLY         call mpi_ALLREDUCE(cv%M(1,1,3),Mave,max_cv_common*cv%num_cv,       &
__MPI_ONLY     &        mpifloat, MPI_SUM, MPI_COMM_STRNG, ierror) ! use M inverse averaged along string
        else
         Mave=cv%M(1,1,3)
        endif
!     11/30/08: note: it is not completely clear to me how the weights should computed
        do j=1,cv%num_cv
         s=zero; do i=1, cv%num_cv ; s=s+Mave(i,j)**2 ; enddo
!        s=one*SIZE_STRNG/sqrt(s) ! average, since we used MPI_SUM above
         s=(s/SIZE_STRNG)**fourth ! average [SIZE_STRNG], since we used MPI_SUM above
         cv%weight(j)=s ! for positions, s will be sqrt(mass), as expected
        enddo
        if (any(cv%weight(1:cv%num_cv).eq.0)) &
        __WRN( whoami,'ZERO CV WEIGHT COMPUTED.')
       endif ! qroot
!
! broadcast to slaves
!
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
        __BROADCAST_LOCAL_4B(cv%weight(1:cv%num_cv), cv%num_cv) !__CHARMM_ONLY##SINGLE
        __BROADCAST_LOCAL_8B(cv%weight(1:cv%num_cv), cv%num_cv) !__CHARMM_ONLY##.not.SINGLE
#else
        __BROADCAST_LOCAL(cv%weight(1:cv%num_cv), cv%num_cv, mpifloat) ! broadcast within groups
#endif
       endif
!
       cv%wrss=1./sqrt( sum( cv%weight(1:cv%num_cv)**2) ) ! compute rms
       cv_common_weights_initialized=.true.
       end subroutine cv_common_compute_wgt
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_wgt(iunit,fmt,qraw_,qhead_)
!
       use parser, only : itoa
!      only root process must call
       int, intent(in) :: iunit
       character(len=*), intent(in), optional :: fmt
       __OPAR(qraw,bool)
       __OPAR(qhead,bool)
!
       int :: i
       character(len=80) :: frm
       __IAM(CV_COMMON_PRINT_WGT)
!      begin
       __PRESENT(qraw,.true.)
       __PRESENT(qhead,.true.)
       if (.not.qraw) then 
        if(qhead) call cv_common_print_header(iunit)
#define _W write(iunit,*)
       _W 'smcv {'
       _W '# Wx : weight corresponding to CV #x in a scalar product; e.g. : ( SUM_{i=1}^N Wi x cv_i x cv_i ) / SUM_{i=1}^N Wi'
       endif ! qraw
!
       if (.not.cv_common_weights_initialized) then
        if (qraw) then
         __WRN(whoami,'CV WEIGHTS NOT INITIALIZED.')
        else
         _W '# CV weights not initialized'
         _W 'weights_initialized = no'
         _W '} # smcv'
         return
        endif ! qraw
       endif ! init
!
       if (qraw) then
        if (.not.present(fmt)) then
         write(frm,'("(",I5,"E15.5)")') max(cv%num_cv,1)
        else
         frm=fmt
        endif
        write(iunit,frm) cv%weight(1:cv%num_cv)
       else ! human-readable
        do i=1, cv%num_cv
         _W 'W'//trim(itoa(i))//' = ',cv%weight(i)
        enddo
        _W '} # smcv'
       endif ! qraw
#undef _W
!
       end subroutine cv_common_print_wgt
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_wgt(iunit, qraw_, qlocal_)
       use parser, only : itoa, parse_file, parser_clear_context, getval_nocase, existtag_nocase, getval_nocase_upper, atol
       use cmd
!
      __DEP_MULTICOM
      __DEP_MPI
!
#include "mpitype.def" 
!
       int, optional, intent(in) :: iunit
       int :: ierror, i, l
       bool :: weights_initialized
       __OPAR(qraw,bool)
       __OPAR(qlocal,bool)
       __IAM(CV_COMMON_READ_WGT)
       character(len=maxlinelen) :: line
       character(len=20) :: keyword
!
       __PRESENT(qraw,.true.)
       __PRESENT(qlocal,.false.)
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (qlocal.or.ME_STRNG.eq.0) then
!
         if (qraw) then ! raw data
          read(abs(iunit),*) cv%weight(1:cv%num_cv) ! only root reads
         else ! human-readable restart
          if (present(iunit)) call parse_file(abs(iunit),&
#ifdef __PARALLEL
     &      MPI_COMM_NULL,&
#endif
     &      quiet_=.true.)
          __GET_OPT_PAR_B(weights_initialized,weights_initialized,.true., __MYCTX)
          if (.not.weights_initialized) then
           __WRN(whoami, 'RESTART FILE REPORTS UNINITIALIZED CV WEIGHTS.');
          endif
          do i=1, cv%num_cv
           keyword='W'//trim(itoa(i))
           if (weights_initialized.or.existtag_nocase(keyword)) then
            line=getval_nocase(keyword,__MYCTX)
            if (len_trim(line).gt.0) then
             read(line,*,iostat=ierror) cv%weight(i)
             if (ierror.ne.0) then
              __WRN(whoami, 'ERROR READING VARIABLE FROM LINE "'//trim(line)//'"')
              cycle
             endif
            endif ! line
           endif ! weights
          enddo ! CVs
!
          if(present(iunit)) then
           if (iunit.lt.0) call parser_clear_context(__MYCTX)
          endif
!
         endif ! qraw
         if (any(cv%weight(1:cv%num_cv).le.0)) __WRN( whoami,'READ ZERO OR NEGATIVE CV WEIGHT')
        endif ! qlocal or ME_STRNG==0
        if (.not.qlocal.and.SIZE_STRNG.gt.1) __BROADCAST_STRING(cv%weight, cv%num_cv, mpifloat)
       endif ! MPI_COMM
!    broadcast to slave nodes
       if (ME_LOCAL.ne.MPI_UNDEFINED.and.SIZE_LOCAL.gt.1) &
!     &  call MPI_BCAST(cv%weight, cv%num_cv, mpifloat,
!     &                     0,MPI_COMM_LOCAL,ierr)
#ifdef __CHARMM
     &  __BROADCAST_LOCAL_4B(cv%weight,cv%num_cv) !__CHARMM_ONLY##SINGLE
     &  __BROADCAST_LOCAL_8B(cv%weight,cv%num_cv) !__CHARMM_ONLY##.not.SINGLE
#else
     &  __BROADCAST_LOCAL(cv%weight,cv%num_cv,mpifloat)
#endif
!
       if (any(cv%weight(1:cv%num_cv).le.zero)) then
        cv_common_weights_initialized=.false.
       else
        cv_common_weights_initialized=.true.
       endif
!
       cv%wrss=1./max(__ERRTOL, sqrt( sum( cv%weight(1:cv%num_cv)**2) ))
!
       end subroutine cv_common_read_wgt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_compute_k()
!      relevant for planar sampling only, which is to be overhauled
!
       int :: i
       __IAM(CV_COMMON_COMPUTE_K)
!
       if (cv_common_weights_initialized) then
        if (cv_common_kpara_initialized) then
         do i=1, cv%num_cv
          cv%k(i)=cv%kpara*(cv%weight(i)**2)
         enddo
         cv_common_k_initialized=.true. ! note: this flag only relevant for off-path sampling
         if (any(cv%k(1:cv%num_cv).lt.0)) &
     &   __WRN( whoami,'COMPUTED NEGATIVE FORCE CONSTANT')
        else
         __WRN( whoami,'PARALLEL FORCE CONSTANT NOT SET. NOTHING DONE.')
        endif
       else
         __WRN( whoami,'CV WEIGHTS NOT INITIALIZED. NOTHING DONE.')
       endif
!
       end subroutine cv_common_compute_k
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_compute_dr()
       use sm_var, only: nstring
       __DEP_MULTICOM
       __DEP_MPI 
!
       int :: ierror
!
#include "mpitype.def"
!      interface to 'compute_dr' utility routine
       interface
        subroutine compute_dr(rin,drout,wgt,n,                          &
     &   d_arclength, curvature, r_bc_0, r_bc_1) ! arrays for fixed bc
!
      __CHARMM_ONLY __DEP_KINDS
!
         int :: n
         float :: rin(n), drout(n), wgt(n)
         float :: d_arclength(:), curvature(:)
         float, optional :: r_bc_0(n), r_bc_1(n)
        end subroutine compute_dr
       end interface
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.                         &
     &                         SIZE_STRNG.gt.1) then
        if (cv%num_cv.gt.0) then
         if (cv_common_fixed_0_bc.eq.1) then
          if (cv_common_fixed_1_bc.eq.1) then
           call compute_dr(RIN=cv%r(1:cv%num_cv,main),                  &
     &      DROUT=cv%r(1:cv%num_cv,dz), WGT=cv%weight,                  &
     &      N=cv%num_cv,D_ARCLENGTH=cv%ds,CURVATURE=cv%curvature,       &
     &      R_BC_0=cv%r_bc_0, R_BC_1=cv%r_bc_1)
          else
           call compute_dr(RIN=cv%r(1:cv%num_cv,main),                  &
     &      DROUT=cv%r(1:cv%num_cv,dz),WGT=cv%weight,                   &
     &      N=cv%num_cv,D_ARCLENGTH=cv%ds,CURVATURE=cv%curvature,       &
     &      R_BC_0=cv%r_bc_0)
          endif
         else
          if (cv_common_fixed_1_bc.eq.1) then
           call compute_dr(RIN=cv%r(1:cv%num_cv,main),                  &
     &      DROUT=cv%r(1:cv%num_cv,dz),WGT=cv%weight,                   &
     &      N=cv%num_cv,D_ARCLENGTH=cv%ds,CURVATURE=cv%curvature,       &
     &      R_BC_1=cv%r_bc_1)
          else
           call compute_dr(RIN=cv%r(1:cv%num_cv,main),                  &
     &      DROUT=cv%r(1:cv%num_cv,dz),WGT=cv%weight,                   &
     &      N=cv%num_cv,D_ARCLENGTH=cv%ds,CURVATURE=cv%curvature)
          endif
         endif
        endif
       endif ! root nodes
!
!      send to slaves
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
__CHARMM_ONLY##IF SINGLE
        __BROADCAST_LOCAL_4B(cv%r(1:cv%num_cv,dz),cv%num_cv)
        __BROADCAST_LOCAL_4B(cv%ds,nstring-1)
        __BROADCAST_LOCAL_4B(cv%curvature, nstring-2)
__CHARMM_ONLY##ELSE
        __BROADCAST_LOCAL_8B(cv%r(1:cv%num_cv,dz),cv%num_cv)
        __BROADCAST_LOCAL_8B(cv%ds,nstring-1)
        __BROADCAST_LOCAL_8B(cv%curvature, nstring-2)
__CHARMM_ONLY##ENDIF
#else
        __BROADCAST_LOCAL(cv%r(1:cv%num_cv,dz),cv%num_cv,mpifloat)
        __BROADCAST_LOCAL(cv%ds,nstring-1,mpifloat)
        __BROADCAST_LOCAL(cv%curvature, nstring-2,mpifloat)
#endif
       endif
!
       cv_common_dz_initialized=.true.
!      cv%r(1,dz) contains the vector tangent to cv%r(:,1) scaled
!      by wgt
       end subroutine cv_common_compute_dr
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_dr(iunit) ! global print
       int :: iunit
       call cv_common_print_global(iunit,dz,.false.) ! do not print BC
       end subroutine cv_common_print_dr
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_dr(iunit) ! global print
       int :: iunit
!      local
       int :: bc0, bc1
!      use a trick to read the tangent file
!      note: cannot change BC between runs, because the tangents to the BC are not stored!
!            in that case we will need to recompute using cv_common_compute_dr()
!      for example, you cannot run off-path sampling with all replicas and then switch
!      to fixed endponits, reading the tangent vector from the old file
       bc0=cv_common_fixed_0_bc;     bc1=cv_common_fixed_1_bc  ! store bc info
       cv_common_fixed_0_bc=0; cv_common_fixed_1_bc=0
       call cv_common_read_global(iunit,dz,.true.) ! make sure everything gets read from the dr file
!      restore bc
       cv_common_fixed_0_bc=bc0;     cv_common_fixed_1_bc=bc1  ! store bc info
!
       cv_common_dz_initialized=.true.
       end subroutine cv_common_read_dr
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_repa(interp_method, def, iterations, dst_c)
       use sm_var, only: nstring
       
       __DEP_MULTICOM
       __DEP_MPI 
!
#include "mpitype.def"
!
       int :: interp_method, iterations, ierror
       float, optional :: dst_c
       float :: def
       __IAM(CV_COMMON_REPA)
!
!      interfaces to reparameterization routine
!      needed because of the keyword calls
!
       interface
        subroutine interp_driver_sci(rin,rout,wgt,n,                    &
     &   interp_method,tol,max_iterations,d_arclength, curvature,       &
     &   dst_cutoff,dr,r_bc_0, r_bc_1)
!
      __CHARMM_ONLY __DEP_KINDS
!
        int n
        float rin(n), rout(n), wgt(n)
        int, intent(in) ::  interp_method
        int max_iterations
        float :: tol, d_arclength(:), curvature(:)
        float, optional :: dst_cutoff
        float , optional :: dr(n), r_bc_0(n), r_bc_1(n)
        end subroutine interp_driver_sci
!
        subroutine interp_linear_exact(rin,rout,wgt,n,                  &
     &   d_arclength, curvature,                                        &
     &   drout,                                                         &
     &   r_bc_0, r_bc_1)
!
      __CHARMM_ONLY __DEP_KINDS
!
        int :: n
        float :: rin(n), rout(n), wgt(n)
        float :: d_arclength(:), curvature(:)
        float, optional :: drout(n) ! optional computation of tangent
        float , optional :: r_bc_0(n), r_bc_1(n)
       end subroutine interp_linear_exact
!
       end interface
!
       if (.not.cv_common_weights_initialized) then
        __WRN( whoami, 'CV WEIGHTS NOT INITIALIZED')
       endif
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.                         &
     &                         SIZE_STRNG.gt.1) then
        if (cv%num_cv.gt.0) then ! in-place repa
         if (present(dst_c)) then
          if (cv_common_fixed_0_bc.eq.1) then
           if (cv_common_fixed_1_bc.eq.1) then
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature,DST_CUTOFF=dst_c, R_BC_0=cv%r_bc_0,  &
     &      R_BC_1=cv%r_bc_1)
           else
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature,DST_CUTOFF=dst_c, R_BC_0=cv%r_bc_0)
           endif
          else
           if (cv_common_fixed_1_bc.eq.1) then
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature,DST_CUTOFF=dst_c, R_BC_1=cv%r_bc_1)
           else
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature,DST_CUTOFF=dst_c)
           endif
          endif
         else
          if (cv_common_fixed_0_bc.eq.1) then
           if (cv_common_fixed_1_bc.eq.1) then
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature, R_BC_0=cv%r_bc_0,                   &
     &      R_BC_1=cv%r_bc_1)
           else
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature,R_BC_0=cv%r_bc_0)
           endif
          else
           if (cv_common_fixed_1_bc.eq.1) then
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature,R_BC_1=cv%r_bc_1)
           else
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature)
           endif
          endif
         endif
!     add current CV coordinates to running average -- this is now done in elsewhere
!        call cv_common_update_ave()
!     call moved to smcv_master
!       if (cv_common_voronoi_initialized) call cv_common_voronoi_update() ! update V.cell nodes
        endif
       endif
!
!      send to slaves
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
__CHARMM_ONLY##IF SINGLE
        __BROADCAST_LOCAL_4B(cv%r(1:cv%num_cv,main),cv%num_cv)
        __BROADCAST_LOCAL_4B(cv%r(1:cv%num_cv,dz),cv%num_cv)
        __BROADCAST_LOCAL_4B(cv%ds,nstring-1)
        __BROADCAST_LOCAL_4B(cv%curvature, nstring-2)
__CHARMM_ONLY##ELSE
        __BROADCAST_LOCAL_8B(cv%r(1:cv%num_cv,main),cv%num_cv)
        __BROADCAST_LOCAL_8B(cv%r(1:cv%num_cv,dz),cv%num_cv)
        __BROADCAST_LOCAL_8B(cv%ds,nstring-1)
        __BROADCAST_LOCAL_8B(cv%curvature, nstring-2)
__CHARMM_ONLY##ENDIF
#else
        __BROADCAST_LOCAL(cv%r(1:cv%num_cv,main),cv%num_cv,mpifloat)
        __BROADCAST_LOCAL(cv%r(1:cv%num_cv,dz),cv%num_cv,mpifloat)
        __BROADCAST_LOCAL(cv%ds,nstring-1,mpifloat)
        __BROADCAST_LOCAL(cv%curvature, nstring-2,mpifloat)
#endif
       endif
!
       end subroutine cv_common_repa
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_evolve_smcv(dt)
!      this is the main/original evolution routine that essentially follows the SMCV paper Maragliano et al.
!      not parallelized because it should be cheaper to execute locally than to broadcast info
!      in the future, may compute on roots, then broadcast
      __DEP_CONST
!
!      the timestep can be specified optionally
!      nskip ( the number of history elements to skip when computing the average) is also optional
       float, optional :: dt
!      locals
       float :: dummy
       int :: i
       float :: delt
       __IAM(CV_COMMON_EVOLVE_SMCV)
!      do work
       cv%r(:,comp)=cv%r(:,main) ! save current as "old" coordinates in column 2
       if (present(dt)) then; delt=dt; else ; delt=cv%dt; endif
!
       if (cv%num_run_ave.lt.1) then
        __WRN( whoami,'NO SLICES IN THE AVERAGE. NOTHING DONE')
        return
       endif
!    (-)forces acting on the CV ( computed from approximate FE gradient i.e. running average of the displacement; see smcv_master, addhist):
       cv%r(1:cv%num_cv,forces) = cv%k(1:cv%num_cv) * cv%r(1:cv%num_cv,frunave)
!    compute free energy ( uses cv%r(:,forces) )
       call cv_common_compute_fe_fd()
!    add fe to the fe running average
       call cv_common_update_fe_ave()
!    now evolve string -- take the negative of the FE gradient
!    (we are assuming that M has been computed)
!    explicit Euler advancement (any reason to use more accuracy, e.g. A-B ?)
!
!    NOTE : below, consistent units require that cv%gamma have units of time (recall that cv%gamma is actually 1/friction[time])
       do i=1, cv%num_cv
        cv%r(i,main)=cv%r(i,main)-delt*cv%gamma(i)*                     &
     &               dot_product(cv%M(i,1:cv%num_cv,2),cv%r(1:cv%num_cv,forces))
        if (cv%type(i).eq.angle_com.or.cv%type(i).eq.anglvec) cv%r(i,main)=abs(cv%r(i,main))
       enddo
!    now reset history (number of slices in the running average)
       cv%num_run_ave=0
!
       end subroutine cv_common_evolve_smcv
!====================================================================================
       subroutine cv_common_evolve_sd(dt) ! steepest descent evolution (no M) with temp; compare with cv_common_evolve_smcv
!                                         temperature not added yet
      __DEP_CONST
      __DEP_RANDOM
!
!      the timestep can be specified optionally
!      nskip ( the number of history elements to skip when computing the average) is also optional
       float, optional :: dt
       float :: dummy
       int :: i
       float :: delt, normal_deviate(1)
!
       __IAM(CV_COMMON_EVOLVE_SD)
!      do work
       cv%r(:,comp)=cv%r(:,main) ! save current as "old" coordinates in column 2
       if (present(dt)) then; delt=dt; else ; delt=cv%dt; endif
!
       if (cv%num_run_ave.lt.1) then
        __WRN( whoami,'NO SLICES IN THE AVERAGE. NOTHING DONE')
        return
       endif
!    (-)forces acting on the CV ( computed from approximate FE gradient i.e. running average of the force; see smcv_master, addhist):
       cv%r(1:cv%num_cv,forces) = cv%k(1:cv%num_cv) * cv%r(1:cv%num_cv,frunave)
!    compute free energy ( uses cv%r(:,forces) )
!    note that the FE below will be meaningless for TAMD (SD evolution at finite temp = BD)
       call cv_common_compute_fe_fd()
!    add fe to the fe running average
       call cv_common_update_fe_ave()
!    now evolve string -- take the negative of the FE gradient
!    NOTE : here, consistent units require that D=kT/gamma, where D is the diffusion coefficient; which means that gamma has units mass/time
!    cv%gamma is 1/gamma (i.e. 1/friction), which means that cv%gamma has implicit units time/mass
!
       do i=1, cv%num_cv
        cv%r(i,main)=cv%r(i,main) - delt * cv%gamma(i) * cv%r(i,forces)                             ! drift
!
        if (cv%temperature(i).gt.zero) then
#ifdef __CHARMM
         normal_deviate=bmgaus(one,__SEED)
#else
         call randomg_vector(normal_deviate,1)
#endif
!
         __INCR(cv%r(i,main),      sqrt ( two*cv%gamma(i)*cv%temperature(i)*kboltz*delt ) * normal_deviate(1)) ! diffusion if T>0
        endif ! temperature > 0 ; NOTE that boundary conditions on the CV will be applied in cv_common_apply_bc
!
        if (cv%type(i).eq.angle_com.or.cv%type(i).eq.anglvec) cv%r(i,main)=abs(cv%r(i,main))
       enddo
!    now reset history (number of slices in the running average)
       cv%num_run_ave=0
!
       end subroutine cv_common_evolve_sd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_evolve_expo(a,nskip)
!      evolve CV using equation: z(n+1)=a * z(n) + (1-a) * <theta(x)>
      __DEP_CONST
!
       float, intent(in) :: a
       int, optional, intent(in) :: nskip
!      locals
       float :: a1
       int :: numskip, i, j ! , k, n, k1, k2, k3, k4
       __IAM(CV_COMMON_EVOLVE_EXPO)
       float :: temp(max_hist_base)=zero
!
!      do work
!      only valid for 0 <= a <= 1
       if (a.lt.0.or.a.gt.1) then
        __WRN( whoami,'MEMORY PARAMETER MUST BE BETWEEN 0 AND 1')
        return
       endif
       if (present(nskip)) then ; numskip=nskip; else; numskip=0; endif
       if (numskip.ge.cv%num_hist) then
        __WRN( whoami,'SKIPPED ALL ELEMENTS. NOTHING DONE')
        return
       endif
       if (cv%num_run_ave.lt.1) then
        __WRN( whoami,'NO SLICES IN THE AVERAGE. NOTHING DONE')
        return
       endif
!    (-)forces acting on the CV ( computed from approximate FE gradient i.e. running average of the force; see smcv_master, addhist):
       cv%r(1:cv%num_cv,forces) = cv%k(1:cv%num_cv) * cv%r(1:cv%num_cv,frunave)
!    compute free energy ( uses cv%r(:,forces) )
       call cv_common_compute_fe_fd()
!    add fe to the fe running average
       call cv_common_update_fe_ave()
!
!       cv%r(:,:,comp)=cv%r(:,:,main) ! save current as "old" coordinates in column 2
!     precompute indices for faster copying
!       k1=cv%beg_hist+main_offset
!       k2=max_hist_base+main_offset
!       k3=main_offset+1
!       k4=k1-1
! the above assumes that all of the history slots are to be used;
! to print only the _actual_ history which may be smaller than the
! max number of slots, use cv%num_hist
!
       a1=one-a
!       n=cv%num_hist-numskip ! number of elements
       do i=1, cv%num_cv
!        temp=(/ (cv%r(i,k),k=k1,k2),(cv%r(i,k),k=k3,k4) /)  ! 'unwrap' history
!c     need CV coordinates that are consistent with the current theta(x): simply take the last slice from above:
!        cv%r(i,comp)=temp(cv%num_hist)
!        (?) replace above line with :
!        cv%r(i,comp)=cv%r(i,instant) ! this should be better for alternating restrained/unrestrained equilibration
        cv%r(i,comp)=cv%r(i,main) ! better for restraints
!===== evolve i_th cv ======
! first, need to compute running average from history
! (as of 8.2016 : runave no longer 
!c        cv%r(i,main)=       a  * cv%r(i,main) +
!c     &                      a1 * sum(temp(numskip+1:cv%num_hist))/n

! VO 3.24.09: angle correction
! NOTE: angle_com main could in principle be negative (e.g. if read in from file)
! 8.2016 : runave is removed ; instead, have frunave, which corresponds (in the case of 0 fb potential) to
! ave < cv%(i,main) - cv%(i,instant) > (see smcv_master)
! In the case of nonzero fb width, frunave is the distance from the fb window (which is probably not what you want)
        __INCR( cv%r(i,main), a1 * ( cv%r(i,frunave) - cv%r(i,main) ) )
!
        if (cv%type(i).eq.angle_com.or.cv%type(i).eq.anglvec) cv%r(i,main)=abs(cv%r(i,main))
!    not clear what to do with M in this evolution scheme : 
!    on the one hand, M should be reset and recomputed when the cv`s change;
!    on the other, as in fts-voronoi, I think we want to have a slowly varying M that includes
!    a long-term average, otherwise the CVs (path) could converge, but not M, because it is reset !
!    thus, store a long-term average in M(4)
!      M:
        do j=1,i
         __INCR ( cv%M(i,j,4) , a1 * ( cv%M(i,j,2) - cv%M(i,j,4) ) ) ;
         cv%M(j,i,4) = cv%M(i,j,4)
        enddo ! j
       enddo ! i
!      reset history (necessary if we are using it for evolution ; not so if runave/frunave are used)
!       call cv_common_clear_hist()
       cv%num_run_ave=0
!      update voronoi cells
!      call moved to smcv_master
!       if (cv_common_voronoi_initialized) call cv_common_voronoi_update() ! update V.cell nodes
       end subroutine cv_common_evolve_expo
!===============================================================
       subroutine cv_common_apply_bc()
       __DEP_PARSER
       __DEP_CONST
!      ensure that the CVs stay within the limits [ cv%minval(i), cv%maxval(i) ]
!      useful for TAMD in which the CVs evolve by a random walk on the FE surface;
!      boundary values localize sampling to a region of interest
!      bc are reflective
       __IAM(CV_COMMON_APPLY_BC)
       float :: cvmin, cvmax, d
       int :: i
!
       do i=1, cv%num_cv
!
! skip if bc values not set
        if ( (cv%minval(i).eq.-__INF).and.(cv%maxval(i).eq.__INF)) cycle
!
        select case(cv%type(i));
!+==============================================
         case(dihe_com)
!    compute minima and maxima in the range [-pi pi] :
!    first, make sure that we have both a minimum and a maximum (otherwise can violate condition via periodicity)
          if ( (cv%minval(i).eq.-__INF).or.(cv%maxval(i).eq.__INF)) then
           __WRN(whoami, ' FOR CV TYPE '//trim(cv_type_names(cv%type(i)))//' BOTH MAXIMUM AND MINIMUM VALUES MUST BE DEFINED. NOTHING DONE.')
          else
           __WRAP_ANGLE(cv%minval(i),cvmin)
           __WRAP_ANGLE(cv%maxval(i),cvmax)
           if (cvmax.lt.cvmin) then 
            __INCR(cvmax,TWOPI)
           elseif (cvmax.eq.cvmin) then
            __WRN(whoami, ' MINIMUM VALUE FOR CV '//itoa(i)//' EQUAL TO THE MAXIMUM VALUE. NOTHING DONE.')
            cycle
           endif
!    use flat-bottom algorithm to check if a reflection is necessary
           __WRAP_ANGLE( half*(cvmin+cvmax) - cv%r(i,main), d)
           d=max(zero, d - half * (cvmax-cvmin)) + min(zero, d + half * (cvmax-cvmin))
           __INCR(cv%r(i,main), two*d) ! reflect into allowed region
          endif
!================================================
         case(angle_com, anglvec)
          if ( cv%minval(i).gt.-__INF ) then
           __WRAP_ANGLE(cv%minval(i), cvmin) ; cvmin=abs(cvmin) ! linear angles defined up to sign
          endif
!
          if ( cv%maxval(i).lt.__INF ) then
           __WRAP_ANGLE(cv%maxval(i), cvmax) ; cvmax=abs(cvmax) ! linear angles defined up to sign
          endif
!
          if (cvmax.lt.cvmin) then
           d=cvmax ; cvmax=cvmin ; cvmin=d ! swap ; also works if one of the boundary values is not defined ; if both undefined, this code is not executed
          elseif (cvmax.eq.cvmin) then
           __WRN(whoami, ' MINIMUM VALUE FOR CV '//itoa(i)//' EQUAL TO THE MAXIMUM VALUE. NOTHING DONE.')
           cycle
          endif
!
!    check low boundary
          d=cvmin-abs(cv%r(i,main))
          if (d.gt.zero) then 
           __INCR(cv%r(i,main), two * d * sign(one, cv%r(i,main)))
           cycle ! to avoid high-boundary check
          endif
!    check high boundary
           d=abs(cv%r(i,main))-cvmax
           if (d.gt.zero) then
             __INCR(cv%r(i,main), -two * d * sign(one, cv%r(i,main)))
           endif
!=========================================================================
         case default ;
           if (cv%minval(i).ge.cv%maxval(i)) then
            __WRN(whoami, ' MINIMUM VALUE FOR CV '//itoa(i)//' GREATER THAN OR EQUAL TO THE MAXIMUM VALUE. NOTHING DONE.')
           elseif (cv%r(i,main).lt.cv%minval(i)) then
            cv%r(i,main) = two * cv%minval(i) - cv%r(i,main)
           elseif (cv%r(i,main).gt.cv%maxval(i)) then
            cv%r(i,main) = two * cv%maxval(i) - cv%r(i,main)
           endif
        end select
!
       enddo ! all cv
!
       end subroutine cv_common_apply_bc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_bc(first,last)
!      tells the module whether collective string operations include
!      virtual fixed CV sets; virtual because the CV are not updated;
!      can be viewed as boundary conditions on the string
       bool first, last
!      clean up first
       call cv_common_done()
!
       if (first) then
        cv_common_fixed_0_bc=1
       else
        cv_common_fixed_0_bc=0
       endif
!
       if (last) then
        cv_common_fixed_1_bc=1
       else
        cv_common_fixed_1_bc=0
       endif
       end subroutine cv_common_set_bc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       function cv_common_add_hist()
!
       int :: cv_common_add_hist
       __IAM(CV_COMMON_ADD_HIST)
!      returns index into cv%r array; the addition is done elsewhere
       if (cv%num_cv.eq.0) then
         __WRN( whoami,'NO CV DEFINED. NOTHING DONE');
         return
       endif
!
       if (cv%num_hist.eq.max_hist_base) then !          maximum storage reached
        cv%beg_hist=mod(cv%beg_hist, max_hist_base)+1 ! wrap around (avoids copying)
        cv%end_hist=mod(cv%end_hist, max_hist_base)+1
       else
        cv%end_hist=cv%end_hist+1 ! location of the last slice
        cv%num_hist=cv%num_hist+1 ! total number of slices in history
       endif
       cv_common_add_hist=cv%end_hist+main_offset ! offset the reference coords
       end function cv_common_add_hist
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_smooth_hist(d,nskip) ! not used in regular SMCV
!      filter the history of CV values so as to obtain new restraining sets
!      the new set is dumped into the main set (1)
!      filter width delta can be specified optionally, default value is 10 (arbitrary)
!      nskip (the number of history elements to skip when computing the average) is also optional
!      this algorithm is entirely heuristic
!
       __DEP_CONST 
!
       int, optional :: d
       int, optional :: nskip
!      locals
       int :: delta
       int :: numskip, i, j, k, n, k1, k2, k3, k4
       float :: t(max_hist_base)=(/(one*i,i=1,max_hist_base)/)
       float :: temp(max_hist_base)=zero, u ! for smoothing
       __IAM(CV_COMMON_SMOOTH_HIST)
!      interface to smooth2
!
       interface
        function smooth2(t,x,delta)
!
      __CHARMM_ONLY __DEP_KINDS
!
        int :: delta
        float :: t(:), x(:)
        float, dimension(size(t)) :: smooth2
        end function smooth2
       end interface
!
!      do work
       if (present(d)) then; delta=d; else ; delta=10; endif
       if (present(nskip)) then ; numskip=nskip; else; numskip=0; endif
       if (numskip.ge.cv%num_hist) then
        __WRN(whoami,'SKIPPED ALL SLICES. NOTHING DONE')
        return
       endif
!       cv%r(:,comp)=cv%r(:,main) ! save current as "old" coordinates in column 2
!     precompute indices for faster copying
       k1=cv%beg_hist+main_offset
       k2=max_hist_base+main_offset
       k3=main_offset+1
       k4=k1-1
!
       n=cv%num_hist-numskip ! number of elements
       do i=1, cv%num_cv
!    'unwrap' history
        temp=(/ (cv%r(i,k),k=k1,k2),(cv%r(i,k),k=k3,k4) /)
!
        if (cv%type(i).eq.angle_com.or.cv%type(i).eq.anglvec) temp=abs(temp) ! +/- angles indistinguishable
!
!    VO 3.24.09: angle correction
        select case(cv%type(i));
         case(dihe_com);
          do j=numskip+2, cv%num_hist
           u=temp(j)-temp(j-1)
           u=modulo(u,TWOPI)
           if (u.gt.PI) u=u-TWOPI
           temp(j)=temp(j-1)+u
          enddo
         case(angle_com, anglvec); ! cannot tell difference between +/- theta
          do j=numskip+2, cv%num_hist
           u=temp(j)-sign(temp(j-1),temp(j))
           u=modulo(u,TWOPI)
           if (u.gt.PI) u=u-TWOPI
           temp(j)=temp(j-1)+u
          enddo
        end select
!
        temp(1:n)=smooth2(                                              &
     &                     t(numskip+1:cv%num_hist),                    &
     &                  temp(numskip+1:cv%num_hist),                    &
     &                  delta)
        cv%r(i,main)=temp(n) ! set the restraint value (z) to the
        cv%r(i,comp)=temp(n) ! the theta(x) are roughly consistent with these CV
!
        if (cv%type(i).eq.angle_com.or.cv%type(i).eq.anglvec) then
         cv%r(i,comp)=abs(cv%r(i,comp))
         cv%r(i,main)=abs(cv%r(i,main))
        endif
!      M: what to do about M in this case is unclear
!         for now, setting the long-term average to the short-term evarage
        do j=1,i
          cv%M(i,j,4)=cv%M(i,j,2); cv%M(j,i,4)=cv%M(i,j,2)
        enddo
       enddo
!      reset history (necessary)
       call cv_common_clear_hist()
       cv%num_run_ave=0
       end subroutine cv_common_smooth_hist
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_hist_local(iunit, nskip) ! not used in regular SMCV
!      assume that unit is prepared
!
       int :: iunit
       int, optional :: nskip
!      locals
       int :: i, j, k, kbeg, kend, numskip
       character(len=80) :: fmt
       __IAM(CV_COMMON_PRINT_HIST)

!      do work
       if (present(nskip)) then ; numskip=nskip; else; numskip=0; endif
       if (numskip.ge.cv%num_hist) then
        __WRN( whoami,'SKIPPED ALL ELEMENTS. NOTHING PRINTED')
        return
       endif

       write(fmt,int_format) cv%num_cv
       kbeg=cv%beg_hist+numskip
       kend=cv%beg_hist+cv%num_hist-1 ! 'unwrapped' end
       do k=kbeg, kend
        j=mod(k-1,max_hist_base)+1+main_offset
         write(iunit,'('//fmt//real_format//')')                        &
     &       (cv%r(i,j),i=1,cv%num_cv) ! each line corresponds to a time slice
       enddo
       end subroutine cv_common_print_hist_local
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_hist_global(iunit, nskip) ! not used in regular SMCV
!      assume that unit is prepared
       __DEP_MPI
       __DEP_MULTICOM
!
#include "mpitype.def"
!
       int :: iunit
       int, optional :: nskip
!      locals
       int :: i, j, k, kbeg, kend, numskip, kout
       int :: ierror
       character(len=80) :: fmt
       float, pointer :: rtemp(:,:)
       float, pointer :: rall(:,:,:)
       bool :: qroot
       __IAM(CV_COMMON_PRINT_HIST)
!
!      do work
       qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL)
!
       if (qroot) then
        if (present(nskip)) then ; numskip=nskip; else; numskip=0; endif
        if (numskip.ge.cv%num_hist) then
         __WRN( whoami,'SKIPPED ALL ELEMENTS. NOTHING PRINTED')
         return
        endif
!
        kbeg=cv%beg_hist+numskip
        kend=cv%beg_hist+cv%num_hist-1 ! 'unwrapped' end
        kout=kend-kbeg+1
!      allocate data array
        if (kout.gt.0) then
         allocate(rall(cv%num_cv,kout,SIZE_STRNG))
         allocate(rtemp(cv%num_cv,kout))
        else
         __WRN( whoami,'SKIPPED ALL ELEMENTS. NOTHING PRINTED.')
         return
        endif ! kout
!
        do k=1, kout
         j=mod(k+kbeg-2,max_hist_base)+1+main_offset
         rtemp(:,k)=cv%r(1:cv%num_cv,j) ! each line corresponds to a time slice
        enddo
!    gather all data on root (0)
        if (SIZE_STRNG.gt.1) then
 __MPI_ONLY call mpi_GATHER(rtemp,cv%num_cv*kout,mpifloat,      &
 __MPI_ONLY     &    rall,cv%num_cv*kout,mpifloat,0,MPI_COMM_STRNG,    &
 __MPI_ONLY     &    ierror)
        else
         rall(:,:,1)=rtemp
        endif
!
        if (ME_STRNG.eq.0) then ! root writes
         write(fmt,int_format) SIZE_STRNG
         do k=1,kout
          write(iunit,'("% ",'//int_format//')') k
          do i=1,cv%num_cv
           write(iunit,'('//fmt//real_format//')')                      &
     &      (rall(i,k,j),j=1,SIZE_STRNG)
          enddo
         enddo
        endif ! ME
!
        __FREE(rtemp)
        __FREE(rall)
       endif ! qroot
       end subroutine cv_common_print_hist_global
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_clear_hist()
       cv%num_hist=0; cv%beg_hist=1; cv%end_hist=0
       end subroutine cv_common_clear_hist
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_header(ifile)
! from a design standpont, unclear to me whether including MULTICOM everywhere is good
       __DEP_MULTICOM
       use parser, only : itoa
       int :: ifile, i
       __IAM(CV_COMMON_PRINT_HEADER)
#define _W write(ifile,*)
        _W '# DATA FOR STRING METHOD IN COLLECTIVE VARIABLES (CVs)'
        _W 'smcv {'
        _W 'nstring =', SIZE_STRNG, ' # string replicas'
        _W 'num_cv =', cv%num_cv, ' # CVs'
!     write types
        do i=1, cv%num_cv
         _W '# CV'//trim(itoa(i))//': ',cv_type_names(cv%type(i))
        enddo
        _W 'fixed_0_bc =',cv_common_fixed_0_bc,' # is left (1st) endpoint fixed ?'
        _W 'fixed_1_bc =',cv_common_fixed_1_bc,' # is right (last) endpoint fixed ?'
        _W '} #smcv'
#undef _W
!
       end subroutine cv_common_print_header
!================================================================================================
       subroutine cv_common_parser_done()
       use parser, only:parser_clear_context
       call parser_clear_context(__MYCTX)
       end subroutine cv_common_parser_done
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_local(iunit, col, qraw_)
!      assume that unit is prepared
!      NOTE that this is a local print!
!      does not print fixed BC
       __DEP_MULTICOM
       use parser, only : itoa
       int :: iunit
       int, optional :: col
       __OPAR(qraw,bool)
!      locals
       character(len=20) :: keyword
       int :: i, c, l
       __IAM(CV_COMMON_PRINT_LOCAL)
!      do work
       __PRESENT(qraw,.true.)
       if (.not.present(col)) then ; c=main ; else ; c=col ; endif
       if (c.lt.1.or.c.gt.(max_hist_base+main_offset)) then
        __WRN( whoami,'COLUMN('//itoa(c)//') OUT OF BOUNDS. NOTHING DONE.')
        return
       endif
!
       if (qraw) then
! simple (raw) dump that is good for analysis in matlab
        do i=1, cv%num_cv ; write(iunit, real_format) cv%r(i,c) ; enddo
       else ! .not. qraw
! write a human-readable file
        call cv_common_print_header(iunit)
#define _W write(iunit,*)
        _W 'smcv {'
        _W '# CVx_y : Collective Variable #y corresponding to replica #x'
!     write coordinates
        keyword='CV'//trim(itoa(ME_STRNG))//'_';l=len_trim(keyword)
        do i=1, cv%num_cv
         _W keyword(1:l)//trim(itoa(i)),' = ',cv%r(i,c)
        enddo
        _W '} # smcv'
#undef _W
       endif
!
       end subroutine cv_common_print_local
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_global(iunit,col,print_bc,qraw_)
!      assume that unit is prepared
!      NOTE that this is a global print!
!
       __DEP_MULTICOM
       __DEP_MPI
       use parser, only: itoa
!
#include "mpitype.def"
!
       int iunit
       int, optional :: col
       bool, optional, intent(in) :: print_bc
       __OPAR(qraw,bool)
!      locals
       int :: i, k, c, l
       bool :: bc
       character(len=80) :: fmt
       character(len=20) :: keyword
       float, pointer :: rtemp(:,:) ! temporary array for holding coords
       int :: ierror
       bool :: qroot
       __IAM(CV_COMMON_PRINT_GLOBAL)
!      do work
       qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL)
       if (qroot) then
!
        __PRESENT(qraw,.true.)
        if (.not.present(col)) then ; c=main ; else ; c=col ; endif
        if (c.lt.1.or.c.gt.(cv%num_hist+main_offset)) then
         __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
         return
        endif
!
        if (present(print_bc)) then ; bc=print_bc ; else ; bc=.true. ; endif ! do we want bc printed if applicable?
!
!      gather all data on root
        allocate(rtemp(cv%num_cv, SIZE_STRNG))
!
        if (SIZE_STRNG.gt.1) then
 __MPI_ONLY call mpi_GATHER(cv%r(1,c),cv%num_cv,mpifloat,       &
 __MPI_ONLY     &   rtemp,cv%num_cv,mpifloat,0,MPI_COMM_STRNG,         &
 __MPI_ONLY     &   ierror)
        else
         rtemp(:,1)=cv%r(1:cv%num_cv,c)
        endif
!
        if (ME_STRNG.eq.0) then ! root writes
         if (qraw) then
! simple (raw) dump that is good for analysis in matlab
!
          if (bc) then ! write inner replicas + bc
           write(fmt,int_format) (SIZE_STRNG+cv_common_fixed_0_bc+cv_common_fixed_1_bc)
           if (cv_common_fixed_0_bc.eq.1) then
            if (cv_common_fixed_1_bc.eq.1) then
             do i=1,cv%num_cv
              write(iunit,'('//fmt//real_format//')') cv%r_bc_0(i), (rtemp(i,k),k=1,SIZE_STRNG), cv%r_bc_1(i)
             enddo ! all cv
            else
             do i=1,cv%num_cv
              write(iunit,'('//fmt//real_format//')') cv%r_bc_0(i), (rtemp(i,k),k=1,SIZE_STRNG)
             enddo
            endif
           else
            if (cv_common_fixed_1_bc.eq.1) then
             do i=1,cv%num_cv
              write(iunit,'('//fmt//real_format//')') (rtemp(i,k),k=1,SIZE_STRNG), cv%r_bc_1(i)
             enddo
            else
             do i=1,cv%num_cv
              write(iunit,'('//fmt//real_format//')') (rtemp(i,k),k=1,SIZE_STRNG)
              enddo
            endif
           endif
          else ! bc; just write the inner replicas
           write(fmt,int_format) SIZE_STRNG
           do i=1,cv%num_cv
            write(iunit,'('//fmt//real_format//')') (rtemp(i,k),k=1,SIZE_STRNG)
           enddo
          endif ! bc
!==========================================
         else ! i.e. : qraw = .false.
          call cv_common_print_header(iunit)
#define _W write(iunit,*)
          _W 'smcv {'
          _W '# CVx_y : Collective Variable #y corresponding to replica #x'
!     write coordinates
! check left boundary condition
          if (bc) then
           if (cv_common_fixed_0_bc.eq.1) then
            keyword='CV'//trim(itoa(0))//'_'; l=len_trim(keyword)
            do i=1, cv%num_cv
             _W keyword(1:l)//trim(itoa(i)),' = ',cv%r_bc_0(i)
            enddo
           endif
          endif
! inner replicas
          do k=1, SIZE_STRNG
           keyword='CV'//trim(itoa(k+cv_common_fixed_0_bc-1))//'_'; l=len_trim(keyword)
           do i=1, cv%num_cv
            _W keyword(1:l)//trim(itoa(i)),' = ',rtemp(i,k)
           enddo
          enddo
! check right boundary condition
          if (bc) then
           if (cv_common_fixed_1_bc.eq.1) then
            keyword='CV'//trim(itoa(SIZE_STRNG + cv_common_fixed_0_bc + cv_common_fixed_0_bc - 1))//'_'; l=len_trim(keyword)
            do i=1, cv%num_cv
             _W keyword(1:l)//trim(itoa(i)),' = ',cv%r_bc_1(i)
            enddo
           endif
          endif ! bc
          _W '} # smcv'
#undef _W
         endif ! qraw
!
        endif ! ME=0
        deallocate(rtemp)
       endif ! qroot
!
       end subroutine cv_common_print_global
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_unwrap_angles(col,ind)
       use sm_var, only: nstring, mestring ! all cpus need to know string length
!
       __DEP_MULTICOM
       __DEP_CONST
       __DEP_MPI
!
#include "mpitype.def"
!
       int, optional :: col, ind
!      locals
       int :: ibeg, iend
       int :: i, j, c, nrep
       float :: dangle
       float, pointer :: rtemp(:,:) ! temporary array for holding coords
       int :: ierror
       __IAM(CV_COMMON_UNWRAP_ANGLES)
!      do work
       if (.not.present(col)) then ; c=main ; else ; c=col ; endif
       if (c.lt.1.or.c.gt.(cv%num_hist+main_offset)) then
        __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
        return
       endif
!
       if (.not.present(ind)) then
        ibeg=1 ; iend=cv%num_cv
       else
        if (ind.lt.1.or.ind.gt.cv%num_cv) then
         __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
         return
        endif
        ibeg=ind; iend=ind ;
       endif
!
       if (nstring.le.1) return
!
       nrep=nstring+cv_common_fixed_0_bc+cv_common_fixed_1_bc
       allocate(rtemp(cv%num_cv, nrep))
!      gather all data on each root processor
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (SIZE_STRNG.gt.1) then
 __MPI_ONLY         call MPI_ALLGATHER(cv%r(1,c),cv%num_cv,mpifloat,    &
 __MPI_ONLY     &    rtemp(1,1+cv_common_fixed_0_bc),                   &
 __MPI_ONLY     &    cv%num_cv,mpifloat,MPI_COMM_STRNG,                 &
 __MPI_ONLY     &    ierror)
        else
         rtemp(:,1+cv_common_fixed_0_bc)=cv%r(1:cv%num_cv,c)
        endif
       endif ! COMM_STRNG .ne. null
!    broadcast rtemp to slaves:
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1)         &
     &  __BROADCAST_LOCAL(rtemp,cv%num_cv*nrep,mpifloat)
!
!    loop over specified cv indices
       do i=ibeg, iend
        select case(cv%type(i))
         case(dihe_com, angle_com, anglvec);
!
          if (cv%type(i).eq.angle_com.or.cv%type(i).eq.anglvec) rtemp(i,:)=abs(rtemp(i,:)) ! make sure only positive values for angles are taken
!
          do j=2,nrep
           dangle=modulo(rtemp(i,j)-rtemp(i,j-1), TWOPI)
           if (dangle .gt. PI ) dangle = dangle - TWOPI
           rtemp(i,j)=rtemp(i,j-1)+dangle
          enddo
          cv%r(i,c)=rtemp(i,mestring+1+cv_common_fixed_0_bc)
          if (cv_common_fixed_1_bc.gt.0) cv%r_bc_1(i)=rtemp(i,nrep)
!
        end select
       enddo
!    free memory
       deallocate(rtemp)
       end subroutine cv_common_unwrap_angles
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_compute_fe_fd()
       use sm_var, only: nstring
!
       __DEP_MULTICOM
       __DEP_MPI 
!
       int :: ierror
       __IAM(CV_COMMON_COMPUTE_FE_FD)
!       define interface for work routine (calling by keyword)
       interface
        subroutine compute_work_fd(r,rbc0,rbc1,f,n,fe)
        __CHARMM_ONLY __DEP_KINDS
        int :: n
        float :: r(n), f(n)
        float :: fe(:)
        float, optional :: rbc0(n), rbc1(n)
        end subroutine compute_work_fd
       end interface
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.                         &
     &                         SIZE_STRNG.gt.1) then
        if (cv%num_cv.eq.0)                                             &
     &   __WRN( whoami,'NO CV DEFINED.')
        if (cv_common_fixed_0_bc.eq.1) then
         if (cv_common_fixed_1_bc.eq.1) then
          call compute_work_fd(                                         &
     &     R=cv%r(1:cv%num_cv,main),RBC0=cv%r_bc_0,RBC1=cv%r_bc_1,      &
     &     F=cv%r(1:cv%num_cv,forces),N=cv%num_cv,FE=cv%fe)
         else
          call compute_work_fd(                                         &
     &     R=cv%r(1:cv%num_cv,main),RBC0=cv%r_bc_0,                     &
     &     F=cv%r(1:cv%num_cv,forces),N=cv%num_cv,FE=cv%fe)
         endif
        else
         if (cv_common_fixed_1_bc.eq.1) then
          call compute_work_fd(                                         &
     &     R=cv%r(1:cv%num_cv,main),RBC1=cv%r_bc_1,                     &
     &     F=cv%r(1:cv%num_cv,forces),N=cv%num_cv,FE=cv%fe)
         else
          call compute_work_fd(                                         &
     &     R=cv%r(1:cv%num_cv,main),                                    &
     &     F=cv%r(1:cv%num_cv,forces),N=cv%num_cv,FE=cv%fe)
         endif
        endif
       endif
!
!      send to slaves
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
__CHARMM_ONLY##IF SINGLE
        __BROADCAST_LOCAL_4B(cv%r(1:cv%num_cv,forces),cv%num_cv)
        __BROADCAST_LOCAL_4B(cv%fe,nstring)
__CHARMM_ONLY##ELSE
        __BROADCAST_LOCAL_8B(cv%r(1:cv%num_cv,forces),cv%num_cv)
        __BROADCAST_LOCAL_8B(cv%fe,nstring)
__CHARMM_ONLY##ENDIF
#else
        __BROADCAST_LOCAL(cv%r(1:cv%num_cv,forces),cv%num_cv,mpifloat)
        __BROADCAST_LOCAL(cv%fe,nstring,mpifloat)
#endif
       endif
!
       end subroutine cv_common_compute_fe_fd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_forces(iunit) ! global
       int :: iunit
       call cv_common_print_global(iunit,forces,.false.,.true.) ! do not print BC if they are present; use raw format
       end subroutine cv_common_print_forces
!=================================================================================================
       function cv_common_check_header(ifile) result(qerror)
       use parser
       use cmd
       __DEP_MULTICOM
!
!
        __IAM(CV_COMMON_CHECK_HEADER)
!
        int, optional, intent(in) :: ifile ! only if present, parse file
!
        bool  :: qerror
        int :: nstring
        int :: nstring_, num_cv_, fixed_0_bc_, fixed_1_bc_
!
        if (present(ifile)) call parse_file(abs(ifile) &
#ifdef __PARALLEL
     &       , MPI_COMM_NULL &
#endif
     &     ) ! parse locally
! some basic checks/warnings
        qerror=.false.
        __GETPAR(nstring,i)
        __GETPAR(num_cv,i)
        __GETPAR(fixed_0_bc,i)
        __GETPAR(fixed_1_bc,i)
!
#define __PRE
        nstring=SIZE_STRNG
        __COMPARE_PAR(nstring,==,.not.)
#undef __PRE
#define __PRE cv%
        __COMPARE_PAR(num_cv,==,.not.)
#undef __PRE
#define __PRE cv_common_
        __COMPARE_PAR(fixed_0_bc,==,.not.)
        __COMPARE_PAR(fixed_1_bc,==,.not.)
#undef __PRE
!
       if (present(ifile)) then
        if (ifile.lt.0) call parser_clear_context(__MYCTX)
       endif
!
       end function cv_common_check_header
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_local(iunit, col, replica_, qraw_)
!      assume that unit is prepared
!      for parallel, broadcast to slaves done by calling routine
       __DEP_MULTICOM
       __DEP_CONST
       use parser
       use cmd
!
       int, optional :: iunit
       int, optional, intent(in) :: col
       __OPAR(qraw,bool)
       __OPAR(replica,int)
! locals
       int :: i, c, nstring, ierr, l
       bool :: qerror
       character(len=maxlinelen) :: line
       character(len=20) :: keyword
!
       __IAM(CV_COMMON_READ_LOCAL)
!      do work
!       character(len=80) :: fmt
!       write(fmt,int_format) max_cv_common
       if (.not.present(col)) then ; c=main ; else ; c=col ; endif
       if (c.lt.1.or.c.gt.(max_hist_base+main_offset)) then
        __WRN( whoami,'OUT OF BOUNDS. NOTHING DONE.')
        return
       endif
!
       __PRESENT(qraw,.true.)
!
       if (qraw) then
        do i=1,cv%num_cv ! NOTE that there is only one replica dataset in a raw file, so ignore replica_ here
!        read(iunit,'('//fmt//'F11.5)')
         read(abs(iunit),*) cv%r(i,c)         ! free-form read in case you want to edit entries by hand
        enddo
!========= human - readable restart
       else 
        __PRESENT(replica,ME_STRNG); if (replica.eq.__INAN) replica=ME_STRNG
! fire up the parser, using null communicator for local execution on each replica
        if (present(iunit)) call parse_file(abs(iunit) &
#ifdef __PARALLEL
     &        , MPI_COMM_NULL &
#endif
     &        ) ! parse locally
        qerror=cv_common_check_header() ! not yet sure what to do with qerror
! read actual coordinates
        keyword='CV'//trim(itoa(replica))//'_' ; l=len_trim(keyword);
        do i=1, cv%num_cv
         line=getval_nocase(keyword(1:l)//trim(itoa(i)),__MYCTX)
         if (len_trim(line).gt.0) then
          read(line,*,iostat=ierr) cv%r(i,c)
          if (ierr.ne.0) then
           __WRN(whoami, 'ERROR READING COORDINATE FROM LINE "'//trim(line)//'"')
           cycle
          endif
         endif ! line
        enddo ! CVs
!
        if (present(iunit)) then
         if (iunit.lt.0) call parser_clear_context(__MYCTX)
        endif
!
       endif ! qraw
!
!
       end subroutine cv_common_read_local
!====================================================================================
       subroutine cv_common_read_local_from_global(iunit,replica_,col,numrep_,qraw_)
!      read data for a particular specified replica from a global file
!      caller needs to provide number of replicas in the file (# cols)
!      assume that unit is prepared
!      note that only the string root will get a valid file handle (all local roots enter, hence MPI)
!      replica assumed to be specified relative to zero (not one)
      __DEP_PARSER
      __DEP_MULTICOM
      __DEP_MPI
      use parser __CHARMM_ONLY , only : parse_file, parser_clear_context, getval_nocase, atoi ! itoa in charmm/source/util/string.src
      use cmd
!
#include "mpitype.def"
!
      __OPAR(qraw,bool)
      __OPAR(replica,int)
      __OPAR(numrep,int)
!
      int, optional :: iunit
      int, optional, intent(in) :: col
      int :: i, k, c, l
      float, pointer :: rtemp(:,:) ! temporary array for holding coords
      int :: ierror, nstring
      character(len=20) :: keyword
      character(len=maxlinelen) :: line
      bool :: qroot, qerror
      int :: nstring_
      __IAM(CV_COMMON_READ_LOCAL_FROM_GLOBAL)
!
      qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL)
!
      nullify(rtemp) ;
!       character(len=80) :: fmt
!       write(fmt,int_format) max_cv_common
      if (.not.present(col)) then ; c=main ; else ; c=col ; endif
      if (c.lt.1.or.c.gt.(cv%num_hist+main_offset)) then
       __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
       return
      endif
!
      __PRESENT(qraw,.true.)
      __PRESENT(replica,ME_STRNG); if (replica.eq.__INAN) replica=ME_STRNG
      __PRESENT(numrep,SIZE_STRNG);
!
!     read file
      if (qroot) then
       if (ME_STRNG.eq.0) then ! root reads, then broadcasts
        if (qraw) then
         if (numrep.eq.__INAN) numrep=SIZE_STRNG
         allocate(rtemp(cv%num_cv, numrep)) ; rtemp=__NAN ;
         do i=1,cv%num_cv
!         read(iunit,'('//fmt//'D23.15)')
          read(abs(iunit),*) (rtemp(i,k),k=1,numrep)
         enddo
        else ! human-readable restart file
! parse file
         if (present(iunit)) call parse_file(abs(iunit) &
#ifdef __PARALLEL
     &    , MPI_COMM_NULL &
#endif
     &    ) ! parse locally
! some basic checks/warnings
         qerror=cv_common_check_header()
         __GETPAR(nstring,i)
         if (present(numrep_).and.numrep.ne.__INAN) then 
          if (numrep_.ne.nstring_) &
     &  __WRN(whoami, ' SPECIFIED NUMBER OF REPLICAS ('//itoa(numrep_)//') DOES NOT MATCH RESTART FILE ('//itoa(nstring_)//').')
          numrep=numrep_ ;
         else 
          numrep=nstring_
         endif
!
         allocate(rtemp(cv%num_cv, numrep)) ; rtemp=__NAN ;
! read actual coordinates
         do k=1, numrep ! as specified above
          keyword='CV'//trim(itoa(k-1))//'_' ; l=len_trim(keyword);
          do i=1, cv%num_cv
           line=getval_nocase(keyword(1:l)//trim(itoa(i)),__MYCTX)
           if (len_trim(line).gt.0) then
            read(line,*,iostat=ierror) rtemp(i,k) ! most versatile read
            if (ierror.ne.0) then
             __WRN(whoami, 'ERROR READING COORDINATE FROM LINE "'//trim(line)//'"')
             cycle
            endif
           endif ! line
          enddo ! CVs
         enddo ! replicas
         if (present(iunit)) then
          if (iunit.lt.0) call parser_clear_context(__MYCTX)
         endif
        endif ! qraw
       endif ! ME_STRNG.eq.0
!
!      now broadcast CV values to other nodes
       if (SIZE_STRNG.gt.1) then 
        __BROADCAST_STRING(numrep, 1, mpiint)
        if (ME_STRNG.gt.0) allocate(rtemp(cv%num_cv, numrep))
        __BROADCAST_STRING(rtemp, cv%num_cv * numrep, mpifloat)
       endif
!     "pick out" what I need
       if (replica .lt. numrep .and. replica .ge. 0) then ! replica offset from 0
         cv%r(1:cv%num_cv,c)=rtemp(:,replica+1)
       else
       __WRN(whoami,'REPLICA '//itoa(ME_STRNG)//' ATTEMPTED TO READ NONEXISTENT COLUMN '//itoa(replica)//'. NOTHING DONE.')
       endif ! replica
!     check for zero coordinate entries
       if (any(cv%r(1:cv%num_cv,c).eq.__NAN)) then
        __WRN(whoami,'REPLICA '//itoa(ME_STRNG)//' HAS UNDEFINED CV COORDINATES AFTER READING.')
       endif
      endif ! root
!
      __FREE(rtemp)
      end subroutine cv_common_read_local_from_global
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_global(iunit,col,read_bc)
!      assume that unit is prepared
       use sm_var, only : nstring
       __DEP_PARSER
       
       __DEP_MULTICOM
       __DEP_MPI
!
#include "mpitype.def"
!
       int :: iunit
       int, optional :: col
       bool, optional :: read_bc
       int :: i, k, c
       float :: rtemp(max_cv_common, nstring), dummy ! temporary array for holding coords
       int :: ierror
       character(len=8) :: me ! for output
       bool :: bc
       bool :: qread
       __IAM(CV_COMMON_READ_GLOBAL)
!
       qread=(MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0)
!      do work
       bc=.false.
       rtemp=__NAN ! initialize
!       character(len=80) :: fmt
!       write(fmt,int_format) max_cv_common
       if (.not.present(col)) then ; c=main ; else ; c=col ; endif
       if (c.lt.1.or.c.gt.(cv%num_hist+main_offset)) then
        __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
        return
       endif
!     read file
       if (c.eq.main) bc=.true.         ! read bc if reading first (main coordinates)
       if (present(read_bc)) bc=read_bc ! do we want to read bc if applicable?
!
       if (qread) then ! root reads
!
        if (bc) then ! read inner replicas + bc
         if (cv_common_fixed_0_bc.eq.1) then
          if (cv_common_fixed_1_bc.eq.1) then
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      cv%r_bc_0(i), (rtemp(i,k),k=1,SIZE_STRNG), cv%r_bc_1(i)
           enddo
          else
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      cv%r_bc_0(i), (rtemp(i,k),k=1,SIZE_STRNG)
           enddo
          endif
         else
          if (cv_common_fixed_1_bc.eq.1) then
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      (rtemp(i,k),k=1,SIZE_STRNG), cv%r_bc_1(i)
           enddo
          else
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      (rtemp(i,k),k=1,SIZE_STRNG)
           enddo
          endif
         endif
        else ! just read the inner replicas and throw away the rest
         if (cv_common_fixed_0_bc.eq.1) then
          if (cv_common_fixed_1_bc.eq.1) then
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      dummy, (rtemp(i,k),k=1,SIZE_STRNG), dummy
           enddo
          else
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      dummy,(rtemp(i,k),k=1,SIZE_STRNG)
           enddo
          endif
         else
          if (cv_common_fixed_1_bc.eq.1) then
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      (rtemp(i,k),k=1,SIZE_STRNG), dummy
           enddo
          else
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      (rtemp(i,k),k=1,SIZE_STRNG)
           enddo
          endif
         endif
        endif ! read_bc
       endif ! root
!      scatter all data on root
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (SIZE_STRNG.gt.1) then
 __MPI_ONLY         call MPI_SCATTER(rtemp, max_cv_common, mpifloat,      &
 __MPI_ONLY     &    cv%r(1,c),max_cv_common,mpifloat,0,MPI_COMM_STRNG,   &
 __MPI_ONLY     &    ierror)
        else
         cv%r(1:cv%num_cv,c)=rtemp(1:cv%num_cv,1)
        endif ! SIZE_STRNG
!      broadcast BC
        if (bc) then
         if (cv_common_fixed_0_bc.eq.1)                                   &
     &    __BROADCAST_STRING(cv%r_bc_0, cv%num_cv, mpifloat)
         if (cv_common_fixed_1_bc.eq.1)                                   &
     &    __BROADCAST_STRING(cv%r_bc_1, cv%num_cv, mpifloat)
        endif ! bc
!     check for zero coordinate entries
        if (any(cv%r(1:cv%num_cv,c).eq.__NAN)) then
         write(me,'(I8)') ME_STRNG
         i=len(me)
         __TRIMA(me,i)
      __WARN( whoami,'SOME CV VALUES ARE UNDEFINED AFTER READING COLUMN '//itoa(c)//' ON REPLICA',me,'.')
        endif
       endif ! MPI_COMM_STRNG
!
!      NOTE : broadcast to slaves in calling routine
       end subroutine cv_common_read_global
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_ds(iunit,fmt)
       use sm_var, only: nstring
!
       int iunit
       character(len=*), optional :: fmt
!      local
       character(len=80) :: frm
!      begin
       if (.not.present(fmt)) then
        write(frm,'('//int_format//',A)')                               &
     &    nstring+cv_common_fixed_0_bc+cv_common_fixed_1_bc, real_format
       else
        frm=fmt
       endif
!
       write(iunit,frm) cv%ds
       end subroutine cv_common_print_ds
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_curvature(iunit,fmt)
       use sm_var, only: smcv_initialized, nstring
       
       int iunit
       character(len=*), optional :: fmt
!      local
       character(len=80) :: frm
       interface
        subroutine smcv_init(maxcv);; int, optional :: maxcv ; end subroutine smcv_init
       end interface
!      begin
       if (.not.smcv_initialized) call smcv_init()
       if (.not.present(fmt)) then
        write(frm,'('//int_format//',A)')                               &
     &    nstring+cv_common_fixed_0_bc+cv_common_fixed_1_bc, real_format
       else
        frm=fmt
       endif
!
       write(iunit,frm) cv%curvature
       end subroutine cv_common_print_curvature
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_fe(iunit,fmt)
       use sm_var, only: smcv_initialized, nstring
!
       int iunit
       character(len=*), optional :: fmt
!      local
       character(len=80) :: frm
       interface
        subroutine smcv_init(maxcv);; int, optional :: maxcv ; end subroutine smcv_init
       end interface
!      begin
       if (.not.smcv_initialized) call smcv_init()
       if (.not.present(fmt)) then
        write(frm, '('//int_format//',A)')                              &
     &    nstring+cv_common_fixed_0_bc+cv_common_fixed_1_bc, real_format
       else
        frm=fmt
       endif
!
       write(iunit,frm) cv%fe
       end subroutine cv_common_print_fe
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_feav(iunit,fmt)
       use sm_var, only: smcv_initialized, nstring
!
       int iunit
       character(len=*), optional :: fmt
!      local
       character(len=80) :: frm
!      begin
       interface
        subroutine smcv_init(maxcv);; int, optional :: maxcv ; end subroutine smcv_init
       end interface
       if (.not.smcv_initialized) call smcv_init()
       if (.not.present(fmt)) then
        write(frm, '('//int_format//',A)')                              &
     &    nstring+cv_common_fixed_0_bc+cv_common_fixed_1_bc, real_format
       else
        frm=fmt
       endif
       write(iunit,frm) cv%feav
!      reset number of fe samples so that the averaging starts over
       cv%num_fe_samples=0
       end subroutine cv_common_print_feav
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_k(i,k)
       int :: i
       float :: k
! no error checking: can set to anything you want!
       if (i.ge.0.and.i.le.cv%num_cv) cv%k(i)=k
       end subroutine cv_common_set_k
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_active(i,flag)
       int :: i
       bool :: flag
       if (i.ge.0.and.i.le.cv%num_cv) cv%active(i)=flag
       end subroutine cv_common_set_active
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_kpara(k)
       float :: k
!
       __IAM(CV_COMMON_SET_KPARA)
       if (k.lt.zero) &
     &__WRN(whoami,' NEGATIVE FORCE CONSTANT SPECIFIED. NOTHING DONE.')
       cv%kpara=k
       cv_common_kpara_initialized=.true.
       end subroutine cv_common_set_kpara
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_kperp(k)
!
       float :: k
!
       __IAM(CV_COMMON_SET_KPERP)
       if (k.lt.zero) &
     & __WRN(whoami,' NEGATIVE FORCE CONSTANT SPECIFIED. YOU HAVE BEEN WARNED.')
       cv%kperp=k
       cv_common_kperp_initialized=.true.
       end subroutine cv_common_set_kperp
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_fbwidth(i,dw)
!
       int :: i
       float :: dw
       __IAM(CV_COMMON_SET_FBWIDTH)
       if (i.gt.0.and.i.le.cv%num_cv) then
        if (dw.lt.zero) then
          __WRN(whoami,' NEGATIVE WIDTH FLAT-BOTTOM REGION OF RESTRAINT SPECIFIED. NOTHING DONE.')
        else
         cv%fbwidth(i)=half*dw ! NOTE THAT I AM STORING HALF_WIDTH FOR COMPUTATION EFFICIENCY
        endif
       endif
       end subroutine cv_common_set_fbwidth
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_g(i,gamma)
       int :: i
       float :: gamma
       __IAM(CV_COMMON_SET_G)
!
       if (i.gt.0.and.i.le.cv%num_cv) then
        if (gamma.le.zero) then
          __WRN(whoami,' NONPOSITIVE FRICTION VALUE SPECIFIED. SETTING TO INFINITY (NO DIFFUSION).')
         cv%gamma(i)=zero
        else
         cv%gamma(i)=one/gamma
        endif
       endif
       end subroutine cv_common_set_g
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_temp(i,temp)
       int :: i
       float :: temp
       __IAM(CV_COMMON_SET_TEMP)
!
       if (i.gt.0.and.i.le.cv%num_cv) then
        if (temp.le.zero) then
          __WRN(whoami,' NONPOSITIVE TEMPERATURE VALUE SPECIFIED. NOTHING DONE.')
        else
         cv%temperature(i)=temp
        endif
       endif
       end subroutine cv_common_set_temp
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_maxval(i,maxv)
       int :: i
       float :: maxv
       cv%maxval(i)=maxv
       end subroutine cv_common_set_maxval
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_minval(i,minv)
       int :: i
       float :: minv
       cv%minval(i)=minv
       end subroutine cv_common_set_minval
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_w(i,weight)
       int :: i
       float :: weight
!       if (weight.le.zero) return ! zero or negative weight breaks
       if (i.gt.0.and.i.le.cv%num_cv) then
        cv%weight(i)=weight
        cv_common_weights_initialized=.true. ! assume that the user will has initialized all weights !
       endif
!
       end subroutine cv_common_set_w
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_r(i,z,col1)
!
       int :: i
       int, optional :: col1
       float :: z
!
       int :: col
       __IAM(CV_COMMON_SET_R)
!
       if (present(col1)) then ; col=col1; else ; col=main; endif
       if (col.gt.0.and.col.le.main_offset+max_hist_base) then
        if (i.gt.0.and.i.le.cv%num_cv) then
         cv%r(i,col)=z
        else
         __WRN( whoami, 'INVALID COLUMN. NOTHING DONE.')
        endif
       else
        __WRN( whoami, 'INVALID CV INDEX. NOTHING DONE.')
       endif
       end subroutine cv_common_set_r
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_dt(dt)
       float :: dt
! no error checking: can set to anything you want!
!      locals
       cv%dt=dt
       end subroutine cv_common_set_dt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_copy(c1, c2)
       int :: c1, c2
!      local
       __IAM(CV_COMMON_COPY)
!      start
       if (c1.gt.0.and.c1.le.main_offset+max_hist_base                  &
     &     .and.                                                        &
     &     c2.gt.0.and.c2.le.main_offset+max_hist_base                  &
     &  .and.c1.ne.c2) then
        cv%r(:,c2)=cv%r(:,c1)
       else
        __WRN(whoami, 'INVALID COLUMN SPECIFIED')
       endif
       end subroutine cv_common_copy
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_swap(col1, col2)
       int, optional :: col1, col2
       __IAM(CV_COMMON_SWAP)
       int :: c1, c2
!      local
       float :: temp(max_cv_common)
!      start
       if (present(col1)) then ; c1=col1; else ; c1=main; endif
       if (present(col2)) then ; c2=col2; else ; c2=comp; endif
       if (c1.gt.0.and.c1.le.main_offset+max_hist_base                  &
     &     .and.                                                        &
     &     c2.gt.0.and.c2.le.main_offset+max_hist_base                  &
     &  .and.c1.ne.c2) then
        temp=cv%r(:,c1);
        cv%r(:,c1)=cv%r(:,c2)
        cv%r(:,c2)=temp
       else
        __WRN(whoami, 'INVALID COLUMN SPECIFIED')
       endif
       end subroutine cv_common_swap
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       function cv_common_rmsd(col1, col2)
       __DEP_CONST
       int, optional :: col1, col2
       int :: c1, c2
!      local
       float :: cv_common_rmsd, dummy, dangle
       int :: i
       __IAM(CV_COMMON_RMSD)
!      start
       if (cv%num_cv.eq.0) then
        __WRN( whoami, 'NO CV DEFINED. EXITING.')
        return
       endif
       if (.not.cv_common_weights_initialized) then
        __WRN( whoami, 'CV WEIGHTS NOT INITIALIZED.')
       endif
!
!     NOTE: might be a good idea to force the (re)computation of weights before this call
!           if weights are indeed the mass matrix M.
!
       cv_common_rmsd=zero
       if (present(col1)) then ; c1=col1; else ; c1=main; endif
       if (present(col2)) then ; c2=col2; else ; c2=comp; endif
       if (c1.gt.0.and.c1.le.(max_hist_base+main_offset)                &
     &  .and.                                                           &
     &    c2.gt.0.and.c2.le.(max_hist_base+main_offset)) then
!
        dummy=zero
        do i=1,cv%num_cv
!    this is 'unclean', but for now keep the angle
!    hardwiring here
         select case(cv%type(i))
         case(dihe_com);
            dangle=modulo(cv%r(i,c1)-cv%r(i,c2), TWOPI)
            if (dangle .gt. PI ) dangle = dangle - TWOPI
            dummy=dummy+(dangle*cv%weight(i))**2
         case(angle_com, anglvec); ! cannot tell between theta/-theta
            dangle=modulo(cv%r(i,c1)-sign(cv%r(i,c2),cv%r(i,c1)), TWOPI)
            if (dangle .gt. PI ) dangle = dangle - TWOPI
            dummy=dummy+(dangle*cv%weight(i))**2
         case default
            dummy=dummy+((cv%r(i,c1)-cv%r(i,c2))*cv%weight(i))**2
         end select
        enddo
        cv_common_rmsd=sqrt(dummy/sum(cv%weight(1:cv%num_cv)**2))
!
!        cv_common_rmsd=sqrt(       ! take square root
!     &    dot_product(
!     &    (cv%r(1:cv%num_cv,c1)-cv%r(1:cv%num_cv,c2))**2, ! square
!     &    cv%weight(1:cv%num_cv)**2)
!     &    *(one/sum(cv%weight(1:cv%num_cv)**2)) ! weight, average
!     &    )  ! sqrt
       else
        __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
       endif
       end function cv_common_rmsd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_update_ave()
!      local
       float :: t
!      begin
       t=one*cv%num_average_samples/(cv%num_average_samples+1)
       cv%r(:,ref2)=t*cv%r(:,ref2)+(one-t)*cv%r(:,main)
       cv%num_average_samples=cv%num_average_samples+1
       end subroutine cv_common_update_ave
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_update_fe_ave()
!      local
       float :: t
!      begin
       t=one*cv%num_fe_samples/(cv%num_fe_samples+1)
       cv%feav=t*cv%feav+(one-t)*cv%fe
       cv%num_fe_samples=cv%num_fe_samples+1
       end subroutine cv_common_update_fe_ave
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_ave_samples(n)
       int :: n
       if (n.ge.0) cv%num_average_samples=n
       end subroutine cv_common_set_ave_samples
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_init(temp)
       use sm_var, only: nstring, smcv_initialized
       __DEP_CONST 
!
       float, optional :: temp
       float :: t
       int :: i
!
       if (.not.cv_common_rex_initialized) then
        if (present(temp)) then ; t=temp; else ; t=300*one; endif
        if (t.gt.0) cv%rex_beta=one/(t*__kboltzmann)
        if (.not.smcv_initialized) return
!
        allocate(cv%rex_map(nstring))
        cv%rex_map=(/ (i, i=0,nstring-1) /)
        call int8_vector_reinit(cv%rex_log)
        cv_common_rex_initialized=.true.
       endif
!
       end subroutine cv_common_rex_init
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_done()
       
       if (cv_common_rex_initialized) then
        deallocate(cv%rex_map)
        call int8_vector_done(cv%rex_log) ! destroy rex log
        cv_common_rex_initialized=.false.
       endif
       end subroutine cv_common_rex_done
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_set_temp(temp)
       __DEP_CONST 
       float, optional :: temp
       float :: t
!
       if (.not.cv_common_rex_initialized) call cv_common_rex_init()
       if (present(temp)) then ; t=temp; else ; t=300*one; endif
       if (t.gt.0) cv%rex_beta=one/(t*__kboltzmann)
!
       end subroutine cv_common_rex_set_temp
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_print_map(iunit,fmt)
       use sm_var, only: nstring
!
!      only root process should call
       int :: iunit
       character(len=*), optional :: fmt
!      local
       int :: i
       character(len=80) :: frm
       __IAM(CV_COMMON_PRINT_REX_MAP)
!      begin
       if (.not.cv_common_rex_initialized) then
        __WRN(whoami,'REX NOT INITIALIZED. NOTHING DONE.')
        return
       endif
!
       if (.not.present(fmt)) then
        write(frm,'("(",I5,"I5)")') nstring
       else
        frm=fmt
       endif
       write(iunit,frm) (/ (i, i=0,nstring-1) /)
       write(iunit,frm) cv%rex_map(1:nstring)
       end subroutine cv_common_rex_print_map
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_read_map(iunit)
       use sm_var, only: nstring
       __DEP_MULTICOM
       __DEP_MPI 
!
       int :: iunit, ierror
#include "mpitype.def"
!
       __IAM(CV_COMMON_READ_REX_MAP)
!      begin
       if (.not.cv_common_rex_initialized) then
        call cv_common_rex_init()
       endif
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (ME_STRNG.eq.0) then
         read(iunit,*) cv%rex_map(1:nstring) ! first row contains indices 0 -- nstring-1
         read(iunit,*) cv%rex_map(1:nstring) ! second row is what we want
         if (any(cv%rex_map.lt.0)) __WRN( whoami,'READ NEGATIVE RANK.')
        endif ! ME_
        if (SIZE_STRNG.gt.1)                                            &
     &  __BROADCAST_STRING(cv%rex_map, nstring, mpiint)
       endif ! MPI_COMM
!    broadcast to slave nodes
       if (ME_LOCAL.ne.MPI_UNDEFINED.and.SIZE_LOCAL.gt.1)               &
!     &  call MPI_BCAST(cv%rex_map, nstring, MPI_INTEGER,
!     &                     0,MPI_COMM_LOCAL,ierr)
#ifdef __CHARMM
     &  __BROADCAST_LOCAL_4B(cv%rex_map,nstring)     !__CHARMM_ONLY##.not.INTEGER8
     &  __BROADCAST_LOCAL_8B(cv%rex_map,nstring)     !__CHARMM_ONLY##INTEGER8
#else
     &  __BROADCAST_LOCAL(cv%rex_map,nstring,mpiint)
#endif
!
       end subroutine cv_common_rex_read_map
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_print_log(iunit, fmt)
!      assume that unit is prepared
!      NOTE that this is a global print!
      __DEP_MULTICOM
      __DEP_MPI
!
       int iunit
       character(len=*), optional :: fmt
!      local
       character(len=80) frm
       int :: i
       int4mpi :: rex_log_size4(SIZE_STRNG)
       int   :: rex_log_size8(SIZE_STRNG)
       int4mpi :: rex_log_disp4(SIZE_STRNG)
       int :: total_size
       INTEGER*8, pointer, dimension(:) :: rex_log_all
       int :: ierror
!
#include "mpitype.def"
!      do work
!      gather all data on root
       if (.not.cv_common_rex_initialized) call cv_common_rex_init()
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (SIZE_STRNG.gt.1) then
!     calculate size of logs
         rex_log_size8=0
 __MPI_ONLY     call MPI_ALLGATHER(cv%rex_log%last,1,mpiint,                    &
 __MPI_ONLY     &                 rex_log_size8,1,mpiint,                          &
 __MPI_ONLY     &                 MPI_COMM_STRNG,ierror)

         total_size=sum(rex_log_size8)
         rex_log_size4=rex_log_size8 ! type cast to 4 byte int
!     allocate space to hold entire log
         allocate(rex_log_all(total_size))
!     calculate send displacements
         rex_log_disp4(1)=0;
         do i=1,SIZE_STRNG-1
          rex_log_disp4(i+1)=rex_log_disp4(i)+rex_log_size4(i)
         enddo
!      now gather the logs
__MPI_ONLY        call MPI_ALLGATHERV(cv%rex_log%i8,cv%rex_log%last,mpiint8,          &
__MPI_ONLY     &                  rex_log_all,rex_log_size4,rex_log_disp4,mpiint8,   &
__MPI_ONLY     &                  MPI_COMM_STRNG,ierror)
!
        if (.not.present(fmt)) then
         frm='(2I5,I8)'
        else
         frm=fmt
        endif
       else ! string_size=1 (NOTE: this is purely for compatibility b/c replica exchange makes no sense with just one replica ! )
        total_size=cv%rex_log%last
        allocate(rex_log_all(total_size)) ; rex_log_all=cv%rex_log%i8(1:total_size)
       endif
!
      if(ME_STRNG.eq.0.and.total_size.gt.0) write(iunit,frm) rex_log_all
!
        call int8_vector_reinit(cv%rex_log) ! erase log
        deallocate(rex_log_all)
       endif ! COMM_STRNG
       end subroutine cv_common_rex_print_log
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_compute_dE(rnew, dE)
       __DEP_CONST 
!
       float :: rnew(:)
       float :: dummy1, dummy2, dE
       int :: i
!      calculate string energies (code adopted from cv_common_evolve_smcv)
       dE=zero
       do i=1, cv%num_cv
!
         select case(cv%type(i))
         case(dihe_com);
          dummy1=(rnew(i) - cv%r(i,instant)) ! new
          dummy1=modulo(dummy1,TWOPI)
          if (dummy1.gt.PI) dummy1=dummy1-TWOPI
!
          dummy2=(cv%r(i,main) - cv%r(i,instant)) ! old
          dummy2=modulo(dummy2,TWOPI)
          if (dummy2.gt.PI) dummy2=dummy2-TWOPI
         case(angle_com, anglvec); ! cannot tell between theta/-theta
          dummy1=rnew(i) - sign(cv%r(i,instant),rnew(i))
          dummy1=modulo(dummy1,TWOPI)
          if (dummy1.gt.PI) dummy1=dummy1-TWOPI
!
          dummy2=cv%r(i,main) - sign(cv%r(i,instant),cv%r(i,main))
          dummy2=modulo(dummy2,TWOPI)
          if (dummy2.gt.PI) dummy2=dummy2-TWOPI
         case default
          dummy1=(rnew(i) - cv%r(i,instant))
          dummy2=(cv%r(i,main) - cv%r(i,instant))
         end select
!
         dE=dE+cv%k(i)*(dummy1**2-dummy2**2)   ! new energy - old energy
        enddo ! loop over CV
        dE=half*dE
!
       end subroutine cv_common_rex_compute_dE
!===================================================================================================
       subroutine cv_common_voronoi_init()
       call cv_common_voronoi_update()
       cv%voronoi_data=0
!       cv%cross_acceptO=1 ! need a nonzero initial condition
       cv%voronoi_cut=9999*one
       cv%voronoi_whereami=-1
       cv%voronoi_map=-1
       end subroutine cv_common_voronoi_init
!===================================================================================================
       subroutine cv_common_voronoi_set_cutoff(cut)
       float :: cut
!
       if (cut.gt.zero) then ! reject invalid values without warning
        if (.not. cv_common_voronoi_initialized)                          &
     &  call cv_common_voronoi_init()
        cv%voronoi_cut=cut
       endif
       end subroutine cv_common_voronoi_set_cutoff
!===================================================================================================
       subroutine cv_common_print_voro_map(iunit,fmt)
       use sm_var, only: nstring
       __DEP_MULTICOM
       __DEP_MPI 
!
       int :: iunit !, ierr
       character(len=*), optional :: fmt
!      local
!#include "mpitype.def"
!
       int :: i
       character(len=80) :: frm
       __IAM(CV_COMMON_PRINT_VORO_MAP)
!      begin
       if (.not.cv_common_voronoi_initialized) call cv_common_voronoi_init()
!
!       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.SIZE_STRNG.gt.1) then
!        call MPI_ALLGATHER(cv%voronoi_whereami, 1, mpiint,
!     &         cv%voronoi_map, 1, mpiint, MPI_COMM_STRNG, ierr)
!
        if (ME_STRNG.eq.0) then
         if (.not.present(fmt)) then
          write(frm,'("(",I5,"I5)")') nstring
         else
          frm=fmt
         endif
         write(iunit,frm) (/ (i, i=1,nstring) /)
         write(iunit,frm) cv%voronoi_map(1:nstring)
        endif ! ME_STRNG
!       endif ! MPI_COMM_STRNG
!
       end subroutine cv_common_print_voro_map
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_voro_map(iunit)
       use sm_var, only: nstring
       __DEP_MULTICOM
       __DEP_MPI 
!
#include "mpitype.def"
!
       int :: iunit, ierror
       __IAM(CV_COMMON_READ_VORO_MAP)
!      begin
       if (.not.cv_common_voronoi_initialized) then
        call cv_common_voronoi_init()
       endif
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (ME_STRNG.eq.0) then
         read(iunit,*) cv%voronoi_map(1:nstring) ! first row contains indices 0 -- nstring-1
         read(iunit,*) cv%voronoi_map(1:nstring) ! second row is what we want
         if (any(cv%voronoi_map.lt.0)) __WRN( whoami,'READ NEGATIVE RANK.')
        endif ! ME_
        if (SIZE_STRNG.gt.1) then
         __BROADCAST_STRING(cv%voronoi_map, nstring,mpiint)
        endif
       endif ! MPI_COMM_STRNG
!    broadcast to slave nodes
       if (ME_LOCAL.ne.MPI_UNDEFINED.and.SIZE_LOCAL.gt.1)               &
!     &  call MPI_BCAST(cv%voronoi_map, nstring, MPI_INTEGER,
!     &                     0,MPI_COMM_LOCAL,ierr)
#ifdef __CHARMM
     &  __BROADCAST_LOCAL_4B(cv%voronoi_map,nstring)     !__CHARMM_ONLY##.not.INTEGER8
     &  __BROADCAST_LOCAL_8B(cv%voronoi_map,nstring)     !__CHARMM_ONLY##INTEGER8
#else
     &  __BROADCAST_LOCAL(cv%voronoi_map,nstring,mpiint)
#endif
!
       end subroutine cv_common_read_voro_map
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_voronoi_update()
       use sm_var, only: nstring, mestring, smcv_initialized
       __DEP_MULTICOM
       __DEP_MPI 
#include "mpitype.def"
!
!      locals
       __IAM(CV_COMMON_VORONOI_UPDATE)
       int :: ierror
       float, pointer :: M(:,:)
       bool :: qroot
       interface
        subroutine smcv_init(maxcv);; int, optional :: maxcv ; end subroutine smcv_init
       end interface
!      begin
       if (.not. smcv_initialized) call smcv_init()
       if (.not.cv_common_voronoi_initialized) then
        allocate(cv%rall(cv%num_cv, nstring))
        allocate(cv%Mall(cv%num_cv, cv%num_cv, nstring))
        allocate(cv%voronoi_data(nstring,2*nstring+1,3))
! assign pointers --  local
        cv%cross_attempt =>cv%voronoi_data(:,1:nstring,1)
        cv%cross_accept  =>cv%voronoi_data(:,nstring+1:2*nstring,1)
        cv%voro_occupancy=>cv%voronoi_data(:,2*nstring+1,1)
! assign pointers -- global
        cv%cross_attemptG =>cv%voronoi_data(:,1:nstring,2)
        cv%cross_acceptG  =>cv%voronoi_data(:,nstring+1:2*nstring,2)
        cv%voro_occupancyG=>cv%voronoi_data(:,2*nstring+1,2)
! assign pointers -- data from previous run (old)
        cv%cross_attemptO =>cv%voronoi_data(:,1:nstring,3)
        cv%cross_acceptO  =>cv%voronoi_data(:,nstring+1:2*nstring,3)
        cv%voro_occupancyO=>cv%voronoi_data(:,2*nstring+1,3)
!
        cv%voronoi_data=0                           ! set all crossing data to zero
!        cv%cross_acceptO=1
        cv%voronoi_cut=9999*one
        cv%voronoi_whereami=-1                   ! -1 indicates this needs to be computed
!
        allocate(cv%voronoi_map(nstring))
        cv%voronoi_map=-1
!
        call int8_vector_reinit(cv%voro_log)
        cv_common_voronoi_initialized=.true.
       endif
!      gather all main coordinate sets (same code as in print_global)
       qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL)
!
       if (qroot) then
        if (SIZE_STRNG.gt.1) then
 __MPI_ONLY     call MPI_ALLGATHER(cv%r,cv%num_cv,mpifloat,         &
 __MPI_ONLY     &    cv%rall,cv%num_cv,mpifloat,MPI_COMM_STRNG,         &
 __MPI_ONLY     &    ierror)
        else
         cv%rall(:,1)=cv%r(1:cv%num_cv,1)
        endif ! string size
!      gather all M^-1 matrices
!
        if (.not.cv_common_Minv_initialized) then
         __WRN( whoami, 'TENSOR M^-1 HAS NOT BEEN SET.')
        endif
        M => cv%M(1:cv%num_cv,1:cv%num_cv,3) ! for use in MPI call
!
        if (SIZE_STRNG.gt.1) then
 __MPI_ONLY        call MPI_ALLGATHER(M,                                            &! cv%M(1:cv%num_cv,1:cv%num_cv,3),
 __MPI_ONLY     &   cv%num_cv**2,mpifloat,                             &
 __MPI_ONLY     &   cv%Mall,cv%num_cv**2,mpifloat,MPI_COMM_STRNG,      &
 __MPI_ONLY     &   ierror)
        else
         cv%Mall(:,:,1)=M
        endif ! string size
       endif
!
! broadcast to slaves
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
__CHARMM_ONLY##IF SINGLE
        __BROADCAST_LOCAL_4B(cv%rall,cv%num_cv*nstring)
        __BROADCAST_LOCAL_4B(cv%Mall,(cv%num_cv**2)*nstring)
__CHARMM_ONLY##ELSE
        __BROADCAST_LOCAL_8B(cv%rall,cv%num_cv*nstring)
        __BROADCAST_LOCAL_8B(cv%Mall,(cv%num_cv**2)*nstring)
__CHARMM_ONLY##ENDIF
#else
        __BROADCAST_LOCAL(cv%rall,cv%num_cv*nstring,mpifloat)
        __BROADCAST_LOCAL(cv%Mall,(cv%num_cv**2)*nstring,mpifloat)
#endif
       endif
!
       cv_common_voronoi_wrong_cell=.false.
       end subroutine cv_common_voronoi_update
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_voronoi_smart_update(rnew, rold, m_iter)
       use sm_var, only: nstring, mestring, smcv_initialized
       use cv_types
!      cv%rall(:,:) is expected to have values from previous update that
!      are consistent with rtemp; if this is not true, the routine
!      just does a regular update and exits
       __DEP_MULTICOM
       __DEP_CONST 
       __DEP_MPI 
!      vars
#include "mpitype.def"
!
       float :: rnew(cv%num_cv) ! current CV values (theta(x))
       float :: rold(cv%num_cv) ! new (possibly reflected) CV values (theta(xcomp))
       int, optional :: m_iter
!      locals
       float, pointer :: M(:,:)
       float :: rall_new(cv%num_cv, nstring)
       float :: rall_temp(cv%num_cv, nstring)
       float :: Mall_new(cv%num_cv, cv%num_cv, nstring)
       float :: Mall_temp(cv%num_cv, cv%num_cv, nstring)
       int :: correct_cell_me, correct_cell
       int :: iter, max_iter
       int, parameter :: default_iter=15
       int :: ierror, me
       bool :: qroot
!
       __IAM(CV_COMMON_VORONOI_SMART_UPDATE)
!
!      begin
!
       if (cv%num_cv.eq.0) then
         __WRN(whoami,'NO CV DEFINED. NOTHING DONE.')
         return
       endif
!
       qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL)
!
       if (qroot) then
        if (SIZE_STRNG.gt.1) then
!      gather all main cv coordinate sets
__MPI_ONLY         call MPI_ALLGATHER(cv%r,cv%num_cv,mpifloat,        &
__MPI_ONLY     &    rall_new,cv%num_cv,mpifloat,MPI_COMM_STRNG,       &
__MPI_ONLY     &    ierror)
!      gather all M^-1 matrices
         M => cv%M(1:cv%num_cv,1:cv%num_cv,3)
!
__MPI_ONLY         call MPI_ALLGATHER(M,                              &
__MPI_ONLY     &    cv%num_cv**2,mpifloat,                            &
__MPI_ONLY     &    Mall_new,cv%num_cv**2,mpifloat,MPI_COMM_STRNG,    &
__MPI_ONLY     &    ierror)
!
        else
         rall_new(:,1)=cv%r(1:cv%num_cv,1)
         Mall_new(:,:,1)=cv%M(1:cv%num_cv,1:cv%num_cv,3)
        endif ! size
       endif !qroot
!
       if (.not.cv_common_voronoi_initialized) then
        allocate(cv%rall(cv%num_cv, nstring))
        allocate(cv%Mall(cv%num_cv, cv%num_cv, nstring))
        cv%rall=rall_new
        cv%Mall=Mall_new
!
        allocate(cv%voronoi_data(nstring,2*nstring+1,3))
! assign pointers --  local
        cv%cross_attempt =>cv%voronoi_data(:,1:nstring,1)
        cv%cross_accept  =>cv%voronoi_data(:,nstring+1:2*nstring,1)
        cv%voro_occupancy=>cv%voronoi_data(:,2*nstring+1,1)
! assign pointers -- global
        cv%cross_attemptG =>cv%voronoi_data(:,1:nstring,2)
        cv%cross_acceptG  =>cv%voronoi_data(:,nstring+1:2*nstring,2)
        cv%voro_occupancyG=>cv%voronoi_data(:,2*nstring+1,2)
! assign pointers -- data from previous run (old)
        cv%cross_attemptO =>cv%voronoi_data(:,1:nstring,3)
        cv%cross_acceptO  =>cv%voronoi_data(:,nstring+1:2*nstring,3)
        cv%voro_occupancyO=>cv%voronoi_data(:,2*nstring+1,3)
!
        cv%voronoi_data=0                           ! set all crossing data to zero
!        cv%cross_acceptO=1
        cv%voronoi_cut=9999*one
        cv%voronoi_whereami=-1                   ! -1 indicates this needs to be computed
!
        allocate(cv%voronoi_map(nstring))
        cv%voronoi_map=-1
!
        call int8_vector_reinit(cv%voro_log)
!
        cv_common_voronoi_initialized=.true.
       else
        me=mestring+1
        if (qroot) then
!
         if (.not.cv_common_Minv_initialized) then
          __WRN( whoami, 'TENSOR M^-1 HAS NOT BEEN SET.')
         endif
!
!     check if the old set is consistent
!
         correct_cell_me=cv_common_voronoi_check_aux                      &
     &           (rold, cv%rall, cv%num_cv, nstring, cv%Mall, me)
!
!      are the coords in rold consistent with the current V. cell centers?
         if  (correct_cell_me.eq.0) then
!      if old set is outside cell, it means that we just crossed into a
!                   neighbor cell; in this case, test rnew, not rold
!                   (repeat as above).
          rold=rnew
          correct_cell_me=cv_common_voronoi_check_aux                     &
     &           (rold, cv%rall, cv%num_cv, nstring, cv%Mall, me)
!      even if correct_cell is true now, the reversed momenta might not place the replica
!      into the cell corresponding to the _evolved_ centers, so it may be best not to evolve this particular
!      cell; this matter in any case is particular to charmm at this stage, so will think on it.-VO.
         endif ! .not. correct_cell_me

!     pool all results
         if (SIZE_STRNG.gt.1) then
__MPI_ONLY         call MPI_ALLREDUCE(correct_cell_me, correct_cell, 1,           &
__MPI_ONLY     &                  mpiint, MPI_MIN, MPI_COMM_STRNG, ierror)
         else
          correct_cell=correct_cell_me
         endif ! string_size
         if (correct_cell.eq.0) then
          __WRN(whoami,' CURRENT VORONOI CELL CENTERS INCONSISTENT WITH COORDINATES.')
!    roll back CVs
           cv%r(1:cv%num_cv,1)=cv%rall(1:cv%num_cv,me)
!
         else ! correct_cell
!     begin iterative adjustment
          if (present(m_iter)) then
           max_iter=m_iter
          else
           max_iter=default_iter
          endif
!
          iter=0
          rall_temp=rall_new
          Mall_temp=Mall_new
          do
!     check if the new set is consistent
           correct_cell_me=cv_common_voronoi_check_aux                    &
     &           (rold, rall_temp, cv%num_cv, nstring, Mall_temp, me)
!     pool all results
           if (SIZE_STRNG.gt.1) then
__MPI_ONLY            call MPI_ALLREDUCE(correct_cell_me, correct_cell, 1,         &
__MPI_ONLY     &                  mpiint, MPI_MIN, MPI_COMM_STRNG, ierror)
           else
            correct_cell=correct_cell_me
           endif ! string_size
!
           if (correct_cell.eq.1) then
            cv%rall=rall_temp
            cv%Mall=Mall_temp
! moved below 1/2013
!!          `roll back' cv's:
!            if (iter.gt.0) then ! otherwise they are fine
!             cv%r(1:cv%num_cv,1)=rall_temp(1:cv%num_cv,me)
!             cv%M(1:cv%num_cv,1:cv%num_cv,3)=Mall_temp(:,:,me)
!            endif
            exit
           elseif (iter.ge.max_iter) then
            __WRN(whoami,' MAXIMUM NUMBER OF ITERATIONS EXCEEDED.')
! moved below 1/2013
!!          reset cv`s to consistent Voronoi cell centers :
!            cv%r(1:cv%num_cv,1)=cv%rall(1:cv%num_cv,me)
!            cv%M(1:cv%num_cv,1:cv%num_cv,3)=cv%Mall(:,:,me)
            exit
           else
            rall_temp=half*(rall_temp+cv%rall)
            Mall_temp=half*(Mall_temp+cv%Mall)
           endif  ! correct cell
           iter=iter+1
          enddo ! <empty>
         endif ! .not. correct_cell
!
        endif ! qroot
       endif ! .not. initialized
!   broadcast to slaves 
! (1.2013: are cv%r broadcast, in case they change ? where ? 
!  Answer: slaves do not need cv%r in voronoi; they only need cv%rall [ in voronoi_compute, which is parallel ], which is computed by roots & broadcast
!  even in the case that the cv%r are evolving: the slaves will have incorrect evolution, but both reflections and image updates only use cv%r from roots
!  however, for a clean look, I am setting cv%r = cv%rall(me) below (& commenting out above for roots)
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
__CHARMM_ONLY##IF SINGLE
        __BROADCAST_LOCAL_4B(cv%rall,cv%num_cv*nstring)
        __BROADCAST_LOCAL_4B(cv%Mall,(cv%num_cv**2)*nstring)
__CHARMM_ONLY##ELSE
        __BROADCAST_LOCAL_8B(cv%rall,cv%num_cv*nstring)
        __BROADCAST_LOCAL_8B(cv%Mall,(cv%num_cv**2)*nstring)
__CHARMM_ONLY##ENDIF
#else
        __BROADCAST_LOCAL(cv%rall,cv%num_cv*nstring,mpifloat)
        __BROADCAST_LOCAL(cv%Mall,(cv%num_cv**2)*nstring,mpifloat)
#endif
       endif
!    moved possible reassignment here (all ranks participate)
       cv%r(1:cv%num_cv,1)=cv%rall(1:cv%num_cv,me)
       cv%M(1:cv%num_cv,1:cv%num_cv,3)=cv%Mall(:,:,me)
!
       end subroutine cv_common_voronoi_smart_update
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       int function cv_common_voronoi_check_aux                       &
     &           (r, rall, ncv, nstring, Mall, me)
!    auxiliary function for use with voronoi_smart_update
!    here, I only need to know whether the host cell is "me";
!    in contrast, in voronoi_compute, I need to know what the host cell is,
!    because that information is used to construct the MSM
!    this is a straightforward implementation of eqs 29/30 (perhaps a bit inefficient but at the benefit of clarity)
!
       __DEP_CONST
!
       int :: ncv, nstring, me
       float :: r(ncv), rall(ncv, nstring), Mall(ncv, ncv, nstring)
! locals
       int :: i,ii,j,jj,k
       float :: z(ncv), dummy, msd_n(nstring), msd_m(nstring)
       bool :: q

       do i=1,nstring
!
!    preprocess differences (wrap angles)
        do j=1,ncv
         select case(cv%type(j))
         case(dihe_com);
            dummy=modulo(r(j)-rall(j,i), TWOPI)
            if (dummy .gt. PI ) dummy = dummy - TWOPI
         case(angle_com, anglvec); ! cannot tell between theta/-theta
            dummy=modulo(r(j)-sign(rall(j,i),r(j)), TWOPI)
            if (dummy .gt. PI ) dummy = dummy - TWOPI
         case default
            dummy=r(j)-rall(j,i)
         end select
         z(j)=dummy
        enddo ! j
!
!    compute two norms
        if (me.eq.i) then ! compute rmsd_me
         do ii=1, nstring
           dummy=zero
           do j=1,ncv
            jj=j-1
            do k=1, jj
             dummy=dummy +                                              &
     &  z(j) * (Mall(j,k,me) + Mall(j,k,ii)) * z(k)
            enddo
           enddo
           dummy=two*dummy ! double contribution from off-diagonal terms
!    contribution from diagonal terms
           do j=1,ncv
            dummy=dummy +                                               &
     &  z(j) * (Mall(j,j,me) + Mall(j,j,ii)) * z(j)
           enddo
           msd_n(ii)=half*dummy
         enddo ! ii=1,nstring
        else  ! compute rmsd_i; computed only for different tensors (hence if/else)
!    same code as above
         dummy=zero
         do j=1,ncv
          jj=j-1
          do k=1, jj
           dummy=dummy +                                                &
     &                z(j) * (Mall(j,k,me)+Mall(j,k,i)) * z(k)
          enddo
         enddo
         dummy=two*dummy ! double contribution from off-diagonal terms
!    contribution from diagonal terms
         do j=1,ncv
          dummy=dummy +                                                 &
     &               z(j) * (Mall(j,j,me)+Mall(j,j,i)) * z(j)
         enddo
         msd_m(i)=half*dummy
        endif ! me.eq.i
!
       enddo ! i=1,nstring
!
       msd_m(me)=msd_n(me)
!    check whether theta(x) lives in this cell
       do i=1, nstring
        q=(msd_n(i).le.msd_m(i))
        if (.not.q) exit
       enddo
!
       if (q.and.((msd_n(me)).lt.cv%voronoi_cut**2)) then
         cv_common_voronoi_check_aux=1
       else
         cv_common_voronoi_check_aux=0
       endif
!
       end function cv_common_voronoi_check_aux
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_voronoi_done()
!
       if (cv_common_voronoi_initialized) then
        deallocate(cv%rall)
        deallocate(cv%Mall)
        deallocate(cv%voronoi_map)
        deallocate(cv%voronoi_data)
!
        nullify(cv%cross_attempt)
        nullify(cv%cross_accept)
        nullify(cv%voro_occupancy)
!
        nullify(cv%cross_attemptG)
        nullify(cv%cross_acceptG)
        nullify(cv%voro_occupancyG)
!
        nullify(cv%cross_attemptO)
        nullify(cv%cross_acceptO)
        nullify(cv%voro_occupancyO)
!
        call int8_vector_done(cv%voro_log) ! destroy Voronoi T. log
        cv_common_voronoi_initialized=.false.
       endif
       end subroutine cv_common_voronoi_done
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       function cv_common_voronoi_compute(rtemp) ! rtemp calculated elsewhere and passed in
!    this is a very straightforward implementation of eqations 29 and 30 in the string paper
       use cv_types
       use sm_var, only: nstring, mestring
       use sm_config, only: calc_voronoi_para
      
      __DEP_MULTICOM
      __DEP_CONST
      __DEP_MPI
!
#include "mpitype.def"
!     variables
       int :: cv_common_voronoi_compute ! index of Voronoi cell that the system is in
       float :: rtemp(cv%num_cv) ! current CV values (theta(x))
!     locals
       float :: msd(nstring,nstring), msdall(nstring,nstring) ! mean square distance
       float :: dummy, z(cv%num_cv)
       int :: i, j, k, n, m, which(1), q(nstring), me
!    parallelization
       bool :: qpara
       int4mpi :: send_displ(SIZE_LOCAL), send_count(SIZE_LOCAL)
       int :: mbeg, mend, ierror
       __IAM(CV_COMMON_VORONOI_COMPUTE)
!
       if (cv%num_cv.eq.0) then
         __WRN(whoami,'NO CV DEFINED. NOTHING DONE.')
         return
       endif
!
       if (.not.cv_common_Minv_initialized) then
        __WRN( whoami, 'TENSOR M^-1 HAS NOT BEEN SET.')
       endif
!      initialize, if necessary
       if (.not.cv_common_voronoi_initialized) call cv_common_voronoi_init()
!      compute RMSD
!      need to compute distances w.r.t. all M tensors on the string
       msd=zero
       msdall=zero
!
!     compute norms in parallel: each slave node is assigned a set of matrices
!     compute index limits (this could be done once in the smcv_init routine)
!
       qpara=(MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1       &
     &   .and.calc_voronoi_para)
       if (qpara) then
!
        j=ceiling(one*nstring/SIZE_LOCAL) ! max. number of CV assigned to slave node
!
        do i=1,SIZE_LOCAL
         send_displ(i)=nstring*min((i-1)*j,nstring-1) ! cannot exceed nstring
         send_count(i)=nstring*max(0,min(j,nstring-j*(i-1)))
        enddo
        me=ME_LOCAL+1
!       indices are below
        mbeg=send_displ(me)/nstring+1
        mend=mbeg+send_count(me)/nstring-1
       else
        mbeg=1
        mend=nstring
       endif ! qpara
!
       do n=1, nstring ! loop over z
!ccccccccccccccccccccccccccccccccccccccccc preprocess differences (wrap angles)
        do j=1,cv%num_cv
!    this is 'unclean', and I may move this routine 'up' but for now keep the angle
         select case(cv%type(j))
         case(dihe_com);
            dummy=modulo(rtemp(j)-cv%rall(j,n), TWOPI)
            if (dummy .gt. PI ) dummy = dummy - TWOPI
         case(angle_com, anglvec); ! cannot tell between +/- theta
            dummy=modulo(rtemp(j)-sign(cv%rall(j,n),rtemp(j)), TWOPI)
            if (dummy .gt. PI ) dummy = dummy - TWOPI
         case default
            dummy=rtemp(j)-cv%rall(j,n)
         end select
         z(j)=dummy
        enddo ! j
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        do m=mbeg,mend ! loop over the M tensors
!cccc compute z_n M_m z_n below
!==============================
         dummy=zero
         do i=1,cv%num_cv
          j=i-1
          do k=1, j     ! M is symmetric, so do not need to iterate over all indices when computing norm
           dummy=dummy +                                                &
     &                z(i) * (cv%Mall(i,k,m)) * z(k)
          enddo
         enddo
         dummy=two*dummy ! double contribution from off-diagonal terms (because M is symmetric)
!    contribution from diagonal terms
         do i=1,cv%num_cv
          dummy=dummy +                                                 &
     &               z(i) * (cv%Mall(i,i,m)) * z(i)
         enddo
         msd(n,m)=dummy
!==============================
        enddo ! m=1,nstring
       enddo ! n=1,nstring
!
!    pool norms on root (gather over matrices (m-index) ):
       if (qpara) then
        if (SIZE_LOCAL.gt.1) then
         if (ME_LOCAL.eq.0) then
__MPI_ONLY          call MPI_GATHERV(MPI_IN_PLACE, send_count(me),                 &
__MPI_ONLY     &    mpifloat,                                                      &
__MPI_ONLY     &    msd, send_count, send_displ,                                   &
__MPI_ONLY     &    mpifloat, 0, MPI_COMM_LOCAL, ierror)
         else ! slaves
__MPI_ONLY          call MPI_GATHERV(msd(1,mbeg),send_count(me),                   &
__MPI_ONLY     &    mpifloat,                                                      &
__MPI_ONLY     &    msd, send_count, send_displ,                                   &
__MPI_ONLY     &    mpifloat, 0, MPI_COMM_LOCAL, ierror)
         endif ! ME_LOCAL
        endif ! local_size
       endif ! qpara

!    root determines where theta(x) is
       if (ME_LOCAL.eq.0.or..not.qpara) then
         do n=1, nstring
          q(n)=1          ! assume replica lives in cell "n" 
          do m=1, nstring
           if (msd(n,n)+msd(n,m).gt.msd(m,n)+msd(m,m)) then ! note that this is false for m=n, as should be
            q(n)=0 ! Voronoi test failed, n is not the cell !
            exit
           endif
          enddo
         enddo
         which=maxloc(q) ! maxloc needs an int array;
         if (msd(which(1),which(1)).gt.cv%voronoi_cut**2)               &
     &    which(1)=-which(1) ! outside of the allowed region (special code)
       endif ! ME_LOCAL
!
       if (qpara)                                                       &
#ifdef __CHARMM
     &  __BROADCAST_LOCAL_4B(which,1)  !__CHARMM_ONLY##.not.INTEGER8
     &  __BROADCAST_LOCAL_8B(which,1)  !__CHARMM_ONLY##INTEGER8
#else
        __BROADCAST_LOCAL(which,1,mpiint)
#endif
!          write(600+ME_GLOBAL,*) q
!           write(600+ME_GLOBAL,'(32G12.4)') msd
!           write(600+ME_GLOBAL,*) rtemp
!            stop
!
       cv_common_voronoi_compute=which(1)
!
       end function cv_common_voronoi_compute
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_voro_data(iunit)
       use sm_var, only: nstring
!      assume that unit is prepared
!      NOTE that this is a global print!
       
       __DEP_MULTICOM
       __DEP_MPI
!
       int :: iunit
!      locals
       character(len=80) :: fmt
       int :: j
       int :: voro_data_all(nstring,2*nstring+1)
       int :: ierror, type
!      do work
!      gather all data on root
__MPI_ONLY       type=MPI_INTEGER                       !__CHARMM_ONLY##.not.INTEGER8
__MPI_ONLY       type=MPI_INTEGER8                      !__CHARMM_ONLY##INTEGER8
!
       if (.not.cv_common_voronoi_initialized) call cv_common_voronoi_init()
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (SIZE_STRNG.gt.1) then
__MPI_ONLY         call MPI_ALLREDUCE(cv%voronoi_data(:,:,1),voro_data_all,       &
__MPI_ONLY     & nstring*(2*nstring+1),type,MPI_SUM,MPI_COMM_STRNG,ierror)
        else
         voro_data_all=cv%voronoi_data(:,:,1)
        endif ! SIZE
!
        if (ME_STRNG.eq.0) then ! string root writes
         write(fmt,int_format) nstring
         do j=1,nstring
          write(iunit,'('//fmt//int_format//')')                        &
     &     voro_data_all(j,1:nstring)+cv%cross_attemptO(j,:)        ! crossing attemps
         enddo
         write(iunit,'("%")') ! break
         do j=1,nstring
          write(iunit,'('//fmt//int_format//')')                        &
     &     voro_data_all(j,nstring+1:2*nstring)+cv%cross_acceptO(j,:) ! crossing accepts
         enddo
         write(iunit,'("%")') ! break
         write(iunit,'('//fmt//int_format//')')                         &
     &    voro_data_all(:,2*nstring+1)+cv%voro_occupancyO(:)        ! occupancy
        endif ! ME
       endif ! MPI_COMM_STRNG
!
       end subroutine cv_common_print_voro_data
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_voro_data(iunit)
       use sm_var, only: nstring
!      assume that unit is prepared
       __DEP_MULTICOM
       __DEP_MPI
!
       int :: iunit
!      locals
       int :: j
       int :: voro_data_all(SIZE_STRNG,2*SIZE_STRNG+1)
       int :: ierror
#include "mpitype.def"
!      do work
!      gather all data on root
!
       if (.not.cv_common_voronoi_initialized) call cv_common_voronoi_init()
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (ME_STRNG.eq.0) then ! string root reads
         do j=1,nstring
          read(iunit,*)  voro_data_all(j,1:nstring)      ! crossing attemps
         enddo
         read(iunit,'(A)') ! break
         do j=1,nstring
          read(iunit,*)  voro_data_all(j,nstring+1:2*nstring)      ! crossing accepts
         enddo
         read(iunit,'(A)') ! break
         read(iunit,*) voro_data_all(:,2*nstring+1)      ! occupancy
        endif ! ME
!
        cv%voronoi_data(:,:,3)=voro_data_all        ! place into "old" position
!
        if (SIZE_STRNG.gt.1) then
         __BROADCAST_STRING(cv%voronoi_data(:,:,3),SIZE_STRNG*(2*SIZE_STRNG+1),mpiint)
        endif
       endif ! MPI_COMM_STRNG
!    broadcast to slaves
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1)         &
#ifdef __CHARMM
     &  __BROADCAST_LOCAL_4B(cv%voronoi_data(:,:,3),nstring*(2*nstring+1))          !__CHARMM_ONLY##.not.INTEGER8
     &  __BROADCAST_LOCAL_8B(cv%voronoi_data(:,:,3),nstring*(2*nstring+1))          !__CHARMM_ONLY##INTEGER8
#else
     &  __BROADCAST_LOCAL(cv%voronoi_data(:,:,3),nstring*(2*nstring+1),mpiint)
#endif
!
       end subroutine cv_common_read_voro_data
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_voronoi_print_log(iunit)
!      assume that unit is prepared
!      NOTE that this is a global print!
       __DEP_MULTICOM
       __DEP_MPI
!
       int :: iunit
!      locals
       int :: i
       int4mpi :: voro_log_size4(SIZE_STRNG)
       int   :: voro_log_size8(SIZE_STRNG)
       int4mpi :: voro_log_disp4(SIZE_STRNG)
       int :: total_size
       INTEGER*8, pointer, dimension(:) :: voro_log_all
       int :: ierror
#include "mpitype.def"
!      do work
!      gather all data on root
!
       if (.not.cv_common_voronoi_initialized) call cv_common_voronoi_init()
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then 
        if (SIZE_STRNG.gt.1) then
!     calculate size of logs
         voro_log_size8=0
!       call MPI_GATHER(cv%voro_log%last,1,type,
!     &                 voro_log_size8,1,type,
!     &                 0,MPI_COMM_WORLD,ierror)
__MPI_ONLY         call MPI_ALLGATHER(cv%voro_log%last,1,mpiint,                     &
__MPI_ONLY     &                 voro_log_size8,1,mpiint,                           &
__MPI_ONLY     &                 MPI_COMM_STRNG,ierror)

         total_size=sum(voro_log_size8)
         voro_log_size4=voro_log_size8 ! type cast to 4 byte int
!     allocate space to hold entire log
         allocate(voro_log_all(total_size))
!     calculate send displacements
         voro_log_disp4(1)=0;
         do i=1,SIZE_STRNG-1
          voro_log_disp4(i+1)=voro_log_disp4(i)+voro_log_size4(i)
         enddo
!      now gather the logs
!__MPI_ONLY       call MPI_GATHERV(cv%voro_log%i,cv%voro_log%last,type,
!__MPI_ONLY     &                  voro_log_all,voro_log_size4,voro_log_disp4,type,
!__MPI_ONLY     &                  0,MPI_COMM_WORLD,ierror)
__MPI_ONLY        call MPI_ALLGATHERV(cv%voro_log%i8,cv%voro_log%last,mpiint8,        &
__MPI_ONLY     &                  voro_log_all,voro_log_size4,voro_log_disp4,mpiint8,&
__MPI_ONLY     &                  MPI_COMM_STRNG,ierror)
        else
         allocate(voro_log_all(cv%voro_log%last)); voro_log_all=cv%voro_log%i8(1:cv%voro_log%last)
        endif !size
!
        if (ME_STRNG.eq.0) write(iunit) voro_log_all
!
        call int8_vector_reinit(cv%voro_log) ! erase log
        deallocate(voro_log_all)
       endif ! STRNG
       end subroutine cv_common_voronoi_print_log
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_M(ifile, ind, qraw_, qlocal_, replica_, numrep_)
       use sm_var, only: nstring
!     print mass matrix; unless otherwise specified assume that cv%m(:,:,4) has what the user wants
! NOTE : need to deal with replica input
      __DEP_MULTICOM
      __DEP_MPI
      __DEP_CONST
      
      use parser
      use cmd
!
      __IAM(CV_COMMON_READ_M)
!
#include "mpitype.def"
       int, optional :: ifile
       int, optional, intent(in) :: ind  ! M index
!
       bool :: M_initialized
       character(len=maxlinelen) :: line
       character(len=20) :: keyword(2)
       int :: ierror, j, Mind, k, l
       int :: nstring_
       float, pointer :: M_all(:,:,:)
       float :: M_me(cv%num_cv, cv%num_cv)
       __OPAR(qraw,bool)
       __OPAR(qlocal,bool)
       __OPAR(replica,int)
       __OPAR(numrep,int)
!
       nullify(M_all)
!
       __PRESENT(qraw,.true.)
       __PRESENT(qlocal,.false.)
       __PRESENT(replica,ME_STRNG); if (replica.eq.__INAN) replica=ME_STRNG
       __PRESENT(numrep,SIZE_STRNG); if (numrep.eq.__INAN) numrep=SIZE_STRNG
!
       if (replica.lt.0) then
         __WRN(whoami, 'REQUESTED NEGATIVE REPLICA NUMBER. NOTHING DONE.')
         return
       endif
!
       if (present(ind)) then ; Mind=ind ; else ; Mind=4 ; endif
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then ! replica roots
!
        if (qraw) then
         if (qlocal) then ! all replicas read
          read(abs(ifile),*) M_me(:,:)
         elseif(ME_STRNG.eq.0) then 
          allocate(M_all(cv%num_cv, cv%num_cv, numrep)); M_all=__NAN;
          do j=1,numrep
!           read(ifile,'(1X,I10)') ! no present use for comment field
           read(abs(ifile),*)
           read(abs(ifile),*) M_all(:,:,j)
          enddo
         endif ! local
!==============================================
        else ! human-readable restart file
          if (qlocal) then
!write(100+ME_STRNG, *) ifile, qlocal ; close(100+ME_STRNG) ;
           if (present(ifile)) call parse_file(abs(ifile), &
#ifdef __PARALLEL
     &           MPI_COMM_NULL,&
#endif
     &            quiet_=.true.)
           __GETPAR(nstring,i) ! number of string replicas in file
           __GET_OPT_PAR_B(M_initialized,M_initialized,.true., __MYCTX)
           if (.not.M_initialized) then
            __WRN(whoami, 'RESTART FILE REPORTS UNINITIALIZED M TENSOR.');
           endif
           if (replica.ge.nstring_) then
             __WRN(whoami, ' REQUESTED REPLICA NUMBER ('//itoa(replica)//') EXCEEDS RESTART STRING SIZE ('//itoa(nstring_)//').')
           endif
! read matrix columns
           M_me=__NAN
           keyword(1)='M_'//itoa(replica)//'_' ; l=len_trim(keyword(1))
           do k=1,cv%num_cv
            keyword(2)=keyword(1)(1:l)//itoa(k)
            if (M_initialized.or.existtag_nocase(keyword(2),__MYCTX)) then
             line=getval_nocase(keyword(2),__MYCTX)
             if (len_trim(line).gt.0) then
              read(line,*,iostat=ierror) M_me(:,k)
              if (ierror.ne.0) then
               __WRN(whoami, 'ERROR READING VARIABLE FROM LINE "'//trim(line)//'"')
               cycle
              endif ! error
             endif ! line
            endif ! M_initialized
           enddo ! k
!
          elseif (ME_STRNG.eq.0) then ! .not.qlocal
           if (present(ifile)) call parse_file(abs(ifile), &
#ifdef __PARALLEL
     &          MPI_COMM_NULL,&
#endif
     &          quiet_=.true.)
! need to check replica
           __GETPAR(nstring,i) ! number of string replicas in file
           if (nstring_.le.0) then
            nstring_=numrep
            __WRN(whoami, ' MISSING OR INVALID NUMBER OF REPLICAS IN RESTART FILE. ASSUMING NSTRING='//itoa(nstring_))
           else
            numrep=nstring_ ! go by the restart file
           endif
           if (replica.ge.nstring_) then
             __WRN(whoami, ' REQUESTED REPLICA NUMBER ('//itoa(replica)//') EXCEEDS RESTART STRING SIZE ('//itoa(nstring_)//').')
           endif
           __GET_OPT_PAR_B(M_initialized,M_initialized,.true., __MYCTX)
           if (.not.M_initialized) then
            __WRN3(whoami, 'RESTART FILE REPORTS UNINITIALIZED M TENSOR.',0);
           endif
!
           allocate(M_all(cv%num_cv, cv%num_cv, numrep)) ; M_all=__NAN
!
           do j=1, numrep
            keyword(1)='M_'//itoa(j-1)//'_' ; l=len_trim(keyword(1));
            do k=1,cv%num_cv
             keyword(2)=keyword(1)(1:l)//itoa(k)
             if (M_initialized.or.existtag_nocase(keyword(2),__MYCTX)) then
              line=getval_nocase(keyword(2),__MYCTX)
              if (len_trim(line).gt.0) then
               read(line,*,iostat=ierror) M_all(:,k,j)
               if (ierror.ne.0) then
                __WRN(whoami, 'ERROR READING VARIABLE FROM LINE "'//trim(line)//'"')
                cycle
               endif ! error
              endif ! line
             endif ! M_initialized
            enddo ! k
           enddo ! j
          endif ! qlocal
           if ((qlocal.or.ME_STRNG.eq.0).and.present(ifile)) then
            if (ifile.lt.0) call parser_clear_context(__MYCTX)
           endif
        endif ! qraw
!
        if (.not.qlocal) then
! need to deal with replica at this level !
! the problem is that in principle, some replicas could have replica_ passed in, and some, not
! so we cannot use the presence/absence (or value ) of replica on any node
! to make the decision on how to distribute the Ms. The only safe way is to broadcastk everything
         if (SIZE_STRNG.gt.1) then
__MPI_ONLY      __BROADCAST_STRING(numrep,1,mpiint) ! num-rep for M_all matrix
                if (ME_STRNG.gt.0) then;allocate(M_all(cv%num_cv, cv%num_cv, numrep));M_all=__NAN;endif
__MPI_ONLY      __BROADCAST_STRING(M_all,numrep*cv%num_cv**2,mpifloat)
         endif

         if (replica .lt. numrep .and. replica .ge. 0) then
          M_me=M_all(:,:,replica+1)
         else
          __WRN(whoami,'REPLICA '//itoa(ME_STRNG)//' ATTEMPTED TO READ NONEXISTENT COLUMN '//itoa(replica)//'. NOTHING DONE.')
         endif ! replica
        endif ! qlocal
!     check for zero coordinate entries
        if (any(M_me.eq.__NAN)) then
         __WRN3(whoami,'M TENSOR HAS UNDEFINED VALUES AFTER READING ON REPLICA '//itoa(ME_STRNG)//'.',0)
        endif
       endif ! replica roots
!
!    broadcast to slaves
       if (ME_LOCAL.ne.MPI_UNDEFINED.and.SIZE_LOCAL.gt.1)               &
#ifdef __CHARMM
     &  __BROADCAST_LOCAL_4B(M_me,cv%num_cv**2) !__CHARMM_ONLY##SINGLE
     &  __BROADCAST_LOCAL_8B(M_me,cv%num_cv**2) !__CHARMM_ONLY##.not.SINGLE
#else
     &  __BROADCAST_LOCAL(M_me,cv%num_cv**2,mpifloat)
#endif
!
       cv%M(1:cv%num_cv, 1:cv%num_cv, Mind)=M_me
!
       if (Mind.eq.4) then
!    set the short-time average to the long-time average
        cv%M(1:cv%num_cv, 1:cv%num_cv, 2)=M_me
        call cv_common_compute_Minv()
       elseif (Mind.eq.3) then
        cv_common_Minv_initialized=.true.
       endif
!
       __FREE(M_all)
       end subroutine cv_common_read_M
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_M_global(ifile, ind, qraw_, qhead_)
       use sm_var, only: nstring
!     print mass matrix; assume that cv%m(:,:,4) has what the user wants (long-term average)
!
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI  ! deal with other platforms later
      use parser, only: itoa
!
#include "mpitype.def"
       int, intent(in) :: ifile
       int, optional, intent(in) :: ind  ! M index to print
       __OPAR(qraw,bool)
       __OPAR(qhead,bool)
!     locals
       character(len=80) :: fmt
       character(len=20) :: keyword
       int :: isizeM, ierror, j, k, Mind, l
       float :: M_all(cv%num_cv, cv%num_cv, nstring)
       float :: M_me(cv%num_cv, cv%num_cv)
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then ! replica roots only
!
        __PRESENT(qraw,.true.)
        if (present(ind)) then ; Mind=ind ; else ; Mind=4 ; endif
!
        isizeM=cv%num_cv;
        M_me=cv%M(1:isizeM, 1:isizeM, Mind)
        isizeM=isizeM*isizeM
!
        if (SIZE_STRNG.gt.1) then
__MPI_ONLY        call MPI_GATHER(M_me,isizeM,mpifloat,               &
__MPI_ONLY     &                 M_all,isizeM,mpifloat,0,             &
__MPI_ONLY     &                 MPI_COMM_STRNG,ierror)
        else
         M_all(:,:,1)=M_me
        endif
!        call MPI_ALLGATHER(M_me,isizeM,mpifloat,
!     &                 M_all,isizeM,mpifloat,
!     &                 MPI_COMM_STRNG,ierror)
        write(fmt,'(I5)') cv%num_cv
        if (ME_STRNG.eq.0) then ! root writes
         if (qraw) then
          do j=1,nstring
           write(ifile,'("% ",I5)') j
           write(ifile,'('//fmt//real_format//')') M_all(:,:,j)
!           write(ifile,'('//fmt//'E15.5)') M_all(:,:,j)
!           write(ifile,'('//fmt//'F11.5)') cv%M(1:cv%num_cv,1:cv%num_cv,1)
          enddo
!=================== human readable format
         else
! unclear when to print header ...
          __PRESENT(qhead,.true.)
          if (qhead) call cv_common_print_header(ifile)
#define _W write(ifile,*)
          _W 'smcv {'
          _W '# M_x_y = ( ... ) :  y column of metric tensor M corresponding to replica x ' 
          if (any(M_all.eq.__NAN)) then
           _W 'M_initialized = no'
          else
           do j=1,nstring
            keyword='M_'//itoa(j-1)//'_' ; l=len_trim(keyword);
            do k=1,cv%num_cv
             _W keyword(1:l)//itoa(k), '=(', M_all(:,k,j),')'
            enddo ! M columns/rows (M=M^t)
           enddo ! replicas
          endif ! M==nan
          _W '} # smcv'
         endif ! qraw
        endif ! ME
       endif ! MPI_COMM
!
       end subroutine cv_common_print_M_global
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_M_local(ifile, ind, qraw_, qhead_)
!     print mass matrix; assume that cv%m(:,:,4) has what the user wants (long-term average)
!
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI  ! deal with other platforms later
      use parser, only: itoa
!
#include "mpitype.def"
       int, intent(in) :: ifile
       int, optional, intent(in) :: ind  ! M index to print
       __OPAR(qraw,bool)
       __OPAR(qhead,bool)
!     locals
       character(len=80) :: fmt
       character(len=20) :: keyword
       int :: k, Mind, l
       float, pointer :: M_me(:,:)
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then ! replica roots only
!
        __PRESENT(qraw,.true.)
        if (present(ind)) then ; Mind=ind ; else ; Mind=4 ; endif
!
        M_me=>cv%M(1:cv%num_cv, 1:cv%num_cv, Mind)
!
!        call MPI_ALLGATHER(M_me,isizeM,mpifloat,
!     &                 M_all,isizeM,mpifloat,
!     &                 MPI_COMM_STRNG,ierror)
        write(fmt,'(I5)') cv%num_cv
        if (qraw) then
         write(ifile,'("% ",I5)') ME_STRNG
         write(ifile,'('//fmt//real_format//')') M_me
!=================== human readable format
        else
! unclear when to print header ...
        __PRESENT(qhead,.true.)
         if (qhead) call cv_common_print_header(ifile)
#define _W write(ifile,*)
         _W 'smcv {'
         _W '# M_x_y = ( ... ) :  y column of metric tensor M corresponding to replica x ' 
         if (any(M_me.eq.__NAN)) then
          _W 'M_initialized = no'
         else
          keyword='M_'//itoa(ME_STRNG)//'_' ; l=len_trim(keyword);
          do k=1,cv%num_cv
           _W keyword(1:l)//itoa(k), '=(', M_me(:,k), ')'
          enddo ! M columns/rows (M=M^t)
         endif ! M==nan
         _W '} # smcv'
        endif ! qraw
       endif ! MPI_COMM
!
       end subroutine cv_common_print_M_local
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_neq_work_init()
!      initialize variables for nonequilibrium work
       cv%work=zero
       cv%r(:,forces2)=zero
       cv%r(:,zcur)=cv%r(:,comp)
       cv%r(:,zold)=cv%r(:,comp)
       end subroutine cv_common_neq_work_init
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       function cv_common_neq_get_work()
!      returns the value of work
       float :: cv_common_neq_get_work
       cv_common_neq_get_work=cv%work
       end function cv_common_neq_get_work
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_interpolate(ifile, ofile, num_rep_in,         &
     &                     num_rep_out, interp_method)
      
!     assume that both units ifile/ofile are prepared
      __DEP_MULTICOM
      __DEP_MPI 
!
       int :: ifile, ofile, num_rep_in, num_rep_out, interp_method
!     local declarations
       float :: rin(max_cv_common,num_rep_in),                           &
     &           dr(max_cv_common,num_rep_in-1)
       float :: rout(max_cv_common,num_rep_out)
       float :: rr(num_rep_in), rr_out(num_rep_out), ds(num_rep_in-1), &
     &           ds2(num_rep_in-1), s(num_rep_in), t(num_rep_out),      &
     &           rrpp(num_rep_in), dum
       int :: i,k
       character(len=80) :: fmt
       bool :: qroot
       __IAM(CV_COMMON_INTERPOLATE)
!
       int, parameter :: linear=1, spline=2, bspline=3
!
       interface ! to linear interpolation routine
        subroutine linear_interp(xin,yin,nin,xout,yout,nout,dydxout)
!
      __CHARMM_ONLY __DEP_KINDS
!
        int :: nin, nout
        float :: xin(nin), yin(nin), xout(nout), yout(nout)
        float, optional :: dydxout(nout) ! tangent computation
        float :: dydx(nout)
        end subroutine linear_interp
       end interface
!
       qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0)
!
       if (cv%num_cv.eq.0) then
        __WRN( whoami,' NO CV DEFINED. NOTHING DONE.')
        return
       endif
!
       rin=zero; dr=zero; rout=zero;
!
       if (qroot) then ! root does the work
        do i=1,cv%num_cv
         read(ifile,*) (rin(i,k),k=1,num_rep_in)
        enddo
       endif ! root
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     do the interpolation --  simple, not self-consistent
       if (qroot) then ! only root does the work
!     check for undefined values
       if (any(rin(1:cv%num_cv,:).eq.__NAN))                             &
     &   __WRN( whoami,'SOME CV VALUES ARE UNDEFINED')
!     compute arclength
        dr=rin(:,2:num_rep_in)-rin(:,1:num_rep_in-1)
        s(1)=0
        do i=1,num_rep_in-1
         ds2(i)=dot_product(dr(:,i)**2,cv%weight**2)
         ds(i)=sqrt(ds2(i))
         s(i+1)=s(i)+ds(i)
        enddo
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     normalize arclength
        do i=1,num_rep_in
         s(i)=s(i)/s(num_rep_in)
        enddo
!ccccccccccccccccccccccccc
!     create uniform array
        do i=1,num_rep_out
         t(i)=one*(i-1)/(num_rep_out-1)
        enddo
!cccccccccccccc now interpolate variables cccccc
        if (interp_method.eq.spline) then
         do i=1,cv%num_cv
           rr=rin(i,:)
           call spline_cubic_set(num_rep_in,s,rr,0,0,0,0,rrpp)
           do k=1,num_rep_out
            call spline_cubic_val(num_rep_in,s,rr,rrpp,t(k),            &
     &                          rout(i,k),dum,dum)
           enddo
         enddo
        elseif (interp_method.eq.bspline) then
         do i=1,cv%num_cv
           rr=rin(i,:)
           do k=1,num_rep_out
            call spline_b_val(num_rep_in,s,rr,t(k),rout(i,k))
           enddo
         enddo
        elseif (interp_method.eq.linear) then
         do i=1,cv%num_cv
           rr=rin(i,:)
           call linear_interp(s,rr,num_rep_in,t,rr_out,num_rep_out)
           rout(i,:)=rr_out
         enddo
        else
         __WRN( whoami,'NO VALID INTERPOLATION METHODS SELECTED')
        endif ! interp_method
!
!     write output file
        write(fmt,int_format) num_rep_out
        do i=1,cv%num_cv
         write(ofile,'('//fmt//real_format//')')                        &
     &     (rout(i,k),k=1,num_rep_out)
        enddo
       endif ! qroot
       end subroutine cv_common_interpolate
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
__CHARMM_ONLY##ENDIF
      end module cv_common
!
