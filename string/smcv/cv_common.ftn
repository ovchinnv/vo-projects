!
!     CV_COMMON.MOD
!
!     COMMON ROUTINES FOR COLLECTIVE VARIABLES
!     SPECIFIC CV USE THIS MODULE
!     ADDITIONAL STORAGE FOR CV TYPES SHOULD BE ALLOCATED IN CV%PRIV(I),
!     WHERE I IS THE CV INDEX
!
__CHARMM_ONLY##IF STRINGM
!
      module cv_common
      use ivector_list
      use cv_types ! unfortunately, need to include this module because angle calculations require special treatment
!
!     declare pointer type (for arrays of pointer)
      type priv_ptr
       int, pointer :: p(:), amap_ptr(:) ! amap_ptr contains a unique list of indices in the amap that the cv depends on
       float,  pointer :: pr(:)
      end type priv_ptr
!****************************************************************************************************************************
      type cv_base
!
      float, dimension(:,:), pointer :: r ! cv coordinates
      float, dimension(:,:,:), pointer :: M ! mass matrix: (running average); two slots for M, (:,:,1) and (:,:,2); two slots for M^{-1} (:,:,3-4)
      float, dimension(:,:,:,:), pointer :: grad ! combined gradient array; introduced for parallelization (comm. efficiency)
      float, dimension(:,:,:), pointer :: gradx ! gradient vector of CV w.r.t. x ; (:,:,2) is mass-weighted to compute M
      float, dimension(:,:,:), pointer :: grady ! gradient vector of CV w.r.t. y ; (:,:,2) is mass-weighted to compute M
      float, dimension(:,:,:), pointer :: gradz ! gradient vector of CV w.r.t. z ; (:,:,2) is mass-weighted to compute M
      int, dimension(:), pointer :: type ! cv type (e.g. position, bond, angle, etc.)
      bool, dimension(:), pointer :: active ! if flag .false., cv will be computed, but force not added, unless this cv is a part of another function
!                                                e.g. RMSD ; experimental as of 7.2010; to make this compatible witl all features, need to ignore cvs
!                                                that are "inactive" in reparametrization, df computation, etc.; currently used for SMD
      type (priv_ptr), dimension(:), pointer :: priv ! cv data that is 'private' to each cv
      type (int_vlist) :: amap ! maps local indices to psf atom indices; also contains an inverse map: which CV make use of an index
      float, dimension(:), pointer :: r_bc_0, r_bc_1 ! arrays for optional fixed b.c.
      float, dimension(:), pointer   :: k ! force constant
      float :: kpara ! force constant for forces parallel to string ; same for all CV (required for off-path sim.)
      float :: kperp ! force constant for forces perpendicular to string ; same for all CV
      float, dimension(:), pointer   :: gamma ! coupling constant for on-the-fly string (currently not used)
      float, dimension(:), pointer   :: weight
      float :: wrss ! one over root-sum-square of the weight array
      int :: num_cv=0 ! number of active collective vars
      int :: num_hist=0 ! number of snapshots in the history
      int :: beg_hist=1 ! index in the history that corresponds to the oldest snapshot (first)
      int :: end_hist=0 ! index in the history that corresponds to the newest snapshot (last)
      int :: num_run_ave=0 ! number of snapshots in the running average
      float  :: dt=0       ! timestep for string evolution
      int :: num_average_samples=0 ! number of samples in the accumulated CV average
      int :: num_fe_samples=0 ! number of samples in the fe running average
      float, dimension(:), pointer   :: ds, fe, curvature, feav ! arclength,FE,curvature, avg. FE
      float, dimension(:,:), pointer :: rall ! holds a complete set of CV for Voronoi T.
      float, dimension(:,:,:), pointer :: Mall ! holds a complete set of M matrices & inverses (Voronoi T.)
      float :: work ! nonequilibrium work
      int, dimension(:,:,:), pointer :: voronoi_data   ! holds the nine arrays listed below
! local
      int, dimension(:,:), pointer :: cross_attempt ! holds the history of crossing attempts in 1st column
      int, dimension(:,:), pointer :: cross_accept  ! history of successful crossing attempts in second column. For Voronoi Tessellation.
      int, dimension(:), pointer :: voro_occupancy ! total # iterations voronoi cells are populated (watch out for max int value !!!)
! global
      int, dimension(:,:), pointer :: cross_attemptG
      int, dimension(:,:), pointer :: cross_acceptG
      int, dimension(:), pointer :: voro_occupancyG
! old global (for restarting)
      int, dimension(:,:), pointer :: cross_attemptO
      int, dimension(:,:), pointer :: cross_acceptO
      int, dimension(:), pointer :: voro_occupancyO
!
      int, dimension(:), pointer :: voronoi_map ! holds map between process rank and voronoi cell
      type (int_vector) :: voro_log ! logs the history of crossing attempts ( which cells and when ); local to each replica
      int :: voronoi_whereami       ! the voronoi cell this replica is inside
      float :: voronoi_cut         ! voronoi cell cutoff in path-perpendicular direction (beyond which MD replicas are not allowed)
      type (int_vector) :: rex_log  ! logs the history of replica exchanges ( which replica and when ); local to each replica
      int, dimension(:), pointer :: rex_map ! holds the map between replica number and the process rank
      float :: rex_beta ! ensemble temperature in replica exchange (usually will be the same as the simulation temperature)
      end type cv_base

      ! subroutines
      public cv_common_init   ! initialize cv array
      public cv_common_done   ! destroy cv array
      public cv_common_add    ! add a CV
      public cv_common_fill   ! set z=theta(x)
      public cv_common_grad_init ! initialize cv%grad arrays
      public cv_common_set_bc ! set boundary conditions on string (fixed or free)
      public cv_common_repa   ! reparameterize
      public cv_common_print_local  ! print out cv values (i.e. z) to separate files
      public cv_common_print_global  ! print out cv values (i.e. z) to a combined file
      public cv_common_add_hist ! save an instance of theta(x)
      public cv_common_print_hist ! write history of computed cv values (i.e. theta(x)) to file
      public cv_common_clear_hist ! clear history
      public cv_common_smooth_hist ! filter history & place in comp-set r(:,:,2)
      public cv_common_evolve_expo ! evolution using exponential averaging of history
      public cv_common_swap   ! swap main-set and comp_set, i.e. r(:,:,1) and r(:,:,2)
      public cv_common_copy   ! swap main-set and comp_set, i.e. r(:,:,1) and r(:,:,2)
      public cv_common_read_global  ! read cv values from separate files
      public cv_common_read_local   ! read cv values from separate files
      public cv_common_read_local_from_global   ! read cv values from a particular column in a global file
      public cv_common_unwrap_angles ! make sure that along the string the angle does not change by more than 180 degrees
      public cv_common_evolve_smcv ! evolve string using average force a la SMCV
      public cv_common_evolve_sd ! evolve string using average force (simple SD)
      public cv_common_rmsd   ! compute rmsd between two sets of CV
      public cv_common_set_kpara  ! set parallel force constant k
      public cv_common_set_kperp  ! set perpendicular force constant k
      public cv_common_set_k  ! set force constant k
      public cv_common_set_w  ! set weight
      public cv_common_set_active  ! set active flag
      public cv_common_set_g  ! set gamma
      public cv_common_set_dt  ! set default timestep
      public cv_common_set_r  ! set collective variable value
      public cv_common_print_curvature ! print out curvature
      public cv_common_print_ds ! print out ds
      public cv_common_print_fe ! print out fe
      public cv_common_print_feav ! print out fe averaged over the statistics interval
      public cv_common_print_forces ! write out forces on CV
      public cv_common_compute_fe_fd ! finite difference computation of free energy using integration
      public cv_common_update_ave ! update average CV set
      public cv_common_update_fe_ave ! update average work curve
      public cv_common_set_ave_samples ! change the number of samples associated with the average CV
      public cv_common_voronoi_compute ! determine which voronoi cell we are in
      public cv_common_voronoi_print_hist ! print voronoi histograms
      public cv_common_voronoi_init ! initialize voronoi histogram matrix
      public cv_common_voronoi_update ! update voronoi cell centers
      public cv_common_voronoi_smart_update ! update vorohnoi cell centers sudh that the MD replicas remain inside their cells
      public cv_common_voronoi_done ! deallocate voronoi histogram matrix
      public cv_common_voronoi_set_cutoff ! set voronoi cell cutoff
      public cv_common_read_voro_map   ! read replica map from file
      public cv_common_print_voro_map   ! read replica map from file
      public cv_common_neq_work_init ! initialize variables for computing work
      public cv_common_neq_get_work ! return work
      public cv_common_interpolate ! interpolate CV onto a different grid
      public cv_common_compute_wgt ! compute CV weights for interpolation and RMSD calculations
      public cv_common_print_wgt ! print CV weights
      public cv_common_read_wgt ! read in CV weights
      public cv_common_compute_dr ! compute tangent to the path
      public cv_common_print_dr ! print tangent to the path
      public cv_common_read_dr ! read tangent to the path
      public cv_common_compute_k ! calculate force constants using k_i=kpara*w_i^2
      public cv_common_print_M_global   ! print mass Matrix
      public cv_common_rex_init       ! initialize replica exchange variables
      public cv_common_rex_done
      public cv_common_rex_compute_dE ! compute energy difference
      public cv_common_read_rex_map   ! read replica map from file
      public cv_common_print_rex_map  ! print replica map
      public cv_common_print_rex_log  ! print replica exchange log

      ! variables
      type (cv_base), public, save :: cv
      bool, public, save ::     cv_common_initialized=.false.,            &
     &                          cv_common_voronoi_initialized=.false.,    &
     &                          cv_common_voronoi_wrong_cell=.false.,     &
     &                          cv_common_grad_initialized=.false.,       & ! have the cv%grad arrays been allocated
     &                          cv_common_weights_initialized=.false.,    & ! has the weight array been initialized, obsolescent
     &                          cv_common_Minv_initialized=.false.,       & ! has the M-1 tensor been initialized
     &                          cv_common_dz_initialized=.false.,         & ! has the weight array been initialized
     &                          cv_common_k_initialized=.false.,          & ! added for off_path sampling
     &                          cv_common_kpara_initialized=.false.,      & ! parallel force constant (off-path)
     &                          cv_common_kperp_initialized=.false.,      & ! perpendicular force constant (off-path)
     &                          cv_common_rex_initialized=.false.    ! exchange of adjacent replicas
!
      int, public, save ::  cv_common_fixed_0_bc=0,                   &  ! first point fixed (not simulated)
     &                      cv_common_fixed_1_bc=0                       ! last point fixed (not simulated)
!
      ! parameters
      int, parameter, public :: max_cv_common=1000,max_hist_base=10000
!     define indices into r array:
      int, parameter, public :: main=1,                             & ! current z
     &                              comp=2,                             & ! previous z
     &                              ref=3,                              &  ! reference z (initial)
     &                              ref2=4,                             & ! reference z (average)
     &                              zcur=5,                             & ! z at current MD iteration (combination of main and comp)
     &                              zold=6,                             & ! z at previous MD iterations (combination of main and comp); currently not used
     &                              dz=7,                               &   ! vector tangent to the path
     &                              runave=8,                           & ! running average between string steps
     &                              instant=9,                          & ! (instantaneous) theta(x)
     &                              previnst=10,                        & ! previous value of (instantaneous) theta(x)
     &                              forces=11,                          & ! average forces on z (dF/dz) for evolution
     &                              forces2=12 ! instantaneous forces (not used for evolution)
!
      int, parameter, public :: main_offset=12 ! num of parameters above
!
      character(len=8), parameter, public :: real_format='(E23.15)'
      character(len=5), parameter, public :: int_format='(I10)'
!
      contains
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_init()
       use sm_var, only: nstring, smcv_initialized
      __DEP_NUMBER 
      __DEP_MULTICOM
!
      __IMPNONE
!
       int :: nrep ! number of total replicas
       int :: i
!
       if (.not.smcv_initialized) call smcv_init() ! defines nstring
!
       if (.not.cv_common_initialized) then
!
        nrep=nstring+cv_common_fixed_0_bc+cv_common_fixed_1_bc
        cv%num_cv=0
        call cv_common_clear_hist()
!
        allocate(cv%r(max_cv_common, max_hist_base+main_offset))
!
        if (cv_common_fixed_0_bc.eq.1) then
         allocate(cv%r_bc_0(max_cv_common))
         cv%r_bc_0=__NAN
        endif
!
        if (cv_common_fixed_1_bc.eq.1) then
         allocate(cv%r_bc_1(max_cv_common))
         cv%r_bc_1=__NAN
        endif
!
        allocate(cv%M(max_cv_common,max_cv_common,4))
        allocate(cv%priv(max_cv_common)) ! allocate pointer array
        do i=1, max_cv_common
         nullify(cv%priv(i)%p) ! initialize pointer array
         nullify(cv%priv(i)%amap_ptr) ! nullify pointer to atom map (see above)
         nullify(cv%priv(i)%pr)
        enddo
        allocate(cv%type(max_cv_common))
        allocate(cv%active(max_cv_common))
        allocate(cv%k(max_cv_common))
        allocate(cv%gamma(max_cv_common))
        allocate(cv%weight(max_cv_common))
        allocate(cv%ds(nrep-1))
        allocate(cv%curvature(nrep-2))
        allocate(cv%fe(nrep))
        allocate(cv%feav(nrep))
        cv_common_initialized=.true.
        cv%r=__NAN
        cv%r(:,runave)=0d0    ! not necessary, but cleaner when CVs include angles which need to be averaged
        cv%r(:,previnst)=0d0  ! not necessary, but cleaner when CVs include angles
        cv%M=0d0
        cv%type=-1d0
        cv%active=.true. ! all cv active by default (and for compatibility with previous code)
        cv%k=0d0
        cv%kpara=0d0
        cv%kperp=0d0
        cv%gamma=0d0
        cv%weight=0d0 ! need to be initialized by user
        cv%ds=0d0
        cv%curvature=0d0
        cv%fe=0d0
        cv%feav=0d0
        cv%dt=0d0
        cv%work=0d0
        cv%num_average_samples=0
        cv%num_fe_samples=0
       endif
       end subroutine cv_common_init
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_done()
       __IMPNONE
       int :: i
       cv%num_cv=0
       call cv_common_clear_hist()
       cv%dt=0d0
       if (cv_common_initialized) then
        deallocate(cv%r)
!
        if (cv_common_fixed_0_bc.eq.1) then
         deallocate(cv%r_bc_0)
        endif
!
        if (cv_common_fixed_1_bc.eq.1) then
         deallocate(cv%r_bc_1)
        endif
!
        do i=1, max_cv_common
         if (associated(cv%priv(i)%p))                                  &
     &     deallocate(cv%priv(i)%p) ! free private memory
         if (associated(cv%priv(i)%amap_ptr))                           &
     &     deallocate(cv%priv(i)%amap_ptr) ! free pointer array to atom map
         if (associated(cv%priv(i)%pr))                                 &
     &     deallocate(cv%priv(i)%pr) ! free private memory
        enddo
        call int_vlist_done(cv%amap) ! deallocate amap if necessasry
!
        deallocate(cv%M)
        if (associated(cv%grad)) deallocate(cv%grad)
        nullify(cv%gradx)
        nullify(cv%grady)
        nullify(cv%gradz)
!        if (associated(cv%gradx)) deallocate(cv%gradx)
!        if (associated(cv%grady)) deallocate(cv%grady)
!        if (associated(cv%gradz)) deallocate(cv%gradz)
        deallocate(cv%type)
        deallocate(cv%active)
        deallocate(cv%k)
        deallocate(cv%gamma)
        deallocate(cv%weight)
        deallocate(cv%ds)
        deallocate(cv%curvature)
        deallocate(cv%fe)
        deallocate(cv%feav)
        cv_common_initialized=.false.
        cv_common_weights_initialized=.false.
        cv_common_Minv_initialized=.false.
        cv_common_voronoi_initialized=.false.
        cv_common_grad_initialized=.false.
        cv_common_dz_initialized=.false.
        cv_common_k_initialized=.false.
        cv_common_kpara_initialized=.false.
        cv_common_kperp_initialized=.false.
        cv_common_rex_initialized=.false.
       endif
       end subroutine cv_common_done
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       function cv_common_add(k,gamma,weight,type)
      __DEP_OUTPUT
      __DEP_NUMBER 
      __IMPNONE
!
       int :: type
       float, optional :: k, gamma, weight
!      locals
       int j
       int cv_common_add ! returns index into cv array
       character(len=13) :: whoami
       data whoami /' CV_BASE_ADD>'/
!      do work
       if (.not.cv_common_initialized) call cv_common_init()
       j=cv%num_cv + 1
       if  (j.le.max_cv_common) then
!       assign cv values
        cv%num_cv=j
        cv%r(j,:)=__NAN ! undefined value
!
        cv%k(j)=0d0
        if (present(k)) then
         if (k.ge.0d0) then  ! negative k are ignored
          cv%k(j)=k
         endif
        endif
!
        if (present(gamma)) then
         if (gamma.gt.0d0) then
          cv%gamma(j)=1d0/gamma; ! disallow zero
         else
          __WRN(whoami,'NONPOSITIVE GAMMA SPECIFIED. WILL RESET TO 1.0.')
          cv%gamma(j)=1d0;
         endif
        else
         cv%gamma(j)=1d0;
        endif
!
        cv%weight(j)=0d0
        if (present(weight)) then
         if (weight.gt.0d0) then  ! negative weights are ignored
          cv%weight(j)=weight
         endif
        endif
        cv%type(j)=type
        cv_common_add=j
!
        if (any(cv%weight(1:cv%num_cv).le.0d0)) then
         cv_common_weights_initialized=.false.
        else
         cv_common_weights_initialized=.true.
        endif
        cv%wrss=1./sqrt( sum( cv%weight(1:cv%num_cv)**2) )
       else ! out of bounds
!       maximum storage space exceeded; for now complain and exit; in the future, can reallocate
        __WRN( whoami,'MAXIMUM NUMBER OF CV EXCEEDED. NOTHING DONE.')
        cv_common_add=0
        return
       endif
       end function cv_common_add
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_fill(i,val,c)
      __DEP_OUTPUT
      __IMPNONE
       int :: i
       float :: val
       int, optional :: c
       int :: c1
       character(len=14) :: whoami
       data whoami /' CV_BASE_FILL>'/
!      do work:
       if (present(c)) then
        if (c.lt.1.or.c.gt.main_offset+max_hist_base) then
         __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
         return
        else ! c valid
         c1=c
        endif
       else ! c was not passed
        c1=main
       endif
       cv%r(i,c1)=val
       end subroutine cv_common_fill
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_grad_init()
!      initialize cv%grad arrays
       __IMPNONE
       if (associated(cv%grad)) deallocate(cv%grad)
!       if (associated(cv%gradx)) deallocate(cv%gradx) !    delete old data if present
!       if (associated(cv%grady)) deallocate(cv%grady) !    delete old data if present
!       if (associated(cv%gradz)) deallocate(cv%gradz) !    delete old data if present
       allocate(cv%grad(cv%num_cv, cv%amap%last, 2, 3)) ! x,y,z components are indexed by last dimension
       cv%gradx=>cv%grad(:, :, :, 1);
       cv%grady=>cv%grad(:, :, :, 2);
       cv%gradz=>cv%grad(:, :, :, 3);
!       allocate(cv%gradx(cv%num_cv, cv%amap%last, 2))
!       allocate(cv%grady(cv%num_cv, cv%amap%last, 2))
!       allocate(cv%gradz(cv%num_cv, cv%amap%last, 2))
!       cv%gradx=0d0; cv%grady=0d0; cv%gradz=0d0
       cv%grad=0d0;
       cv_common_grad_initialized=.true.
       end subroutine cv_common_grad_init
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_compute_Minv(inverse_LU)
       use lu, only: inv_lu  ! matrix inverse by LU decomposition
       use multidiag, only: inv_mdiag
       __IMPNONE
       int :: bug
       bool, optional :: inverse_LU
       bool :: qLU=.true.
       if (present(inverse_LU)) then ; qLU=inverse_LU; endif
!    assume matrix M is regular
!    if using multidiag, also assume it has nonzero diagonals
       if (qLU) then
        call inv_lu(cv%M(1:cv%num_cv,1:cv%num_cv,2),                    &
     &            cv%M(1:cv%num_cv,1:cv%num_cv,3), cv%num_cv, bug) ! M inverse in M(,,3)
       else
        call inv_mdiag(cv%M(1:cv%num_cv,1:cv%num_cv,2),                 &
     &            cv%M(1:cv%num_cv,1:cv%num_cv,3), cv%num_cv, bug)
       endif
!
       if (bug.eq.0) cv_common_Minv_initialized=.true.
!
       end subroutine cv_common_compute_Minv
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_compute_wgt()
!      compute weight array from M matrix
!      assume that M is valid on each node
      __DEP_OUTPUT
      __DEP_MULTICOM
      __DEP_MPI 
      __IMPNONE
!
#include "../mpitype.def"
!
       float :: s, sum
       int :: i, j, ierror
!    local
!
       bool :: qroot
!
       float :: Mave(max_cv_common, cv%num_cv)
       character(len=21) :: whoami
       data whoami /' CV_BASE_COMPUTE_WGT>'/
!
       qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL)
       if (qroot) then
       call MPI_ALLREDUCE(cv%M(1,1,3),Mave,max_cv_common*cv%num_cv,       &
     &        mpifloat, MPI_SUM, MPI_COMM_STRNG, ierror) ! use M inverse averaged along string
!     11/30/08: note: it is not completely clear to me how the weights should computed
        do j=1,cv%num_cv
         s=0d0; do i=1, cv%num_cv ; s=s+Mave(i,j)**2 ; enddo
!        s=1d0*SIZE_STRNG/sqrt(s) ! average, since we used MPI_SUM above
         s=(s/SIZE_STRNG)**0.25d0 ! average [SIZE_STRNG], since we used MPI_SUM above
         cv%weight(j)=s ! for positions, s will be sqrt(mass), as expected
        enddo
        if (any(cv%weight(1:cv%num_cv).eq.0)) &
        __WRN( whoami,'ZERO CV WEIGHT COMPUTED.')
       endif ! qroot
!
! broadcast to slaves
!
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
        __BROADCAST_LOCAL_4B(cv%weight(1:cv%num_cv), cv%num_cv) !__CHARMM_ONLY##SINGLE
        __BROADCAST_LOCAL_8B(cv%weight(1:cv%num_cv), cv%num_cv) !__CHARMM_ONLY##.not.SINGLE
#else
        __BROADCAST_LOCAL(cv%weight(1:cv%num_cv), cv%num_cv, mpifloat) ! broadcast within groups
#endif
       endif
!
       cv%wrss=1./sqrt( sum( cv%weight(1:cv%num_cv)**2) ) ! compute rms
       cv_common_weights_initialized=.true.
       end subroutine cv_common_compute_wgt
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_wgt(iunit,fmt)
       __DEP_OUTPUT
       __IMPNONE
!      only root process must call
       int iunit
       character(len=*), optional :: fmt
!      local
       character(len=80) :: frm
       character(len=19) :: whoami
       data whoami /' CV_BASE_PRINT_WGT>'/
!      begin
       if (.not.cv_common_weights_initialized)                            &
     & __WRN(whoami,'CV WEIGHTS NOT INITIALIZED.')
       if (.not.present(fmt)) then
        write(frm,'("(",I5,"E15.5)")') max(cv%num_cv,1)
       else
        frm=fmt
       endif
       write(iunit,frm) cv%weight(1:cv%num_cv)
       end subroutine cv_common_print_wgt
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_wgt(iunit)
      __DEP_OUTPUT
      __DEP_MULTICOM
      __DEP_MPI 
      __IMPNONE
!
#include "../mpitype.def" 
!
       int iunit, ierror
       character(len=18) :: whoami
       data whoami /' CV_BASE_READ_WGT>'/
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (ME_STRNG.eq.0) then
         read(iunit,*) cv%weight(1:cv%num_cv) ! only root reads
         if (any(cv%weight(1:cv%num_cv).le.0)) &
     &   __WRN( whoami,'READ ZERO OR NEGATIVE CV WEIGHT')
        endif ! ME_
        if (SIZE_STRNG.gt.1)                                            &
     &  __BROADCAST_STRING(cv%weight, cv%num_cv, mpifloat)
       endif ! MPI_COMM
!    broadcast to slave nodes
       if (ME_LOCAL.ne.MPI_UNDEFINED.and.SIZE_LOCAL.gt.1)               &
!     &  call MPI_BCAST(cv%weight, cv%num_cv, mpifloat,
!     &                     0,MPI_COMM_LOCAL,ierr)
#ifdef __CHARMM
     &  __BROADCAST_LOCAL_4B(cv%weight,cv%num_cv) !__CHARMM_ONLY##SINGLE
     &  __BROADCAST_LOCAL_8B(cv%weight,cv%num_cv) !__CHARMM_ONLY##.not.SINGLE
#else
     &  __BROADCAST_LOCAL(cv%weight,cv%num_cv,mpifloat)
#endif
!
       cv%wrss=1./sqrt( sum( cv%weight(1:cv%num_cv)**2) )
       cv_common_weights_initialized=.true.
       end subroutine cv_common_read_wgt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_compute_k()
       __DEP_OUTPUT
       __IMPNONE
       int :: i
       character(len=20) :: whoami
       data whoami /' CV_BASE_COMPUTE_K>'/
!
       if (cv_common_weights_initialized) then
        if (cv_common_kpara_initialized) then
         do i=1, cv%num_cv
          cv%k(i)=cv%kpara*(cv%weight(i)**2)
         enddo
         cv_common_k_initialized=.true. ! note: this flag only relevant for off-path sampling
         if (any(cv%k(1:cv%num_cv).lt.0)) &
     &   __WRN( whoami,'COMPUTED NEGATIVE FORCE CONSTANT')
        else
         __WRN( whoami,'PARALLEL FORCE CONSTANT NOT SET. NOTHING DONE.')
        endif
       else
         __WRN( whoami,'CV WEIGHTS NOT INITIALIZED. NOTHING DONE.')
       endif
!
       end subroutine cv_common_compute_k
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_compute_dr()
       use sm_var, only: nstring
       __DEP_MULTICOM
       __DEP_MPI 
       __IMPNONE
       int :: ierror
!
#include "../mpitype.def"
!      interface to 'compute_dr' utility routine
       interface
        subroutine compute_dr(rin,drout,wgt,n,                          &
     &   d_arclength, curvature, r_bc_0, r_bc_1) ! arrays for fixed bc
         int :: n
         float :: rin(n), drout(n), wgt(n)
         float :: d_arclength(:), curvature(:)
         float, optional :: r_bc_0(n), r_bc_1(n)
        end subroutine compute_dr
       end interface
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.                         &
     &                         SIZE_STRNG.gt.1) then
        if (cv%num_cv.gt.0) then
         if (cv_common_fixed_0_bc.eq.1) then
          if (cv_common_fixed_1_bc.eq.1) then
           call compute_dr(RIN=cv%r(1:cv%num_cv,main),                  &
     &      DROUT=cv%r(1:cv%num_cv,dz), WGT=cv%weight,                  &
     &      N=cv%num_cv,D_ARCLENGTH=cv%ds,CURVATURE=cv%curvature,       &
     &      R_BC_0=cv%r_bc_0, R_BC_1=cv%r_bc_1)
          else
           call compute_dr(RIN=cv%r(1:cv%num_cv,main),                  &
     &      DROUT=cv%r(1:cv%num_cv,dz),WGT=cv%weight,                   &
     &      N=cv%num_cv,D_ARCLENGTH=cv%ds,CURVATURE=cv%curvature,       &
     &      R_BC_0=cv%r_bc_0)
          endif
         else
          if (cv_common_fixed_1_bc.eq.1) then
           call compute_dr(RIN=cv%r(1:cv%num_cv,main),                  &
     &      DROUT=cv%r(1:cv%num_cv,dz),WGT=cv%weight,                   &
     &      N=cv%num_cv,D_ARCLENGTH=cv%ds,CURVATURE=cv%curvature,       &
     &      R_BC_1=cv%r_bc_1)
          else
           call compute_dr(RIN=cv%r(1:cv%num_cv,main),                  &
     &      DROUT=cv%r(1:cv%num_cv,dz),WGT=cv%weight,                   &
     &      N=cv%num_cv,D_ARCLENGTH=cv%ds,CURVATURE=cv%curvature)
          endif
         endif
        endif
       endif ! root nodes
!
!      send to slaves
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
__CHARMM_ONLY##IF SINGLE
        __BROADCAST_LOCAL_4B(cv%r(1:cv%num_cv,dz),cv%num_cv)
        __BROADCAST_LOCAL_4B(cv%ds,nstring-1)
        __BROADCAST_LOCAL_4B(cv%curvature, nstring-2)
__CHARMM_ONLY##ELSE
        __BROADCAST_LOCAL_8B(cv%r(1:cv%num_cv,dz),cv%num_cv)
        __BROADCAST_LOCAL_8B(cv%ds,nstring-1)
        __BROADCAST_LOCAL_8B(cv%curvature, nstring-2)
__CHARMM_ONLY##ENDIF
#else
        __BROADCAST_LOCAL(cv%r(1:cv%num_cv,dz),cv%num_cv,mpifloat)
        __BROADCAST_LOCAL(cv%ds,nstring-1,mpifloat)
        __BROADCAST_LOCAL(cv%curvature, nstring-2,mpifloat)
#endif
       endif
!
       cv_common_dz_initialized=.true.
!      cv%r(1,dz) contains the vector tangent to cv%r(:,1) scaled
!      by wgt
       end subroutine cv_common_compute_dr
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_dr(iunit) ! global print
       __IMPNONE
       int :: iunit
       call cv_common_print_global(iunit,dz,.false.) ! do not print BC
       end subroutine cv_common_print_dr
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_dr(iunit) ! global print
       __IMPNONE
       int :: iunit
!      local
       int :: bc0, bc1
!      use a trick to read the tangent file
!      note: cannot change BC between runs, because the tangents to the BC are not stored!
!            in that case we will need to recompute using cv_common_compute_dr()
!      for example, you cannot run off-path sampling with all replicas and then switch
!      to fixed endponits, reading the tangent vector from the old file
       bc0=cv_common_fixed_0_bc;     bc1=cv_common_fixed_1_bc  ! store bc info
       cv_common_fixed_0_bc=0; cv_common_fixed_1_bc=0
       call cv_common_read_global(iunit,dz,.true.) ! make sure everything gets read from the dr file
!      restore bc
       cv_common_fixed_0_bc=bc0;     cv_common_fixed_1_bc=bc1  ! store bc info
!
       cv_common_dz_initialized=.true.
       end subroutine cv_common_read_dr
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_repa(interp_method, def, iterations, dst_c)
       use sm_var, only: nstring
       __DEP_OUTPUT
       __DEP_MULTICOM
       __DEP_MPI 
       __IMPNONE
!
#include "../mpitype.def"
!
       int :: interp_method, iterations, ierror
       float, optional :: dst_c
       float :: def
       character(len=14) :: whoami
       data whoami /' CV_BASE_REPA>'/
!
!      interfaces to reparameterization routine
!      needed because of the keyword calls
!
       interface
        subroutine interp_driver_sci(rin,rout,wgt,n,                    &
     &   interp_method,tol,max_iterations,d_arclength, curvature,       &
     &   dst_cutoff,dr,r_bc_0, r_bc_1)
        int n
        float rin(n), rout(n), wgt(n)
        int, intent(in) ::  interp_method
        int max_iterations
        float :: tol, d_arclength(:), curvature(:)
        float, optional :: dst_cutoff
        float , optional :: dr(n), r_bc_0(n), r_bc_1(n)
        end subroutine interp_driver_sci
       end interface
!
       if (.not.cv_common_weights_initialized) then
        __WRN( whoami, 'CV WEIGHTS NOT INITIALIZED')
       endif
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.                         &
     &                         SIZE_STRNG.gt.1) then
        if (cv%num_cv.gt.0) then ! in-place repa
         if (present(dst_c)) then
          if (cv_common_fixed_0_bc.eq.1) then
           if (cv_common_fixed_1_bc.eq.1) then
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature,DST_CUTOFF=dst_c, R_BC_0=cv%r_bc_0,  &
     &      R_BC_1=cv%r_bc_1)
           else
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature,DST_CUTOFF=dst_c, R_BC_0=cv%r_bc_0)
           endif
          else
           if (cv_common_fixed_1_bc.eq.1) then
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature,DST_CUTOFF=dst_c, R_BC_1=cv%r_bc_1)
           else
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature,DST_CUTOFF=dst_c)
           endif
          endif
         else
          if (cv_common_fixed_0_bc.eq.1) then
           if (cv_common_fixed_1_bc.eq.1) then
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature, R_BC_0=cv%r_bc_0,                   &
     &      R_BC_1=cv%r_bc_1)
           else
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature,R_BC_0=cv%r_bc_0)
           endif
          else
           if (cv_common_fixed_1_bc.eq.1) then
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature,R_BC_1=cv%r_bc_1)
           else
            call interp_driver_sci(RIN=cv%r(1:cv%num_cv,main),          &
     &      ROUT=cv%r(1:cv%num_cv,main),WGT=cv%weight,                  &
     &      N=cv%num_cv,INTERP_METHOD=interp_method,TOL=def,            &
     &      MAX_ITERATIONS=iterations,D_ARCLENGTH=cv%ds,                &
     &      DR=cv%r(1:cv%num_cv,dz),                                    &
     &      CURVATURE=cv%curvature)
           endif
          endif
         endif
!     add current CV coordinates to running average -- this is now done in elsewhere
!        call cv_common_update_ave()
!     call moved to smcv_master
!       if (cv_common_voronoi_initialized) call cv_common_voronoi_update() ! update V.cell nodes
        endif
       endif
!
!      send to slaves
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
__CHARMM_ONLY##IF SINGLE
        __BROADCAST_LOCAL_4B(cv%r(1:cv%num_cv,main),cv%num_cv)
        __BROADCAST_LOCAL_4B(cv%r(1:cv%num_cv,dz),cv%num_cv)
        __BROADCAST_LOCAL_4B(cv%ds,nstring-1)
        __BROADCAST_LOCAL_4B(cv%curvature, nstring-2)
__CHARMM_ONLY##ELSE
        __BROADCAST_LOCAL_8B(cv%r(1:cv%num_cv,main),cv%num_cv)
        __BROADCAST_LOCAL_8B(cv%r(1:cv%num_cv,dz),cv%num_cv)
        __BROADCAST_LOCAL_8B(cv%ds,nstring-1)
        __BROADCAST_LOCAL_8B(cv%curvature, nstring-2)
__CHARMM_ONLY##ENDIF
#else
        __BROADCAST_LOCAL(cv%r(1:cv%num_cv,main),cv%num_cv,mpifloat)
        __BROADCAST_LOCAL(cv%r(1:cv%num_cv,dz),cv%num_cv,mpifloat)
        __BROADCAST_LOCAL(cv%ds,nstring-1,mpifloat)
        __BROADCAST_LOCAL(cv%curvature, nstring-2,mpifloat)
#endif
       endif
!
       end subroutine cv_common_repa
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_evolve_smcv(dt)
!      not parallelized (yet?) because it should be cheaper to execute locally than to broadcast info
!      in the future, may compute on roots, then broadcast
      __DEP_OUTPUT
      __DEP_CONST 
      __IMPNONE
!      the timestep can be specified optionally
!      nskip ( the number of history elements to skip when computing the average) is also optional
       float, optional :: dt
!      locals
       float :: dummy
       int :: i
       float :: delt
       character(len=21) :: whoami
       data whoami /' CV_BASE_EVOLVE_SMCV>'/
!      do work
       cv%r(:,comp)=cv%r(:,main) ! save current as "old" coordinates in column 2
       if (present(dt)) then; delt=dt; else ; delt=cv%dt; endif
!
       if (cv%num_run_ave.lt.1) then
        __WRN( whoami,'NO SLICES IN THE AVERAGE. NOTHING DONE')
        return
       endif
!    compute average F.E. gradient and dump into force set
!    assuming that the runnung average has been computed
       do i=1, cv%num_cv
!
        select case(cv%type(i))
        case(dihe_com);
          dummy=(cv%r(i,main) - cv%r(i,runave))
          dummy=modulo(dummy,TWOPI)
          if (dummy.gt.PI) dummy=dummy-TWOPI;
        case(angle_com); ! cannot tell between theta/-theta
          dummy=(abs(cv%r(i,main)) - cv%r(i,runave))
        case default
          dummy=(cv%r(i,main) - cv%r(i,runave))
        end select
!
        cv%r(i,forces)=cv%k(i)*dummy
       enddo
!    compute free energy ( uses cv%r(:,forces) )
       call cv_common_compute_fe_fd()
!    add fe to the fe running average
       call cv_common_update_fe_ave()
!    now evolve string -- take the negative of the FE gradient
!    (we are assuming that M has been computed)
!    explicit Euler advancement (any reason to use more accuracy, e.g. A-B ?)
!
       do i=1, cv%num_cv
        cv%r(i,main)=cv%r(i,main)-delt*cv%gamma(i)*                     &
     &               dot_product(cv%M(i,:,2),cv%r(:,forces))
!     & cv%r(i,forces)
!       write(600+whoiam,*) size(cv%M(i,:,1))
!       write(600+whoiam,*) cv%r(1:cv%num_cv,forces)
!       write(600+whoiam,*)
!     &   dot_product(cv%M(i,:,1),cv%r(:,forces)),
!     &  cv%r(i,forces)/cv%weight(i)
       enddo
!    now reset history (number of slices in the running average)
       cv%num_run_ave=0
!
       end subroutine cv_common_evolve_smcv
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_evolve_sd(dt) ! steepest descent evolution (no M) with temp; compare with cv_common_evolve_smcv
!                                         temperature not added yet
      __DEP_OUTPUT
      __DEP_CONST 
      __IMPNONE
!      the timestep can be specified optionally
!      nskip ( the number of history elements to skip when computing the average) is also optional
       float, optional :: dt
       float :: dummy
       int :: i
       float :: delt
       character(len=19) :: whoami
       data whoami /' CV_BASE_EVOLVE_BD>'/
!      do work
       cv%r(:,comp)=cv%r(:,main) ! save current as "old" coordinates in column 2
       if (present(dt)) then; delt=dt; else ; delt=cv%dt; endif
!
       if (cv%num_run_ave.lt.1) then
        __WRN( whoami,'NO SLICES IN THE AVERAGE. NOTHING DONE')
        return
       endif
!    compute average F.E. gradient and dump into force set
!    assuming that the runnung average has been computed
       do i=1, cv%num_cv
!
        select case(cv%type(i))
        case(dihe_com);
          dummy=(cv%r(i,main) - cv%r(i,runave))
          dummy=modulo(dummy,TWOPI)
          if (dummy.gt.PI) dummy=dummy-TWOPI;
        case(angle_com); ! cannot tell between theta/-theta
          dummy=(abs(cv%r(i,main)) - cv%r(i,runave))
        case default
          dummy=(cv%r(i,main) - cv%r(i,runave))
        end select
!
        cv%r(i,forces)=cv%k(i)*dummy
       enddo
!    compute free energy ( uses cv%r(:,forces) )
       call cv_common_compute_fe_fd()
!    add fe to the fe running average
       call cv_common_update_fe_ave()
!    now evolve string -- take the negative of the FE gradient
!
       do i=1, cv%num_cv
        cv%r(i,main)=cv%r(i,main)-delt*cv%gamma(i)*                     &
!     &               dot_product(cv%M(i,:,2),cv%r(:,forces))
     &                                        cv%r(i,forces) ! + temp (coming soon)
       enddo
!    now reset history (number of slices in the running average)
       cv%num_run_ave=0
!
       end subroutine cv_common_evolve_sd
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       function cv_common_add_hist()
       __DEP_OUTPUT
       __IMPNONE
       int :: cv_common_add_hist
       float :: t
       character(len=18) :: whoami
       data whoami /' CV_BASE_ADD_HIST>'/
!      returns index into cv%r array; the addition is done elsewhere
       if (cv%num_cv.eq.0) then
         __WRN( whoami,'NO CV DEFINED. NOTHING DONE');
         return
       endif
!
       if (cv%num_hist.eq.max_hist_base) then !          maximum storage reached
        cv%beg_hist=mod(cv%beg_hist, max_hist_base)+1 ! wrap around (avoids copying)
        cv%end_hist=mod(cv%end_hist, max_hist_base)+1
       else
        cv%end_hist=cv%end_hist+1 ! location of the last slice
        cv%num_hist=cv%num_hist+1 ! total number of slices in history
       endif
       cv_common_add_hist=cv%end_hist+main_offset ! offset the reference coords
       end function cv_common_add_hist
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_smooth_hist(d,nskip) ! not used in regular SMCV
!      filter the history of CV values so as to obtain new restraining sets
!      the new set is dumped into the main set (1)
!      filter width delta can be specified optionally, default value is 10 (arbitrary)
!      nskip (the number of history elements to skip when computing the average) is also optional
!      this algorithm is entirely heuristic
!
       __DEP_OUTPUT
       __DEP_CONST 
       __IMPNONE
!
       int, optional :: d
       int, optional :: nskip
!      locals
       int :: delta
       int :: numskip, i, j, k, n, k1, k2, k3, k4
       float :: t(max_hist_base)=(/(1.0d0*i,i=1,max_hist_base)/)
       float :: temp(max_hist_base)=0.0d0, u ! for smoothing
       character(len=21) :: whoami
       data whoami /' CV_BASE_SMOOTH_HIST>'/
!      interface to smooth2
!
       interface
        function smooth2(t,x,delta)
        int :: delta
        float :: t(:), x(:)
        float, dimension(size(t)) :: smooth2
        end function smooth2
       end interface
!
!      do work
       if (present(d)) then; delta=d; else ; delta=10; endif
       if (present(nskip)) then ; numskip=nskip; else; numskip=0; endif
       if (numskip.ge.cv%num_hist) then
        __WRN('CV_BASE_SMOOTH_HIST','SKIPPED ALL SLICES. NOTHING DONE')
        return
       endif
!       cv%r(:,comp)=cv%r(:,main) ! save current as "old" coordinates in column 2
!     precompute indices for faster copying
       k1=cv%beg_hist+main_offset
       k2=max_hist_base+main_offset
       k3=main_offset+1
       k4=k1-1
!
       n=cv%num_hist-numskip ! number of elements
       do i=1, cv%num_cv
!    'unwrap' history
        temp=(/ (cv%r(i,k),k=k1,k2),(cv%r(i,k),k=k3,k4) /)
!
!    VO 3.24.09: angle correction
        select case(cv%type(i));
         case(dihe_com, angle_com, anglvec);
          do j=numskip+2, cv%num_hist
           u=temp(j)-temp(j-1)
           u=modulo(u,TWOPI)
           if (u.gt.PI) u=u-TWOPI
           temp(j)=temp(j-1)+u
          enddo
        end select
!
        temp(1:n)=smooth2(                                              &
     &                     t(numskip+1:cv%num_hist),                    &
     &                  temp(numskip+1:cv%num_hist),                    &
     &           delta)
        cv%r(i,main)=temp(n) ! set the restraint value (z) to the
        cv%r(i,comp)=temp(n) ! the theta(x) are roughly consistent with these CV
!      M: what to do about M in this case is unclear
        do j=1,i
          cv%M(i,j,2)=cv%M(i,j,1); cv%M(j,i,2)=cv%M(i,j,1)
        enddo
       enddo
!      reset history (necessary)
       call cv_common_clear_hist()
       cv%num_run_ave=0
       end subroutine cv_common_smooth_hist
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_hist_local(iunit, nskip) ! not used in regular SMCV
!      assume that unit is prepared
       __DEP_OUTPUT
       __IMPNONE
       int :: iunit
       int, optional :: nskip
!      locals
       int :: i, j, k, kbeg, kend, numskip
       character(len=80) :: fmt
       character(len=20) :: whoami
       data whoami /' CV_BASE_PRINT_HIST>'/

!      do work
       if (present(nskip)) then ; numskip=nskip; else; numskip=0; endif
       if (numskip.ge.cv%num_hist) then
        __WRN( whoami,'SKIPPED ALL ELEMENTS. NOTHING PRINTED')
        return
       endif

       write(fmt,int_format) cv%num_cv
       kbeg=cv%beg_hist+numskip
       kend=cv%beg_hist+cv%num_hist ! 'unwrapped' end
       do k=kbeg, kend
        j=mod(k-1,max_hist_base)+1+main_offset
         write(iunit,'('//fmt//real_format//')')                        &
     &       (cv%r(i,j),i=1,cv%num_cv) ! each line corresponds to a time slice
       enddo
       end subroutine cv_common_print_hist_local
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_hist_global(iunit, nskip) ! not used in regular SMCV
!      assume that unit is prepared
       __DEP_OUTPUT
       __DEP_MPI 
       __DEP_MULTICOM
       __IMPNONE
       int :: iunit
       int, optional :: nskip
!      locals
       int :: i, j, k, kbeg, kend, numskip, kout
       int :: ierror
       character(len=80) :: fmt
       character(len=20) :: whoami
       float, allocatable :: rtemp(:,:)
       float, allocatable :: rall(:,:,:)
       bool :: qroot
       data whoami /' CV_BASE_PRINT_HIST>'/
!
!      do work
       qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL)
!
       if (qroot) then
        if (present(nskip)) then ; numskip=nskip; else; numskip=0; endif
        if (numskip.ge.cv%num_hist) then
         __WRN( whoami,'SKIPPED ALL ELEMENTS. NOTHING PRINTED')
         return
        endif
!
        kbeg=cv%beg_hist+numskip
        kend=cv%beg_hist+cv%num_hist-1 ! 'unwrapped' end
        kout=kend-kbeg+1
!      allocate data array
        if (kout.gt.0) then
         allocate(rall(cv%num_cv,kout,SIZE_STRNG))
         allocate(rtemp(cv%num_cv,kout))
        else
         __WRN( whoami,'SKIPPED ALL ELEMENTS. NOTHING PRINTED')
         return
        endif ! kout
!
        do k=1, kout
         j=mod(k+kbeg-2,max_hist_base)+1+main_offset
         rtemp(:,k)=cv%r(1:cv%num_cv,j) ! each line corresponds to a time slice
        enddo
!    gather all data on root (0)
        call MPI_GATHER(rtemp,cv%num_cv*kout,mpifloat,      &
     &    rall,cv%num_cv*kout,mpifloat,0,MPI_COMM_STRNG,    &
     &    ierror)
!
        if (ME_STRNG.eq.0) then ! root writes
         write(fmt,int_format) cv%num_cv
         do k=1,kout
          write(iunit,'("% ",'//int_format//')') k
          do i=1,cv%num_cv
           write(iunit,'('//fmt//real_format//')')                      &
     &      (rall(i,k,j),j=1,SIZE_STRNG)
          enddo
         enddo
        endif ! ME
!
        deallocate(rtemp, rall)
       endif ! qroot
       end subroutine cv_common_print_hist_global
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_clear_hist()
       __IMPNONE
       cv%num_hist=0; cv%beg_hist=1; cv%end_hist=0
       end subroutine cv_common_clear_hist
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_evolve_expo(a,nskip)
!      evolve CV using equation: z(n+1)=a * z(n) + (1-a) * <theta(x)>
      __DEP_OUTPUT
      __DEP_CONST 
!
      __IMPNONE
       float :: a, a1
       int, optional :: nskip
!      locals
       float :: dummy, u, v
       int :: numskip, i, j, k, n, k1, k2, k3, k4
       character(len=21) :: whoami
       data whoami /' CV_BASE_EVOLVE_EXPO>'/
       float :: temp(max_hist_base)=0.0d0
!
!      do work
!      only valid for 0 <= a <= 1
       if (a.lt.0.or.a.gt.1) then
        __WRN( whoami,'MEMORY PARAMETER MUST BE BETWEEN 0 AND 1')
        return
       endif
       if (present(nskip)) then ; numskip=nskip; else; numskip=0; endif
       if (numskip.ge.cv%num_hist) then
        __WRN( whoami,'SKIPPED ALL ELEMENTS. NOTHING DONE')
        return
       endif
!     12.08.08: made modifications: 1) compute forces 2) evolve using runave
!     from Euler evolve:
!    compute average F.E. gradient and dump into force set
!    assuming that the runnung average has been computed
       do i=1, cv%num_cv
!
        select case(cv%type(i))
        case(dihe_com);
          dummy=(cv%r(i,main) - cv%r(i,runave))
          dummy=modulo(dummy,TWOPI)
          if (dummy.gt.PI) dummy=dummy-TWOPI;
        case(angle_com); ! cannot tell between theta/-theta
          dummy=(abs(cv%r(i,main)) - cv%r(i,runave))
        case default
          dummy=(cv%r(i,main) - cv%r(i,runave))
        end select
!
        cv%r(i,forces)=cv%k(i)*dummy
       enddo
!    compute free energy ( uses cv%r(:,forces) )
       call cv_common_compute_fe_fd()
!    add fe to the fe running average
       call cv_common_update_fe_ave()
!
!       cv%r(:,:,comp)=cv%r(:,:,main) ! save current as "old" coordinates in column 2
!     precompute indices for faster copying
       k1=cv%beg_hist+main_offset
       k2=max_hist_base+main_offset
       k3=main_offset+1
       k4=k1-1
!cc
       a1=1d0-a
       n=cv%num_hist-numskip ! number of elements
       do i=1, cv%num_cv
        temp=(/ (cv%r(i,k),k=k1,k2),(cv%r(i,k),k=k3,k4) /)  ! 'unwrap' history
!c     need CV coordinates that are consistent with the current theta(x): simply take the last slice from above:
        cv%r(i,comp)=temp(cv%num_hist)
!         replaced above line with:
!        cv%r(i,comp)=cv%r(i,instant) ! this is better for alternating restrained/unrestrained equilibration
!        cv%r(i,comp)=cv%r(i,main) ! this is better for planar sampling
! cc      evolve i_th cv
!c        cv%r(i,main)=       a  * cv%r(i,main) +
!c     &                      a1 * sum(temp(numskip+1:cv%num_hist))/n

! VO 3.24.09: angle correction
        u=cv%r(i,main)
        v=u-cv%r(i,runave)
!
        select case(cv%type(i));
         case(dihe_com, angle_com, anglvec);
          v=modulo(v,TWOPI)
          if (v.gt.PI) v=v-TWOPI
        end select
!
        cv%r(i,main)=       u -                                         &
     &                      a1 * v
!cccccc from Euler evolve cccccccccccc
!    compute average F.E. gradient and dump into force set
!    assuming that the runnung average has been computed
!    not clear what to do with M in this evolution scheme
!      M:
        do j=1,i
         cv%M(i,j,2)=a * cv%M(i,j,2) + a1 * cv%M(i,j,1);
         cv%M(j,i,2)=cv%M(i,j,2)
        enddo ! j
       enddo ! i
!c      reset history (necessary)
       call cv_common_clear_hist()
       cv%num_run_ave=0
!      update voronoi cells
!     call moved to smcv_master
!       if (cv_common_voronoi_initialized) call cv_common_voronoi_update() ! update V.cell nodes
       end subroutine cv_common_evolve_expo
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_bc(first,last)
!      tells the module whether collective string operations include
!      virtual fixed CV sets; virtual because the CV are not updated;
!      can be viewed as boundary conditions on the string
       __IMPNONE
       bool first, last
!      clean up first
       call cv_common_done()
!
       if (first) then
        cv_common_fixed_0_bc=1
       else
        cv_common_fixed_0_bc=0
       endif
!
       if (last) then
        cv_common_fixed_1_bc=1
       else
        cv_common_fixed_1_bc=0
       endif
       end subroutine cv_common_set_bc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_local(iunit,col)
!      assume that unit is prepared
!      NOTE that this is a local print!
!      does not print fixed BC
       __DEP_OUTPUT
       __IMPNONE
       int iunit
       int, optional :: col
!      locals
       int :: i, c
       character(len=21) :: whoami
       data whoami /' CV_BASE_PRINT_LOCAL>'/
!      do work
       if (.not.present(col)) then ; c=main ; else ; c=col ; endif
       if (c.lt.1.or.c.gt.(max_hist_base+main_offset)) then
        __WRN( whoami,'OUT OF BOUNDS. NOTHING DONE.')
        return
       endif
       do i=1, cv%num_cv
        write(iunit, real_format) cv%r(i,c)
       enddo
       end subroutine cv_common_print_local
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_global(iunit,col,print_bc)
!      assume that unit is prepared
!      NOTE that this is a global print!
       __DEP_OUTPUT
       __DEP_MULTICOM
       __DEP_MPI
!
       __IMPNONE
!
       int iunit
       int, optional :: col
       bool, optional :: print_bc
!      locals
       int :: i, k, c, nrep
       bool :: bc
       character(len=80) :: fmt
       float, allocatable :: rtemp(:,:) ! temporary array for holding coords
       int :: ierror
       bool :: qroot
       character(len=22) :: whoami
       data whoami /' CV_BASE_PRINT_GLOBAL>'/
!      do work
       qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL)
       if (qroot) then
!
        if (.not.present(col)) then ; c=main ; else ; c=col ; endif
        if (c.lt.1.or.c.gt.(cv%num_hist+main_offset)) then
         __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
         return
        endif
!
        bc=.true.
        if (present(print_bc)) bc=print_bc ! do we want bc printed if applicable?
!
!      gather all data on root
        allocate(rtemp(cv%num_cv, SIZE_STRNG))
!
        call MPI_GATHER(cv%r(1,c),cv%num_cv,mpifloat,       &
     &   rtemp,cv%num_cv,mpifloat,0,MPI_COMM_STRNG,         &
     &   ierror)
!
        if (ME_STRNG.eq.0) then ! root writes
!
         if (bc) then ! write inner replicas + bc
          write(fmt,int_format)                                         &
     &      (SIZE_STRNG+cv_common_fixed_0_bc+cv_common_fixed_1_bc)
          if (cv_common_fixed_0_bc.eq.1) then
           if (cv_common_fixed_1_bc.eq.1) then
            do i=1,cv%num_cv
             write(iunit,'('//fmt//real_format//')')                    &
     &       cv%r_bc_0(i), (rtemp(i,k),k=1,SIZE_STRNG), cv%r_bc_1(i)
            enddo
           else
            do i=1,cv%num_cv
             write(iunit,'('//fmt//real_format//')')                    &
     &       cv%r_bc_0(i), (rtemp(i,k),k=1,SIZE_STRNG)
            enddo
           endif
          else
           if (cv_common_fixed_1_bc.eq.1) then
            do i=1,cv%num_cv
             write(iunit,'('//fmt//real_format//')')                    &
     &       (rtemp(i,k),k=1,SIZE_STRNG), cv%r_bc_1(i)
            enddo
           else
            do i=1,cv%num_cv
             write(iunit,'('//fmt//real_format//')')                    &
     &       (rtemp(i,k),k=1,SIZE_STRNG)
            enddo
           endif
          endif
         else ! bc; just write the inner replicas
          write(fmt,int_format) SIZE_STRNG
          do i=1,cv%num_cv
           write(iunit,'('//fmt//real_format//')')                      &
     &      (rtemp(i,k),k=1,SIZE_STRNG)
          enddo
         endif ! print_bc
        endif ! ME=0
        deallocate(rtemp)
       endif ! qroot
!
       end subroutine cv_common_print_global
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_unwrap_angles(col,ind)
       use sm_var, only: nstring, mestring ! all cpus need to know string length
       __DEP_OUTPUT
       __DEP_MULTICOM
       __DEP_CONST
       __DEP_MPI
!
       __IMPNONE
!
#include "../mpitype.def"
!
       int iunit
       int, optional :: col, ind
!      locals
       int :: ibeg, iend
       int :: i, j, c, nrep
       character(len=80) :: fmt
       float :: dangle
       float, allocatable :: rtemp(:,:) ! temporary array for holding coords
       int :: ierror
       character(len=23) :: whoami
       bool :: qroot
       data whoami /' CV_BASE_UNWRAP_ANGLES>'/
!      do work
       if (.not.present(col)) then ; c=main ; else ; c=col ; endif
       if (c.lt.1.or.c.gt.(cv%num_hist+main_offset)) then
        __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
        return
       endif
!
       if (.not.present(ind)) then
        ibeg=1 ; iend=cv%num_cv
       else
        if (ind.lt.1.or.ind.gt.cv%num_cv) then
         __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
         return
        endif
        ibeg=ind; iend=ind ;
       endif
!
       if (nstring.le.1) return
!
       nrep=nstring+cv_common_fixed_0_bc+cv_common_fixed_1_bc
       allocate(rtemp(cv%num_cv, nrep))
!      gather all data on each root processor
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.SIZE_STRNG.gt.1)         &
     &  call MPI_ALLGATHER(cv%r(1,c),cv%num_cv,mpifloat,    &
     &   rtemp(1,1+cv_common_fixed_0_bc),                                 &
     &   cv%num_cv,mpifloat,MPI_COMM_STRNG,                 &
     &   ierror)
!    broadcast rtemp to slaves:
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1)         &
     &  __BROADCAST_LOCAL(rtemp,cv%num_cv*nrep,mpifloat)
!
!    loop over specified cv indices
       do i=ibeg, iend
        select case(cv%type(i))
         case(dihe_com, angle_com, anglvec);
!
          do j=2,nrep
           dangle=modulo(rtemp(i,j)-rtemp(i,j-1), TWOPI)
           if (dangle .gt. PI ) dangle = dangle - TWOPI
           rtemp(i,j)=rtemp(i,j-1)+dangle
          enddo
          cv%r(i,c)=rtemp(i,mestring+1+cv_common_fixed_0_bc)
          if (cv_common_fixed_1_bc.gt.0) cv%r_bc_1(i)=rtemp(i,nrep)
!
        end select
       enddo
!    free memory
       deallocate(rtemp)
       end subroutine cv_common_unwrap_angles
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_compute_fe_fd()
       use sm_var, only: nstring
       __DEP_OUTPUT
       __DEP_MULTICOM
       __DEP_MPI 
       __IMPNONE
       int :: ierror
       character(len=23) :: whoami
       data whoami /' CV_BASE_COMPUTE_FE_FD>'/
!       define interface for work routine (calling by keyword)
       interface
        subroutine compute_work_fd(r,rbc0,rbc1,f,n,fe)
        int :: n
        float :: r(n), f(n)
        float :: fe(:)
        float, optional :: rbc0(n), rbc1(n)
        end subroutine compute_work_fd
       end interface
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.                         &
     &                         SIZE_STRNG.gt.1) then
        if (cv%num_cv.eq.0)                                             &
     &   __WRN( whoami,'NO CV DEFINED.')
        if (cv_common_fixed_0_bc.eq.1) then
         if (cv_common_fixed_1_bc.eq.1) then
          call compute_work_fd(                                         &
     &     R=cv%r(1:cv%num_cv,main),RBC0=cv%r_bc_0,RBC1=cv%r_bc_1,      &
     &     F=cv%r(1:cv%num_cv,forces),N=cv%num_cv,FE=cv%fe)
         else
          call compute_work_fd(                                         &
     &     R=cv%r(1:cv%num_cv,main),RBC0=cv%r_bc_0,                     &
     &     F=cv%r(1:cv%num_cv,forces),N=cv%num_cv,FE=cv%fe)
         endif
        else
         if (cv_common_fixed_1_bc.eq.1) then
          call compute_work_fd(                                         &
     &     R=cv%r(1:cv%num_cv,main),RBC1=cv%r_bc_1,                     &
     &     F=cv%r(1:cv%num_cv,forces),N=cv%num_cv,FE=cv%fe)
         else
          call compute_work_fd(                                         &
     &     R=cv%r(1:cv%num_cv,main),                                    &
     &     F=cv%r(1:cv%num_cv,forces),N=cv%num_cv,FE=cv%fe)
         endif
        endif
       endif
!
!      send to slaves
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
__CHARMM_ONLY##IF SINGLE
        __BROADCAST_LOCAL_4B(cv%r(1:cv%num_cv,forces),cv%num_cv)
        __BROADCAST_LOCAL_4B(cv%fe,nstring)
__CHARMM_ONLY##ELSE
        __BROADCAST_LOCAL_8B(cv%r(1:cv%num_cv,forces),cv%num_cv)
        __BROADCAST_LOCAL_8B(cv%fe,nstring)
__CHARMM_ONLY##ENDIF
#else
        __BROADCAST_LOCAL(cv%r(1:cv%num_cv,forces),cv%num_cv,mpifloat)
        __BROADCAST_LOCAL(cv%fe,nstring,mpifloat)
#endif
       endif
!
       end subroutine cv_common_compute_fe_fd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_forces(iunit) ! global
       __IMPNONE
       int :: iunit
       call cv_common_print_global(iunit,forces,.false.) ! do not print BC if they are present
       end subroutine cv_common_print_forces
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_local(iunit,col)
!      assume that unit is prepared
!      for parallel, broadcast to slaves done by calling routine
       __DEP_OUTPUT
       __IMPNONE
       int :: iunit
       int, optional :: col
       int :: i, c
       character(len=20) :: whoami
       data whoami /' CV_BASE_READ_LOCAL>'/
!      do work
!       character(len=80) :: fmt
!       write(fmt,int_format) max_cv_common
       if (.not.present(col)) then ; c=main ; else ; c=col ; endif
       if (c.lt.1.or.c.gt.(max_hist_base+main_offset)) then
        __WRN( whoami,'OUT OF BOUNDS. NOTHING DONE.')
        return
       endif
       do i=1,cv%num_cv
!        read(iunit,'('//fmt//'F11.5)')
        read(iunit,*)                                                   & ! free-form read in case you want to edit entries by hand
     &        cv%r(i,c)
       enddo
       end subroutine cv_common_read_local
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_global(iunit,col,read_bc)
!      assume that unit is prepared
       use sm_var, only : nstring
       __DEP_PARSER
       __DEP_OUTPUT
       __DEP_MULTICOM
       __DEP_NUMBER 
       __DEP_MPI
!
      __IMPNONE
      __DECLARE_MSGBUF
!
#include "../mpitype.def"
!
       int :: iunit
       int, optional :: col
       bool, optional :: read_bc
       int :: i, k, c
       float :: rtemp(max_cv_common, nstring), dummy ! temporary array for holding coords
       int :: ierror
       character(len=8) :: me ! for output
       bool :: bc
       character(len=21) :: whoami
       bool :: qread
       data whoami /' CV_BASE_READ_GLOBAL>'/
!
       qread=(MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0)
!      do work
       bc=.false.
       rtemp=__NAN ! initialize
!       character(len=80) :: fmt
!       write(fmt,int_format) max_cv_common
       if (.not.present(col)) then ; c=main ; else ; c=col ; endif
       if (c.lt.1.or.c.gt.(cv%num_hist+main_offset)) then
        __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
        return
       endif
!     read file
       if (c.eq.main) bc=.true.         ! read bc if reading first (main coordinates)
       if (present(read_bc)) bc=read_bc ! do we want to read bc if applicable?
!
       if (qread) then ! root reads
!
        if (bc) then ! read inner replicas + bc
         if (cv_common_fixed_0_bc.eq.1) then
          if (cv_common_fixed_1_bc.eq.1) then
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      cv%r_bc_0(i), (rtemp(i,k),k=1,SIZE_STRNG), cv%r_bc_1(i)
           enddo
          else
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      cv%r_bc_0(i), (rtemp(i,k),k=1,SIZE_STRNG)
           enddo
          endif
         else
          if (cv_common_fixed_1_bc.eq.1) then
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      (rtemp(i,k),k=1,SIZE_STRNG), cv%r_bc_1(i)
           enddo
          else
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      (rtemp(i,k),k=1,SIZE_STRNG)
           enddo
          endif
         endif
        else ! just read the inner replicas and throw away the rest
         if (cv_common_fixed_0_bc.eq.1) then
          if (cv_common_fixed_1_bc.eq.1) then
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      dummy, (rtemp(i,k),k=1,SIZE_STRNG), dummy
           enddo
          else
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      dummy,(rtemp(i,k),k=1,SIZE_STRNG)
           enddo
          endif
         else
          if (cv_common_fixed_1_bc.eq.1) then
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      (rtemp(i,k),k=1,SIZE_STRNG), dummy
           enddo
          else
           do i=1,cv%num_cv
            read(iunit,*)                                               &
     &      (rtemp(i,k),k=1,SIZE_STRNG)
           enddo
          endif
         endif
        endif ! read_bc
       endif ! root
!      scatter all data on root
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        call MPI_SCATTER(rtemp, max_cv_common, mpifloat,      &
     &   cv%r(1,c),max_cv_common,mpifloat,0,MPI_COMM_STRNG,   &
     &   ierror)
!      broadcast BC
        if (bc) then
         if (cv_common_fixed_0_bc.eq.1)                                   &
     &    __BROADCAST_STRING(cv%r_bc_0, cv%num_cv, mpifloat)
         if (cv_common_fixed_1_bc.eq.1)                                   &
     &    __BROADCAST_STRING(cv%r_bc_1, cv%num_cv, mpifloat)
        endif ! bc
!     check for zero coordinate entries
        if (any(cv%r(1:cv%num_cv,c).eq.__NAN)) then
         write(me,'(I8)') ME_STRNG
         i=len(me)
         __TRIMA(me,i)
      __WARN( whoami,'SOME CV VALUES ARE UNDEFINED AFTER READING ON REPLICA',me,'.')
        endif
       endif ! MPI_COMM_STRNG
!
!      broadcast to slaves in calling routine
       end subroutine cv_common_read_global
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_local_from_global                        &
     &                                    (iunit,numrep,replica,col)
!      read data for a particular specified replica from a global file
!      caller needs to provide number of replicas in the file (# cols)
!      assume that unit is prepared
      __DEP_OUTPUT
      __DEP_PARSER
      __DEP_MULTICOM
      __DEP_NUMBER 
      __DEP_MPI
!
       __IMPNONE
!
__DECLARE_MSGBUF
!
#include "../mpitype.def"
!
       int :: iunit
       int :: numrep  ! number of replicas in the CV data file
       int :: replica ! will read CV values corresponding to 'replica'
       int, optional :: col
       int :: i, k, c
       float :: rtemp(max_cv_common, numrep) ! temporary array for holding coords
       int :: ierror
       character(len=8) :: me, which ! for output
       character(len=32) :: whoami
       bool :: qroot
       data whoami /' CV_BASE_READ_LOCAL_FROM_GLOBAL>'/
!
       qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL)
!
       rtemp=__NAN ! initialize
!       character(len=80) :: fmt
!       write(fmt,int_format) max_cv_common
       if (.not.present(col)) then ; c=main ; else ; c=col ; endif
       if (c.lt.1.or.c.gt.(cv%num_hist+main_offset)) then
        __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
        return
       endif
!
!     read file
       if (qroot.and.ME_STRNG.eq.0) then ! root reads, then broadcasts
        do i=1,cv%num_cv
!        read(iunit,'('//fmt//'D23.15)')
         read(iunit,*)                                                  &
     &      (rtemp(i,k),k=1,numrep)
        enddo
       endif
!
!      now broadcast CV values to other nodes
       if (qroot) then
        if (SIZE_STRNG.gt.1)                                            &
     &    __BROADCAST_STRING(rtemp, max_cv_common*numrep,mpifloat)
!     "pick out" what I need
        if (replica .le. numrep .and. replica .gt. 0) then
         cv%r(1:cv%num_cv,c)=rtemp(1:cv%num_cv,replica)
        else
         write(me,'(I8)') ME_STRNG
         write(which,'(I8)') replica
__WARN(whoami,'REPLICA',me,'ATTEMPTED TO READ NONEXISTENT COLUMN',which,'. NOTHING DONE.')
        endif ! replica

!     check for zero coordinate entries
        if (any(cv%r(1:cv%num_cv,c).eq.0.0d0)) then
         write(me,'(I8)') ME_STRNG
         i=len(me)
         __TRIMA(me,i)
__WARN(whoami,'SOME CV COORDINATES ARE ZERO AFTER READING ON REPLICA ',me,'.')
        endif
       endif ! root
!
       end subroutine cv_common_read_local_from_global
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_ds(iunit,fmt)
       use sm_var, only: nstring
       __IMPNONE
       int iunit
       character(len=*), optional :: fmt
!      local
       character(len=80) :: frm
!      begin
       if (.not.present(fmt)) then
        write(frm,'('//int_format//',A)')                               &
     &    nstring+cv_common_fixed_0_bc+cv_common_fixed_1_bc, real_format
       else
        frm=fmt
       endif
!
       write(iunit,frm) cv%ds
       end subroutine cv_common_print_ds
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_curvature(iunit,fmt)
       use sm_var, only: smcv_initialized, nstring
       __IMPNONE
       int iunit
       character(len=*), optional :: fmt
!      local
       character(len=80) :: frm
!      begin
       if (.not.smcv_initialized) call smcv_init()
       if (.not.present(fmt)) then
        write(frm,'('//int_format//',A)')                               &
     &    nstring+cv_common_fixed_0_bc+cv_common_fixed_1_bc, real_format
       else
        frm=fmt
       endif
!
       write(iunit,frm) cv%curvature
       end subroutine cv_common_print_curvature
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_fe(iunit,fmt)
       use sm_var, only: smcv_initialized, nstring
       __IMPNONE
!
       int iunit
       character(len=*), optional :: fmt
!      local
       character(len=80) :: frm
!      begin
       if (.not.smcv_initialized) call smcv_init()
       if (.not.present(fmt)) then
        write(frm, '('//int_format//',A)')                              &
     &    nstring+cv_common_fixed_0_bc+cv_common_fixed_1_bc, real_format
       else
        frm=fmt
       endif
!
       write(iunit,frm) cv%fe
       end subroutine cv_common_print_fe
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_feav(iunit,fmt)
       use sm_var, only: smcv_initialized, nstring
       __IMPNONE
       int iunit
       character(len=*), optional :: fmt
!      local
       character(len=80) :: frm
!      begin
       if (.not.smcv_initialized) call smcv_init()
       if (.not.present(fmt)) then
        write(frm, '('//int_format//',A)')                              &
     &    nstring+cv_common_fixed_0_bc+cv_common_fixed_1_bc, real_format
       else
        frm=fmt
       endif
       write(iunit,frm) cv%feav
!      reset number of fe samples so that the averaging starts over
       cv%num_fe_samples=0
       end subroutine cv_common_print_feav
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_k(i,k)
       __IMPNONE
       int :: i
       float :: k
! no error checking: can set to anything you want!
       if (i.ge.0.and.i.le.cv%num_cv) cv%k(i)=k
       end subroutine cv_common_set_k
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_active(i,flag)
       __IMPNONE
       int :: i
       bool :: flag
       if (i.ge.0.and.i.le.cv%num_cv) cv%active(i)=flag
       end subroutine cv_common_set_active
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_kpara(k)
       __DEP_OUTPUT
       __IMPNONE
       float :: k
!
       character(len=19) :: whoami
       data whoami /' CV_BASE_SET_KPARA>'/
       if (k.lt.0d0) &
     &__WRN(whoami,' NEGTIVE FORCE CONSTANT SPECIFIED. NOTHING DONE.')
       cv%kpara=k
       cv_common_kpara_initialized=.true.
       end subroutine cv_common_set_kpara
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_kperp(k)
       __DEP_OUTPUT
       __IMPNONE
       float :: k
!
       character(len=19) :: whoami
       data whoami /' CV_BASE_SET_KPERP>'/
       if (k.lt.0d0) &
     & __WRN(whoami,' NEGTIVE FORCE CONSTANT SPECIFIED. NOTHING DONE.')
       cv%kperp=k
       cv_common_kperp_initialized=.true.
       end subroutine cv_common_set_kperp
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_g(i,gamma)
       __IMPNONE
       int :: i
       float :: gamma
!
       if (i.gt.0.and.i.le.cv%num_cv.and.gamma.gt.0d0)                  & ! disallow neagtive or zero values
     &      cv%gamma(i)=1d0/gamma
       end subroutine cv_common_set_g
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_w(i,weight)
       __IMPNONE
       int :: i
       float :: weight
!
!       if (weight.le.0.0) return ! zero or negative weight breaks
       if (i.gt.0.and.i.le.cv%num_cv) then
        cv%weight(i)=weight
        cv_common_weights_initialized=.true. ! assume that the user will has initialized all weights !
       endif
!
       end subroutine cv_common_set_w
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_r(i,z,col1)
       __DEP_OUTPUT
       __IMPNONE
!
       int :: i
       int, optional :: col1
       float :: z
!
       int :: col
       character(len=15) :: whoami
       data whoami /' CV_BASE_SET_R>'/
!
       if (present(col1)) then ; col=col1; else ; col=main; endif
       if (col.gt.0.and.col.le.main_offset+max_hist_base) then
        if (i.gt.0.and.i.le.cv%num_cv) then
         cv%r(i,col)=z
        else
         __WRN( whoami, 'INVALID COLUMN. NOTHING DONE.')
        endif
       else
        __WRN( whoami, 'INVALID CV INDEX. NOTHING DONE.')
       endif
       end subroutine cv_common_set_r
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_dt(dt)
       __IMPNONE
       float :: dt
! no error checking: can set to anything you want!
!      locals
       cv%dt=dt
       end subroutine cv_common_set_dt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_copy(c1, c2)
       __IMPNONE
!      be careful -- you can do damage here!
       int :: c1, c2
!      local
!      start
       if (c1.gt.0.and.c1.le.main_offset+max_hist_base                  &
     &     .and.                                                        &
     &     c2.gt.0.and.c2.le.main_offset+max_hist_base                  &
     &  .and.c1.ne.c2) then
        cv%r(:,c2)=cv%r(:,c1)
       endif
       end subroutine cv_common_copy
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_swap(col1, col2)
       __IMPNONE
!      be careful -- you can do damage here!
       int, optional :: col1, col2
       int :: c1, c2
!      local
       float, allocatable, dimension(:) :: temp
!      start
       if (present(col1)) then ; c1=col1; else ; c1=main; endif
       if (present(col2)) then ; c2=col2; else ; c2=comp; endif
       if (c1.gt.0.and.c1.le.main_offset+max_hist_base                  &
     &     .and.                                                        &
     &     c2.gt.0.and.c2.le.main_offset+max_hist_base                  &
     &  .and.c1.ne.c2) then
        allocate(temp(max_cv_common))
        temp=cv%r(:,c1);
        cv%r(:,c1)=cv%r(:,c2)
        cv%r(:,c2)=temp
       endif
       end subroutine cv_common_swap
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       function cv_common_rmsd(col1, col2)
       __DEP_OUTPUT
       __DEP_CONST 
       __IMPNONE
       int, optional :: col1, col2
       int :: c1, c2
!      local
       float :: cv_common_rmsd, dummy, dangle
!       float, parameter :: pi=3.14159265358979 ! hardwired for angles
       int :: i
       character(len=14) :: whoami
       data whoami /' CV_BASE_RMSD>'/
!      start
       if (cv%num_cv.eq.0) then
        __WRN( whoami, 'NO CV DEFINED. EXITING.')
        return
       endif
       if (.not.cv_common_weights_initialized) then
        __WRN( whoami, 'CV WEIGHTS NOT INITIALIZED.')
       endif
!
!     NOTE: might be a good idea to force the (re)computation of weights before this call
!           if weights are indeed the mass matrix M.
!
       cv_common_rmsd=0.0
       if (present(col1)) then ; c1=col1; else ; c1=main; endif
       if (present(col2)) then ; c2=col2; else ; c2=comp; endif
       if (c1.gt.0.and.c1.le.(max_hist_base+main_offset)                &
     &  .and.                                                           &
     &    c2.gt.0.and.c2.le.(max_hist_base+main_offset)) then
!
        dummy=0d0
        do i=1,cv%num_cv
!    this is 'unclean', but for now keep the angle
!    hardwiring here
         select case(cv%type(i))
         case(dihe_com);
            dangle=modulo(cv%r(i,c1)-cv%r(i,c2), TWOPI)
            if (dangle .gt. PI ) dangle = dangle - TWOPI
            dummy=dummy+(dangle*cv%weight(i))**2
         case(angle_com); ! cannot tell between theta/-theta
            dummy=dummy+((abs(cv%r(i,c1))-abs(cv%r(i,c2)))*             &
     &                  cv%weight(i))**2
         case default
            dummy=dummy+((cv%r(i,c1)-cv%r(i,c2))*cv%weight(i))**2
         end select
        enddo
        cv_common_rmsd=sqrt(dummy/sum(cv%weight(1:cv%num_cv)**2))
!
!        cv_common_rmsd=sqrt(       ! take square root
!     &    dot_product(
!     &    (cv%r(1:cv%num_cv,c1)-cv%r(1:cv%num_cv,c2))**2, ! square
!     &    cv%weight(1:cv%num_cv)**2)
!     &    *(1.0d0/sum(cv%weight(1:cv%num_cv)**2)) ! weight, average
!     &    )  ! sqrt
       else
        __WRN( whoami, 'OUT OF BOUNDS. NOTHING DONE.')
       endif
       end function cv_common_rmsd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_update_ave()
       __IMPNONE
!      local
       float :: t
!      begin
       t=1.0d0*cv%num_average_samples/(cv%num_average_samples+1)
       cv%r(:,ref2)=t*cv%r(:,ref2)+(1.0d0-t)*cv%r(:,main)
       cv%num_average_samples=cv%num_average_samples+1
       end subroutine cv_common_update_ave
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_update_fe_ave()
       __IMPNONE
!      local
       float :: t
!      begin
       t=1.0d0*cv%num_fe_samples/(cv%num_fe_samples+1)
       cv%feav=t*cv%feav+(1.0d0-t)*cv%fe
       cv%num_fe_samples=cv%num_fe_samples+1
       end subroutine cv_common_update_fe_ave
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_set_ave_samples(n)
       __IMPNONE
       int :: n
       if (n.ge.0) cv%num_average_samples=n
       end subroutine cv_common_set_ave_samples
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_init(temp)
       use sm_var, only: nstring, smcv_initialized
       __DEP_CONST 
       __IMPNONE
       float, optional :: temp
       float :: t
       int :: i
!
       if (.not.cv_common_rex_initialized) then
        if (present(temp)) then ; t=temp; else ; t=300d0; endif
        if (t.gt.0) cv%rex_beta=1d0/(t*__kboltzmann)
        if (.not.smcv_initialized) return
!
        allocate(cv%rex_map(nstring))
        cv%rex_map=(/ (i, i=0,nstring-1) /)
        call int_vector_init(cv%rex_log)
        cv_common_rex_initialized=.true.
       endif
!
       end subroutine cv_common_rex_init
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_done()
       __IMPNONE
       if (cv_common_rex_initialized) then
        deallocate(cv%rex_map)
        call int_vector_done(cv%rex_log) ! destroy rex log
        cv_common_rex_initialized=.false.
       endif
       end subroutine cv_common_rex_done
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_set_temp(temp)
       __DEP_CONST 
       __IMPNONE
       float, optional :: temp
       float :: t
!
       if (.not.cv_common_rex_initialized) call cv_common_rex_init()
       if (present(temp)) then ; t=temp; else ; t=300d0; endif
       if (t.gt.0) cv%rex_beta=1d0/(t*__kboltzmann)
!
       end subroutine cv_common_rex_set_temp
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_print_map(iunit,fmt)
       use sm_var, only: nstring
       __DEP_OUTPUT
       __IMPNONE
!      only root process should call
       int :: iunit
       character(len=*), optional :: fmt
!      local
       int :: i
       character(len=80) :: frm
       character(len=23) :: whoami
       data whoami /' CV_BASE_PRINT_REX_MAP>'/
!      begin
       if (.not.cv_common_rex_initialized) then
        __WRN(whoami,'REX NOT INITIALIZED. NOTHING DONE.')
        return
       endif
!
       if (.not.present(fmt)) then
        write(frm,'("(",I5,"I5)")') nstring
       else
        frm=fmt
       endif
       write(iunit,frm) (/ (i, i=0,nstring-1) /)
       write(iunit,frm) cv%rex_map(1:nstring)
       end subroutine cv_common_rex_print_map
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_read_map(iunit)
       use sm_var, only: nstring
       __DEP_OUTPUT
       __DEP_MULTICOM
       __DEP_MPI 
       __IMPNONE
       int :: iunit, ierror
#include "../mpitype.def"
!
       character(len=22) :: whoami
       data whoami /' CV_BASE_READ_REX_MAP>'/
!      begin
       if (.not.cv_common_rex_initialized) then
        call cv_common_rex_init()
       endif
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (ME_STRNG.eq.0) then
         read(iunit,*) cv%rex_map(1:nstring) ! first row contains indices 0 -- nstring-1
         read(iunit,*) cv%rex_map(1:nstring) ! second row is what we want
         if (any(cv%rex_map.lt.0)) __WRN( whoami,'READ NEGATIVE RANK.')
        endif ! ME_
        if (SIZE_STRNG.gt.1)                                            &
     &  __BROADCAST_STRING(cv%rex_map, nstring, mpiint)
       endif ! MPI_COMM
!    broadcast to slave nodes
       if (ME_LOCAL.ne.MPI_UNDEFINED.and.SIZE_LOCAL.gt.1)               &
!     &  call MPI_BCAST(cv%rex_map, nstring, MPI_INTEGER,
!     &                     0,MPI_COMM_LOCAL,ierr)
#ifdef __CHARMM
     &  __BROADCAST_LOCAL_4B(cv%rex_map,nstring)     !__CHARMM_ONLY##.not.INTEGER8
     &  __BROADCAST_LOCAL_8B(cv%rex_map,nstring)     !__CHARMM_ONLY##INTEGER8
#else
     &  __BROADCAST_LOCAL(cv%rex_map,nstring,mpiint)
#endif
!
       end subroutine cv_common_rex_read_map
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_print_log(iunit, fmt)
!      assume that unit is prepared
!      NOTE that this is a global print!
      __DEP_OUTPUT
      __DEP_MULTICOM
      __DEP_MPI
!
       __IMPNONE
       int iunit
       character(len=*), optional :: fmt
!      local
       character(len=80) frm
       int :: i
       int4mpi :: rex_log_size4(SIZE_STRNG)
       int   :: rex_log_size8(SIZE_STRNG)
       int4mpi :: rex_log_disp4(SIZE_STRNG)
       int :: total_size
       int, allocatable, dimension(:) :: rex_log_all
       int :: ierror
!
#include "../mpitype.def"
!      do work
!      gather all data on root
       if (.not.cv_common_rex_initialized) call cv_common_rex_init()
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.SIZE_STRNG.gt.1) then
!     calculate size of logs
        rex_log_size8=0
        call MPI_ALLGATHER(cv%rex_log%last,1,mpiint,                    &
     &                 rex_log_size8,1,mpiint,                          &
     &                 MPI_COMM_STRNG,ierror)

        total_size=sum(rex_log_size8)
        rex_log_size4=rex_log_size8 ! type cast to 4 byte int
!     allocate space to hold entire log
        allocate(rex_log_all(total_size))
!     calculate send displacements
        rex_log_disp4(1)=0;
        do i=1,SIZE_STRNG-1
         rex_log_disp4(i+1)=rex_log_disp4(i)+rex_log_size4(i)
        enddo
!      now gather the logs
        call MPI_ALLGATHERV(cv%rex_log%i,cv%rex_log%last,mpiint,          &
     &                  rex_log_all,rex_log_size4,rex_log_disp4,mpiint,   &
     &                  MPI_COMM_STRNG,ierror)
!
        if (.not.present(fmt)) then
         frm='(2I5,I8)'
        else
         frm=fmt
        endif
!
      if(ME_STRNG.eq.0.and.total_size.gt.0) write(iunit,frm) rex_log_all
!
        call int_vector_init(cv%rex_log) ! erase log
        deallocate(rex_log_all)
       endif ! STRNG
       end subroutine cv_common_rex_print_log
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_rex_compute_dE(rnew, dE)
       __DEP_CONST 
       __IMPNONE
       float :: rnew(:)
       float :: dummy1, dummy2, dE
       int :: i
!      calculate string energies (code adopted from cv_common_evolve_smcv)
       dE=0d0
       do i=1, cv%num_cv
!
         select case(cv%type(i))
         case(dihe_com);
          dummy1=(rnew(i) - cv%r(i,instant)) ! new
          dummy1=modulo(dummy1,TWOPI)
          if (dummy1.gt.PI) dummy1=dummy1-TWOPI
!
          dummy2=(cv%r(i,main) - cv%r(i,instant)) ! old
          dummy2=modulo(dummy2,TWOPI)
          if (dummy2.gt.PI) dummy2=dummy2-TWOPI
         case(angle_com); ! cannot tell between theta/-theta
          dummy1=(abs(rnew(i)) - cv%r(i,instant))
!
          dummy2=(abs(cv%r(i,main)) - cv%r(i,instant))
         case default
          dummy1=(rnew(i) - cv%r(i,instant))
          dummy2=(cv%r(i,main) - cv%r(i,instant))
         end select
!
         dE=dE+cv%k(i)*(dummy1**2-dummy2**2)   ! new energy - old energy
        enddo ! loop over CV
        dE=0.5d0*dE
!
       end subroutine cv_common_rex_compute_dE
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_voronoi_init()
       __IMPNONE
       call cv_common_voronoi_update()
       cv%voronoi_data=0
!       cv%cross_acceptO=1 ! need a nonzero initial condition
       cv%voronoi_cut=9999d0
       cv%voronoi_whereami=-1
       cv%voronoi_map=-1
       end subroutine cv_common_voronoi_init
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_voronoi_set_cutoff(cut)
       __IMPNONE
!
       float :: cut
!
       if (cut.gt.0d0) then ! reject invalid values without warning
        if (.not. cv_common_voronoi_initialized)                          &
     &  call cv_common_voronoi_init()
        cv%voronoi_cut=cut
       endif
       end subroutine cv_common_voronoi_set_cutoff
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_voro_map(iunit,fmt)
       use sm_var, only: nstring
       __DEP_OUTPUT
       __DEP_MULTICOM
       __DEP_MPI 
       __IMPNONE
       int :: iunit, ierr
       character(len=*), optional :: fmt
!      local
!#include "../mpitype.def"
!
       int :: i
       character(len=80) :: frm
       character(len=24) :: whoami
       data whoami /' CV_BASE_PRINT_VORO_MAP>'/
!      begin
       if (.not.cv_common_voronoi_initialized) call cv_common_voronoi_init()
!
!       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.SIZE_STRNG.gt.1) then
!        call MPI_ALLGATHER(cv%voronoi_whereami, 1, mpiint,
!     &         cv%voronoi_map, 1, mpiint, MPI_COMM_STRNG, ierr)
!
        if (ME_STRNG.eq.0) then
         if (.not.present(fmt)) then
          write(frm,'("(",I5,"I5)")') nstring
         else
          frm=fmt
         endif
         write(iunit,frm) (/ (i, i=1,nstring) /)
         write(iunit,frm) cv%voronoi_map(1:nstring)
        endif ! ME_STRNG
!       endif ! MPI_COMM_STRNG
!
       end subroutine cv_common_print_voro_map
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_voro_map(iunit)
       use sm_var, only: nstring
       __DEP_OUTPUT
       __DEP_MULTICOM
       __DEP_MPI 
       __IMPNONE
#include "../mpitype.def"
!
       int :: iunit, ierror
       character(len=23) :: whoami
       data whoami /' CV_BASE_READ_VORO_MAP>'/
!      begin
       if (.not.cv_common_voronoi_initialized) then
        call cv_common_voronoi_init()
       endif
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (ME_STRNG.eq.0) then
         read(iunit,*) cv%voronoi_map(1:nstring) ! first row contains indices 0 -- nstring-1
         read(iunit,*) cv%voronoi_map(1:nstring) ! second row is what we want
         if (any(cv%voronoi_map.lt.0)) __WRN( whoami,'READ NEGATIVE RANK.')
        endif ! ME_
        if (SIZE_STRNG.gt.1)                                            &
     &  __BROADCAST_STRING(cv%voronoi_map, nstring,mpiint)
       endif ! MPI_COMM_STRNG
!    broadcast to slave nodes
       if (ME_LOCAL.ne.MPI_UNDEFINED.and.SIZE_LOCAL.gt.1)               &
!     &  call MPI_BCAST(cv%voronoi_map, nstring, MPI_INTEGER,
!     &                     0,MPI_COMM_LOCAL,ierr)
#ifdef __CHARMM
     &  __BROADCAST_LOCAL_4B(cv%voronoi_map,nstring)     !__CHARMM_ONLY##.not.INTEGER8
     &  __BROADCAST_LOCAL_8B(cv%voronoi_map,nstring)     !__CHARMM_ONLY##INTEGER8
#else
     &  __BROADCAST_LOCAL(cv%voronoi_map,nstring,mpiint)
#endif
!
       end subroutine cv_common_read_voro_map
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_voronoi_update()
       use sm_var, only: nstring, mestring, smcv_initialized
       __DEP_MULTICOM
       __DEP_MPI 
       __IMPNONE
!      locals
       int :: ierror
       float, pointer :: M(:,:)
!      begin
       if (.not. smcv_initialized) call smcv_init()
       if (.not.cv_common_voronoi_initialized) then
        allocate(cv%rall(cv%num_cv, nstring))
        allocate(cv%Mall(cv%num_cv, cv%num_cv, nstring))
        allocate(cv%voronoi_data(nstring,2*nstring+1,3))
! assign pointers --  local
        cv%cross_attempt =>cv%voronoi_data(:,1:nstring,1)
        cv%cross_accept  =>cv%voronoi_data(:,nstring+1:2*nstring,1)
        cv%voro_occupancy=>cv%voronoi_data(:,2*nstring+1,1)
! assign pointers -- global
        cv%cross_attemptG =>cv%voronoi_data(:,1:nstring,2)
        cv%cross_acceptG  =>cv%voronoi_data(:,nstring+1:2*nstring,2)
        cv%voro_occupancyG=>cv%voronoi_data(:,2*nstring+1,2)
! assign pointers -- data from previous run (old)
        cv%cross_attemptO =>cv%voronoi_data(:,1:nstring,3)
        cv%cross_acceptO  =>cv%voronoi_data(:,nstring+1:2*nstring,3)
        cv%voro_occupancyO=>cv%voronoi_data(:,2*nstring+1,3)
!
        cv%voronoi_data=0                           ! set all crossing data to zero
!        cv%cross_acceptO=1
        cv%voronoi_cut=9999d0
        cv%voronoi_whereami=-1                   ! -1 indicates this needs to be computed
!
        allocate(cv%voronoi_map(nstring))
        cv%voronoi_map=-1
!
        call int_vector_init(cv%voro_log)
        cv_common_voronoi_initialized=.true.
       endif
!      gather all main coordinate sets (same code as in print_global)
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.SIZE_STRNG.gt.1) then
        call MPI_ALLGATHER(cv%r,cv%num_cv,mpifloat,         &
     &   cv%rall,cv%num_cv,mpifloat,MPI_COMM_STRNG,         &
     &   ierror)
!      gather all M^-1 matrices
       M => cv%M(1:cv%num_cv,1:cv%num_cv,3) ! for use in MPI call
!
       call MPI_ALLGATHER(M,                                            &! cv%M(1:cv%num_cv,1:cv%num_cv,3),
     &   cv%num_cv**2,mpifloat,                             &
     &   cv%Mall,cv%num_cv**2,mpifloat,MPI_COMM_STRNG,      &
     &   ierror)
       endif
!
! broadcast to slaves
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
__CHARMM_ONLY##IF SINGLE
        __BROADCAST_LOCAL_4B(cv%rall,cv%num_cv*nstring)
        __BROADCAST_LOCAL_4B(cv%Mall,(cv%num_cv**2)*nstring)
__CHARMM_ONLY##ELSE
        __BROADCAST_LOCAL_8B(cv%rall,cv%num_cv*nstring)
        __BROADCAST_LOCAL_8B(cv%Mall,(cv%num_cv**2)*nstring)
__CHARMM_ONLY##ENDIF
#else
        __BROADCAST_LOCAL(cv%rall,cv%num_cv*nstring,mpifloat)
        __BROADCAST_LOCAL(cv%Mall,(cv%num_cv**2)*nstring,mpifloat)
#endif
       endif
!
       cv_common_voronoi_wrong_cell=.false.
       end subroutine cv_common_voronoi_update
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_voronoi_smart_update(rnew, rold, m_iter)
       use sm_var, only: nstring, mestring, smcv_initialized
       use cv_types
       __DEP_OUTPUT
!      cv%rall(:,:) is expected to have values from previous update that
!      are consistent with rtemp; if this is not true, the routine
!      just does a regular update and exits
       __DEP_MULTICOM
       __DEP_CONST 
       __DEP_MPI 
       __IMPNONE
!      vars
#include "../mpitype.def"
!
       float :: rnew(cv%num_cv) ! current CV values (theta(x))
       float :: rold(cv%num_cv) ! new reflected CV values (theta(xcomp))
       int, optional :: m_iter
!      locals
       float, pointer :: M(:,:)
       float :: rall_new(cv%num_cv, nstring)
       float :: rall_temp(cv%num_cv, nstring)
       float :: Mall_new(cv%num_cv, cv%num_cv, nstring)
       float :: Mall_temp(cv%num_cv, cv%num_cv, nstring)
       float :: z(cv%num_cv)
       int :: correct_cell_me, correct_cell
       int :: iter, max_iter
       int, parameter :: default_iter=15
       float :: dummy
       int :: i, j, which(1), ierror, me
       character(len=30) :: whoami
       bool :: qroot
!
       data whoami /' CV_BASE_VORONOI_SMART_UPDATE>'/
!
!      begin
!
       if (cv%num_cv.eq.0) then
         __WRN(whoami,'NO CV DEFINED. NOTHING DONE.')
         return
       endif
!
       qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL)
!
        if (qroot.and.SIZE_STRNG.gt.1) then
!      gather all main cv coordinate sets
         call MPI_ALLGATHER(cv%r,cv%num_cv,mpifloat,        &
     &    rall_new,cv%num_cv,mpifloat,MPI_COMM_STRNG,       &
     &    ierror)
!      gather all M^-1 matrices
         M => cv%M(1:cv%num_cv,1:cv%num_cv,3)
!
         call MPI_ALLGATHER(M,                              &
     &    cv%num_cv**2,mpifloat,                            &
     &    Mall_new,cv%num_cv**2,mpifloat,MPI_COMM_STRNG,    &
     &    ierror)
       endif
!
       if (.not.cv_common_voronoi_initialized) then
        allocate(cv%rall(cv%num_cv, nstring))
        allocate(cv%Mall(cv%num_cv, cv%num_cv, nstring))
        cv%rall=rall_new
        cv%Mall=Mall_new
!
        allocate(cv%voronoi_data(nstring,2*nstring+1,3))
! assign pointers --  local
        cv%cross_attempt =>cv%voronoi_data(:,1:nstring,1)
        cv%cross_accept  =>cv%voronoi_data(:,nstring+1:2*nstring,1)
        cv%voro_occupancy=>cv%voronoi_data(:,2*nstring+1,1)
! assign pointers -- global
        cv%cross_attemptG =>cv%voronoi_data(:,1:nstring,2)
        cv%cross_acceptG  =>cv%voronoi_data(:,nstring+1:2*nstring,2)
        cv%voro_occupancyG=>cv%voronoi_data(:,2*nstring+1,2)
! assign pointers -- data from previous run (old)
        cv%cross_attemptO =>cv%voronoi_data(:,1:nstring,3)
        cv%cross_acceptO  =>cv%voronoi_data(:,nstring+1:2*nstring,3)
        cv%voro_occupancyO=>cv%voronoi_data(:,2*nstring+1,3)
!
        cv%voronoi_data=0                           ! set all crossing data to zero
!        cv%cross_acceptO=1
        cv%voronoi_cut=9999d0
        cv%voronoi_whereami=-1                   ! -1 indicates this needs to be computed
!
        allocate(cv%voronoi_map(nstring))
        cv%voronoi_map=-1
!
        call int_vector_init(cv%voro_log)
!
        cv_common_voronoi_initialized=.true.
       else
        if (qroot) then
!
         if (.not.cv_common_Minv_initialized) then
          __WRN( whoami, 'TENSOR M^-1 HAS NOT BEEN SET.')
         endif
!
         me=mestring+1
!     check if the old set is consistent
!
         correct_cell_me=cv_common_voronoi_check_aux                      &
     &           (rold, cv%rall, cv%num_cv, nstring, cv%Mall, me)
!
!      are the coords in rold consistent with the current V. cell centers?
         if  (correct_cell_me.eq.0) then
!      if old set is outside cell, it means that we just crossed into a
!                   neighbor cell; in this case, test rnew, not rold
!                   repeat as above:
          rold=rnew
          correct_cell_me=cv_common_voronoi_check_aux                     &
     &           (rold, cv%rall, cv%num_cv, nstring, cv%Mall, me)
         endif ! .not. correct_cell_me

!     pool all results
         call MPI_ALLREDUCE(correct_cell_me, correct_cell, 1,           &
     &                  mpiint, MPI_MIN, MPI_COMM_STRNG, ierror)
         if (correct_cell.eq.0) then
          __WRN(whoami,' CURRENT VORONOI CELL CENTERS INCONSISTENT WITH COORDINATES.')
!    roll back CVs
           cv%r(1:cv%num_cv,1)=cv%rall(1:cv%num_cv,me)
!
         else ! not correct_cell
!     begin iterative adjustment
          if (present(m_iter)) then
           max_iter=m_iter
          else
           max_iter=default_iter
          endif
!
          iter=0
          rall_temp=rall_new
          Mall_temp=Mall_new
          do
!     check if the new set is consistent
           correct_cell_me=cv_common_voronoi_check_aux                    &
     &           (rold, rall_temp, cv%num_cv, nstring, Mall_temp, me)
!     pool all results
           call MPI_ALLREDUCE(correct_cell_me, correct_cell, 1,         &
     &                  mpiint, MPI_MIN, MPI_COMM_STRNG, ierror)
           if (correct_cell.eq.1) then
            cv%rall=rall_temp
            cv%Mall=Mall_temp
!          `roll back' cv's:
            if (iter.gt.0) then ! otherwise they are fine
             cv%r(1:cv%num_cv,1)=rall_temp(1:cv%num_cv,me)
             cv%M(1:cv%num_cv,1:cv%num_cv,3)=Mall_temp(:,:,me)
            endif
            exit
           elseif (iter.ge.max_iter) then
            __WRN(whoami,' MAXIMUM NUMBER OF ITERATIONS EXCEEDED.')
!          reset cv's to consistent Voronoi cell centers :
            cv%r(1:cv%num_cv,1)=cv%rall(1:cv%num_cv,me)
            cv%M(1:cv%num_cv,1:cv%num_cv,3)=cv%Mall(:,:,me)
            exit
           else
            rall_temp=0.5d0*(rall_temp+cv%rall)
            Mall_temp=0.5d0*(Mall_temp+cv%Mall)
           endif  ! correct cell
           iter=iter+1
          enddo ! <empty>
         endif ! .not. correct_cell

        endif ! qroot
       endif ! .not. initialized
!   broadcast to slaves
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
__CHARMM_ONLY##IF SINGLE
        __BROADCAST_LOCAL_4B(cv%rall,cv%num_cv*nstring)
        __BROADCAST_LOCAL_4B(cv%Mall,(cv%num_cv**2)*nstring)
__CHARMM_ONLY##ELSE
        __BROADCAST_LOCAL_8B(cv%rall,cv%num_cv*nstring)
        __BROADCAST_LOCAL_8B(cv%Mall,(cv%num_cv**2)*nstring)
__CHARMM_ONLY##ENDIF
#else
        __BROADCAST_LOCAL(cv%rall,cv%num_cv*nstring,mpifloat)
        __BROADCAST_LOCAL(cv%Mall,(cv%num_cv**2)*nstring,mpifloat)
#endif
       endif
!
       end subroutine cv_common_voronoi_smart_update
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       int function cv_common_voronoi_check_aux                       &
     &           (r, rall, ncv, nstring, Mall, me)
!    auxiliary function for use with voronoi_smart_update
       __DEP_CONST 
       __IMPNONE
       int :: ncv, nstring, me
       float :: r(ncv), rall(ncv, nstring), Mall(ncv, ncv, nstring)
! locals
       int :: i,ii,j,jj,k
       float :: z(ncv), dummy, msd_n(nstring), msd_m(nstring)
       bool :: q

       do i=1,nstring
!
!    preprocess differences (wrap angles)
        do j=1,ncv
         select case(cv%type(j))
         case(dihe_com);
            dummy=modulo(r(j)-rall(j,i), TWOPI)
            if (dummy .gt. PI ) dummy = dummy - TWOPI
         case(angle_com); ! cannot tell between theta/-theta
            dummy=abs(r(j))-abs(rall(j,i))
         case default
            dummy=r(j)-rall(j,i)
         end select
         z(j)=dummy
        enddo ! j
!
!    compute two norms
        if (me.eq.i) then ! compute rmsd_me
         do ii=1, nstring
           dummy=0d0
           do j=1,ncv
            jj=j-1
            do k=1, jj
             dummy=dummy +                                              &
     &  z(j) * (Mall(j,k,me) + Mall(j,k,ii)) * z(k)
            enddo
           enddo
           dummy=2d0*dummy ! double contribution from off-diagonal terms
!    contribution from diagonal terms
           do j=1,ncv
            dummy=dummy +                                               &
     &  z(j) * (Mall(j,j,me) + Mall(j,j,ii)) * z(j)
           enddo
           msd_n(ii)=0.5*dummy
         enddo ! ii=1,nstring
        else  ! compute rmsd_i; coputed only for different tensors (hence if/else)
!    same code as above
         dummy=0d0
         do j=1,ncv
          jj=j-1
          do k=1, jj
           dummy=dummy +                                                &
     &                z(j) * (Mall(j,k,me)+Mall(j,k,i)) * z(k)
          enddo
         enddo
         dummy=2d0*dummy ! double contribution from off-diagonal terms
!    contribution from diagonal terms
         do j=1,ncv
          dummy=dummy +                                                 &
     &               z(j) * (Mall(j,j,me)+Mall(j,j,i)) * z(j)
         enddo
         msd_m(i)=0.5d0*dummy
        endif ! me.eq.i
!
       enddo ! i=1,nstring
!
       msd_m(me)=msd_n(me)
!    check whether theta(x) lives in this cell
       do i=1, nstring
        q=(msd_n(i).le.msd_m(i))
        if (.not.q) exit
       enddo
!
       if (q.and.((msd_n(me)).lt.cv%voronoi_cut**2)) then
         cv_common_voronoi_check_aux=1
       else
         cv_common_voronoi_check_aux=0
       endif
!
       end function cv_common_voronoi_check_aux
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_voronoi_done()
       __IMPNONE
       if (cv_common_voronoi_initialized) then
        deallocate(cv%rall)
        deallocate(cv%Mall)
        deallocate(cv%voronoi_map)
        deallocate(cv%voronoi_data)
!
        nullify(cv%cross_attempt)
        nullify(cv%cross_accept)
        nullify(cv%voro_occupancy)
!
        nullify(cv%cross_attemptG)
        nullify(cv%cross_acceptG)
        nullify(cv%voro_occupancyG)
!
        nullify(cv%cross_attemptO)
        nullify(cv%cross_acceptO)
        nullify(cv%voro_occupancyO)
!
        call int_vector_done(cv%voro_log) ! destroy Voronoi T. log
        cv_common_voronoi_initialized=.false.
       endif
       end subroutine cv_common_voronoi_done
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       function cv_common_voronoi_compute(rtemp) ! rtemp calculated elsewhere and passed in
       use cv_types
       use sm_var, only: nstring, mestring
       use sm_config, only: calc_voronoi_para
      __DEP_OUTPUT
      __DEP_MULTICOM
      __DEP_CONST 
      __DEP_MPI 
!
      __IMPNONE
#include "../mpitype.def"
!     variables
       int :: cv_common_voronoi_compute ! index of Voronoi cell that the system is in
       float :: rtemp(cv%num_cv) ! current CV values (theta(x))
!     locals
       float :: msd(nstring,nstring), msdall(nstring,nstring) ! mean square distance
       float :: dummy, z(cv%num_cv)
       int :: i, j, k, n, m, iatom, which(1), q(nstring), me
!    parallelization
       bool :: qpara
       int4mpi :: send_displ(SIZE_LOCAL), send_count(SIZE_LOCAL)
       int :: mbeg, mend, ierror
!
       character(len=25) :: whoami
!
       data whoami /' CV_BASE_VORONOI_COMPUTE>'/
!
       if (cv%num_cv.eq.0) then
         __WRN(whoami,'NO CV DEFINED. NOTHING DONE.')
         return
       endif
!
       if (.not.cv_common_Minv_initialized) then
        __WRN( whoami, 'TENSOR M^-1 HAS NOT BEEN SET.')
       endif
!      initialize, if necessary
       if (.not.cv_common_voronoi_initialized) call cv_common_voronoi_init()
!      compute RMSD
!      need to compute distances w.r.t. all M tensors on the string
       msd=0d0
       msdall=0d0
!
!     compute norms in parallel: each slave node is assigned a set of matrices
!     compute index limits (this could be done once in the smcv_init routine)
!
       qpara=(MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1       &
     &   .and.calc_voronoi_para)
       if (qpara) then
!
        j=ceiling(1.0d0*nstring/SIZE_LOCAL) ! max. number of CV assigned to slave node
!
        do i=1,SIZE_LOCAL
         send_displ(i)=nstring*min((i-1)*j,nstring-1) ! cannot exceed nstring
         send_count(i)=nstring*max(0,min(j,nstring-j*(i-1)))
        enddo
        me=ME_LOCAL+1
!       indices are below
        mbeg=send_displ(me)/nstring+1
        mend=mbeg+send_count(me)/nstring-1
       else
        mbeg=1
        mend=nstring
       endif ! qpara
!
       do n=1, nstring ! loop over z
!ccccccccccccccccccccccccccccccccccccccccc preprocess differences (wrap angles)
        do j=1,cv%num_cv
!    this is 'unclean', and I may move this routine 'up' but for now keep the angle
         select case(cv%type(j))
         case(dihe_com);
            dummy=modulo(rtemp(j)-cv%rall(j,n), TWOPI)
            if (dummy .gt. PI ) dummy = dummy - TWOPI
         case(angle_com); ! cannot tell between theta/-theta
            dummy=abs(rtemp(j))-abs(cv%rall(j,n))
         case default
            dummy=rtemp(j)-cv%rall(j,n)
         end select
         z(j)=dummy
        enddo ! j
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        do m=mbeg,mend ! loop over the M tensors
         dummy=0d0
         do i=1,cv%num_cv
          j=i-1
          do k=1, j
           dummy=dummy +                                                &
     &                z(i) * (cv%Mall(i,k,m)) * z(k)
          enddo
         enddo
         dummy=2d0*dummy ! double contribution from off-diagonal terms
!    contribution from diagonal terms
         do i=1,cv%num_cv
          dummy=dummy +                                                 &
     &               z(i) * (cv%Mall(i,i,m)) * z(i)
         enddo
         msd(n,m)=dummy
        enddo ! m=1,nstring
       enddo ! i=1,nstring
!
!    pool norms on root
       if (qpara)                                                       &
     &  call MPI_GATHERV(msd(1,mbeg),send_count(me),                    &
     &   mpifloat,                                                      &
     &   msd, send_count, send_displ,                                   &
     &   mpifloat, 0, MPI_COMM_LOCAL, ierror)

!    root determines where theta(x) is
        if (ME_LOCAL.eq.0.or..not.qpara) then
         do n=1, nstring
          q(n)=1
          do m=1, nstring
           if (msd(n,n)+msd(n,m).gt.msd(m,n)+msd(m,m)) then
            q(n)=0
            exit
           endif
          enddo
         enddo
         which=maxloc(q) ! maxloc needs an int array;
         if (msd(which(1),which(1)).gt.cv%voronoi_cut**2)               &
     &    which(1)=-which(1) ! outside of the allowed region (special code)
        endif ! ME_LOCAL
!
       if (qpara)                                                       &
#ifdef __CHARMM
     &  __BROADCAST_LOCAL_4B(which,1)  !__CHARMM_ONLY##.not.INTEGER8
     &  __BROADCAST_LOCAL_8B(which,1)  !__CHARMM_ONLY##INTEGER8
#else
        __BROADCAST_LOCAL(which,1,mpiint)
#endif
!          write(600+ME_GLOBAL,*) q
!           write(600+ME_GLOBAL,'(32G12.4)') msd
!           write(600+ME_GLOBAL,*) rtemp
!            stop
!
       cv_common_voronoi_compute=which(1)
!
       end function cv_common_voronoi_compute
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_voro_data(iunit)
       use sm_var, only: nstring
!      assume that unit is prepared
!      NOTE that this is a global print!
       __DEP_OUTPUT
       __DEP_MULTICOM
       __DEP_MPI
!
       __IMPNONE
!
       int iunit
!      locals
       character(len=80) :: fmt
       int :: i, j
       int :: voro_data_all(nstring,2*nstring+1)
       int :: ierror, type
!      do work
!      gather all data on root
       type=MPI_INTEGER                       !__CHARMM_ONLY##.not.INTEGER8
       type=MPI_INTEGER8                      !__CHARMM_ONLY##INTEGER8

       if (.not.cv_common_voronoi_initialized) call cv_common_voronoi_init()
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (SIZE_STRNG.gt.1) then
         call MPI_ALLREDUCE(cv%voronoi_data(:,:,1),voro_data_all,       &
     & nstring*(2*nstring+1),type,MPI_SUM,MPI_COMM_STRNG,ierror)
        else
         voro_data_all=cv%voronoi_data(:,:,1)
        endif ! SIZE
!
        if (ME_STRNG.eq.0) then ! string root writes
         write(fmt,int_format) nstring
         do j=1,nstring
          write(iunit,'('//fmt//int_format//')')                        &
     &     voro_data_all(j,1:nstring)+cv%cross_attemptO(j,:)        ! crossing attemps
         enddo
         write(iunit,'("%")') ! break
         do j=1,nstring
          write(iunit,'('//fmt//int_format//')')                        &
     &     voro_data_all(j,nstring+1:2*nstring)+cv%cross_acceptO(j,:) ! crossing accepts
         enddo
         write(iunit,'("%")') ! break
         write(iunit,'('//fmt//int_format//')')                         &
     &    voro_data_all(:,2*nstring+1)+cv%voro_occupancyO(:)        ! occupancy
        endif ! ME
       endif ! MPI_COMM_STRNG
!
       end subroutine cv_common_print_voro_data
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_voro_data(iunit)
       use sm_var, only: nstring
!      assume that unit is prepared
       __DEP_MULTICOM
       __DEP_MPI
!
       __IMPNONE
!
       int iunit
!      locals
       character(len=80) :: fmt
       int :: i, j
       int :: voro_data_all(SIZE_STRNG,2*SIZE_STRNG+1)
       int :: ierror
#include "../mpitype.def"
!      do work
!      gather all data on root
!
       if (.not.cv_common_voronoi_initialized) call cv_common_voronoi_init()
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (ME_STRNG.eq.0) then ! string root reads
         do j=1,nstring
          read(iunit,*)  voro_data_all(j,1:nstring)      ! crossing attemps
         enddo
         read(iunit,'(A)') ! break
         do j=1,nstring
          read(iunit,*)  voro_data_all(j,nstring+1:2*nstring)      ! crossing accepts
         enddo
         read(iunit,'(A)') ! break
         read(iunit,*) voro_data_all(:,2*nstring+1)      ! occupancy
        endif ! ME
!
        cv%voronoi_data(:,:,3)=voro_data_all        ! place into "old" position
!
        if (SIZE_STRNG.gt.1) then
         __BROADCAST_LOCAL(cv%voronoi_data(:,:,3),SIZE_STRNG*(2*SIZE_STRNG+1),mpiint)
        endif
       endif ! MPI_COMM_STRNG
!    broadcast to slaves
       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1)         &
#ifdef __CHARMM
     &  __BROADCAST_LOCAL_4B(cv%voronoi_data(:,:,3),nstring*(2*nstring+1))          !__CHARMM_ONLY##.not.INTEGER8
     &  __BROADCAST_LOCAL_8B(cv%voronoi_data(:,:,3),nstring*(2*nstring+1))          !__CHARMM_ONLY##INTEGER8
#else
     &  __BROADCAST_LOCAL(cv%voronoi_data(:,:,3),nstring*(2*nstring+1),mpiint)
#endif
!
       end subroutine cv_common_read_voro_data
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_voronoi_print_log(iunit)
!      assume that unit is prepared
!      NOTE that this is a global print!
!      this routine is redundant with cv_common_voronoi_print_hist
       __DEP_MULTICOM
       __DEP_MPI
!
       __IMPNONE
!
       int iunit
!      locals
       int :: i
       int4mpi :: voro_log_size4(SIZE_STRNG)
       int   :: voro_log_size8(SIZE_STRNG)
       int4mpi :: voro_log_disp4(SIZE_STRNG)
       int :: total_size
       int, allocatable, dimension(:) :: voro_log_all
       int :: ierror
#include "../mpitype.def"
!      do work
!      gather all data on root
!
       if (.not.cv_common_voronoi_initialized) call cv_common_voronoi_init()
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.SIZE_STRNG.gt.1) then
!     calculate size of logs
        voro_log_size8=0
!       call MPI_GATHER(cv%voro_log%last,1,type,
!     &                 voro_log_size8,1,type,
!     &                 0,MPI_COMM_WORLD,ierror)
        call MPI_ALLGATHER(cv%voro_log%last,1,mpiint,                     &
     &                 voro_log_size8,1,mpiint,                           &
     &                 MPI_COMM_STRNG,ierror)

        total_size=sum(voro_log_size8)
        voro_log_size4=voro_log_size8 ! type cast to 4 byte int
!     allocate space to hold entire log
        allocate(voro_log_all(total_size))
!     calculate send displacements
        voro_log_disp4(1)=0;
        do i=1,SIZE_STRNG-1
         voro_log_disp4(i+1)=voro_log_disp4(i)+voro_log_size4(i)
        enddo
!      now gather the logs
!       call MPI_GATHERV(cv%voro_log%i,cv%voro_log%last,type,
!     &                  voro_log_all,voro_log_size4,voro_log_disp4,type,
!     &                  0,MPI_COMM_WORLD,ierror)
        call MPI_ALLGATHERV(cv%voro_log%i,cv%voro_log%last,mpiint,        &
     &                  voro_log_all,voro_log_size4,voro_log_disp4,mpiint,&
     &                  MPI_COMM_STRNG,ierror)
!
        if (ME_STRNG.eq.0) write(iunit) voro_log_all
!
        call int_vector_init(cv%voro_log) ! erase log
        deallocate(voro_log_all)
       endif ! STRNG
       end subroutine cv_common_voronoi_print_log
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_read_M_global(ifile, ind)
       use sm_var, only: nstring
!     print mass matrix; assume that cv%m(:,:,2) has what the user wants
      __DEP_MULTICOM
      __DEP_MPI
!
       __IMPNONE
!
#include "../mpitype.def"
       int :: ifile
       int, optional :: ind  ! M index
!     locals
       int :: isizeM, ierror, j, Mind
       float :: M_all(cv%num_cv, cv%num_cv, nstring)
       float :: M_me(cv%num_cv, cv%num_cv)
!
       if (present(ind)) then ; Mind=ind ; else ; Mind=2 ; endif
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
!
        if (ME_STRNG.eq.0) then ! root reads
         do j=1,nstring
          read(ifile,'(1X,I10)')
          read(ifile,*) M_all(:,:,j)
         enddo
        endif ! ME
        call MPI_SCATTER(M_all,cv%num_cv**2,mpifloat,       &
     &                 M_me,cv%num_cv**2,mpifloat,0,        &
     &                 MPI_COMM_STRNG,ierror)
       endif ! COMM_STRNG
!    broadcast to slaves
       if (ME_LOCAL.ne.MPI_UNDEFINED.and.SIZE_LOCAL.gt.1)               &
#ifdef __CHARMM
     &  __BROADCAST_LOCAL_4B(M_me,cv%num_cv**2) !__CHARMM_ONLY##SINGLE
     &  __BROADCAST_LOCAL_8B(M_me,cv%num_cv**2) !__CHARMM_ONLY##.not.SINGLE
#else
     &  __BROADCAST_LOCAL(M_me,cv%num_cv**2,mpifloat)
#endif
!
       cv%M(1:cv%num_cv, 1:cv%num_cv, Mind)=M_me
!
       if (Mind.eq.2) then
        call cv_common_compute_Minv()
       elseif (Mind.eq.3) then
        cv_common_Minv_initialized=.true.
       endif
!
       end subroutine cv_common_read_M_global
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_print_M_global(ifile, ind)
       use sm_var, only: nstring
!     print mass matrix; assume that cv%m(:,:,2) has what the user wants
!
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI  ! deal with other platforms later
!
       __IMPNONE
       int :: ifile
       int, optional :: ind  ! M index to print
!     locals
       character(len=80) :: fmt
       int :: isizeM, ierror, j, Mind
       float :: M_all(cv%num_cv, cv%num_cv, nstring)
       float :: M_me(cv%num_cv, cv%num_cv)
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
!
        if (present(ind)) then ; Mind=ind ; else ; Mind=2 ; endif
!
        isizeM=cv%num_cv;
        M_me=cv%M(1:isizeM, 1:isizeM, Mind)
        isizeM=isizeM*isizeM
!
        call MPI_GATHER(M_me,isizeM,mpifloat,               &
     &                 M_all,isizeM,mpifloat,0,             &
     &                 MPI_COMM_STRNG,ierror)
!        call MPI_ALLGATHER(M_me,isizeM,mpifloat,
!     &                 M_all,isizeM,mpifloat,
!     &                 MPI_COMM_STRNG,ierror)
        write(fmt,'(I5)') cv%num_cv
        if (ME_STRNG.eq.0) then ! root writes
         do j=1,nstring
          write(ifile,'("% ",I5)') j
          write(ifile,'('//fmt//real_format//')') M_all(:,:,j)
!          write(ifile,'('//fmt//'E15.5)') M_all(:,:,j)
!         write(ifile,'('//fmt//'F11.5)') cv%M(1:cv%num_cv,1:cv%num_cv,1)
         enddo
        endif ! ME
       endif ! MPI_COMM
!
       end subroutine cv_common_print_M_global
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_neq_work_init()
!      initialize variables for nonequilibrium work
       __IMPNONE
       cv%work=0.
       cv%r(:,forces2)=0.
       cv%r(:,zcur)=cv%r(:,comp)
       cv%r(:,zold)=cv%r(:,comp)
       end subroutine cv_common_neq_work_init
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       function cv_common_neq_get_work()
!      returns the value of work
       __IMPNONE
       float :: cv_common_neq_get_work
       cv_common_neq_get_work=cv%work
       end function cv_common_neq_get_work
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine cv_common_interpolate(ifile, ofile, num_rep_in,         &
     &                     num_rep_out, interp_method)
      __DEP_OUTPUT
!     assume that both units ifile/ofile are prepared
      __DEP_MULTICOM
      __DEP_NUMBER 
      __DEP_MPI 
!
       __IMPNONE
       int :: ifile, ofile, num_rep_in, num_rep_out, interp_method
!     local declarations
       float :: rin(max_cv_common,num_rep_in),                           &
     &           dr(max_cv_common,num_rep_in-1)
       float :: rout(max_cv_common,num_rep_out)
       float :: rr(num_rep_in), rr_out(num_rep_out), ds(num_rep_in-1), &
     &           ds2(num_rep_in-1), s(num_rep_in), t(num_rep_out),      &
     &           rrpp(num_rep_in), dum
       int :: i,k
       character(len=80) :: fmt
       bool :: qroot
       character(len=20) :: whoami
       data whoami /' CV_BASE_INTERPOLATE'/
!
       int, parameter :: linear=1, spline=2, bspline=3
!
       interface ! to linear interpolation routine
        subroutine linear_interp(xin,yin,nin,xout,yout,nout,dydxout)
        int :: nin, nout
        float :: xin(nin), yin(nin), xout(nout), yout(nout)
        float, optional :: dydxout(nout) ! tangent computation
        float :: dydx(nout)
        end subroutine linear_interp
       end interface
!
       qroot=(MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0)
!
       if (cv%num_cv.eq.0) then
        __WRN( whoami,' NO CV DEFINED. NOTHING DONE.')
        return
       endif
!
       rin=0d0; dr=0d0; rout=0d0;
!
       if (qroot) then ! root does the work
        do i=1,cv%num_cv
         read(ifile,*) (rin(i,k),k=1,num_rep_in)
        enddo
       endif ! root
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     do the interpolation --  simple, not self-consistent
       if (qroot) then ! only root does the work
!     check for undefined values
       if (any(rin(1:cv%num_cv,:).eq.__NAN))                             &
     &   __WRN( whoami,'SOME CV VALUES ARE UNDEFINED')
!     compute arclength
        dr=rin(:,2:num_rep_in)-rin(:,1:num_rep_in-1)
        s(1)=0
        do i=1,num_rep_in-1
         ds2(i)=dot_product(dr(:,i)**2,cv%weight**2)
         ds(i)=sqrt(ds2(i))
         s(i+1)=s(i)+ds(i)
        enddo
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     normalize arclength
        do i=1,num_rep_in
         s(i)=s(i)/s(num_rep_in)
        enddo
!ccccccccccccccccccccccccc
!     create uniform array
        do i=1,num_rep_out
         t(i)=1.0d0*(i-1)/(num_rep_out-1)
        enddo
!cccccccccccccc now interpolate variables cccccc
        if (interp_method.eq.spline) then
         do i=1,cv%num_cv
           rr=rin(i,:)
           call spline_cubic_set(num_rep_in,s,rr,0,0,0,0,rrpp)
           do k=1,num_rep_out
            call spline_cubic_val(num_rep_in,s,rr,rrpp,t(k),            &
     &                          rout(i,k),dum,dum)
           enddo
         enddo
        elseif (interp_method.eq.bspline) then
         do i=1,cv%num_cv
           rr=rin(i,:)
           do k=1,num_rep_out
            call spline_b_val(num_rep_in,s,rr,t(k),rout(i,k))
           enddo
         enddo
        elseif (interp_method.eq.linear) then
         do i=1,cv%num_cv
           rr=rin(i,:)
           call linear_interp(s,rr,num_rep_in,t,rr_out,num_rep_out)
           rout(i,:)=rr_out
         enddo
        else
         __WRN( whoami,'NO VALID INTERPOLATION METHODS SELECTED')
        endif ! interp_method
!
!     write output file
        write(fmt,int_format) num_rep_out
        do i=1,cv%num_cv
         write(ofile,'('//fmt//real_format//')')                        &
     &     (rout(i,k),k=1,num_rep_out)
        enddo
       endif ! qroot
       end subroutine cv_common_interpolate
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      end module cv_common
!
__CHARMM_ONLY##ENDIF
