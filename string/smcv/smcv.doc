
File: Stringm, Node: SMCV, Up: Top, Previous: SM0K, Next: FTSM

String Method in Collective Variables (SMCV).
-------------------------------------------------------------------------------------------------------------

Command Syntax.

STRIng COLVar [INITialize [{MAXCV}]                                                                         |
              [DONE]                                                                                        |
              [ADD [POSI_COM_X[{FORCe<real>}][{<WEIGht<real>}][{GAMMa<real>}][FRAMe<int>] <atom_selection>]|
                   [POSI_COM_Y[{FORCe<real>}][{<WEIGht<real>}][{GAMMa<real>}][FRAMe<int>] <atom_selection>]|
                   [POSI_COM_Z[{FORCe<real>}][{<WEIGht<real>}][{GAMMa<real>}][FRAMe<int>] <atom_selection>]|
                   [DIHE_COM [{FORCe<real>}][{<WEIGht<real>}][{GAMMa<real>}]<atom_selection><x4> ]  |
                   [ANGLE_COM [{FORCe<real>}][{<WEIGht<real>}][{GAMMa<real>}]<atom_selection><x3> ] |
                   [DIST_COM [{FORCe<real>}][{<WEIGht<real>}][{GAMMa<real>}]<atom_selection><x2> ]  |
                   [ANGLVEC [{FORCe<real>}][{<WEIGht<real>}][{GAMMa<real>}] -
                            [P1 [<atom_selection> | 3<real>]] [P2 [<atom_selection> | 3<real>]] -
                            [P3 [<atom_selection> | 3<real>]] [P4 [<atom_selection> | 3<real>]] -
                            [{FR1<int>}] [{FR2<int>}] ] |
                   [FRAME <atom_selection>] |
                   [QUATERNION [{FORCe<real>}][{<WEIGht<real>}][{GAMMa<real>}][{FRA1<int>}][{FRA2<int>}]] |
                   [RMSD [{FORCe<real>}][{<WEIGht<real>}][{GAMMa<real>}] <atom_selection> -
                         [{ORIE <atom_selection>}] [{MASS}] [{MAIN|COMP}]] |
                   [DRMSD [{FORCe<real>}][{<WEIGht<real>}][{GAMMa<real>}] <atom_selection> -
                         [{ORIE <atom_selection>}] [{MASS}] [{MAIN|COMP}]] |
                   [PROJ [{FORCe<real>}][{<WEIGht<real>}][{GAMMa<real>}] <atom_selection> -
                         [{ORIE <atom_selection>}] [{MASS}] [{MAIN|COMP}]]]                                 |
              [LIST]                                                                                        |
              [CLEAr]                                                                                       |
              [REPArametrize [{DEFI <real>}] -
                             [{ITER <int>}] -
                             [{LINE | SPLI | BSPL | DST [{WNCT <real>}] | LIN2}]                            |
              [TEST [GRAD {STEP <real>} | PARA | MINV] ]                                                    |
              [FILL {COL <int>} {COMP} ]                                                                    |
              [SWAP <int> <int>]                                                                            |
              [COPY <int> <int>]                                                                            |
              [PRINt[{ALL}] {UNIT <int>} {NAME <character*>} {COL}]                                         |
              [READ [{ALL | SCOL<int> TCOL<int>}] {UNIT <int>} {NAME <character*>} {COL}]                   |
              [SET  [{IND<int> | ALL }] -
                    [{FORCe<real>}] [{GAMMa<real>}] [{WEIGht<real>}] [{ZVAL<real> [REP<int>] [{COL<int>}]}] ]                                                               |
              [VOROnoi [VCUT <real> [{REP<int>}]] |
                       [VMAP [CALC] | -
                             [PRINt[{UNIT <int>}] [NAME <character*>] ] -
                             [READ [{UNIT <int>}] [NAME <character*>] ] -
                             [CLEA] ] | -
                       [READ [UNIT <int>] [NAME <character*>] ] -
                       [PRINt[UNIT <int>] [NAME <character*>] ] ]                                           |
              [FRAMe[CLEAr] |
                    [RESEt] |
                    [FILL [{COMP}] [{ALIGn}]] |
                    [PRINt[{ALL}] [{UNIT<int>}] [{NAME<character*>}]] |
                    [READ [{ALL}] [{UNIT<int>}] [{NAME<character*>}]] |
                    [LIST] |
                    [ALIGn [{RMSD | VORO}]] ]                                                               |
              [PARA [QUAT [YES|ON|TRUE|T|yes|on|true|t|NO|OFF|FALSE|F|no|off|false|f]] |-
                    [FRAM [YES|ON|TRUE|T|yes|on|true|t|NO|OFF|FALSE|F|no|off|false|f]] |-
                    [COLV [YES|ON|TRUE|T|yes|on|true|t|NO|OFF|FALSE|F|no|off|false|f]] |-
                    [MMAT [YES|ON|TRUE|T|yes|on|true|t|NO|OFF|FALSE|F|no|off|false|f]] |-
                    [VORO [YES|ON|TRUE|T|yes|on|true|t|NO|OFF|FALSE|F|no|off|false|f]] ]                    |
              [MINV [LU|lu|DIAG|diag]]                                                                      |
              [MMAT [CALC | -
                    [PRINt[{INV}] [{UNIT<int>}] [NAME<character*>]] | - 
                    [READ [{INV}] [{UNIT<int>}] [NAME<character*>]] | -
                    [FAST [YES|ON|TRUE|T|yes|on|true|t|NO|OFF|FALSE|F|no|off|false|f]] ]                    |
              [WEIGht[CALC|
                     [PRINt[{UNIT<int>}] [NAME<character*>]] | - 
                     [READ [{UNIT<int>}] [NAME<character*>]] ]                                              |
              [INTE [{INTERPCV [METH [LINE|SPLI|BSPL|LIN2]]}] -
                    [NIN<int>] [CVIN<character*>] -
                    [NOUT<int>][CVOUT<character*>] -
                    [{COOR [CRIN<character*>][CROUT<character*>] -
                           [{PDB  [{RESI}] | FILE | UNFO | CARD | FORM}]]]                                  |
              [DYNAmics[{STAF <int>}]  -
                       [{NOPR}] -
                       [{VORO}] -
                       [{REPA [REPF <int>]} ] -
                       [{STAT [STAF]}] -
                       [{HISF <int>] -
                       [{EVOL [EVOF <int>] -
                              [{EVOS <int>}] -
                              [{EVOStep <real>}] -
                              [{EXPO {MEMO <real>} | AVER {NAVE <int> }]]
                       [{RSTR [REEQ <int>]}] -
                       [{REX [REXF <int>] [REXT <real>]}] -
                       <regular dynamics options>]                                       |
              [STATistics[{COUNt <int>]} -
                         [{RMSD [RNAM <character*>] [{RAPP}]} ] -
                         [{RMSA [RANM <character*>] [{RAAP}]} ] -
                         [{DELS [DNAM <character*>] [{DAPP}]} ] -
                         [{ARCL [ANAM <character*>] [{AAPP}]} ] -
                         [{CURV [CVNM <character*>] [{CAPP}]} ] -
                         [{FREE [FENM <character*>] [{FAPP}]} ] -
                         [{COLV [CNAM <character*>] [{CVAP}] }]
                         [{VORO [VNAM <character*>]} ] -
                         [{VMAP [{VNAM <character*>}]} ] -
                         [{VLOG [{VNAM <character*>}]} [{VOFF <int>}] [{VLAP}]}] -
                         [{REXM [RXNM <character*>] [{RXOL <character*>}]}] -
                         [{REXL [{RXNM <character*>}] [{ROFF <int>}] [{RXAP}]}] -
                         [{FORC [FCNM <character*>] [{FCAP}] }] -
                         [{MMAT [MNAM <character*>]}]]

Command Description.
--------------------------------------------------------------------------

[INIT] Initialize the string method in collective variables (SMCV).
Substitution parameters ?MESTRING and ?NSTRING will be set to correspond
to the string rank of each CPU group, and to the total number of string
replicas, respectively.
--------------------------------------------------------------------------

[DONE] Finalize SMCV module
--------------------------------------------------------------------------

[ADD [<CV_specification>]]  Define a collective variable.  The following
CV are supported.

1)POSI_COM_X : X-component of COM of atom group
2)POSI_COM_Y : Y-component of COM of atom group
3)POSI_COM_Z : Z-component of COM of atom group
4)DIST       : Distance between two COM groups 
5)ANGL       : Angle between two COM groups 
6)ANGLVEC    : Angle between two vectors 
7)DIHE       : Dihedral angle between two COM groups 
8)RMSD       : Root-mean-square distance to a reference
               coordinate set of an atom group 
9)DRMSD      : Difference between RMSDs to two coordinate sets
10)PROJ      : Fraction of distance between two coordiante sets
               (projected onto vector connecting the two sets,
               accounting for rotation)

11)QUATERNION : quaternion representation of rotation transformation
between two frames.  When a quaternion CV is specified, four CVs will
actually be created, corresponding to the components of the quaternion.

A new coordinate reference frame can be specified on the basis of an
atom selection using ADD FRAME <atom_selection>; the frame axes will be
defined as the eigenvectors of the moment of inertia tensor of the
selected coordinates.

The following (optional) keywords are valid for all CV:

[{FORCe<real>}] Set harmonic force constant.
[{<WEIGht<real>}] Set CV weight in distance computation (this is akin to
atomic mass in the case of absolute position CV.
[{GAMMa<real>}] Set the CV friction coefficient for the evolution of the
CV in inverse AKMA time units (see EVOL keyword for the evolution equation)

NOTE: Each CV definition requires a corresponding number of atom
selections as indicated in teh syntax section above.

RMSD, DRMSD and PROJ CVs take an optional orientation set specified by
the keyword ORIE after the main (RMSD) selection. The MASS keyword
causes mass-weighting to be used in the RMSD computation ans in best-fit
superpositions.

POSI_COM_[X|Y|Z] CVs take a optional frame number via `FRAMe <int>`
(default 0 for absolute frame) in which the positions will be expressed. 
To use a non-absolute frame, such a frame must first be defined via `ADD
FRAMe <atom_selection>`; frame indices correspond to the order in which
frames have been defined.

The ANGLVEC CV specifies the angle between two vectors. The vectors are
defined using four coordinate triplets.  Each coordinate triplet can be
defined either using an atom selection or three real numbers. The first
vector is defined by coordinates P1 and P2, and the second vector, by
coordinates P3 and P4.  In addition, each vector can be defined in a
different reference frame, specified optionally as `FR1<int>` and
`FR2<int>`; the default frame is zero for each vector, which corresponds
to the absolute coordinate frame. The angle and its derivatives are
computed after the vectors are implicitly rotated into the same
reference frame.

The QUATERNION CV definition requires the specification of two
coordinate frames FR1<int> and FR2<int>; the quaternion that is defined
corresponds to the rotation of frame 2 into frame 1.  Frames must be
different (otherwise the quaternion is the identity rotation).
--------------------------------------------------------------------------

[REPA] Call reparametriation (Repa) module.  The supported
reparametrization methods are the same as those described for the
finite-temperature string module (FTSM) and the zero-temperature string
(SM0K).
--------------------------------------------------------------------------

[LIST] List currently defined collective variables.
--------------------------------------------------------------------------

[CLEAr] Remove all collective variables, frames and quaternions.
--------------------------------------------------------------------------

[TEST [GRAD {STEP <real>}|PARA|MINV] Test gradients of the string
restraint potentials by finite difference if GRAD is specified; test
parallel force computation when PARA is specified; test the computation
of M-tensor inverse by LU decomposition, and by direct multi-diagonal
matrix inversion. STEP sets the finite difference interval to use with
GRAD. Parallel force computation test will work only when more than one
CPU is assigned to a string image. The MINV test is provided for
cross-validation.
--------------------------------------------------------------------------

[FILL {COL<int>} {COMP} ] Calculate values of the CV from instantaneous
coordinates and put into string column specified by COL<int>.  This is
how an initial string is defined in the beginning of a set of
optimizations.  Omission of COL<int> will result in the main column (#1)
being populated.  Reference coordinates for statistics (see e.g. STAT
RMSD) are assumed to be in column #3.  There are currently 12 CV
coordinate sets, which are used for various parts of the SMCV
calculations; the user should not normally need to use the columns other
than the main and the reference. COMP specified that CHARMM comparison
coordinates are to be used for computing CV.
--------------------------------------------------------------------------

[PRINt {ALL} {UNIT <int>} {NAME <character*>} {COL}] Write current CV
coordinates to file from the column specified by COL. `ALL` indicates
that the root node of each string replica is to write a separate file
containing only the CV values of the corresponding replica. If ALL is
omitted,  one file will be created with the number of lines equal to the
number of defined CV, each line containing M values, corresponding to M
CVs.
--------------------------------------------------------------------------

[READ {ALL | SCOL<int> TCOL<int>} {UNIT <int>} {NAME <character*>}
{COL}] Read CV coordinates from file into the column specified by COL.
`ALL` indicates that the root node of each string replica is to read a
separate file containing only the CV values of the corresponding
replica. If ALL is omitted, all CV coordinates are assumed to be
contained in one with the number of lines equal to the number of defined
CV, each line containing M values, corresponding to M CVs. If SCOL<i> is
specified, each replica will read the CV coordinates of the i-th replica
(i-th column) provided in the file (rather than it's corresponding
column); TCOL must be provided along with SCOL, and indicates the number
of columns (string images) in the file.
--------------------------------------------------------------------------

[SWAP <int> <int>] Swap string coordinates in the specified columns.
--------------------------------------------------------------------------

[COPY <int> <int>] Copy string coordinates from the first column to the
second column.
--------------------------------------------------------------------------

[SET  [{IND<int> | ALL }] <parameter>] Will set parameter value for CV
with index IND<i>, or for all CV if ALL is specified.  <parameter> can
be one or more of the following:  [FORCe<real>] force constant for
harmonic restraint potential. [GAMMa<real>] friction constant for CV
evolution (see EVOL in DYNAmics  below). [WEIGht<real>] CV weight for
computing (string) distances. [ZVAL<real> [REP<int>] [{COL<int>}]] value
for the CV variable, set for the specified replica in the specified
column.
--------------------------------------------------------------------------

[VOROnoi VCUT <real> {REP <int>} ] Set the maximum allowed distance from
the string in the plane perpendicular to the string tangent that the
instantaneous MD replica is allowed to travel in Voronoi simulations.
This allows one to limit the transition tube width in Voronoi
calculations. REP<i> will set the Voronoi cutoff distance on replica <i>
only.

[VOROnoi VMAP CALC] Compute the Voronoi map, which lists the Voronoi
cell in which each instantaneous string coordinate set resides.  In the
present implementation, the functionality is used to ascertain that each
instantaneous replica corresponds to the correct string image; i.e. MD
replica on node (i) is closest to the string image (i), in which case
the Voronoi map will consist ot two identical rows with entries 1 ... M, 
where M is the number of string images. Instantaneous coordinates and
string coordinates must be defined prior to invoking this command.

[VOROnoi VMAP PRIN [{UNIT <int>}] [NAME <character*>] ] Print Voronoi
map to file with provided NAME and (optionally) provided unit number.

[VOROnoi VMAP READ [{UNIT <int>}] [NAME <character*>] ] Read Voronoi map
from file with provided NAME and (optionally) provided unit number.

[VOROnoi VMAP CLEA] Clear the Voronoi map if it has been READ or
CALCulated.  This will force the Voronoi map to be recomputed at the
beginning of dynamics.  This option is important due to the present
CHARMM implementation of Voronoi calculations.  The integrator will
issue warnings if an MD replica is found outside its corresponding
Voronoi cell; however, each replica is technically allowed to leave its
cell for one iteration, at which point its (half-kick) momenta (the
Verlet integrator is assumed) are reversed to return it to its home
cell. In particular, is it possible that a replica will be outside of
its cell at the timestep at which the restart file is written, in which
case, the Voronoi map will be flagged as incorrect unless it is CLEARed
prior to dynamics.

[VOROnoi PRINt[{UNIT <int>}] [NAME <character*>] ] Print matrix C_ij
with the number of Voronoi crossing attempts from cell (i) to cell (j)
to file with provided NAME and (optionally) provided unit number.  This
file can be quickly postprocessed for a fast calculation of free energies
of the tessellation.

[VOROnoi READ [{UNIT <int>}] [NAME <character*>] ] Read matrix C_ij with
the number of Voronoi crossing attempts from cell (i) to cell (j) to
file with provided NAME and (optionally) provided unit number. This
command is useful for restarting a Voronoi calculation with previously
accumulated crossing statistics.

--------------------------------------------------------------------------
[FRAMe <char*>] The FRAMe commands concern the manipulation of
coordinate reference frames that can be used to compute rigid-body
invariant positions, angles between vectors in different reference
frames, and orientation quaternions. Addition of new frames is described
under the ADD command above.

[CLEAr] Remove all reference frames.

[RESEt] Force any code that depends on a reference frame to recompute
all reference frame axes. E.g., evaluating of a position CV expressed in
a non-absolute frame of reference.

[FILL [{COMP}] [{ALIGn}]] Compute reference frame axes from
instantaneous coordinates according to the atom selection specified in
ADD FRAME command. Because frame vectors are defined as eigenvectors of
moment of inertia tensors of a set of atoms, frame vectors are only
unique up to a sign.  Considering only right-handed coordinate frames,
there are three possible definitions of a frame.  To ensure that different
replicas define the frame vectors consistently, the option ALIGn is
provided. When ALIGn is present, a reference coordinate set is assumed
to be present in the comparison set, and the frame vectors computed from
the main coordinate set are consistent with those computed from the
comparison set. If the comparison set has the same coordinates for all
string replicas, this almost surely implies that the frames are also
defined consistently between the different replicas. COMP swaps the
roles of the main and the comparison sets.

[PRINt[{ALL}] [{UNIT<int>}] [{NAME<character*>}]] Write frame vectors to
file with specified name and optional unit number.  If ALL is specified,
the root node of each string group/image will write a separate file with
the frame vectors corresponding to the image.  If ALL is omitted, frame
vectors will be written for all replicas by the root node for the entire
string.  Each line in the files consists of nine entries corresponding
to the three frame vectors (written out columnwise).  The frame axes
corresponding to different replicas are written on consecutive lines. 
If more than one frame is defined, the first frame is written out as a
block of M lines (where M is the number of replicas); for N frames,
there will be N such consecutive blocks.

[READ [{ALL}] [{UNIT<int>}] [{NAME<character*>}]] Read frame vectors to
file with specified name and optional unit number.  File format and
`ALL` option is as described for PRINt above.

[LIST] List all defined frames and their constituent atoms.

[ALIGn [{RMSD | VORO}]] Align frames along the string, making sure that
the frames are defined consistently on different replicas.  RMSD will
cause the code to find the frame vectors such that the (position) CV
values computed from the coordinates are closest to the string (in the
notation of ref. [1] ||\theta(x) - z || is minimum).  if VORO is
specified, the code will select frame vectors such that the (position)
CV values computed from the coordinates are closest to the string in the
sense of the Voronoi metric,  i.e. that each instantaneous coordinate
set is within its corresponding Voronoi cell.

The ALIGn oiptions should not normally be needed if the frame vectors
are written out and read in during successive simulation, because in
that case there is no ambiguity in their definition.

--------------------------------------------------------------------------
[PARA [QUAT [YES|ON|TRUE|T|yes|on|true|t|NO|OFF|FALSE|F|no|off|false|f]]]
Indicate whether to enable parallel computation of quaternions and
quaternion derivatives; default : off

[PARA [FRAM [YES|ON|TRUE|T|yes|on|true|t|NO|OFF|FALSE|F|no|off|false|f]]]
Indicate whether to enable parallel computationl of reference frames and
their derivatives; default : off

[PARA [COLV [YES|ON|TRUE|T|yes|on|true|t|NO|OFF|FALSE|F|no|off|false|f]]]
Indicate whether to enable parallel computation of collective variables
and their derivatives; default : off

[PARA [MMAT [YES|ON|TRUE|T|yes|on|true|t|NO|OFF|FALSE|F|no|off|false|f]]]
Indicate whether to enable parallel computation of the metric tensor;
default : on

[PARA [VORO[YES|ON|TRUE|T|yes|on|true|t|NO|OFF|FALSE|F|no|off|false|f]]]
Indicate whether to enable parallel computation of Voronoi distances;
default : on

--------------------------------------------------------------------------
[MINV [LU|lu|DIAG|diag]] Specify method for inverting the metric tensor.
LU specifies LU decomposition; DIAG specifies a multidiagonal direct
inversion. DIAG is expected to be faster for matrices with nonzero
entries clustered near the diagonal. The structure of the metric tensor
depends on the definition of the CV.

--------------------------------------------------------------------------
[MMAT [CALC]] Calculate the instantaneous metric tensor from
coordinates.

[MMAT PRINt[{INV}] [{UNIT<int>}] [NAME<character*>]] Write metric tensor
to file with specified name and (optional) unit number. INV indicates
that the inverse of the metric tensor is to be written.

[MMAT READ [{INV}] [{UNIT<int>}] [NAME<character*>]] Read metric tensor
from file with specified name and (optional) unit number. INV indicates
that the inverse of the metric tensor is to be read.

[MMAT [FAST[YES|ON|TRUE|T|yes|on|true|t|NO|OFF|FALSE|F|no|off|false|f]]]
Specify whether to use a sparse matrix algorithm for computing the
metric tensor. The FAST routine may not be faster if the metric tensor
is not sparse (whether this is true depends on the definition of the
CV).

--------------------------------------------------------------------------
[WEIGht [CALC]] Compute CV weights from metric tensor. The weights are
necessary do define distance in the space of CV. Alternatively, weights
can be specified at the time of CV definition or read from file as
described below. Whatever the method of choice, the weights should
typically be held constant throughout a given SMCV simulation (e.g. they
are equivalent to atomic masses if the CV are Cartesian coordinates).

[WEIGht PRINt[{UNIT<int>}] [NAME<character*>]] Write CV weights to file
with provided name and optional unit number. The output will consist of
a single line with a number of floating point entries equal to the
number of CV.

[WEIGht READ [{UNIT<int>}] [NAME<character*>]] Read CV weights from file
with provided name and optional unit number.

--------------------------------------------------------------------------
[INTE [{INTERPCV [METH [LINE|SPLI|BSPL|LIN2]]}] -
      [NIN<int>] [CVIN<character*>] -
      [NOUT<int>][CVOUT<character*>] -
      [{COOR [CRIN<character*>][CROUT<character*>] -
             [{PDB  [{RESI}] | FILE | UNFO | CARD | FORM}]]]

[INTE] Interpolate a string onto a new string with different resolution.
The routine can be used to interpolate CVs using the INTERPCV option,
and also to create coordinate files that are optimal for the given CV
values (starting from supplied coordinate files).

[INTERPCV METH [LINE|SPLI|BSPL|LIN2] ] interpolation method to use. The
valid methods are  as described in the zero-temperature string
documentation; default : LINE

[NIN] Number of images in the existing string.

[CVIN <character*>] Name of text file which contains the existing CV
values (format given in PRINt command above).

[NOUT] Number of coordinate sets in the interpolated string.

[CVOUT <character*>] Name of text file to which interpolated CV values
will be written. If INTERPCV is not set, the file specified by CVOUT is
assumed to exist, containing the CV values for which coordinate files
are to be generated (see CRIN/CROUT below).

[{COOR <character*>}] When provided, coordinate files will be written in
correspondence to the CV values in file CVOUT<char*>, using the
following parameters.

[CRIN <character*>] Name of text file that contains the filenames in
which existing coordinates are stored, with one file name per line.

[CROUT <character*> ] Name of text file that contains file names to
which coordinate sets corresponding to the CVs in CVOUT<char*>
are to be written.

The following options are passed to the CHARMM coordinate input/output
routines:

[PDB [{RESI}] ] Indicates that input/output coordinate files are in PDB
format.  RESI will pass the 'RESID' option to the coordinate reader.

[FILE | UNFO ] Indicates that input/output coordinate files are
UNFORMATTED.

[CARD | FORM}] Indicates that input/output coordinate files are
FORMATTED.
-------------------------------------------------------------------------

[DYNAmics] The STRIng COLV DYNAmics command will parse options relevant
for the SMCV and subsequently call the regular dynamics integrator.
Currently, SMCV support is limited to the default Verlet leapfrog
integrator (dynamc module). The following, all optional, keywords are
supported.

[{STAF <int>}] Number of steps to skip between successive outputs of
statistics. STAT options must be set prior to dynamics.

[{NOPRint}] Reduce output from FTSM during dynamics.

[{VORO}] For each FTSM replica, dynamics will be constrained to the
corresponding Voronoi cell by reversing momenta at cell boundaries. This
allows computing the free energy of the Voronoi tessellation and the
MFPT between different Voronoi cells.


[{EVOL [EVOF <int>] [{EVOS <int>}] [{EXPO {MEMO <real>}|AVER [NAVE
<int>] {MAXAVE <int>}}]}] Specify string evolution options. EVOL turns
on string evolution during dynamics. 

EVOF <int> specifies the frequency at which the evolution is to be
performed. A reasonable value for EVOF is 10, implying, essentially that
every 10th structure during dynamics will be added to a running average.

EVOS <int> specifies the number of dynamics steps after each update (if
UPDA is set) during which evolution is temporarily turned off. This can
be used to set an equilibration period after each update.  A reasonable
choice is to use the value for REEQ (see below) which specifies the
number of dynamics steps over which the restraint potentials are
adjusted to new string coordinates after an update.

EVST <real> specifies the evolution step for the string images. By
default, string evolution follows steepest descent dynamics on the  free
energy landscape of the collective variables (refs. 1-2), i.e.,  

cv_i(n+1) = cv_i(n) - dt / gamma_i * M_ij * dF(cv_k; k\in[1,M])/dcv_j,

where n is the nth iteration, dt is specified by EVST, gamma is the 
friction coefficient specified in the definition of each CV, M is the
metric tensor, and F is the (M-dimensional) free energy as a function of
the M collective variables. In the above equation, the quantity
(dt/gamma) must units of squared time, where the unit of time is
determined implicitly by the units of the MD engine; e.g. in CHARMM, the
AKMA time unit is used. Reasonable values for dt (EVST) and gamma depend
on the collective variable and the evolution frequency, but O(-3) and
O(1), respectively, are a good place to start.

EXPO {MEMO} specifies that evolution will use the exponential averaging,
i.e.,  CV(N+1) =  <rMEMO> *CV(N) + (1-<rMEMO>) * X_INST, where CV(N) are
the CV coordinates at the Nth evolution call, X_INST are the
instantaneous CV values computed from MD coordinates, and MEMO is a
memory parameter in the range [0, 1]. Reasonable values for MEMO are
0.999 - 0.9999.

EXPO AVER {NAVE <int>} Evolution will use simple averaging, i.e.,
PHI(N)=AVERAGE_{i=0}^{N}(X_i).  To dampen oscillations at the beginning
of a simulation, NAVE can be used to set an artificial number of samples
in the average. That is, the average is updated using  PHI(N+1) = ( NAVE
* PHI(N) + X_INST ) / (NAVE++) ; therefore a high value for NAVE will
decrease | PHI(N+1)-PHI(N) |.

[{REPA [REPF <int>]}] indicates that reparametrization is to be
performed after each block of REPF<int> iterations. REPA options must be
set prior to dynamics.

RSTR [REEQ <int>] RSTR specifies that SMCV restraints are to be turned
on during dynamics.  REEQ specifies the number of simulation steps
during which the restraint potentials will switch to the EVOLved
CV coordinates from previous CV coordinates (during each evolution,
if EVOL EVOF<i> is set). This option prevents abrupt changes in the
restraints which can lead to instability. Values in the range 10 -- 500
are reasonable, depending on the system.

REX [REXF <int>] [REXT <real>] Instructs the code to attempt to swap MD
coordinates between adjacent replicas at frequency REXF <i> using
temperature REXT <r> in the Metropolis criterion.  This option can
significantly improve the convergence of free energy profiles but
requires that the force constants in the restraining potentials be
sufficiently low to facilitate frequent exchanges (a success rate of at
least 10% is recommended).  REXT can be increased beyond the simulation
temperature to facilitate exchanges, but this will cause the
thermodynamic ensemble to deviate from the Boltzmann distribution.

------------------------------------------------------------------------
[STATistics] Call statistics module. Specify statistics options when
arguments are present. When called without arguments, an instance of
statistics output will be written out. The SMCV STAT module has similar
syntax to the zero-temperature (SM0K) and finite-temperature (FTSM) STAT
modules.  The specification of keywords RMSD RMSA DELS ARCL CURV FREE
FORC VORO VMAP VLOG REXM REXL is as described for the SM0K and FTSM STAT
routines.  Keywords MMAT and COLV are described below.

[STAT MMAT [MNAM <character*>]] Indicate that the metric tensor is to be
output at each statistics call.  The output file with the specified name
will contain a column of N MxM matrices where N is the number of string
replicas and M is the number of CV.

[STAT COLV [CNAM <character*> {CVAP}]] Indicate that CV values are to be
output at each statistics iteration to the fiel with the specified name,
appending to an existing file (e.g. from previous calculations) is CVAP
is set.  Each line of the file corresponds to a single CV and contains N
values for the N replicas. Successive lines correspond to different CV.

------------------------------------------------------------------------
SMCV References:

[1] L. Maragliano, A. Fischer, E. Vanden-Eijnden, and G. Ciccotti, J.
Chem.Phys. 125, 024106 (2006).
[2] L. Maragliano and E. Vanden-Eijnden, Chem. Phys. Lett. 426, 168
(2006).
[3] V. Ovchinnikov, M. Karplus, and E. Vanden-Eijnden, J. Chem. Phys.
134, 085103 (2011).

If you find the CHARMM SMCV code useful in preparing a manuscript,
please cite the implementation reference 3 above.
