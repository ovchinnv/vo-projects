!CHARMM Element source/stringm/sm0k.src $Revision: 1.5 $
!
! zero-temperature string code
! documentation will be provided in stringm.doc
!
##IF STRINGM
##IF PARALLEL
!
      module sm0k ! string-method-at-0-K
      private
!
!     VARIABLES
!ccccc initialization flag
      logical, public, save :: sm0k_initialized=.false.
!ccccc number of replicas on the string
      integer, save :: nstring=-1
      integer, save :: mestring=-1
!ccccc GENERAL VARS
      logical, save :: repa_initialized
      integer, save :: norient, nmove
!     interpolation methods
      integer, parameter :: linear=1, spline=2, bspline=3, dst=4,       &
     &  linear_exact=5
!
      integer, save :: interp_method=0,orient=0
      logical, save :: qstat_orient=.false.
      integer, save :: orient_mass=0, repa_mass=0
      integer, save :: iterations=1 ! maximum interpolation iterations
      real*8, save  :: def=1.1d0 ! interpolation tolerance
      real*8, save  :: dst_cutoff=1.0d0 ! wavenumber truncation parameter for DST
!
!ccccc arrays
      real*8, save, allocatable ::                                      &
     &        rcurrent_m(:,:), rref_o(:,:), rcurrent_o(:,:)
!     arclength and curvature
      real*8, save, allocatable :: ds(:), curv(:) ! unavailable at first iteration
!     orientation weights -- for 0-temp. string
      real*8, save, allocatable :: orientWeights(:), repaWeights(:)
      integer, save, allocatable :: iatom_o(:), iatom_m(:),             &
     &      iatom_free_o(:), iatom_free_m(:)
      integer, save, pointer :: iatom_f(:)
      integer, save :: nfix_bckl
      logical, save, allocatable :: fixed_o(:), fixed_m(:), fixed_s(:)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccc STATISTICS VARS cccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      integer, save :: stat_iteration_counter=0 ! how many times 'stat' has been called
      logical, save :: output_energy=.false., output_rmsd0=.false.,     &
     &                 output_dsdt=.false.,                             &
     &                 output_arclength=.false.,                        & ! output options
     &                 output_curvature=.false.,                        &
     &                 output_rmsd_ave=.false. ! rmsd wrt to the average structure
      logical, save :: stat_rmsd_mass=.false. ! should the statistics routine do mass-weighted RMSD?
      logical, save :: stat_initialized=.false.

      character*80, save :: energy_fname='',                            &
     &  rmsd0_fname='', dsdt_fname='', s_fname='',                      &
     &  rmsd_ave_fname='', c_fname=''         ! output names
!
      integer, save :: nstat
      integer, save :: rmsd0_funit=-1, dsdt_funit=-1, s_funit=-1,       &
     &           rmsd_ave_funit=-1, c_funit=-1

      integer, parameter :: enmax=100
      character*4, save :: energy_names(enmax) ! arrays large enough to
      integer, save :: energy_indices(enmax) ! indices into the EPROP array
      integer, save :: num_energy_terms=0
      integer, save :: num_average_samples=0 ! number of samples in the average set
      integer, save :: energy_flen=0,                                   &
     & rmsd0_flen=0, dsdt_flen=0, s_flen=0, rmsd_ave_flen=0, c_flen
!ccccc arrays
      real*8, save, allocatable, dimension(:,:) ::                      &
     &      rold_s, rave_s, rcurrent_s, rcomp_s, rold_o, rave_o, rcomp_o
      real*8, save, allocatable :: statWeights(:)
      integer, save, allocatable :: iatom_s(:), iatom_free_s(:)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     SUBROUTINES
!
      public sm0k_main
      public sm0k_repa
      public sm0k_stat
!
      contains
!
      SUBROUTINE sm0k_main(COMLYN,COMLEN)
!----------------------------------------------------------------------
! command parser for the 0K string
!----------------------------------------------------------------------
      use sm_config, only : stat_on, stat_freq, repa_on, repa_freq      ! for communication with MINI
      use string
!      implicit none
      use dimens_fcm 
      use coord 
      use psf 
      use stream 
!
      CHARACTER*(*) COMLYN
      INTEGER COMLEN

! local variables
      character*8 keyword
      character*11 whoami
      integer :: isd, iconj, icgsd, iabnr, inrap
!     functions
!      logical eqstwc
!      character*4 nexta4
!      integer indxa, gtrmi
!      real*8 gtrmf
      logical :: qprint
!
      data whoami /' SM0K_MAIN>'/
!
      qprint=(prnlev.ge.3)
!
      keyword=nexta4(comlyn,comlen)
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (eqstwc(keyword(1:4),4,'INIT',4)) then
        call sm0k_init()
        return
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (.not.sm0k_initialized) then
        call sm0k_init()
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (eqstwc(keyword(1:4),4,'INTE',4)) then
        call sm0k_interpolate(comlyn, comlen)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (eqstwc(keyword(1:4),4,'REPA',4)) then
       if (comlen.gt.0) then ! this is an initialization call!
        call sm0k_repa_init(comlyn, comlen)
       else
        call sm0k_repa(0)! repa routine will reparametrize main coords
       endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (eqstwc(keyword(1:4),4,'STAT',4)) then
       if (comlen.gt.0) then ! this is an initialization call!
        call sm0k_stat_init(comlyn, comlen)
       else
        call sm0k_stat(0) ! compute statistics from main coordinates
       endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (eqstwc(keyword(1:4),4,'MINI',4)) then
!     string minimization
!     SD routine will be called;
!     SD is the only minimizer allowed, other minimizers removed below
!     setting "repa_on" to true so that
!     SD knows to call reparametrization
!     other options are let through -- use at your risk!
!      delete ABNR, POWE, CONJ, CGSD
       isd=indxa(comlyn, comlen, 'SD')
       iconj=indxa(comlyn, comlen, 'CONJ')
       icgsd=indxa(comlyn, comlen, 'CGSD')
       iabnr=indxa(comlyn, comlen, 'ABNR')
       inrap=indxa(comlyn, comlen, 'NRAP')
       if ((iconj+icgsd+iabnr+inrap).gt.0) then
        call wrndie(0,'<STRING_MINI>',                                  &
     &   ' ONLY SD MINIMIZATION IS SUPPORTED. NOTHING DONE')
        return
       endif
!      force SD minimization
       call joinwd(comlyn, mxcmsz, comlen, 'SD ', 3)
!cccccccccccccccccc reparametrization option cccccccccccccccccccccc
       repa_freq=gtrmi(comlyn, comlen, 'REPF',-1)
       if (repa_freq.le.0) then
        repa_on=.false.
        if (qprint)                                                     &
     &      WRITE (OUTU,'(/,2A,/,2A,/,2A/)')                            &
     &      whoami,' STRING METHOD ENABLED, BUT',                       &
     &      whoami,' REPARAMETRIZATION FREQUENCY ZERO OR UNSPECIFIED.', &
     &      whoami,' REPARAMETRIZATION WILL NOT BE DONE.'
       else
        repa_on=.true.
        if (qprint)                                                     &
     &      WRITE (OUTU,'(/,2A,/,2A,I7,A/)')                            &
     &      whoami,' STRING METHOD ENABLED.',                           &
     &      whoami,' WILL REPARAMETRIZE AFTER EVERY ',                  &
     &       repa_freq,' MINIMIZATION ITERATIONS'
       endif ! repa_freq
!cccccccccccccccccc statistics output option cccccccccccccccccccccc
       if (repa_on) then ! logically, it makes sense to output string statistics only when reparametrization is enabled
!                          if you want to follow the unparametrized dynamics, just set maxiter to 0 in the repa setup call
        stat_freq=gtrmi(comlyn, comlen, 'STAF',-1)
        if (stat_freq.le.0) then
        stat_on=.false.
         if (qprint)                                                    &
     &   WRITE (OUTU,'(/,2A,/,2A/)')                                    &
     &      whoami,' STATISTICS OUTPUT FREQUENCY NOT SPECIFIED.',       &
     &      whoami,' STATISTICS WILL NOT BE OUTPUT.'
        else
         stat_on=.true.
         if (qprint)                                                    &
     &   WRITE (OUTU,'(/,2A,I6,A/)')                                    &
     &      whoami,' WILL OUTPUT STATISTICS AFTER EVERY ',              &
     &       stat_freq,' REPARAMETRIZATION ITERATIONS'
        stat_freq=stat_freq*repa_freq
        endif ! stat_freq
       else ! repa_on
        if (qprint)                                                     &
     &  WRITE (OUTU,'(/,2A,/,2A/)')                                     &
     &      whoami,' STATISTICS OUTPUT REQUIRES REPARAMETRIZATION',     &
     &      whoami,' (DISABLED). STATISTICS WILL NOT BE OUTPUT.'
        stat_on=.false.
       endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       call minmiz(comlyn, comlen)
       repa_on=.false. ! turn off reparametrization for regular SD
       stat_on=.false. ! turn off statistics output for regular SD
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      else
            CALL WRNDIE(0, whoami,                                      &
     &       'UNRECOGNIZED SUBCOMMAND: '//keyword)
      endif
!
      end subroutine sm0k_main
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sm0k_init()
      use string
!      implicit none
      use stream 
      use multicom_ltm       !##MULTICOM
      use parallel 
      use mpi 
!
      logical :: qroot, qslave
      character*11 :: whoami
!
      data whoami /' SM0K_INIT>'/
!
!      do a basic communicator check:
      if (ME_LOCAL.eq.0.and.ME_STRNG.eq.MPI_UNDEFINED) then
        write(outu, 111) whoami, ME_GLOBAL, whoami
 111  FORMAT(A, ' WORLD REPLICA ',I5, ' HAS ZERO GROUP ID',             &
     & /,A,' BUT INVALID STRING ID (MAY BE OK).')
      elseif (ME_STRNG.ne.MPI_UNDEFINED.and.                            &
     &  (ME_LOCAL.ne.0.or.MPI_COMM_LOCAL.eq.MPI_COMM_NULL)) then
        write(outu, 111) whoami, ME_GLOBAL, whoami
 112  FORMAT(A, ' WORLD REPLICA ',I5, ' HAS A VALID STRING ID',         &
     & /,A,' BUT A NONZERO GROUP ID. ABORTING.')
       return
      endif
!
      qroot=ME_STRNG.ne.MPI_UNDEFINED
      qslave=ME_LOCAL.ne.MPI_UNDEFINED ! (also includes roots)
!
      if (sm0k_initialized) then
       if (qroot) then
        if (ME_STRNG.eq.0) then
          write(outu,'(2A)')                                            &
     &    whoami, ' SM0K ALREADY INITIALIZED. CALL "DONE" TO CLEAN UP.'
        endif
       endif
       return
      endif
!
      nstring=1 ! safe (hopefully) default
      mestring=-1 ! safe (hopefully) default
!
      if (qroot) then
        nstring=SIZE_STRNG
        mestring=ME_STRNG
      endif
!      broadcast string size to all slave nodes
      call psnd4(nstring, 1)
      call psnd4(mestring, 1)
!      set envorinment variable
      call setmsi('NSTRING',nstring)
      call setmsi('MESTRING',mestring)
!
      if (qroot) then
        if (ME_STRNG.eq.0) then
          write(outu,'(2A,I5, A)')                                      &
     &    whoami, ' FOUND ',nstring,' REPLICAS.'
        endif
      endif
!      store fixed atom indices
      iatom_f=>sm0k_fixed_atoms()
      nfix_bckl=size(iatom_f)
!
      sm0k_initialized=.true.
!
      end subroutine sm0k_init
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sm0k_done()
      use stream 
      use multicom_ltm       !##MULTICOM
      use parallel 
      use mpi 
      character*11 :: whoami
      integer :: bug
!
      data whoami /' SM0K_DONE>'/
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0)            &
     &  write(outu,'(2A,I5, A)') whoami, ' CLEANING UP.'
      sm0k_initialized=.false.
      nstring=-1
      mestring=-1
! deallocate fixed atom indices
      nfix_bckl=-1;
      if (associated(iatom_f)) deallocate(iatom_f)
!
      if (allocated(ds)) deallocate(ds)
      if (allocated(curv)) deallocate(curv)
!
!      set envorinment variable
      call setmsi('NSTRING',nstring)
      call setmsi('MESTRING',mestring)
!
      end subroutine sm0k_done
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function sm0k_fixed_atoms()
      use string
!      implicit none
      use dimens_fcm 
      use psf 
      use tsmh, only : backls  ! TSM common blocks included because minimizer DOF depend on TSM
      use tsms_mod, only : qtsm
!      use heap 
      use coord 
      integer, pointer :: sm0k_fixed_atoms(:)
      integer, allocatable :: backlist(:)
      integer :: nfix, i, j
      logical :: qfree
      allocate(backlist(natom)); backlist=0 ! need to initialize, otherwise nfix might be wrong
! try to acommodate TSM
##IF TSM
      if (qtsm) then
!       j=bpert(backls)
!       backlist=heap(j:j+natom-1) ! heap must have of integer type (it was when this line was written)
        backlist=backls
      endif
##ENDIF
!     construct indexing that excludes fixed and backlist atoms
      nfix = count(abs(imove(1:natom))+abs(backlist(1:natom)).gt.0)
      allocate(sm0k_fixed_atoms(nfix))
!
      nfix=0
      do i=1,natom
       qfree=imove(i).eq.0   ! see egrad1.src routines
       if (qtsm) qfree=qfree.and.backlist(i).eq.0 !##TSM
       if (.not.qfree) then
        nfix=nfix+1
        sm0k_fixed_atoms(nfix)=i
       endif
      enddo
!
      deallocate(backlist)
      end function sm0k_fixed_atoms
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sm0k_repa_init(COMLYN, COMLEN)
!     initialize string reparametrization
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      use string
!      implicit none
      use dimens_fcm 
      use stream 
      use coord 
      use select, only : selrpn, nselct
!##INCLUDE '~/charmm_fcm/coordc.fcm'
      use psf 
      use tsmh, only:backls  !##TSM ! TSM common blocks included because minimizer DOF depend on TSM
      use tsms_mod, only:qtsm  !##TSM
!      use heap  !##TSM
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      CHARACTER*(*) COMLYN
      INTEGER COMLEN
!
      character*22 methods(5)
      character*16 whoami
      character*8 keyword
      data methods                                                      &
     & / 'LINEAR','CUBIC SPLINE','B-SPLINE','DST','LINEAR EXACT'/
!     selection array
      integer, allocatable :: islct(:), jslct(:) ! for atom selections
      integer nslct
      integer i ,j, imode, mlen
      integer qlinear, qspline, qbspline, qdst, qlinear_exact
      logical :: qprint, qfree
      integer, allocatable :: backlist(:) ! for nominal compatibility with TSM
      integer, pointer :: ifixed(:) ! fixed atom indices
!
!     functions
!      real*8 :: gtrmf
!      integer gtrmi, indxa, indx
      data whoami /' SM0K_REPA_INIT>'/
!
!      interface ! not needed because string is now a module
!       function itoa(i) ! V. Ovchinnikov 2010; convert integer to a string
!       integer :: i
!       character(LEN=(ceiling(log10(1.0*abs(i)+1.0))+1)) :: itoa
!       character*(80) :: b
!       end function itoa
!
!       function sm0k_fixed_atoms() ! pre module days
!       integer, pointer :: sm0k_fixed_atoms(:)
!       end function sm0k_fixed_atoms
!      end interface
!
!     begin
      if (.not.sm0k_initialized) call sm0k_init()
!
      qprint=(prnlev.ge.3)
!     reset variables
      qspline=0
      qbspline=0
      qlinear=0
      qdst=0
      qlinear_exact=0
      dst_cutoff=0.0
      interp_method=0
      orient=0
      orient_mass=0 ! will the orientation use mass weighting?
      repa_mass=0 ! will the reparametrization use mass weighting
      nmove=0
      norient=0
      num_average_samples=0
!
!     deallocate arrays
      if (allocated(fixed_o)) deallocate(fixed_o) ! flags
      if (allocated(fixed_m)) deallocate(fixed_m) ! flags
      if (allocated(iatom_o)) deallocate(iatom_o)
      if (allocated(iatom_m)) deallocate(iatom_m)
      if (allocated(iatom_free_o)) deallocate(iatom_free_o)
      if (allocated(iatom_free_m)) deallocate(iatom_free_m)
      if (allocated(rref_o)) deallocate(rref_o)
      if (allocated(rcurrent_o)) deallocate(rcurrent_o)
      if (allocated(rcurrent_m)) deallocate(rcurrent_m)
      if (allocated(orientWeights)) deallocate(orientWeights)
      if (allocated(repaWeights)) deallocate(repaWeights)
!
!     deallocate arclength+curavture arrays
      if (allocated(ds)) deallocate(ds)
!     initialize curvature array
      if (allocated(curv)) deallocate(curv)
!
      repa_initialized=.false.
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (indxa(comlyn,comlen,'LINE').gt.0) then
       qlinear=1
       interp_method=linear
      endif
      if ((indxa(comlyn,comlen,'CSPL').gt.0).or.                        &
     &    (indxa(comlyn,comlen,'SPLI').gt.0)) then
       qspline=1
       interp_method=spline
      endif
      if (indxa(comlyn,comlen,'BSPL').gt.0) then
       qbspline=1
       interp_method=bspline
      endif
      if (indxa(comlyn,comlen,'DST').gt.0) then
       qdst=1
       interp_method=dst
!      did the user specify filter cutoff?
       dst_cutoff=gtrmf(comlyn, comlen, 'WNCT', -1.0d0)
       if (dst_cutoff.lt.0.0) then
        if (qprint) write(outu,664) whoami, whoami
 664   FORMAT(A,' DST REQUESTED BUT FILTER CUTOFF',                     &
     &  A, ' NOT SPECIFIED.',/,' WILL USE 0.500')
        dst_cutoff=0.5
       endif
      endif
      if (indxa(comlyn,comlen,'LIN2').gt.0) then
       qlinear_exact=1
       interp_method=linear_exact
      endif
!ccccccc CHECK FOR MULTIPLE OPTIONS
      if ((qspline+qlinear+qbspline+qdst+qlinear_exact) .eq. 0) then
       if (qprint) write(outu,665) whoami, whoami
 665   FORMAT(A,' INTERPOLATION METHOD NOT SPECIFIED.',/,               &
     & A,' WILL USE LINEAR INTERPOLATION.')
       interp_method=linear
      elseif ((qdst+qspline+qlinear+qbspline+qlinear_exact) .gt. 1)then
       CALL WRNDIE(0,whoami,                                            &
     &   'TOO MANY INTERPOLATION OPTIONS')
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     did the user specify an interpolation tolerance?
      if (interp_method.ne.linear_exact) then ! options below are invalid for exact interpolation
       def=gtrmf(comlyn, comlen, 'DEFI', 1.1d0)
       if (def.lt.1.0) then
         call wrndie(0,whoami,                                          &
     &'INTERPOLATION TOLERANCE MUST BE >= 1. EXITING.')
         return
       endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     did the user specify a maximum number of iterations?
       iterations=gtrmi(comlyn, comlen, 'ITER',10)
      else
       def=0d0
       iterations=0
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     check for orientation options: must appear after 'ORIE'
!     process selection
!
      allocate(islct(natom), jslct(natom), backlist(natom))
      islct=1     ! select all atoms by default
      backlist=0  ! setting this to zero is the simplest way to provide correct default behavior (see below)
!
      i=indxa(comlyn,comlen,'ORIE') ! find the position of `intc'
      if (i.gt.0) then ! only if the ORIE directive exists
!      selection text taken from corman.src
       orient=1
       j=indx(comlyn, comlen, 'SELE', 4)
       if (j.gt.0.and.j.lt.i) then ! sele occurs before orie
        call wrndie(0,whoami,                                           &
     &    'ATOM SELECTION MUST BE SPECIFIED AFTER ORIE.')
        return
       endif
       IMODE=0
!
       CALL SELRPN(COMLYN,COMLEN,islct,NATOM,1,IMODE,                   &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
       IF(IMODE.NE.0) THEN
        CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
        RETURN
       ENDIF
      endif ! orie specified
!
!     check for mass weighting
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      j=1
      do while (j.gt.0)
       mlen=comlen
       j=indxa(comlyn,comlen,'MASS') ! s
       if ( (orient.eq.1).and.(j.ge.i) ) then
        orient_mass=1
       else if (j.gt.0) then
        repa_mass=1
        i=i-(mlen-comlen) ! how much the string has shrunk
       endif
      enddo
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     check which atoms will be moved by reparametrization (default: all atoms)
!     process selection
      i=indxa(comlyn,comlen,'MOVE') !
      if (i.gt.0) then ! only if the MOVE directive exists
       j=indx(comlyn, comlen, 'SELE', 4)
       if (j.gt.0.and.j.lt.i) then ! sele occurs before orie
        call wrndie(0,whoami,                                           &
     &    'ATOM SELECTION MUST BE SPECIFIED AFTER MOVE.')
        return
       endif
       IMODE=0
!
       CALL SELRPN(COMLYN,COMLEN,jslct,NATOM,1,IMODE,                   &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
       IF(IMODE.NE.0) THEN
        CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
        RETURN
       ENDIF
      else
       jslct=1   ! reparametrization will move all atoms by default
      endif ! move specified
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! now process the selections
! 3/11 provide compatibiliy with fixed atoms and nominal compatibility with TSM backlists
      norient=count( islct(1:natom).gt.0 ) ! total number of orientation atoms
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if (norient.eq.0) then
        call wrndie(0,whoami,                                           &
     &   ' NO ATOMS SELECTED FOR ORIENTATION. WILL NOT ORIENT.')
        orient=0 ! invalid or missing selection for orientation
       elseif (norient.lt.4) then
        call wrndie(0,whoami,                                           & ! 10.09 (it is easier and more robust to disallow pathogical selections)
     &   ' FEWER THAN FOUR ATOMS SELECTED FOR ORIENTATION.'//           &
     &   ' WILL NOT ORIENT.')
        orient=0
      endif
!
      nmove=count( jslct(1:natom).gt.0 )   ! total number of moving atoms (may be overcounted -- see below)
!
! try to acommodate TSM
##IF TSM
      if (qtsm) then
!       j=bpert(backls)
!       backlist=heap(j:j+natom-1) ! heap must have of integer type (it was when this line was written)
        backlist=backls
      endif
##ENDIF
! check that the number of fixed atoms hasn't changed since initialization; if it has, warn and quit
      ifixed=>sm0k_fixed_atoms()
!     the problem is that ifort sometimes crashes when arrays of unequal length are compared
      qfree=size(ifixed).eq.nfix_bckl
      if (qfree) qfree=all(ifixed.eq.iatom_f)
!
      if (.not.qfree) then
       call wrndie(0,whoami,'FIXED ATOM ARRAY CHANGED AFTER LAST '//    &
     &             'STRING COMMAND.')
       deallocate(iatom_f)
       iatom_f=>ifixed
       nfix_bckl=size(iatom_f)
       nullify(ifixed)
      else
       deallocate(ifixed)
      endif
!
!     allocate space for various arrays atom array
      allocate(iatom_o(norient), iatom_m(nmove),                        &
     &  iatom_free_o(norient), iatom_free_m(nmove),                     & ! these index lists are for use with minimizer arrays (fixed atoms removed)
     &  fixed_o(norient), fixed_m(nmove),                               &           ! these flags indicate that the atom will be absent from minimizer array
     &  rref_o(norient,3),rcurrent_o(norient,3),                        &
     &  rcurrent_m(nmove,3),                                            &
     &  orientWeights(norient), repaWeights(nmove))
!
      iatom_o=0; iatom_m=0; iatom_free_o=0; iatom_free_m=0;
      rref_o=0d0
      rcurrent_o=0d0
      rcurrent_m=0d0
      orientWeights=1d0
      repaWeights=1d0
! build various index arrays
!
      norient=0
      nmove=0
!
      j=-2 ! free atom index; want the valid indices to be 1,4,7,..etc (see below)
      do i=1,natom
       qfree=imove(i).eq.0   ! see egrad1.src routines
       if (qtsm) qfree=qfree.and.backlist(i).eq.0 !##TSM
       if (qfree) j=j+3 ! increment free index -- atom is movable and will be moved by minimization
! orientation indices
       if (islct(i).gt.0) then
        norient=norient+1
        iatom_o(norient)=i
        if (qfree) then
         iatom_free_o(norient)=j
         fixed_o(norient)=.false.
        else
         iatom_free_o(norient)=-999 ! unknown index because the minimization routine will not supply the coordinate
         fixed_o(norient)=.true.  ! this flag will tepp sm0k repa not to use free index
        endif
       endif
! moving indices
       if (jslct(i).gt.0) then
        if (.not.qfree) then ! cannot (well, should not) move fixed atoms: warn but skip entry & continue
         call wrndie(0,whoami,'ATOM '//itoa(i)//                        & ! this is why the moving atom arrays may be overdimensioned
     &   ' IS FIXED OR IN A TSM BACKLIST. SKIPPING.') !##TSM
     &   ' IS FIXED. SKIPPING.')                      !##.not.TSM
        else
         nmove=nmove+1
         iatom_m(nmove)=i
         iatom_free_m(nmove)=j
         fixed_m(nmove)=.false.
        endif
       endif
!
      enddo
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if (nmove.eq.0) then ! this will occur if all of the atoms selected are fixed
        call wrndie(0,whoami,                                           &
     &   ' NO ATOMS SELECTED FOR REPARAMETRIZATION. CANNOT CONTINUE.')
        if (allocated(islct)) deallocate(islct)
        if (allocated(jslct)) deallocate(jslct)
        if (allocated(backlist)) deallocate(backlist)
        return
      endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! done with selections
!!!!!!!!! process mass-weighting
      if (orient_mass.eq.1) then 
       do i=1,norient
        orientWeights(i)=amass(iatom_o(i))*orientWeights(i)        ! these weights are for the Best-Fit routine
!        orientWeights(i)=sqrt(amass(iatom_o(i)))*orientWeights(i)
       enddo
!
       do i=1, nmove
!        repaWeights(i)=sqrt(amass(iatom_m(i)))*repaWeights(i)      ! these weights are essentially for multiplications
        repaWeights(i)=amass(iatom_m(i))*repaWeights(i)
       enddo
      endif
!!!!!!
!     normalize orientWeights;
      orientWeights=orientWeights/sum(orientWeights)
!     unnecessary -- repaWeights are normalized in interpolation routine
      repaWeights=repaWeights/sum(repaWeights)
!
!     print summary
      if (qprint) then
!!!!!! reparametrization summary !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       mlen=len(methods(interp_method))
       call trima(methods(interp_method),mlen)
       if (interp_method.eq.linear_exact) then
        write(outu,666) whoami,methods(interp_method)(1:mlen)
       else
        write(outu,667) whoami,methods(interp_method)(1:mlen),whoami,   &
     &  def
       endif
 666  format(A,' WILL REPARAMETRIZE STRING USING ',A,' INTERPOLATION')
 667  format(A,' WILL REPARAMETRIZE STRING USING ',A,/,                 &
     &A,' INTERPOLATION TO WITHIN MAX(DS)/MIN(DS) < ',F7.3,' TOLERANCE')
       if (iterations.gt.0) write(outu,668) whoami, iterations
 668  format(A,' WITH A MAXIMUM OF ',I3,' ITERATIONS')
       if(interp_method.eq.dst) write(outu,6680) whoami,dst_cutoff*100.0
 6680 format(A,' DST INTERPOLATION WILL USE THE LOWER ',F8.4,           &
     & '% OF WAVENUMBERS')
!
      write(keyword,'(I8)') nmove
      mlen=len(keyword)
      call trima(keyword,mlen)
      write(outu,669) whoami, keyword(1:mlen)
 669  format(A,' INTERPOLATION IS BASED ON ',A,' CARTESIAN COORDINATES')
       if (repa_mass.eq.1) write(outu,672) whoami
 672  format(A,' INTERPOLATION WILL USE MASS-WEIGHTING')
!
!!!!!! orientation summary !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       if (orient.eq.1) then
        write(keyword,'(I8)') norient
        mlen=len(keyword)
        call trima(keyword,mlen)
        write(outu,670) whoami, keyword(1:mlen)
 670  format(A,' STRING WILL BE ORIENTED BASED ON ',A,' ATOMS')
        if (orient_mass.eq.1) write(outu,671) whoami
 671  format(A,' ORIENTATION WILL USE MASS-WEIGHTING')
       endif ! orient
      endif ! qprint
!     initialize arclength array
      if (.not.allocated(ds)) then
       allocate(ds(nstring-1))
       ds=0.0
      endif
!     initialize curvature array
      if (.not.allocated(curv)) then
       allocate(curv(nstring-2))
       curv=0.0
      endif
!
      repa_initialized=.true.
!
!    deallocate temporary variables
      if (allocated(islct)) deallocate(islct)
      if (allocated(jslct)) deallocate(jslct)
      if (allocated(backlist)) deallocate(backlist)
!
      end subroutine sm0k_repa_init
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sm0k_repa(n,var)
!     zero-temperature:reparametrization is based
!     on Cartesian coordinates
!
      use bestfit, only: RMSBestFit
!      use string
      use multicom_ltm       !##MULTICOM
      use parallel 
      use number 
      use dimens_fcm 
      use psf 
      use coord 
      use stream 
      use mpi  ! deal with other platforms later
!
      implicit none
!ccccccccccccccccccccccccccccccccccccccc
      integer :: n ! NOTE: arrays as optional arguments are quite a dangerous feature of F90
      real*8, optional :: var(*) ! ideally, n should give the dimension of n, but we live in an imperfect world
!
      integer :: RTYPE=MPI_REAL8
      integer :: stat(MPI_STATUS_SIZE)
      integer :: ierr
      integer :: me, ncpu
      integer :: i, j
      real*8 :: t
      logical :: qroot, qslave, qmanual
!     aux arrays
      real*8 :: weights(nmove,3) ! for reparametrization
      real*8 :: u(3,3)=RESHAPE( (/1,0,0,0,1,0,0,0,1/), (/3,3/) ) ! rotation matrix
      real*8 :: rcurrent_com(3)=(/0d0,0d0,0d0/) ! COM vector
!
      character*11 :: whoami
!      interface to reparametrization routine
!      needed because of assumed shape array below
!
      interface
        subroutine interp_driver_sci(rin,rout,wgt,n,                    &
     &   interp_method,tol,max_iterations,d_arclength, curvature,       &
     &   dst_cutoff, dr,r_bc_0, r_bc_1)
      use string
!        implicit none
        integer :: n
        real*8 :: rin(n), rout(n), wgt(n)
        integer, intent(in) ::  interp_method
        integer :: max_iterations
        real*8 :: tol, d_arclength(:), curvature(:)
        real*8, optional :: dst_cutoff
        real*8, optional :: dr(n) ,r_bc_0(n), r_bc_1(n)
        end subroutine interp_driver_sci
!
        subroutine interp_driver_sci_root(rin,rout,wgt,n,               &
     &   interp_method,tol,max_iterations,d_arclength, curvature,       &
     &   dst_cutoff, dr,r_bc_0, r_bc_1)
      use string
!        implicit none
        integer :: n
        real*8 :: rin(n), rout(n), wgt(n)
        integer, intent(in) ::  interp_method
        integer :: max_iterations
        real*8 :: tol, d_arclength(:), curvature(:)
        real*8, optional :: dst_cutoff
        real*8, optional :: dr(n) ,r_bc_0(n), r_bc_1(n)
        end subroutine interp_driver_sci_root
!
        subroutine interp_linear_exact(rin,rout,wgt,n,                  &
     &   d_arclength, curvature,                                        &
     &   drout,                                                         &
     &   r_bc_0, r_bc_1)
        integer :: n
        real*8 :: rin(n), rout(n), wgt(n)
        real*8 :: d_arclength(:), curvature(:)
        real*8, optional :: drout(n) ! optional computation of tangent
        real*8 , optional :: r_bc_0(n), r_bc_1(n)   ! optional fixed bc data
       end subroutine interp_linear_exact
!
      end interface
!
      data whoami /' SM0K_REPA>'/
!
      if (.not.sm0k_initialized) call sm0k_init()
      qmanual=(n.eq.0)
!
      qroot =MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.SIZE_STRNG.gt.1
      qslave=MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1
!
! check if the user has made an initialization call
      if (.not.repa_initialized) then
       call wrndie(0, whoami,                                           &
     &    'NO REPARAMETRIZATION OPTIONS SELECTED. NOTHING DONE.')
       return
      endif
!
!      load coordinates
! manual reparametrization: use PSF indices
      if (qmanual) then
! orientation
       do i=1,norient
        j=iatom_o(i)
        rcurrent_o(i,1)=x(j); rcurrent_o(i,2)=y(j); rcurrent_o(i,3)=z(j)
       enddo
! moving
       do i=1,nmove
        j=iatom_m(i)
        if (imove(j).ne.0) call wrndie(0,whoami,                        &
     & 'ATTEMPED TO MOVE A FIXED ATOM. THIS IS MOST LIKELY BAD.')
        rcurrent_m(i,1)=x(j); rcurrent_m(i,2)=y(j); rcurrent_m(i,3)=z(j)
       enddo
      else ! `automatic', i.e. called from a minimization routine
! orientation atoms
       do i=1,norient
        if (fixed_o(i)) then ! grab coordinates from main coordinate array
         j=iatom_o(i)
         rcurrent_o(i,1)=x(j);rcurrent_o(i,2)=y(j);rcurrent_o(i,3)=z(j);
        else ! grab coordinates provided by minimizer
         j=iatom_free_o(i) ! x-index (y- z- indices follow)
         rcurrent_o(i,1)=var(j);j=j+1
         rcurrent_o(i,2)=var(j);j=j+1
         rcurrent_o(i,3)=var(j)
        endif
       enddo
! moving atoms
       do i=1,nmove
! here, we should be able to assume that the moving atom coords are passed in
        j=iatom_free_m(i) ! x-index (y- z- indices follow)
        rcurrent_m(i,1)=var(j);j=j+1
        rcurrent_m(i,2)=var(j);j=j+1
        rcurrent_m(i,3)=var(j)
       enddo
      endif ! qmanual
!
      if (orient.eq.1) then
!       translate to centroid
       rcurrent_com=matmul(transpose(rcurrent_o), orientWeights)
!
       rcurrent_m(:,1)=rcurrent_m(:,1)-rcurrent_com(1)
       rcurrent_m(:,2)=rcurrent_m(:,2)-rcurrent_com(2)
       rcurrent_m(:,3)=rcurrent_m(:,3)-rcurrent_com(3)
!
       rcurrent_o(:,1)=rcurrent_o(:,1)-rcurrent_com(1)
       rcurrent_o(:,2)=rcurrent_o(:,2)-rcurrent_com(2)
       rcurrent_o(:,3)=rcurrent_o(:,3)-rcurrent_com(3)
      endif
!
! statistics: save current structure
      if (stat_initialized) then
        if (output_dsdt.or.output_rmsd_ave) then
! also need to deal with fixed atoms
         do i=1,nstat
          if (qmanual.or.fixed_s(i)) then ! grab coordinates from main coordinate array
           j=iatom_s(i)
           rold_s(i,1)=x(j)
           rold_s(i,2)=y(j)
           rold_s(i,3)=z(j)
          else
           j=iatom_free_s(i) ! x-index (y- z- indices follow)
           rold_s(i,1)=var(j);j=j+1
           rold_s(i,2)=var(j);j=j+1
           rold_s(i,3)=var(j)
          endif
         enddo
!     stat orientation atoms
         if (qstat_orient) then
          rold_o=rcurrent_o ! COM-free
          rold_s(:,1)=rold_s(:,1) - rcurrent_com(1)
          rold_s(:,2)=rold_s(:,2) - rcurrent_com(2)
          rold_s(:,3)=rold_s(:,3) - rcurrent_com(3)
         endif
        endif ! dsdt or rmsd_ave
!     update running average
        if (output_rmsd_ave) then
         t=1.0d0*num_average_samples/(num_average_samples+1)
         if (qstat_orient) then
          if (num_average_samples.gt.0) then
           call RMSBestFit(rold_o, rave_o, orientWeights, u)
           u=transpose(u)
           rold_o=matmul(rold_o, u)
           rold_s=matmul(rold_s, u)
          endif
          rave_o=t*rave_o+(1.0d0-t)*rold_o
         endif ! qstat_orient
         rave_s=t*rave_s+(1.0d0-t)*rold_s
         num_average_samples=num_average_samples+1
        endif
      endif
!
      if (qroot) then
       if (orient.eq.1) then
!ccccccccccc take care of orientation ccccccc
!      send/receive orientation structure
        me=ME_STRNG
        ncpu=SIZE_STRNG
        if (me.gt.0) then
         call mpi_recv(rref_o,3*norient,RTYPE,me-1,1,                   &
     &        MPI_COMM_STRNG, stat,ierr)
!       orient rcurrent based on rref
!       12.09: using RTMD orientation routines
!       no checking for undefined coordinates here
         call RMSBestFit(rcurrent_o,rref_o,orientWeights,u)
!       transform current structure to overlap with reference
!       (if orientation is off, u=I)
         u=transpose(u)
         rcurrent_o=matmul(rcurrent_o, u)
         rcurrent_m=matmul(rcurrent_m, u)
        endif
        if (me.lt.ncpu-1) then
         call mpi_send(rcurrent_o,norient*3,RTYPE,me+1,1,               &
     &        MPI_COMM_STRNG, ierr)
        endif ! me
       endif ! orient
!cccccccccccccc now call the approproate interpolation subroutine
       if (repa_mass.eq.1) then
        weights(:,1)=repaWeights(:)! need 3 sets for  x-,y-,z- coords
        weights(:,2)=repaWeights(:)
        weights(:,3)=repaWeights(:)
       else
        weights=1.0d0
       endif
!
! call by name
! there is the following (compiler?) bug: the routine thinks that dr is present
! even though it is not -- can survive without this but this is disturbing
!       call interp_driver_sci_root(RIN=rcurrent_m,ROUT=rcurrent_m,
       if (interp_method.eq.linear_exact) then
        call interp_linear_exact(RIN=rcurrent_m,ROUT=rcurrent_m,        &
     &  WGT=weights,N=3*nmove, D_ARCLENGTH=ds,CURVATURE=curv)
       else
        call interp_driver_sci(RIN=rcurrent_m,ROUT=rcurrent_m,          &
     &  WGT=weights,N=3*nmove, INTERP_METHOD=interp_method,TOL=def,     &
     &  MAX_ITERATIONS=iterations,D_ARCLENGTH=ds,CURVATURE=curv,        &
     &  DST_CUTOFF=dst_cutoff)
!
! call by argument order
!       call interp_driver_sci(rcurrent_m,rcurrent_m,weights,3*nmove,
!     &  interp_method,def,iterations,ds,curv,dst_cutoff)
!       call interp_driver_sci_root(rcurrent_m,rcurrent_m,weights,
!     &  3*nmove,interp_method,def,iterations,ds,curv,dst_cutoff)
       endif
!
       if (orient.eq.1) then
        u=transpose(u)
        rcurrent_m=matmul(rcurrent_m, u)      ! rotate back
!     restore original COM
        rcurrent_m(:,1)=rcurrent_m(:,1)+rcurrent_com(1)
        rcurrent_m(:,2)=rcurrent_m(:,2)+rcurrent_com(2)
        rcurrent_m(:,3)=rcurrent_m(:,3)+rcurrent_com(3)
!
       endif ! orient
      endif ! root
!
!    broadcast coordinates to slaves
      if (qslave) call PSND8(rcurrent_m,nmove*3)
!     copy back moving atoms
      if (qmanual) then
       do i=1,nmove
        j=iatom_m(i)
        x(j)=rcurrent_m(i,1)
        y(j)=rcurrent_m(i,2)
        z(j)=rcurrent_m(i,3)
       enddo
      else
       do i=1,nmove
        if (fixed_m(i)) cycle ! do not return fixed atoms (should not be used)
        j=iatom_free_m(i) ! x-index (y- z- indices follow)
        var(j)=rcurrent_m(i,1);j=j+1
        var(j)=rcurrent_m(i,2);j=j+1
        var(j)=rcurrent_m(i,3)
       enddo
      endif
!
      end subroutine sm0k_repa
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sm0k_interpolate(comlyn, comlen)
!     given a collection of n string replicas, interpolate onto a finer/coarser path
!     done in serial mode (or on root node)
      use bestfit, only: RMSBestFit
!
      use string
!      implicit none
      use mpi 
!
      use stream 
      use dimens_fcm 
      use psf 
      use number 
      use exfunc 
      use ctitla 
      use multicom_ltm       !##MULTICOM
      use parallel 
      use select, only : selrpn, nselct
      use corsubs, only : rotls1
      use coorio_mod, only : cread, cwrite
!
      CHARACTER*(*) COMLYN
      INTEGER COMLEN
!
!     local declarations only: I do not want persistence, so no saving into modules
      integer, parameter :: linear=1, spline=2, bspline=3
      integer :: ifile, ofile, num_rep_in, num_rep_out
      integer :: len_cv_in, len_cv_out, len_cor_in, len_cor_out,        &
     &           moder, modew, length, mlen, imode, interp_method
      integer :: i,j,k, orient=0, repa_mass=0, orient_mass=0, me
!
      real*8, allocatable :: rin_all(:,:,:), dr(:,:,:), rout_all(:,:,:)
      real*8, allocatable :: rr(:),rr_out(:),ds(:),s(:),t(:),rrpp(:)
      real*8 :: orient_weights(natom), weight(natom)
      real*8 :: dum
!
      character*80 :: name_cor_in, name_cor_out, dummy
      character*20 :: methods(4), method, form
      character*18 :: whoami
      character*8  :: keyword
      character*4  :: ext
!
      logical :: lresid=.false.
      logical :: qprint
!
!     compatibility variables for coordinate reading/writing
      real*8 :: xdum(natom+1), ydum(natom+1), zdum(natom+1),            &
     &          wdum(natom+1)
      integer :: icntrl(20), error
      integer :: islct(natom), ifreea(natom), pairs(2,natom)
!
!
      interface ! to linear interpolation routine
       subroutine linear_interp(xin,yin,nin,xout,yout,nout,dydxout)
      use string
!       implicit none
       integer :: nin, nout
       real*8 :: xin(nin), yin(nin), xout(nout), yout(nout)
       real*8, optional :: dydxout(nout) ! tangent computation
       real*8 :: dydx(nout)
       end subroutine linear_interp
      end interface
!
      data whoami /' SM0K_INTERPOLATE>'/
      data methods/ 'LINEAR','CUBIC SPLINE','B-SPLINE','DST'/
!
      if (.not.sm0k_initialized) call sm0k_init()
!
      qprint=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qprint=qprint.and.(ME_STRNG.eq.0)
! get interpolation specifications
! interpolation type
!
      interp_method=0
      method=gtrma(comlyn, comlen, 'METH')
      length=len(method)
      call trima(method, length)
      if (length.ge.4) then
       if (eqstwc(method(1:4),4,'LINE',4)) then
        interp_method=linear
       elseif (eqstwc(method(1:4),4,'BSPL',4)) then
        interp_method=bspline
       elseif (eqstwc(method(1:4),4,'SPLI',4)) then
        interp_method=spline
       endif
      endif
!     print summary
      if (qprint) then
       if (interp_method.gt.0) then
        length=len(methods(interp_method))
        call trima(methods(interp_method),length)
        write(outu,6770) whoami, methods(interp_method)(1:length)
 6770 format(/A,' WILL INTERPOLATE USING ',A,' INTERPOLATION')
       else
        if (length.gt.0) then
         write(outu,6771) whoami, method(1:length), whoami
 6771 format(/A,' UNRECOGNIZED INTERPOLATION METHOD: ',A,'.',/,         &
     &       A, ' WILL INTERPOLATE USING LINEAR INTERPOLATION')
        else
         write(outu,6772) whoami, whoami
 6772 format(/A,' UNSPECIFIED INTERPOLATION METHOD.',/,                 &
     &       A, ' WILL INTERPOLATE USING LINEAR INTERPOLATION')
        endif ! length
       endif ! interp_method
      endif ! qprint
      if (interp_method.eq.0) interp_method=linear ! choose linear interpolation as default
! process other options ccccccccccccccccccccccccccccccccccccccccccccccc
! number of input replicas
      if (indx(comlyn,comlen,'NIN',3).gt.0) then
       num_rep_in=gtrmi(comlyn, comlen, 'NIN', 0)
       if (num_rep_in.le.0) then
        if (qprint) write(outu, 6781) whoami
 6781 format(A,' NUMBER OF INPUT REPLICAS MUST BE > 0. ',/,             &
     & ' NOTHING DONE.')
        return
       else
         if (qprint) write(outu,6783)                                   &
     &          whoami, num_rep_in
 6783 format(A,' INITIAL STRING RESOLUTION: ', I5, ' REPLICAS.')
       endif ! num_rep_in<=0
      else
        if (qprint) write(outu, 6784) whoami
 6784 format(A,' NUMBER OF INPUT REPLICAS UNSPECIFIED',/,               &
     & A,' NOTHING DONE.')
         return
      endif ! indx('NIN')
! number of output replicas
      if (indx(comlyn,comlen,'NOUT',4).gt.0) then
       num_rep_out=gtrmi(comlyn, comlen, 'NOUT', 0)
       if (num_rep_out.le.0) then
        if (qprint) write(outu, 6782) whoami
 6782 format(A,' NUMBER OF OUTPUT REPLICAS MUST BE > 0. ',/,            &
     & ' NOTHING DONE.')
        return
       else
         if (qprint) write(outu,6785)                                   &
     &          whoami, num_rep_out
 6785 format(A,' INTERPOLATED STRING RESOLUTION: ', I5, ' REPLICAS.')
       endif ! num_rep_in<=0
      else
        if (qprint) write(outu, 6786) whoami
 6786 format(A,' NUMBER OF OUTPUT REPLICAS UNSPECIFIED',/,              &
     & A,' NOTHING DONE.')
         return
      endif ! indx('NIN')
!ccccc
! get input coordinate file info
      call gtrmwa(comlyn, comlen, 'CRIN', 4,                            &
     &          name_cor_in, 80, len_cor_in)
      if (len_cor_in.le.0) then
       if (qprint) write(outu, 6789) whoami
 6789 format(A,' INPUT COORDINATE FILE NAME UNSPECIFIED.',/,            &
     & '  NOTHING DONE.')
       return
      endif
! get output coordinate file info
      call gtrmwa(comlyn, comlen, 'CROUT', 5,                           &
     &          name_cor_out, 80, len_cor_out)
      if (len_cor_out.le.0) then
       if (qprint) write(outu, 6790) whoami
 6790 format(A,' OUTPUT COORDINATE FILE NAME UNSPECIFIED.',/,           &
     & ' NOTHING DONE.')
       return
      endif ! len_cor_out
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!        parse file format spec. (same for both input/output)c
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      lresid=.false.
      if (indxa(comlyn,comlen,'PDB').gt.0) then
        moder=-1
        modew=4
        form='FORMATTED'
        ext='.PDB'
        if (indxa(comlyn,comlen,'RESI').gt.0) lresid=.true.
      elseif ( (indxa(comlyn,comlen,'FILE').gt.0).or.                   &
     &  (indxa(comlyn,comlen,'UNFO').gt.0)) then
        moder=0
        modew=1
        form='UNFORMATTED'
        ext='.COR'
      elseif ( (indxa(comlyn,comlen,'CARD').gt.0).or.                   &
     &  (indxa(comlyn,comlen,'FORM').gt.0)) then
        moder=1
        modew=2
        form='FORMATTED'
        ext='.COR'
      else ! default
        moder=1
        modew=2
        form='FORMATTED'
        ext='.COR'
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!       write summary
      if (qprint) then
!ccccc input cords
       write(dummy,'(I5)') num_rep_in-1
       length=len(dummy)
       call trima(dummy,length)
       write(outu,6791) whoami,                                         &
     &    name_cor_in(1:len_cor_in),0,dummy(1:length),ext
 6791 format(A,' COORDINATE SETS WILL BE READ FROM',/,                  &
     & ' THE FILES ',A,'[',I1,'--',A,']',A)
!ccccc output cords
       write(dummy,'(I5)') num_rep_out-1
       length=len(dummy)
       call trima(dummy,length)
       write(outu,6793) whoami,                                         &
     &    name_cor_out(1:len_cor_out),0,dummy(1:length),ext
 6793 format(A,' COORDINATE SETS WILL BE GENERATED AND SAVED',/,        &
     & ' TO THE FILES ',A,'[',I1,'--',A,']',A)
      endif ! qprint
!cccccccccccccccccccccc parse weighting/orientation options
!     check for orientation options: must appear after 'ORIE'
!     process selection
      i=indxa(comlyn,comlen,'ORIE')
      if (i.gt.0) then ! only if the ORIE directive exists
!      selection text taken from corman.src
       orient=1
       j=indx(comlyn, comlen, 'SELE', 4)
       if (j.gt.0.and.j.lt.i) then ! sele occurs before orie
        call wrndie(0,whoami,                                           &
     &    'ATOM SELECTION MUST BE SPECIFIED AFTER ORIE.')
         return
       endif
       IMODE=0
!
       CALL SELRPN(COMLYN,COMLEN,ISLCT,NATOM,1,IMODE,                   &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,xdum,ydum,zdum,.TRUE.,1,wdum)
       IF(IMODE.NE.0) THEN
        CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
        RETURN
       ENDIF
      endif ! orie specified
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     check for mass weighting
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      j=1
      do while (j.gt.0)
       mlen=comlen
       j=indxa(comlyn,comlen,'MASS') ! s
       if ( (orient.eq.1).and.(j.ge.i) ) then
        orient_mass=1
       else if (j.gt.0) then
        repa_mass=1
        i=i-(mlen-comlen) ! how much the string has shrunk
       endif
      enddo
!
      orient_weights=                                                   &
     & (amass(1:natom)*orient_mass+(1.0-orient_mass))*islct
!
!     print summary
      if (qprint) then
       if (repa_mass.eq.1) write(outu,6720) whoami
 6720 format(A,' INTERPOLATION WILL USE MASS-WEIGHTING')
!
       if (orient.eq.1) then
        write(keyword,'(I8)') count(islct.gt.0)
        mlen=len(keyword)
        call trima(keyword,mlen)
        write(outu,6700) whoami, keyword(1:mlen)
 6700 format(A,' STRING WILL BE ORIENTED BASED ON ',A,' ATOMS')
        if (orient_mass.eq.1) write(outu,6710) whoami
 6710 format(A,' ORIENTATION WILL USE MASS-WEIGHTING')
       endif
      endif ! qprint
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccc do work cccccccccccccccccccccccccccc
      if (qprint) write(outu,6974) whoami
 6974 format(A,' READING COORDINATES FILES')
!     allocate memory for ALL replicas (may not be the best solution if
!     the structure is very large; however, with 0K string, you will want
!     to exclude water

!   coordinate arrays input & output
      if (allocated(rin_all)) deallocate(rin_all)
      allocate(rin_all(natom,3,num_rep_in))
      rin_all=anum ! initialize
!
      if (allocated(rout_all)) deallocate(rout_all)
      allocate(rout_all(natom,3,num_rep_out))
      rout_all=anum
!
      ifile=-1 ! open_file will assign a valut unit #
      islct=1. ! for compatibility
      do j=1, num_rep_in
!     create file name
        write(dummy,'(I5)') j-1
        length=len(dummy)
        call trima(dummy,length)
        dummy=name_cor_in(1:len_cor_in)//dummy(1:length)//ext ! concatenate basename, index, extension
        length=len(dummy)
        call trima(dummy,length)
!
        call open_file(ifile,dummy,form,'READ')
        dummy=''
        call cread(ifile, titleb, ntitlb, icntrl,                       &
     &        rin_all(1,1,j), rin_all(1,2,j), rin_all(1,3,j),           &
     &        wdum, natom, moder, islct,              &
     &        0, res, nres, atype, ibase, 1, ifreea,               &
     &        segid, resid, nictot, nseg, lresid, .false.,              &
     &        dummy, 80, 0, .false.)
      enddo
      call vclose(ifile,'KEEP',error)
!
!     check for undefined coordinates
      if (any(rin_all.eq.anum)) call wrndie(0,whoami,                   &
     &  'WARNING: SOME INPUT COORDINATES ARE UNDEFINED AFTER READING.')
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     orient structures if requested

      if (qprint) then
        if (orient.eq.1) then
!   set up pairs
         pairs = RESHAPE( (/ (i, i=1,natom),                            &
     &   (i, i=1,natom) /), (/ 2,natom /), order=(/ 2,1 /) )
!       orient x based on the previous replica
         do j=2,num_rep_in
          call rotls1(                                                  &
     &     rin_all(1,1,j-1), rin_all(1,2,j-1), rin_all(1,3,j-1),        &
     &     rin_all(1,1,j), rin_all(1,2,j), rin_all(1,3,j),              &
     &     natom,pairs,natom,                                           &
     &     orient_weights,                                              &
     &     .false.,.false.)
         enddo ! j
        endif ! orient
!
        if (repa_mass.eq.1) then
         weight=amass(1:natom)
        else
         weight=1.0
        endif
!
!     do the actual interpolation --  simple, not self-consistent
!      allocate memory
        if (allocated(dr)) deallocate(dr)
        allocate(dr(natom,3,num_rep_in-1))
        if (allocated(ds)) deallocate(ds)
        allocate(ds(num_rep_in-1))
        if (allocated(s)) deallocate(s)
        allocate(s(num_rep_in))
        if (allocated(t)) deallocate(t)
        allocate(t(num_rep_out))
        if (allocated(rr)) deallocate(rr)
        allocate(rr(num_rep_in))
        if (allocated(rr_out)) deallocate(rr_out)
        allocate(rr_out(num_rep_out))
        if (allocated(rrpp)) deallocate(rrpp)
        allocate(rrpp(num_rep_in))
!
!     compute arclength
        dr=rin_all(:,:,2:num_rep_in)-rin_all(:,:,1:num_rep_in-1)
        s(1)=0
        do i=1,num_rep_in-1
         ds(i)=sqrt(sum(matmul( (transpose(dr(:,:,i)))**2, weight**2)))
         s(i+1)=s(i)+ds(i)
        enddo
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     normalize arclength
        do i=1,num_rep_in
         s(i)=s(i)/s(num_rep_in)
        enddo
!ccccccccccccccccccccccccc
!     create uniform array
        do i=1,num_rep_out
         t(i)=1.0d0*(i-1)/(num_rep_out-1)
        enddo
!cccccccccccccc now interpolate variables cccccc
        if (interp_method.eq.spline) then
         do i=1,natom
          do j=1,3
           rr=rin_all(i,j,:)
           call spline_cubic_set(num_rep_in,s,rr,0,0,0,0,rrpp)
           do k=1,num_rep_out
            call spline_cubic_val(num_rep_in,s,rr,rrpp,t(k),            &
     &                          rout_all(i,j,k),dum,dum)
           enddo
          enddo
         enddo
        elseif (interp_method.eq.bspline) then
         do i=1,natom
          do j=1,3
           rr=rin_all(i,j,:)
           do k=1,num_rep_out
            call spline_b_val(num_rep_in,s,rr,t(k),rout_all(i,j,k))
           enddo
          enddo
         enddo
        elseif (interp_method.eq.linear) then
         do i=1,natom
          do j=1,3
           rr=rin_all(i,j,:)
           call linear_interp(s,rr,num_rep_in,t,rr_out,num_rep_out)
           rout_all(i,j,:)=rr_out
          enddo
         enddo
        endif ! interp_method
!       check for undefined coordinates
        if (any(rout_all.eq.anum)) call wrndie(0,whoami,                &
     & 'WARNING: SOME COORDINATES ARE UNDEFINED AFTER INTERPOLATION.')
!
!cccccccccccc write file cccccccccccccccccccccccc
!
        wdum=1. ! reset weighting array (can modify this if needed)
        ofile=-1 ! open_file will assign a valut unit #
        do j=1,num_rep_out
!     create file name
         write(dummy,'(I5)') j-1
         length=len(dummy)
         call trima(dummy,length)
         dummy=name_cor_out(1:len_cor_out)//dummy(1:length)//ext ! concatenate basename, index, extension
         length=len(dummy)
         call trima(dummy,length)
!
         call open_file(ofile,dummy,form,'WRITE')
!            write(6,*) ofile, iolev
         if (ntitla+1 .lt. maxtit)                                      &
     &      write(titlea(ntitla+1),'(A,I5,A,I5)')                       &
     &      '* REPLICA ',j,' OF ',num_rep_out
!
         call CWRITE(ofile,TITLEA,min(NTITLA+1,maxtit),icntrl,          &
     &              rout_all(1,1,j), rout_all(1,2,j), rout_all(1,3,j),  &
     &               wdum,res,atype,ibase,                               &
     &               NRES,NATOM,islct,modew,0,0,.false.)
        enddo ! loop over new coordinates
        call vclose(ofile,'KEEP',error)
!
        deallocate(rr, rr_out, dr, s, t, ds, rrpp)
      endif ! qprint
!
      deallocate(rin_all, rout_all)
!
      end subroutine sm0k_interpolate
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sm0k_stat_init(comlyn, comlen)
!
      use string
!      implicit none
      use exfunc 
      use dimens_fcm 
      use stream 
      use psf 
      use coordc 
      use coord 
!
      use energym 
      use multicom_ltm       !##MULTICOM
      use parallel 
      use select, only : selrpn, nselct
##IF TSM
      use tsmh  ! TSM common blocks included because minimizer DOF depend on TSM
      use tsms_mod, only:qtsm
!      use heap 
##ENDIF
      use mpi                               !##MPI
!ccccccccccccccccccccccccccccccccccccccccccccccccc
      CHARACTER*(*) COMLYN
      INTEGER COMLEN
!
      character*80 rform, dform, sform, fcform, cform
      integer :: klen=0, error, i, j
      integer, allocatable :: islct(:)
      logical :: found
      logical :: qprint, qfree
      integer, allocatable :: backlist(:) ! for nominal compatibility with TSM
      integer, pointer :: ifixed(:)
!
      integer :: imode
      integer, parameter :: errTol=1.0e-9
      real*8 :: d, com(3)
!
      character*8 keyword
      character*16 whoami
      data whoami/' SM0K_STAT_INIT>'/
!
!      interface
!       function sm0k_fixed_atoms()
!       integer, pointer :: sm0k_fixed_atoms(:)
!       end function sm0k_fixed_atoms
!      end interface
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (.not.sm0k_initialized) call sm0k_init()
!
      qprint=(ME_STRNG.eq.0).and.(MPI_COMM_STRNG.ne.MPI_COMM_NULL)
!     begin
!     reset iteration counter
!     did the user specify it?
      stat_iteration_counter=gtrmi(comlyn, comlen, 'COUN', -1)
      stat_iteration_counter=max(stat_iteration_counter,0)
      if (stat_iteration_counter.gt.0) then
       if (qprint) write(outu,639) whoami, stat_iteration_counter
 639  format(A,' SETTING ITERATION COUNTER TO ',I7)
      endif
!
      energy_fname=''
      output_energy=.false.

      if (rmsd0_funit.ge.0) call VCLOSE(rmsd0_funit,'KEEP',error)
      rmsd0_fname=''
      output_rmsd0=.false.

      if (dsdt_funit.ge.0) call VCLOSE(dsdt_funit,'KEEP',error)
      dsdt_fname=''
      output_dsdt=.false.
!
      if (c_funit.ge.0) call VCLOSE(c_funit,'KEEP',error)
      c_fname=''
      output_curvature=.false.
!
      if (s_funit.ge.0) call VCLOSE(s_funit,'KEEP',error)
      s_fname=''
      output_arclength=.false.
!
!    memory allocation
      if (allocated(fixed_s)) deallocate(fixed_s) ! flags
      if (allocated(iatom_s)) deallocate(iatom_s)
      if (allocated(iatom_free_s)) deallocate(iatom_free_s)
      if (allocated(rold_s)) deallocate(rold_s)
      if (allocated(rave_s)) deallocate(rave_s)
      if (allocated(rcurrent_s)) deallocate(rcurrent_s)
      if (allocated(rcomp_s)) deallocate(rcomp_s)
      if (allocated(statWeights)) deallocate(statWeights)
      if (allocated(rcomp_o)) deallocate(rcomp_o)
      if (allocated(rold_o)) deallocate(rold_o)
      if (allocated(rave_o)) deallocate(rave_o)
      nstat=0
      qstat_orient=.false.
! first check that the number of fixed atoms hasn't changed since initialization; if it has, warn and quit
      ifixed=>sm0k_fixed_atoms()
      qfree=size(ifixed).eq.nfix_bckl
      if (qfree) qfree=all(ifixed.eq.iatom_f)
      if (.not.qfree) then
       call wrndie(0,whoami,'FIXED ATOM ARRAY CHANGED AFTER LAST '//    &
     &             'STRING COMMAND.')
       deallocate(iatom_f)
       iatom_f=>ifixed
       nfix_bckl=size(iatom_f)
       nullify(ifixed)
      else
       deallocate(ifixed)
      endif
!
!cccccccccc first process energy terms (ZTS ONLY) ccccccccccccc
      keyword=nexta4(comlyn,comlen)
      if (eqstwc(keyword(1:4),4,'ENER',4)) then
        output_energy=.true.
!       get nergy file name
        CALL GTRMWD(COMLYN,COMLEN,'ENAM',4,energy_fname,80,energy_flen)

!       get energy file name
!       now parse until the 'end' keyword
        keyword=nexta4(comlyn,comlen)
        klen=len(keyword)
        call trima(keyword,klen)
        do while (keyword(1:3).ne.'END'.and.klen.gt.0)
!     assume that it is a energy parameter; locate it in the property/term arrays:
!
         found=.false.
! 1) search properties
         i=0
         do while (.not.found.and.i.lt.lenenp)
          i=i+1
          if ( (keyword(1:klen).EQ.ceprop(i)) ) then
           found=.true.
          endif
         enddo
!
         if (.not.found) then
! 2) search energy terms
          i=0
          do while (.not.found.and.i.lt.lenent)
           i=i+1
           if ( (keyword(1:klen).EQ.ceterm(i)) ) then
            found=.true.
           endif
          enddo
          i=-i ! this is a 'trick' to keep distinguish between indices into eprop and eterm
         endif
!
         if (.not.found) then ! if still not found, warn
           call wrndie(0,whoami,                                        &
     &      'ENERGY VALUE '//KEYWORD(1:KLEN)//' NOT FOUND')
         else
          num_energy_terms=num_energy_terms+1
          if (num_energy_terms.gt.enmax) then
           call wrndie(0,whoami,                                        &
     &      'NUMBER OF REQUESTED ENERGY TERMS TOO LARGE. ABORTING.')
           return
          else
           energy_indices(num_energy_terms)=i
           energy_names(num_energy_terms)=keyword(1:klen)
          endif
         endif
!        read the next keyword
         keyword=nexta4(comlyn,comlen)
         klen=len(keyword)
         call trima(keyword,klen)
        enddo ! lop over all keywords
!ccccccccccc print summary
        if (qprint) then
         if (energy_flen.gt.0) then
          write(outu,662 ) whoami,whoami,energy_fname(1:energy_flen)
         else
          write(outu,663 ) whoami
         endif
         write(outu,664) whoami,(energy_names(i),i=1,num_energy_terms)
        endif
 662  format(A,' WILL WRITE STRING ENERGY TO FILES ',/A,' ',A,'[I].DAT,'&
     &, ' AT EACH ITERATION INDEX I.')
 663  format(A,' WILL WRITE STRING ENERGY TO STDOUT.')
 664  format(A,' THE FOLLOWING KEYWORDS',                               &
     & ' WILL BE USED:',100(' ',A5),/)
!
      endif ! energy terms
!
!cccccccccccccccccccccc deal with RMSD comparison options cccccccccccccccccccccccccccccccc
!      is there an atom selection ?
      allocate(islct(natom), backlist(natom))
      islct=1     ! select all atoms by default
      backlist=0  ! setting this to zero is the simplest way to provide correct default behavior (see below)
!ccccccccccccccccc first process the RMSD-related commands
      j=indx(comlyn, comlen, 'SELE', 4)
      if (j.gt.0) then
       imode=0
       CALL SELRPN(COMLYN,COMLEN,islct,NATOM,1,IMODE,                   &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN) !
       IF(IMODE.NE.0) THEN
        CALL WRNDIE(0,whoami,'ATOM SELECTION ERROR')
        RETURN
       ENDIF
      else
       islct=1
      endif
      nstat=count( islct(1:natom).gt.0 )
!*************************************************************************
      if (nstat.eq.0) then
        call wrndie(0,whoami,                                           &
     &' NO ATOMS SELECTED FOR RMSD COMPUTATION. WILL NOT COMPUTE RMSD.')
        output_rmsd0=.false.
        output_dsdt=.false.
        output_rmsd_ave=.false.
      else
!    determine whether structures are to be oriented before comparison
       qstat_orient=(indxa(comlyn,comlen,'ORIE').gt.0)
       if (qstat_orient) then
        if (repa_initialized.and.norient.gt.0) then
         if (qprint) write(outu,638) whoami
 638  format(A,' RMSD CALCULATIONS WILL INCLUDE ORIENTATION.')
        else
         call wrndie(0, whoami,                                         &
     &   'REPARAMETRIZATION DISABLED OR NO ORIENTATION ATOMS FOUND.'//  &
     &   ' WILL NOT ORIENT.')
         qstat_orient=.false.
        endif ! repa_initialized
       endif ! qstat_orient
!
!!!!!!!!!!!!!! RMSD from static structure in comp
       if (indxa(comlyn,comlen,'RMSD').gt.0) then ! request for RMSD
        output_rmsd0=.true.
!
        if (.not.allocated(rcurrent_s)) allocate(rcurrent_s(nstat,3))
        if (.not.allocated(rcomp_s))    allocate(rcomp_s(nstat,3))
        if (qstat_orient) then
         if (.not.allocated(rcomp_o))   allocate(rcomp_o(norient,3))
        endif ! qstat_orient
!
        CALL GTRMWA(COMLYN,COMLEN,'RNAM',4,rmsd0_fname,80,rmsd0_flen)
        if (rmsd0_flen.eq.0) then
         call wrndie(0,whoami,                                          &
     &   'NO RMSD FILE NAME SPECIFIED. WILL WRITE TO STDOUT.')
         rmsd0_funit=outu
        else
         if (indxa(comlyn,comlen,'RAPP').gt.0) then ! APPEND?
           rform='APPEND'
         else
           rform='WRITE'
         endif
         if (qprint) then
          rmsd0_funit=-1
          call open_file(rmsd0_funit, rmsd0_fname,                      &
     &      'FORMATTED',rform)
         endif
        endif
!ccccccccccc print summary
        if (qprint) then
         if (rmsd0_flen.gt.0) then
          write(outu,660 ) whoami,rmsd0_fname(1:rmsd0_flen)
         else
          write(outu,661 ) whoami
         endif
        endif
 660  format(A,' WILL WRITE STRING RMSD TO FILE ',A)
 661  format(A,' WILL WRITE STRING RMSD TO STDOUT.')
!
       endif ! RMSD
!!!!!!!!!!!!!! RMSD from structure at the previous step (zts/fts)
       if (indxa(comlyn,comlen,'DELS').gt.0) then
        output_dsdt=.true.
!
        if (.not.allocated(rold_s))     allocate(rold_s(nstat,3)) ! for storing "old" coords
        if (.not.allocated(rcurrent_s)) allocate(rcurrent_s(nstat,3))
        if (qstat_orient) then
         if (.not.allocated(rold_o))    allocate(rold_o(norient,3))
        endif
!
        CALL GTRMWA(COMLYN,COMLEN,'DNAM',4,dsdt_fname,80,dsdt_flen)
        if (dsdt_flen.eq.0) then
         call wrndie(0,whoami,                                          &
     &   'NO DELS FILE NAME SPECIFIED. WILL WRITE TO STDOUT.')
         dsdt_funit=outu
        else
         if (indxa(comlyn,comlen,'DAPP').gt.0) then ! APPEND?
           dform='APPEND'
         else
           dform='WRITE'
         endif
         if (qprint) then
          dsdt_funit=-1
          call open_file(dsdt_funit, dsdt_fname,                        &
     &      'FORMATTED',dform)
         endif
        endif
!ccccccccccc print summary
        if (qprint) then
         if (dsdt_flen.gt.0) then
          write(outu,650 ) whoami,dsdt_fname(1:dsdt_flen)
         else
          write(outu,651 ) whoami
         endif
        endif
 650  format(A,' WILL WRITE STRING RMSD(I,I+1) TO FILE ',A)
 651  format(A,' WILL WRITE STRING RMSD(I,I+1) TO STDOUT.')
!
       endif ! rmsd0
!!!!!!!!!!!!!! RMSD from average structure (zts/fts)
       if (indxa(comlyn,comlen,'RMSA').gt.0) then
        output_rmsd_ave=.true.
!
        if (.not.allocated(rave_s)) allocate(rave_s(nstat,3)) ! for storing average coords
        if (.not.allocated(rold_s)) allocate(rold_s(nstat,3)) ! for storing "old" coords
        rave_s=0d0
        if (.not.allocated(rcurrent_s)) allocate(rcurrent_s(nstat,3))
        if (qstat_orient) then
         if (.not.allocated(rold_o))    allocate(rold_o(norient,3))
         if (.not.allocated(rave_o))    allocate(rave_o(norient,3))
         rave_o=0d0
        endif
!
        CALL GTRMWA(COMLYN,COMLEN,'RANM',4,rmsd_ave_fname,80,           &
     &                  rmsd_ave_flen)
        if (rmsd_ave_flen.eq.0) then
         call wrndie(0,whoami,                                          &
     &   'NO RMSA FILE NAME SPECIFIED. WILL WRITE TO STDOUT.')
         rmsd_ave_funit=outu
        else
         if (indxa(comlyn,comlen,'RAAP').gt.0) then ! APPEND?
           rform='APPEND'
         else
           rform='WRITE'
         endif
         if (qprint) then
          rmsd_ave_funit=-1
          call open_file(rmsd_ave_funit, rmsd_ave_fname,                &
     &      'FORMATTED',rform)
         endif
        endif
!ccccccccccc print summary
        if (qprint) then
         if (rmsd_ave_flen.gt.0) then
          write(outu,6500 ) whoami,rmsd_ave_fname(1:rmsd_ave_flen)
         else
          write(outu,6510 ) whoami
         endif
        endif
 6500 format(A,' WILL WRITE STRING RMSD FROM AVERAGE STRUC. TO FILE ',A)
 6510 format(A,' WILL WRITE STRING RMSD FROM AVERAGE STRUC. TO STDOUT.')
       endif ! rmsd_ave
!
       if (output_rmsd_ave.or.output_rmsd0.or.output_dsdt) then
!       populate iatom array
        if (.not.allocated(fixed_s)) allocate(fixed_s(nstat)) ! psf indices
        if (.not.allocated(iatom_s)) allocate(iatom_s(nstat)) ! psf indices
        if (.not.allocated(iatom_free_s)) allocate(iatom_free_s(nstat)) ! free indices for atoms with minimizer
        nstat=0
        iatom_s=0; iatom_free_s=0;
!
##IF TSM
        if (qtsm) then
!         j=bpert(backls)
!         backlist=heap(j:j+natom-1) ! heap must have of integer type (it was when this line was written)
          backlist=backls
        endif
##ENDIF
!
        j=-2 ! free atom index
        do i=1,natom
         qfree=imove(i).eq.0   ! see egrad1.src routines
         if (qtsm) qfree=qfree.and.backlist(i).eq.0 !##TSM
         if (qfree) j=j+3 ! indices increase in increments of 3: 1,4,...
! orientation indices
         if (islct(i).gt.0) then
          nstat=nstat+1
          iatom_s(nstat)=i
          if (qfree) then
           iatom_free_s(nstat)=j
           fixed_s(nstat)=.false.
          else
           iatom_free_s(nstat)=-999 ! unknown index because the minimization routine will not supply the coordinate
           fixed_s(nstat)=.true.  ! this flag will tepp sm0k stat not to use free index
          endif
         endif
        enddo ! all atoms
!
        if (output_rmsd0) then
         do i=1, nstat
           j=iatom_s(i)
           rcomp_s(i,1)=xcomp(j);
           rcomp_s(i,2)=ycomp(j);
           rcomp_s(i,3)=zcomp(j);
         enddo
!    orientation atoms
         if (qstat_orient) then
          do i=1, norient
           j=iatom_o(i)
           rcomp_o(i,1)=xcomp(j);
           rcomp_o(i,2)=ycomp(j);
           rcomp_o(i,3)=zcomp(j);
          enddo
!    subtract COM
          com=matmul(transpose(rcomp_o), orientWeights)
          rcomp_o(:,1)=rcomp_o(:,1)-com(1)
          rcomp_o(:,2)=rcomp_o(:,2)-com(2)
          rcomp_o(:,3)=rcomp_o(:,3)-com(3)
!
          rcomp_s(:,1)=rcomp_s(:,1)-com(1)
          rcomp_s(:,2)=rcomp_s(:,2)-com(2)
          rcomp_s(:,3)=rcomp_s(:,3)-com(3)
!
         endif ! qstat_orient
        endif
!
        if (.not.(allocated(statWeights))) allocate(statWeights(nstat))
        statWeights=1d0
!
!     use mass-weighting in RMSD computation?
!
        stat_rmsd_mass=(indxa(comlyn,comlen,'MASS').gt.0)
        if (stat_rmsd_mass) then
         if (qprint) write(outu,640) whoami
         do i=1,nstat
          statWeights(i)=amass(iatom_s(i))*statWeights(i)
         enddo
        endif ! stat_rmsd_mass
!
        d=sum(statWeights)
        if (abs(d).gt.errTol) then
         d=1d0/d
         statWeights=d*statWeights
        endif
!
 640  format(A, ' WILL USE MASS WEIGHTING IN RMSD CALCULATIONS.')
       endif ! output_ ...
      endif ! nstat .eq. 0
!
!!!!!!!!!!!!!! ARCLENGTH
      if (indxa(comlyn,comlen,'ARCL').gt.0) then
        output_arclength=.true.
        CALL GTRMWA(COMLYN,COMLEN,'ANAM',4,s_fname,80,s_flen)
        if (s_flen.eq.0) then
         call wrndie(0,whoami,                                          &
     &   'STRING LENGTH FILE NAME NOT SPECIFIED. WILL WRITE TO STDOUT.')
         s_funit=outu
        else
         if (indxa(comlyn,comlen,'AAPP').gt.0) then ! APPEND?
           sform='APPEND'
         else
           sform='WRITE'
         endif
         if (qprint) then
          s_funit=-1
          call open_file(s_funit, s_fname,                              &
     &      'FORMATTED',sform)
         endif
        endif
!ccccccccccc print summary
        if (qprint) then
         if (s_flen.gt.0) then
          write(outu,652) whoami,s_fname(1:s_flen)
         else
          write(outu,653) whoami
         endif
        endif
 652  format(A,' WILL WRITE STRING LENGTH TO FILE ',A)
 653  format(A,' WILL WRITE STRING LENGTH TO STDOUT.')
!
      endif ! ARCLENGTH
!!!!!!!!!!!!!! CURVATURE
      if (indxa(comlyn,comlen,'CURV').gt.0) then
        output_curvature=.true.
        CALL GTRMWA(COMLYN,COMLEN,'CVNM',4,c_fname,80,c_flen)
        if (c_flen.eq.0) then
         call wrndie(0,whoami,                                          &
     &   'CURVATURE FILE NAME NOT SPECIFIED. WILL WRITE TO STDOUT.')
         c_funit=outu
        else
         if (indxa(comlyn,comlen,'CAPP').gt.0) then ! APPEND?
           cform='APPEND'
         else
           cform='WRITE'
         endif
         if (qprint) then
          c_funit=-1
          call open_file(c_funit, c_fname,                              &
     &      'FORMATTED',cform)
         endif
        endif
!ccccccccccc print summary
        if (qprint) then
         if (c_flen.gt.0) then
          write(outu,6521) whoami,c_fname(1:c_flen)
         else
          write(outu,6531) whoami
         endif
        endif
 6521 format(A,' WILL WRITE CURVATURE TO FILE ',A)
 6531 format(A,' WILL WRITE CURVATURE TO STDOUT.')
!
      endif ! CURVATURE
!      if we got this far, we are probably OK
      stat_initialized=.true.
!
      end subroutine sm0k_stat_init
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sm0k_stat(n,var)
      use bestfit, only : RMSBestFit, rmsd
      use string
!      implicit none
      use exfunc 
      use dimens_fcm 
      use stream 
      use coordc 
      use coord 
      use psf 
!
      use energym 
      use eutil, only : gete
      use multicom_ltm       !##MULTICOM
      use parallel 
      use number 

      use mpi 
!
      integer :: n
      real*8, optional :: var(*)
!    locals
      character*8 :: keyword
      real*8 :: u(3,3), com(3)
!
      integer :: klen, i, j, k, ifile
!
!     for  output
      real*8 :: energy_values(enmax,SIZE_STRNG)! store data from all procs
      real*8 :: energy_values_me(enmax)
      integer :: me, error, fmt_len, fmt_e_len
      character*80 :: fmt, fmt_ene
      character*8 :: dummy
      real*8 :: energy_val
      logical :: found
      logical :: qprint, qroot, qmanual
      real*8 :: rmsd0, rmsd0_all(SIZE_STRNG), dsdt, dsdt_all(SIZE_STRNG)
!
      character*11 :: whoami
      data whoami/' SM0K_STAT>'/
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qprint=qroot.and.ME_STRNG.eq.0
      qmanual=(n.eq.0)
!cccccccccccccccccccccc begin ccccccccccccccccccccccccccccc
! check if the user has made an initialization call
      if (.not.sm0k_initialized) call sm0k_init()
!
      if (.not.stat_initialized) then
       call wrndie(0,whoami,                                            &
     &   'NO OUTPUT OPTIONS SELECTED. NOTHING DONE')
       return
      endif
!
      stat_iteration_counter=stat_iteration_counter+1
!     define number format string for output
!
      if (qroot) then
       write(fmt,*) SIZE_STRNG
       fmt_len=len(fmt)
       call trima(fmt,fmt_len)
!
       write(fmt_ene,*) num_energy_terms
       fmt_e_len=len(fmt_ene)
       call trima(fmt_ene,fmt_e_len)
      endif
      me=mestring
!
      if (output_energy) then
!      call energy
!      NOTE: this routine needs to be called after "update"
       if (qmanual) call gete(x,y,z,x,y,z,0) ! is everything calculated in this routine?
!      otherwise, the minimizer has already called energy routines (off by one iteration, but this should be insignificant)
       if (qroot) then
        if (energy_flen.eq.0) then
         call wrndie(0,whoami,                                          &
     &   'NO ENERGY FILE NAME SPECIFIED. WILL WRITE TO STDOUT.')
         ifile=outu
        else
         if (qprint) then
          write(dummy,'(I8)') stat_iteration_counter
          k=len(dummy)
          call trima(dummy, k)
          ifile=-1
          call open_file(ifile,                                         &
     & energy_fname(1:energy_flen)//dummy(1:k)//'.dat',                 &
     &      'FORMATTED','WRITE')
         endif
        endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     assume file is open
!     loop over energy terms
        do i=1, num_energy_terms
          j=energy_indices(i)
          if (j.gt.0) then
           energy_values_me(i)=eprop(j)
          elseif (j.lt.0) then
           energy_values_me(i)=eterm(-j)
          endif
        enddo
!ccccccccccccccccc
!      gather data and write file
!        call mpi_gather(energy_values(1,me+1),enmax,MPI_DOUBLE_PRECISION
!     &                ,energy_values,enmax,MPI_DOUBLE_PRECISION,0,
!     &                 MPI_COMM_STRNG, error)
! some compilers require mpi_in_place when the input and output buffere are the same
! mpi_in_place, however, behaves strangely on some systems, so I am using
! the additional array `energy_values_me'
        call mpi_gather(energy_values_me,enmax,MPI_DOUBLE_PRECISION     &
     &                 ,energy_values,enmax,MPI_DOUBLE_PRECISION,0,     &
     &                 MPI_COMM_STRNG, error)
!
        if (qprint) then
         if (ifile.ne.outu) then
          write(ifile,'("%",'//fmt_ene(1:fmt_e_len)//'(A19))')          &
     &         (energy_names(i),i=1,num_energy_terms)
          do j=1,SIZE_STRNG
           write(ifile,'(I5," ",'//fmt_ene(1:fmt_e_len)//'F20.10)')     &
     &           j,(energy_values(i,j),i=1,num_energy_terms)
          enddo
          call VCLOSE(ifile,'KEEP',error)
         else
      write(ifile,'("ENERGY> ",'//fmt_ene(1:fmt_e_len)//'(," ",A19))')  &
     &         (energy_names(i),i=1,num_energy_terms)
          do j=1,SIZE_STRNG
          write(ifile,'("ENERGY> ",I5," ",'//                           &
     &           fmt_ene(1:fmt_e_len)//'F20.10)')                       &
     &           j,(energy_values(i,j),i=1,num_energy_terms)
          enddo
         endif ! ifile
        endif ! qprint
! 6650 format('ENERGY> ',100(' ',A19))
! 6660 format('ENERGY> ',I5,' ',100F20.10)
! 665  format('%',100(A19))
! 666  format(I5,' ',100F20.10)
!
       endif ! qroot
      endif ! output energy
!
      if (output_rmsd0.or.output_rmsd_ave.or.output_dsdt) then
       do i=1, nstat
         if (qmanual.or.fixed_s(i)) then
          j=iatom_s(i)
          rcurrent_s(i,1)=x(j);rcurrent_s(i,2)=y(j);rcurrent_s(i,3)=z(j)
         else
          j=iatom_free_s(i);
          rcurrent_s(i,1)=var(j);j=j+1
          rcurrent_s(i,2)=var(j);j=j+1
          rcurrent_s(i,3)=var(j)
         endif
       enddo ! nstat
! orientation atoms
       if (qstat_orient) then
        do i=1,norient
          if (qmanual.or.fixed_o(i)) then ! grab coordinates from main coordinate array
           j=iatom_o(i)
           rcurrent_o(i,1)=x(j)
           rcurrent_o(i,2)=y(j)
           rcurrent_o(i,3)=z(j)
          else ! grab coordinates provided by minimizer
           j=iatom_free_o(i) ! x-index (y- z- indices follow)
           rcurrent_o(i,1)=var(j);j=j+1
           rcurrent_o(i,2)=var(j);j=j+1
           rcurrent_o(i,3)=var(j)
          endif
        enddo ! norient
        com=matmul(transpose(rcurrent_o), orientWeights)
        rcurrent_o(:,1)=rcurrent_o(:,1)-com(1)
        rcurrent_o(:,2)=rcurrent_o(:,2)-com(2)
        rcurrent_o(:,3)=rcurrent_o(:,3)-com(3)
        rcurrent_s(:,1)=rcurrent_s(:,1)-com(1)
        rcurrent_s(:,2)=rcurrent_s(:,2)-com(2)
        rcurrent_s(:,3)=rcurrent_s(:,3)-com(3)
       endif ! qstat_orient
      endif ! output rmsd
!
!ccccccccccccccccccccccccccccccccccccc
      if (output_rmsd0) then
        if (qroot) then
!       reference structure is in the comparison set
         if (qstat_orient) then
           call RMSBestFit(rcurrent_o,rcomp_o,orientWeights,u)
!       transform current structure to overlap with reference
!       (if orientation is off, u=I)
           u=transpose(u)
           rcurrent_o=matmul(rcurrent_o, u) ! need to rotate both (see below)
           rcurrent_s=matmul(rcurrent_s, u)
         endif
         rmsd0=rmsd(rcurrent_s, rcomp_s, statWeights)
!
!  gather !
         call mpi_gather(rmsd0,1,MPI_DOUBLE_PRECISION                   &
     &                ,rmsd0_all,1,MPI_DOUBLE_PRECISION,0,              &
     &                 MPI_COMM_STRNG, error)
         if (qprint) then ! root writes
           if (rmsd0_funit.eq.outu) then
      write(rmsd0_funit,'("RMSD0> ",I5," ",'//fmt(1:fmt_len)//'F11.5)') &
     &       stat_iteration_counter,                                    &
     &      (rmsd0_all(i),i=1,SIZE_STRNG)
           else
            write(rmsd0_funit,'(I5," ",'//fmt(1:fmt_len)//'F11.5)')     &
     &      stat_iteration_counter,                                     &
     &      (rmsd0_all(i),i=1,SIZE_STRNG)
           endif
!     flush unit: close and reopen
           call vclose(rmsd0_funit, 'KEEP', error)
           call open_file(rmsd0_funit, rmsd0_fname,                     &
     &      'FORMATTED','APPEND')
!     done
         endif ! qprint
        endif ! qroot
      endif
! 667  format(I5,' ',100F11.5)
! 6670 format('RMSD0> ',I5,' ',100F11.5)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_dsdt) then
        if (qroot) then
         if (repa_initialized) then ! proceed only if rold is defined
          if (qstat_orient) then
           call RMSBestFit(rcurrent_o,rold_o,orientWeights,u)
           u=transpose(u)
           rcurrent_o=matmul(rcurrent_o, u)
           rcurrent_s=matmul(rcurrent_s, u)
          endif
          dsdt=rmsd(rcurrent_s, rold_s, statWeights)
!  gather !
          call mpi_gather(dsdt,1,MPI_DOUBLE_PRECISION                   &
     &                ,dsdt_all,1,MPI_DOUBLE_PRECISION,0,               &
     &                 MPI_COMM_STRNG, error)
          if (qprint) then ! root writes
           if (dsdt_funit.eq.outu) then
      write(dsdt_funit,'("DLEN> ",I5," ",'//fmt(1:fmt_len)//'F11.5)')   &
     &      stat_iteration_counter,                                     &
     &      (dsdt_all(i),i=1,SIZE_STRNG)
           else
            write(dsdt_funit,'(I5," ",'//fmt(1:fmt_len)//'F11.5)')      &
     &      stat_iteration_counter,                                     &
     &      (dsdt_all(i),i=1,SIZE_STRNG)
           endif
!     flush unit: close and reopen
           call vclose(dsdt_funit, 'KEEP', error)
           call open_file(dsdt_funit, dsdt_fname,                       &
     &      'FORMATTED','APPEND')
!     done
          endif ! qprint
         else ! repa_initialized
          call wrndie(0,whoami,                                         &
     & ' NO REPARAMETRIZATION OPTIONS SELECTED. SKIPPING DSDT.')
         endif
        endif ! qroot
! 6680 format('DLEN> ',I5,' ',100F11.5)
! 668  format(I5,' ',100F11.5)
      endif ! dsdt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_rmsd_ave) then
        if (qroot) then
         if (repa_initialized) then ! proceed only if rave defined
          if (qstat_orient) then
           call RMSBestFit(rcurrent_o,rave_o,orientWeights,u)
           u=transpose(u)
           rcurrent_o=matmul(rcurrent_o, u)
           rcurrent_s=matmul(rcurrent_s, u)
          endif
          dsdt=rmsd(rcurrent_s, rave_s, statWeights)
!  gather !
          call mpi_gather(rmsd0,1,MPI_DOUBLE_PRECISION                  &
     &                ,rmsd0_all,1,MPI_DOUBLE_PRECISION,0,              &
     &                 MPI_COMM_STRNG, error)
          if (qprint) then ! root writes
           if (rmsd_ave_funit.eq.outu) then
            write(rmsd_ave_funit,'("RMSD_AVE> ",I5," ",'//              &
     &      fmt(1:fmt_len)//'F11.5)')                                   &
     &      stat_iteration_counter,                                     &
     &      (rmsd0_all(i),i=1,SIZE_STRNG)
           else
            write(rmsd_ave_funit,'(I5," ",'//fmt(1:fmt_len)//'F11.5)')  &
     &      stat_iteration_counter,                                     &
     &      (rmsd0_all(i),i=1,SIZE_STRNG)
           endif
          endif
! 6681 format('RMSD_AVE> ',I5,' ',100F11.5)
! 6682 format(I5,' ',100F11.5)
!     flush unit: close and reopen
          call vclose(rmsd_ave_funit, 'KEEP', error)
          call open_file(rmsd_ave_funit, rmsd_ave_fname,                &
     &      'FORMATTED','APPEND')
        else ! repa_initialized
          call wrndie(0,whoami,                                         &
     & ' NO REPARAMETRIZATION OPTIONS SELECTED. SKIPPING RMSD_AVE.')
        endif ! repa_initialized
       endif ! qroot
!     done
      endif ! RMSD from average structure
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_arclength) then
       if (qprint) then
        if (repa_initialized) then ! proceed only if arclength defined
         if (s_funit.eq.outu) then
      write(s_funit,'("ARCL> ",I5," ",'//fmt(1:fmt_len)//'F11.5)')      &
     &          stat_iteration_counter, (ds(i),i=1,SIZE_STRNG-1)
         else
          write(s_funit,'(I5," ",'//fmt(1:fmt_len)//'F11.5)')           &
     & stat_iteration_counter, (ds(i),i=1,SIZE_STRNG-1)
         endif
!     flush unit: close and reopen
         call vclose(s_funit, 'KEEP', error)
         call open_file(s_funit, s_fname,                               &
     &      'FORMATTED','APPEND')
!     done
        else
          call wrndie(0,whoami,                                         &
     & ' NO REPARAMETRIZATION OPTIONS SELECTED. SKIPPING ARCLENGTH.')
        endif
       endif ! qprint
! 669  format(I5,' ',100F11.5)
! 6690 format('ARCL> ',I5,' ',100F11.5)
      endif ! output_arclength
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_curvature) then
       if (qprint) then
        if (repa_initialized) then ! proceed only if arclength defined
         if (c_funit.eq.outu) then
      write(c_funit,'("CURV> ",I5," ",'//fmt(1:fmt_len)//'F11.5)')      &
     & stat_iteration_counter, (curv(i),i=1,SIZE_STRNG-1)
         else
          write(c_funit,'(I5," ",'//fmt(1:fmt_len)//'F11.5)')           &
     &          stat_iteration_counter, (curv(i),i=1,SIZE_STRNG-1)
         endif
!     flush unit: close and reopen
         call vclose(c_funit, 'KEEP', error)
         call open_file(c_funit, c_fname,                               &
     &      'FORMATTED','APPEND')
!     done
        else
          call wrndie(0,whoami,                                         &
     & ' NO REPARAMETRIZATION OPTIONS SELECTED. SKIPPING CURVATURE.')
        endif
       endif ! me
! 6692 format(I5,' ',100F11.5)
! 6691 format('CURV> ',I5,' ',100F11.5)
      endif ! output_curvature
!
      end subroutine sm0k_stat
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      end module sm0k
##ENDIF
##ENDIF
