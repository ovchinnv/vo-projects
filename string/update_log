##IF PARALLEL						      |	__CHARMM_ONLY##IF PARALLEL
##IF STRINGM						      |	__CHARMM_ONLY##IF STRINGM
      character*8 keyword				      |	      character(len=8 keyword
      character*9 whoami				      |	      character(len=9 whoami
!      logical eqstwc					      |	!      bool eqstwc
!      character*4 nexta4				      |	!      character(len=4 nexta4
      use mpi               !##MPI			      |	      use mpi               !__CHARMM_ONLY##MPI
      use multicom_ltm       !##MULTICOM		      |	      use multicom_ltm       !__CHARMM_ONLY##MULTICOM
##IF UNIX OS2						      |	__CHARMM_ONLY##IF UNIX OS2
##ELSE							      |	__CHARMM_ONLY##ELSE
##ENDIF							      |	__CHARMM_ONLY##ENDIF
       integer :: oldiol				      |	       int :: oldiol
       logical :: loud					      |	       bool :: loud
       character*(9) :: whoami				      |	       character(len=(9) :: whoami
!          if (MPI_COMM_STRNG.ne.MPI_COMM_NULL)       !##MPI  |	!          if (MPI_COMM_STRNG.ne.MPI_COMM_NULL)       !__CHAR
!     &     call MPI_BARRIER(MPI_COMM_STRNG, IERROR)  !##MPI  |	!     &     call MPI_BARRIER(MPI_COMM_STRNG, IERROR)  !__CHAR
      use multicom_ltm       !##MULTICOM		      |	      use multicom_ltm       !__CHARMM_ONLY##MULTICOM
       character*(10) :: whoami				      |	       character(len=(10) :: whoami
##ELSE ! string not compiled				      |	__CHARMM_ONLY##ELSE ! string not compiled
##ENDIF							      |	__CHARMM_ONLY##ENDIF
##ENDIF							      |	__CHARMM_ONLY##ENDIF
##IF PARALLEL						      |	__CHARMM_ONLY##IF PARALLEL
##IF STRINGM						      |	__CHARMM_ONLY##IF STRINGM
      use multicom_ltm       !##MULTICOM		      |	      use multicom_ltm       !__CHARMM_ONLY##MULTICOM
      integer n						      |	      int n
      real*8 :: x(n), f(n)				      |	      float :: x(n), f(n)
      real*8 :: work(:)					      |	      float :: work(:)
      real*8, optional :: xbc0(n), xbc1(n)		      |	      float, optional :: xbc0(n), xbc1(n)
      integer :: fbc0=0, fbc1=0 ! fixed bc local flags	      |	      int :: fbc0=0, fbc1=0 ! fixed bc local flags
      integer ierror, nall, i, nrep, me, nensem		      |	      int ierror, nall, i, nrep, me, nensem
      integer, parameter :: ITYPE = MPI_DOUBLE_PRECISION      |	      int, parameter :: ITYPE = MPI_DOUBLE_PRECISION
!      integer :: ITYPE = MPI_REAL8			      |	!      int :: ITYPE = MPI_REAL8
      real*8, allocatable :: xall(:,:), fall(:,:)	      |	      float, allocatable :: xall(:,:), fall(:,:)
      real*8, allocatable :: dxall(:,:), fall_c(:,:)	      |	      float, allocatable :: dxall(:,:), fall_c(:,:)
      real*8, allocatable :: wme(:)			      |	      float, allocatable :: wme(:)
      integer*4 :: s_disp(SIZE_STRNG), r_disp(SIZE_STRNG),    |	      mpiint :: s_disp(SIZE_STRNG), r_disp(SIZE_STRNG),      
     & s_count(SIZE_STRNG), r_count(SIZE_STRNG)        ! have |	     & s_count(SIZE_STRNG), r_count(SIZE_STRNG)        ! have
      use multicom_ltm       !##MULTICOM		      |	      use multicom_ltm       !__CHARMM_ONLY##MULTICOM
      integer n						      |	      int n
      real*8 :: rin(n), rout(n), wgt(n)			      |	      float :: rin(n), rout(n), wgt(n)
      integer :: interp_method				      |	      int :: interp_method
      real*8 :: d_arclength(:), curvature(:)		      |	      float :: d_arclength(:), curvature(:)
      real*8, optional :: r_bc_0(n), r_bc_1(n)   ! optional f |	      float, optional :: r_bc_0(n), r_bc_1(n)   ! optional fi
      integer, parameter :: linear=1, spline=2, bspline=3     |	      int, parameter :: linear=1, spline=2, bspline=3
      real*8 :: rin_w(n) ! weighted by wgt		      |	      float :: rin_w(n) ! weighted by wgt
      real*8 :: swgt(n)  ! square root of weights	      |	      float :: swgt(n)  ! square root of weights
      integer :: fbc0=0, fbc1=0 ! fixed bc local flags	      |	      int :: fbc0=0, fbc1=0 ! fixed bc local flags
      integer :: ierror, nall, i, j, nrep, me, nensem	      |	      int :: ierror, nall, i, j, nrep, me, nensem
      integer, parameter :: ITYPE = MPI_DOUBLE_PRECISION      |	      int, parameter :: ITYPE = MPI_DOUBLE_PRECISION
!      integer :: ITYPE = MPI_REAL8			      |	!      int :: ITYPE = MPI_REAL8
      real*8, allocatable :: rall(:,:), drall(:,:), dr2all(:, |	      float, allocatable :: rall(:,:), drall(:,:), dr2all(:,:
      integer*4  :: s_disp(SIZE_STRNG), r_disp(SIZE_STRNG),   |	      mpiint  :: s_disp(SIZE_STRNG), r_disp(SIZE_STRNG),     
     & s_count(SIZE_STRNG), r_count(SIZE_STRNG)       !   hav |	     & s_count(SIZE_STRNG), r_count(SIZE_STRNG)       !   hav
      real*8, allocatable :: rr(:), rrpp(:), dsn(:), ds(:), d |	      float, allocatable :: rr(:), rrpp(:), dsn(:), ds(:), ds
      real*8 :: dum, wrs				      |	      float :: dum, wrs
       integer :: nin, nout				      |	       int :: nin, nout
       real*8 :: xin(nin), yin(nin), xout(nout), yout(nout)   |	       float :: xin(nin), yin(nin), xout(nout), yout(nout)
       real*8, optional :: dydxout(nout) ! tangent computatio |	       float, optional :: dydxout(nout) ! tangent computation
       real*8 :: dydx(nout)				      |	       float :: dydx(nout)
      use multicom_ltm       !##MULTICOM		      |	      use multicom_ltm       !__CHARMM_ONLY##MULTICOM
      integer :: n					      |	      int :: n
      real*8 :: rin(n), rout(n), wgt(n)			      |	      float :: rin(n), rout(n), wgt(n)
      integer, intent(in) ::  interp_method		      |	      int, intent(in) ::  interp_method
      integer :: max_iterations				      |	      int :: max_iterations
      real*8 :: tol, d_arclength(:), curvature(:)	      |	      float :: tol, d_arclength(:), curvature(:)
      real*8, optional :: dst_cutoff ! wavenumber cutoff for  |	      float, optional :: dst_cutoff ! wavenumber cutoff for t
      real*8, optional :: drout(n) ! optional computation of  |	      float, optional :: drout(n) ! optional computation of t
      real*8 , optional :: r_bc_0(n), r_bc_1(n)   ! optional  |	      float , optional :: r_bc_0(n), r_bc_1(n)   ! optional f
      integer, parameter :: linear=1, spline=2, bspline=3, ds |	      int, parameter :: linear=1, spline=2, bspline=3, dst=4
      real*8 :: rin_w(n)				      |	      float :: rin_w(n)
      real*8 :: swgt(n)					      |	      float :: swgt(n)
      integer :: fbc0=0, fbc1=0 ! fixed bc local flags	      |	      int :: fbc0=0, fbc1=0 ! fixed bc local flags
      integer :: ierror, nall, i, j, nrep, me, n_me, nensem   |	      int :: ierror, nall, i, j, nrep, me, n_me, nensem
      integer :: nfine					      |	      int :: nfine
      real*8, pointer, dimension(:) :: sfine, tfine	      |	      float, pointer, dimension(:) :: sfine, tfine
      integer, parameter :: ITYPE = MPI_DOUBLE_PRECISION      |	      int, parameter :: ITYPE = MPI_DOUBLE_PRECISION
!      integer :: ITYPE = MPI_REAL8			      |	!      int :: ITYPE = MPI_REAL8
      real*8, allocatable :: rall(:,:), drall(:,:), dr2all(:, |	      float, allocatable :: rall(:,:), drall(:,:), dr2all(:,:
      real*8, pointer :: rfine(:,:), drfine(:,:)	      |	      float, pointer :: rfine(:,:), drfine(:,:)
      real*8, allocatable :: rh(:) ! for sine transform	      |	      float, allocatable :: rh(:) ! for sine transform
      real*8, allocatable :: sinvec(:,:) ! for sine transform |	      float, allocatable :: sinvec(:,:) ! for sine transform
      real*8, allocatable :: sinvec_fine(:,:) ! for sine tran |	      float, allocatable :: sinvec_fine(:,:) ! for sine tranf
      integer*4  :: s_disp(SIZE_STRNG), r_disp(SIZE_STRNG),   |	      mpiint  :: s_disp(SIZE_STRNG), r_disp(SIZE_STRNG),     
     & s_count(SIZE_STRNG), r_count(SIZE_STRNG)       !   hav |	     & s_count(SIZE_STRNG), r_count(SIZE_STRNG)       !   hav
      real*8, allocatable ::  rr(:), rrpp(:), rrtan(:),       |	      float, allocatable ::  rr(:), rrpp(:), rrtan(:),       
      real*8, pointer, dimension(:) :: rrfine, ds2me_fine,    |	      float, pointer, dimension(:) :: rrfine, ds2me_fine,    
!      real*8 :: rrfine(nfine), ds2me_fine(nfine-1),	      |	!      float :: rrfine(nfine), ds2me_fine(nfine-1),
      integer :: iteration				      |	      int :: iteration
      integer :: npass ! for sine transform		      |	      int :: npass ! for sine transform
      real*8 :: def, dum				      |	      float :: def, dum
      real*8, parameter :: pi=3.14159265358979323846	      |	      float, parameter :: pi=3.14159265358979323846
      real*8 :: r0, r1, wrs				      |	      float :: r0, r1, wrs
      character*19 :: whoami				      |	      character(len=19 :: whoami
       integer :: nin, nout				      |	       int :: nin, nout
       real*8 :: xin(nin), yin(nin), xout(nout), yout(nout)   |	       float :: xin(nin), yin(nin), xout(nout), yout(nout)
       real*8, optional :: dydxout(nout) ! tangent computatio |	       float, optional :: dydxout(nout) ! tangent computation
       real*8 :: dydx(nout)				      |	       float :: dydx(nout)
      use multicom_ltm       !##MULTICOM		      |	      use multicom_ltm       !__CHARMM_ONLY##MULTICOM
      integer :: n					      |	      int :: n
      real*8 :: rin(n), rout(n), wgt(n)			      |	      float :: rin(n), rout(n), wgt(n)
      integer, intent(in) ::  interp_method		      |	      int, intent(in) ::  interp_method
      integer :: max_iterations				      |	      int :: max_iterations
      real*8 :: tol, d_arclength(:), curvature(:)	      |	      float :: tol, d_arclength(:), curvature(:)
      real*8, optional :: dst_cutoff ! wavenumber cutoff for  |	      float, optional :: dst_cutoff ! wavenumber cutoff for t
      real*8, optional :: drout(n) ! optional computation of  |	      float, optional :: drout(n) ! optional computation of t
      real*8 , optional :: r_bc_0(n), r_bc_1(n)   ! optional  |	      float , optional :: r_bc_0(n), r_bc_1(n)   ! optional f
      integer, parameter :: linear=1, spline=2, bspline=3, ds |	      int, parameter :: linear=1, spline=2, bspline=3, dst=4
      real*8 :: rin_w(n)				      |	      float :: rin_w(n)
      real*8 :: swgt(n)					      |	      float :: swgt(n)
      integer :: fbc0=0, fbc1=0 ! fixed bc local flags	      |	      int :: fbc0=0, fbc1=0 ! fixed bc local flags
      integer :: ierror, nall, i, j, nrep, me, n_me, nensem   |	      int :: ierror, nall, i, j, nrep, me, n_me, nensem
      logical :: qroot					      |	      bool :: qroot
      integer :: nfine					      |	      int :: nfine
      real*8, allocatable, dimension(:) :: sfine, tfine	      |	      float, allocatable, dimension(:) :: sfine, tfine
      integer, parameter :: ITYPE = MPI_DOUBLE_PRECISION      |	      int, parameter :: ITYPE = MPI_DOUBLE_PRECISION
!      integer :: ITYPE = MPI_REAL8			      |	!      int :: ITYPE = MPI_REAL8
      real*8, allocatable :: rall(:,:), drall(:,:), dr2all(:, |	      float, allocatable :: rall(:,:), drall(:,:), dr2all(:,:
      real*8, allocatable :: rfine(:,:), drfine(:,:)	      |	      float, allocatable :: rfine(:,:), drfine(:,:)
      real*8, allocatable :: rh(:) ! for sine transform	      |	      float, allocatable :: rh(:) ! for sine transform
      real*8, allocatable :: sinvec(:,:) ! for sine transform |	      float, allocatable :: sinvec(:,:) ! for sine transform
      real*8, allocatable :: sinvec_fine(:,:) ! for sine tran |	      float, allocatable :: sinvec_fine(:,:) ! for sine tranf
      integer*4  :: s_disp(SIZE_STRNG), r_disp(SIZE_STRNG),   |	      mpiint  :: s_disp(SIZE_STRNG), r_disp(SIZE_STRNG),     
     & s_count(SIZE_STRNG), r_count(SIZE_STRNG)       !   hav |	     & s_count(SIZE_STRNG), r_count(SIZE_STRNG)       !   hav
      real*8, allocatable ::  rr(:), rrpp(:), rrtan(:),       |	      float, allocatable ::  rr(:), rrpp(:), rrtan(:),       
      real*8, allocatable, dimension(:) :: rrfine,            |	      float, allocatable, dimension(:) :: rrfine,            
      integer :: iteration				      |	      int :: iteration
      integer :: npass ! for sine transform		      |	      int :: npass ! for sine transform
      real*8 :: def, dum				      |	      float :: def, dum
      real*8, parameter :: pi=3.14159265358979323846	      |	      float, parameter :: pi=3.14159265358979323846
      real*8 :: r0, r1, wrs				      |	      float :: r0, r1, wrs
      character*24 :: whoami				      |	      character(len=24 :: whoami
       integer :: nin, nout				      |	       int :: nin, nout
       real*8 :: xin(nin), yin(nin), xout(nout), yout(nout)   |	       float :: xin(nin), yin(nin), xout(nout), yout(nout)
       real*8, optional :: dydxout(nout) ! tangent computatio |	       float, optional :: dydxout(nout) ! tangent computation
       real*8 :: dydx(nout)				      |	       float :: dydx(nout)
       call mpi_bcast(iteration,1,MPI_INTEGER8,0,MPI_COMM_STR |	       call mpi_bcast(iteration,1,MPI_INTEGER8,0,MPI_COMM_STR
       call mpi_bcast(iteration,1,MPI_INTEGER, 0,MPI_COMM_STR |	       call mpi_bcast(iteration,1,MPI_INTEGER, 0,MPI_COMM_STR
      use multicom_ltm       !##MULTICOM		      |	      use multicom_ltm       !__CHARMM_ONLY##MULTICOM
      integer :: n					      |	      int :: n
      real*8 :: rin(n), rout(n), wgt(n)			      |	      float :: rin(n), rout(n), wgt(n)
      real*8 :: d_arclength(:), curvature(:)		      |	      float :: d_arclength(:), curvature(:)
      real*8, optional :: drout(n) ! optional computation of  |	      float, optional :: drout(n) ! optional computation of t
      real*8 , optional :: r_bc_0(n), r_bc_1(n)   ! optional  |	      float , optional :: r_bc_0(n), r_bc_1(n)   ! optional f
      real*8 :: rin_w(n)				      |	      float :: rin_w(n)
      real*8 :: swgt(n)					      |	      float :: swgt(n)
      integer :: fbc0=0, fbc1=0 ! fixed bc local flags	      |	      int :: fbc0=0, fbc1=0 ! fixed bc local flags
      integer :: ierror, nall, i, j, nrep, me, nensem, im, it |	      int :: ierror, nall, i, j, nrep, me, nensem, im, iterat
      logical :: qroot					      |	      bool :: qroot
      integer, parameter :: ITYPE = MPI_DOUBLE_PRECISION      |	      int, parameter :: ITYPE = MPI_DOUBLE_PRECISION
      real*8, allocatable :: rall(:,:), drall(:,:),           |	      float, allocatable :: rall(:,:), drall(:,:),           
      real*8, pointer :: a(:,:), ao(:), am(:), ap(:)	      |	      float, pointer :: a(:,:), ao(:), am(:), ap(:)
      integer*4  :: s_disp(SIZE_STRNG), r_disp(SIZE_STRNG),   |	      mpiint  :: s_disp(SIZE_STRNG), r_disp(SIZE_STRNG),     
     & s_count(SIZE_STRNG), r_count(SIZE_STRNG)       !   hav |	     & s_count(SIZE_STRNG), r_count(SIZE_STRNG)       !   hav
      real*8 :: r0, r1, wrs, err, dum			      |	      float :: r0, r1, wrs, err, dum
      real*8, parameter :: errtol = 1e-8		      |	      float, parameter :: errtol = 1e-8
      integer , parameter :: max_iterations = 200	      |	      int , parameter :: max_iterations = 200
      character*21 :: whoami				      |	      character(len=21 :: whoami
      use multicom_ltm       !##MULTICOM		      |	      use multicom_ltm       !__CHARMM_ONLY##MULTICOM
      integer :: n					      |	      int :: n
      real*8 :: rin(n), drout(n), wgt(n)		      |	      float :: rin(n), drout(n), wgt(n)
      real*8 :: d_arclength(:), curvature(:)		      |	      float :: d_arclength(:), curvature(:)
      real*8, optional :: r_bc_0(n), r_bc_1(n)   ! optional f |	      float, optional :: r_bc_0(n), r_bc_1(n)   ! optional fi
      real*8 :: rin_w(n) ! r weighted by wgt		      |	      float :: rin_w(n) ! r weighted by wgt
      real*8 :: swgt(n)					      |	      float :: swgt(n)
      integer :: fbc0=0, fbc1=0 ! fixed bc local flags	      |	      int :: fbc0=0, fbc1=0 ! fixed bc local flags
      integer ierror, nall, i, j, nrep, me, nensem ! 9.08: re |	      int ierror, nall, i, j, nrep, me, nensem ! 9.08: replac
      integer, parameter :: ITYPE = MPI_DOUBLE_PRECISION      |	      int, parameter :: ITYPE = MPI_DOUBLE_PRECISION
!      integer :: ITYPE = MPI_REAL8			      |	!      int :: ITYPE = MPI_REAL8
      real*8, allocatable :: rall(:,:), drall(:,:), dr2all(:, |	      float, allocatable :: rall(:,:), drall(:,:), dr2all(:,:
      integer*4  :: s_disp(SIZE_STRNG), r_disp(SIZE_STRNG),   |	      mpiint  :: s_disp(SIZE_STRNG), r_disp(SIZE_STRNG),     
     &              s_count(SIZE_STRNG), r_count(SIZE_STRNG)  |	     &              s_count(SIZE_STRNG), r_count(SIZE_STRNG) 
      real*8, allocatable :: ds(:), dsn(:), ds2me(:),         |	      float, allocatable :: ds(:), dsn(:), ds2me(:),         
      real*8 :: wrs					      |	      float :: wrs
      use multicom_ltm       !##MULTICOM		      |	      use multicom_ltm       !__CHARMM_ONLY##MULTICOM
      integer ifile					      |	      int ifile
      character*(*) fname, form, acc			      |	      character(len=(*) fname, form, acc
      character*11 whoami				      |	      character(len=11 whoami
      integer error,ifile2,flen,k			      |	      int error,ifile2,flen,k
      logical OPENUN,QFORM,QWRITE, QERROR		      |	      bool OPENUN,QFORM,QWRITE, QERROR
      integer l						      |	      int l
      character*(MXCMSZ) fname_bkp			      |	      character(len=(MXCMSZ) fname_bkp
      integer lunass ! function				      |	      int lunass ! function
      use multicom_ltm       !##MULTICOM		      |	      use multicom_ltm       !__CHARMM_ONLY##MULTICOM
       real*8 :: x(:), y(:), z(:), mass(:)		      |	       float :: x(:), y(:), z(:), mass(:)
       logical, optional :: min_rmsd			      |	       bool, optional :: min_rmsd
       integer, optional :: ind ! frame index		      |	       int, optional :: ind ! frame index
!							      |	!
       logical :: qrmsd					      |	       bool :: qrmsd
       character*21 :: whoami				      |	       character(len=21 :: whoami
       real*8 :: A1(3,3), A2(3,3), A3(3,3), A4(3,3), o(3), xx |	       float :: A1(3,3), A2(3,3), A3(3,3), A4(3,3), o(3), xx,
       real*8, allocatable, dimension(:) :: x0, x1, x2, x3, x |	       float, allocatable, dimension(:) :: x0, x1, x2, x3, x4
       real*8 :: totm0, corr1, corr2, corr3, corr4, cmax,     |	       float :: totm0, corr1, corr2, corr3, corr4, cmax,     
       integer, allocatable, dimension (:) :: ind0	      |	       int, allocatable, dimension (:) :: ind0
       integer :: i, j, ii, jj, ibeg, iend, ncom	      |	       int :: i, j, ii, jj, ibeg, iend, ncom
       integer :: stat(MPI_STATUS_SIZE)			      |	       int :: stat(MPI_STATUS_SIZE)
       integer :: error					      |	       int :: error
      use multicom_ltm       !##MULTICOM		      |	      use multicom_ltm       !__CHARMM_ONLY##MULTICOM
       real*8 :: x(:), y(:), z(:), mass(:)		      |	       float :: x(:), y(:), z(:), mass(:)
       integer, optional :: ind ! frame index		      |	       int, optional :: ind ! frame index
       character*18 :: whoami				      |	       character(len=18 :: whoami
       real*8 :: A1(3,3), A2(3,3), A3(3,3), A4(3,3)	      |	       float :: A1(3,3), A2(3,3), A3(3,3), A4(3,3)
       real*8 :: rmsd1, rmsd2, rmsd3, rmsd4, mrmsd ! for rmsd |	       float :: rmsd1, rmsd2, rmsd3, rmsd4, mrmsd ! for rmsd 
       integer :: i, ibeg, iend, error			      |	       int :: i, ibeg, iend, error
      use multicom_ltm       !##MULTICOM		      |	      use multicom_ltm       !__CHARMM_ONLY##MULTICOM
       real*8 :: x(:), y(:), z(:), mass(:)		      |	       float :: x(:), y(:), z(:), mass(:)
       integer, optional :: ind ! frame index		      |	       int, optional :: ind ! frame index
       character*18 :: whoami				      |	       character(len=18 :: whoami
       real*8 :: A1(3,3), A2(3,3), A3(3,3), A4(3,3)	      |	       float :: A1(3,3), A2(3,3), A3(3,3), A4(3,3)
       integer :: where1, where2, where3, where4, me	      |	       int :: where1, where2, where3, where4, me
       integer :: i, ibeg, iend				      |	       int :: i, ibeg, iend
!##INCLUDE 'parallel.fcm' ! aa				      |	!__CHARMM_ONLY##INCLUDE 'parallel.fcm' ! aa
      real*8 :: message(*)				      |	      float :: message(*)
      integer :: size, type, rank, error, comm		      |	      int :: size, type, rank, error, comm
      integer*4 :: count(size), displ(size)		      |	      mpiint :: count(size), displ(size)
      integer :: step, partner, scount, sdispl, rcount, rdisp |	      int :: step, partner, scount, sdispl, rcount, rdispl, i
      integer :: stat(MPI_STATUS_SIZE)			      |	      int :: stat(MPI_STATUS_SIZE)
##ENDIF							      |	__CHARMM_ONLY##ENDIF
##ENDIF							      |	__CHARMM_ONLY##ENDIF
##IF PARALLEL						      |	__CHARMM_ONLY##IF PARALLEL
##IF STRINGM						      |	__CHARMM_ONLY##IF STRINGM
!    Input, integer NDATA, the number of data values.	      |	!    Input, int NDATA, the number of data values.
!    Input, real*8  YDATA(NDATA), the data values.	      |	!    Input, float  YDATA(NDATA), the data values.
!    Input, real*8  TVAL, a point at which the spline is to b |	!    Input, float  TVAL, a point at which the spline is to be
!    Output, real*8  YVAL, the value of the function at TVAL. |	!    Output, float  YVAL, the value of the function at TVAL.
      integer ndata					      |	      int ndata
      real*8  bval					      |	      float  bval
      integer left					      |	      int left
      integer right					      |	      int right
      real*8  tdata(ndata)				      |	      float  tdata(ndata)
      real*8  tval					      |	      float  tval
      real*8  u						      |	      float  u
      real*8  ydata(ndata)				      |	      float  ydata(ndata)
      real*8  yval					      |	      float  yval
!    Input, integer N, length of input array.		      |	!    Input, int N, length of input array.
!    Output, integer LEFT, RIGHT, the results of the search.  |	!    Output, int LEFT, RIGHT, the results of the search.
       integer n					      |	       int n
       integer i					      |	       int i
       integer left					      |	       int left
       integer right					      |	       int right
       real*8  x(n)					      |	       float  x(n)
       real*8  xval					      |	       float  xval
!    Input, integer N, length of the input array.	      |	!    Input, int N, length of the input array.
!    Input/output, integer LEFT.			      |	!    Input/output, int LEFT.
       integer n					      |	       int n
       integer high					      |	       int high
       integer left					      |	       int left
       integer low					      |	       int low
       integer mid					      |	       int mid
       real*8  t(n)					      |	       float  t(n)
       real*8  tval					      |	       float  tval
!    Input, integer N, the number of data points; N must be a |	!    Input, int N, the number of data points; N must be at le
!    Input, integer IBCBEG, the left boundary condition flag: |	!    Input, int IBCBEG, the left boundary condition flag:
!    Input, integer IBCEND, the right boundary condition flag |	!    Input, int IBCEND, the right boundary condition flag:
       integer n					      |	       int n
       real*8 diag(n)					      |	       float diag(n)
       integer i					      |	       int i
       integer ibcbeg					      |	       int ibcbeg
       integer ibcend					      |	       int ibcend
       real*8 sub(2:n)					      |	       float sub(2:n)
       real*8 sup(1:n-1)				      |	       float sup(1:n-1)
       real*8 t(n)					      |	       float t(n)
       real*8 y(n)					      |	       float y(n)
       real*8 ybcbeg					      |	       float ybcbeg
       real*8 ybcend					      |	       float ybcend
       real*8 ypp(n)					      |	       float ypp(n)
!    Input, integer N, the number of data values.	      |	!    Input, int N, the number of data values.
       integer n					      |	       int n
       real*8 dt					      |	       float dt
       real*8 h						      |	       float h
       integer left					      |	       int left
       integer right					      |	       int right
       real*8 t(n)					      |	       float t(n)
       real*8 tval					      |	       float tval
       real*8 y(n)					      |	       float y(n)
       real*8 ypp(n)					      |	       float ypp(n)
       real*8 yppval					      |	       float yppval
       real*8 ypval					      |	       float ypval
       real*8 yval					      |	       float yval
!    Input, integer N, the number of knots.		      |	!    Input, int N, the number of knots.
!    Input/output, integer LEFT, the suggested T interval to  |	!    Input/output, int LEFT, the suggested T interval to sear
       integer n					      |	       int n
       real*8 dt					      |	       float dt
       real*8 h						      |	       float h
       integer left					      |	       int left
       integer right					      |	       int right
       real*8 t(n)					      |	       float t(n)
       real*8 tval					      |	       float tval
       real*8 y(n)					      |	       float y(n)
       real*8 ypp(n)					      |	       float ypp(n)
       real*8 yppval					      |	       float yppval
       real*8 ypval					      |	       float ypval
       real*8 yval					      |	       float yval
!    Input, integer N, the order of the linear system.	      |	!    Input, int N, the order of the linear system.
       integer n					      |	       int n
       real*8 a1(2:n)					      |	       float a1(2:n)
       real*8 a2(1:n)					      |	       float a2(1:n)
       real*8 a3(1:n-1)					      |	       float a3(1:n-1)
       real*8 b(n)					      |	       float b(n)
       integer i					      |	       int i
       real*8 x(n)					      |	       float x(n)
       real*8 xmult					      |	       float xmult
      integer :: nin, nout				      |	      int :: nin, nout
      real*8 :: xin(nin), yin(nin), xout(nout), yout(nout)    |	      float :: xin(nin), yin(nin), xout(nout), yout(nout)
      real*8, optional :: dydxout(nout) ! tangent computation |	      float, optional :: dydxout(nout) ! tangent computation
      real*8 :: dydx(nout)				      |	      float :: dydx(nout)
      integer i,j					      |	      int i,j
      integer :: delta					      |	      int :: delta
      real*8 :: t(:), x(:)				      |	      float :: t(:), x(:)
      integer :: dlen=80, nt, nx, i			      |	      int :: dlen=80, nt, nx, i
      character*80 dchar				      |	      character(len=80 dchar
      real*8, dimension(size(t)) :: xtemp, xnew, smooth2      |	      float, dimension(size(t)) :: xtemp, xnew, smooth2
      integer :: nin, nout				      |	      int :: nin, nout
      real*8 :: xin(nin), yin(nin), xout(nout), yout(nout)    |	      float :: xin(nin), yin(nin), xout(nout), yout(nout)
      real*8, optional :: dydxout(nout) ! tangent computation |	      float, optional :: dydxout(nout) ! tangent computation
##ENDIF							      |	__CHARMM_ONLY##ENDIF
##ENDIF							      |	__CHARMM_ONLY##ENDIF
