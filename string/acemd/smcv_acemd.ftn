#define __INITCTX SMCV_INIT
#define __DONECTX SMCV_DONE
!
#define __CBIND use, intrinsic :: iso_c_binding
!
module smcv_acemd
 use minimal_system
 __DEP_OUTPUT
 __DEP_CONST
 __CBIND

 __IMPNONE

 private
!
 bool, save :: defer_init_until_dyna=.false. ! if true, will call initializer after coordinates are available
 bool, save :: initialized=.false.
 int, save :: iteration
 int(__FCINT), save, allocatable, target :: atomlist(:)
!
 interface
  subroutine smcv_exec(ctx)
  character(len=*) :: ctx
  end subroutine smcv_exec
 end interface
!
 contains
! a collection of subroutines to call the SMCV code from ACEMD plugin interface
! module encapsulation allows storage
!
#define __CSUB(__NAME, ...) subroutine __NAME (__VA_ARGS__) bind(c, name=__STRING(__NAME))
#define __CFUN(__NAME, ...) function __NAME (__VA_ARGS__) bind(c, name=__STRING(__NAME))
!
#define _ME smcv_init_from_acemd
 __CFUN(_ME, n, mass, charge, inputname, il, outputname, ol, alist)
 __DEP_VECTORS
 __DEP_PARSER
 __DEP_FILES
 __DEP_MPI
 use cv_common, only : cv
 int(__FCINT) :: _ME
 int( __FCINT), intent(in), value :: n, il, ol
 real(__FCFLOAT), intent(in), dimension(n) :: mass, charge
 type(c_ptr), intent(out) :: alist ! send back a list of atom indices, if computable
 type (c_ptr), value, intent(in) :: inputname, outputname
!
 character(len=il), pointer :: ifname
 character(len=ol), pointer :: ofname

 int :: i, fid, ierr
 __IAM(_ME)
 _ME=1
!
 call c_f_pointer(inputname, ifname)
 call c_f_pointer(outputname, ofname)
!
 call output_init(ofname)
!
 if (n<0) then
  __WRN(whoami, 'NUMBER OF ATOMS MUST BE POSITIVE (RECEIVED '//itoa(n)//')')
  return
 else
  call smcv_done_from_acemd()
  __MESSAGE(whoami, 'INITIALIZING SMCV PLUGIN WITH '//itoa(n)//' ATOMS');
  allocate(r(3,n), rcomp(3,n), f(3,n), m(n), q(n))
  minimal_system_natom=n
  m=mass
  q=charge
  r=__NAN
  rcomp=__NAN
! open input file
  fid=-1
  call files_open(fid, ifname, 'FORMATTED', 'READ')
! parse input file
  call parse_file(fid, MPI_COMM_NULL, quiet_=.false.)
  call files_close(fid)
!
 __GET_OPT_PAR_B(defer_init_dyna, defer_init_until_dyna, .false., __STRING(__INITCTX));
!
! defer initialization until coordinates are available
 if ( defer_init_until_dyna ) then 
  __MESSAGE(whoami, 'WILL DEFER EXECUTION OF INITIALIZATION STACK UNTIL DYNAMICS');
 else
   __MESSAGE(whoami, 'EXECUTING INITIALIZATION STACK');
   if (noexec(__STRING(__INITCTX))) then
    call warning(whoami, 'CONTEXT "'//__STRING(__INITCTX)//'" DOES NOT CONTAIN EXECUTABLE STATEMENTS.', -1);
   else
    call smcv_exec(__STRING(__INITCTX))
   endif
   if (fatal_warning()) return
   call parser_clear_context(__STRING(__INITCTX))
! compute atomlist
   i=cv%amap%last
   allocate(atomlist(i+1)) ; ! include number of elements as first entry
   atomlist(1)=i ; atomlist(2:)=cv%amap%i(1:i)
   call isort('i', i, atomlist(2), ierr) ! pass second element b/c 1st contains the list size
   alist=c_loc(atomlist)
  endif
!
  initialized=.not.defer_init_until_dyna
  _ME=0
!
 endif ! defer

end function _ME
#undef _ME
!===================================================================
#define _ME smcv_dyna_from_acemd
 __CFUN(_ME, iteration_, r_acemd, f_acemd, e, alist)
 use cv_common, only : cv
 use smcv_master, only : smcv_main
 __DEP_PARSER
!
 int(C_LONG), value, intent(in) :: iteration_
 real(__FCFLOAT), intent(in), dimension(3, minimal_system_natom) :: r_acemd
 real(C_FLOAT), intent(out), dimension(3, minimal_system_natom) :: f_acemd
 real(__FCFLOAT), intent(out) :: e
 type(c_ptr), intent(out) :: alist ! send back a list of atom indices if smcv not initialized
 int(__FCINT) :: _ME
 int :: i, ierr
!
 __IAM(_ME)
!
 _ME=1 ! default return is failure
!
 e=zero ; ! not computed yet
!
 if (initialized .or. defer_init_until_dyna) then

  iteration=iteration_
!
  if (initialized) then ! just load coordinates
   r(:,atomlist(2:))=r_acemd(:,atomlist(2:))
  else
! complete initialization
   __MESSAGE(whoami, 'EXECUTING INITIALIZATION STACK');
! load all coords (we do not know which ones we will need b/c initialization is incomplete)
   r=r_acemd
   if (noexec(__STRING(__INITCTX))) then
    call warning(whoami, 'CONTEXT "'//__STRING(__INITCTX)//'" DOES NOT CONTAIN EXECUTABLE STATEMENTS.', -1);
   else
    call smcv_exec(__STRING(__INITCTX))
    call parser_clear_context(__STRING(__INITCTX))
   endif
   if (fatal_warning()) return
!
   initialized=.true.
! now the atom list should be defined -- use it below for forces
! compute atomlist
   i=cv%amap%last
   allocate(atomlist(i+1)) ; ! include number of elements as first entry
   atomlist(1)=i ; atomlist(2:)=cv%amap%i(1:i)
   call isort('i', i, atomlist(2), ierr) ! pass second element b/c 1st contains the list size
   alist=c_loc(atomlist)
  endif ! not initialized
!
  f(:,atomlist(2:))=zero ! start from zero force
  call smcv_main(__X, __Y, __Z, __XCOMP, __YCOMP, __ZCOMP, m, f(1,:), f(2,:), f(3,:), iteration)
! update acemd forces
! note that per CHARMM convention, which the plugin code inherits, forces correspond to grad V, not -grad V !
  f_acemd(:,atomlist(2:)) = - f(:,atomlist(2:))
! update energy
 endif
!
 _ME=0
!
end function _ME
#undef _ME
!===================================================================
#define _ME smcv_done_from_acemd
 __CSUB(_ME)
 use sm_var, only : smcv_initialized
 __DEP_PARSER, only : parser_done, parser_clear_context
!
 call smcv_exec(__STRING(__DONECTX))
 call parser_clear_context(__STRING(__DONECTX))
!
 call parser_done()
 if (smcv_initialized) call smcv_done()
!
 __FREE(r)
 __FREE(rcomp)
 __FREE(m)
 __FREE(q)
!
 __DEALL(atomlist)
 initialized=.false.
end
end module smcv_acemd
