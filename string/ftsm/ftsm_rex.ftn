!
!     FTSM_REX.MOD
!
!     REPLICA EXCHANGE MODULE FOR THE FINITE TEMPERATURE STRING METHOD
__CHARMM_ONLY##IF STRINGM
!
      module ftsm_rex
      __CHARMM_ONLY __DEP_KINDS
      use ivector
      use ftsm_var, only: nstring, ftsm_initialized
!
      __IMPNONE
!
      private
!
      float, save, public :: rex_beta
      int, save, allocatable, public :: rex_map(:)
      type (int_vector), save, public :: rex_log
!
      bool, save, public :: rex_initialized=.false.
!
      public ftsm_rex_init
      public ftsm_rex_done
      public ftsm_rex_set_temp
      public ftsm_rex_print_map
      public ftsm_rex_read_map
      public ftsm_rex_print_log
!
      contains
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine ftsm_rex_init(temp)
      __DEP_CONST 
!
       float, optional :: temp
       float :: t
       int :: i
!
       if (.not.rex_initialized) then
        if (present(temp)) then ; t=temp; else ; t=300d0; endif
        if (t.gt.0) rex_beta=1d0/(t*__kboltzmann)
        if (.not.ftsm_initialized) return
!
        allocate(rex_map(nstring))
        rex_map=(/ (i, i=0,nstring-1) /)
        call int_vector_init(rex_log)
        rex_initialized=.true.
       endif
!
       end subroutine ftsm_rex_init
!!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine ftsm_rex_done()
       if (rex_initialized) then
        deallocate(rex_map)
        call int_vector_done(rex_log)
        rex_initialized=.false.
       endif
       end subroutine ftsm_rex_done
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine ftsm_rex_set_temp(temp)
      __DEP_CONST 
       float, optional :: temp
       float :: t
!
       if (.not.rex_initialized) call ftsm_rex_init()
       if (present(temp)) then ; t=temp; else ; t=300d0; endif
       if (t.gt.0) rex_beta=1d0/(t*__kboltzmann)
       end subroutine ftsm_rex_set_temp
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine ftsm_rex_print_map(iunit,fmt)
      __DEP_OUTPUT
!      only root process should call
       int :: iunit
       character(len=*), optional :: fmt
!      local
       int :: i
       character(80) :: frm
       character(len=20) :: whoami
       data whoami /' FTSM_PRINT_REX_MAP>'/
!      begin
       if (.not.rex_initialized) then
        __WRN(whoami,'REX NOT INITIALIZED. NOTHING DONE.')
        return
       endif
!
       if (.not.present(fmt)) then
        write(frm,'("(",I5,"I5)")') nstring
       else
        frm=fmt
       endif
       write(iunit,frm) (/ (i, i=0,nstring-1) /)
       write(iunit,frm) rex_map(1:nstring)
       end subroutine ftsm_rex_print_map
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine ftsm_rex_read_map(iunit)
      __DEP_OUTPUT
      __DEP_MULTICOM
      __DEP_MPI 
!
#include "../mpitype.def"
!
       int :: iunit, ierror
       character(len=19) :: whoami
       data whoami /' FTSM_READ_REX_MAP>'/
!      begin
       if (.not.rex_initialized) then
        call ftsm_rex_init()
       endif
!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
        if (ME_STRNG.eq.0) then
         read(iunit,*) rex_map(1:nstring) ! first row contains indices 0 -- nstring-1
         read(iunit,*) rex_map(1:nstring) ! second row is what we want
         if (any(rex_map.lt.0)) __WRN(whoami,'READ NEGATIVE RANK.')
        endif ! ME_
        if (SIZE_STRNG.gt.1) __BROADCAST_STRING(rex_map, nstring, mpiint)
       endif ! MPI_COMM
!    broadcast to slave nodes
       if (ME_LOCAL.ne.MPI_UNDEFINED.and.SIZE_LOCAL.gt.1)               &
!     &  call MPI_BCAST(cv%rex_map, nstring, MPI_INTEGER,
!     &                     0,MPI_COMM_LOCAL,ierr)
#ifdef __CHARMM
     &  call PSND4(rex_map,nstring)     !__CHARMM_ONLY##.not.INTEGER8
     &  call PSND8(rex_map,nstring)     !__CHARMM_ONLY##INTEGER8
#else
     & __BROADCAST_LOCAL(rex_map,nstring,mpiint)
#endif
!
       end subroutine ftsm_rex_read_map
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine ftsm_rex_print_log(iunit, fmt)
!      assume that unit is prepared
!      NOTE that this is a global print!
      __DEP_MULTICOM
      __DEP_MPI
!
       int :: iunit
       character(len=*), optional :: fmt
!      local
       character(80) :: frm
       int :: i
       int4mpi :: rex_log_size4(nstring)
       int :: rex_log_size8(nstring)
       int4mpi :: rex_log_disp4(nstring)
       int :: total_size
       int, allocatable, dimension(:) :: rex_log_all
       int :: ierror, type
       bool :: qroot
!
#include "../mpitype.def"
!      do work
!      gather all data on root
       qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
!
       if (.not.rex_initialized) call ftsm_rex_init()
!
       if (qroot.and.SIZE_STRNG.gt.1) then
!     calculate size of logs
        rex_log_size8=0
!        call MPI_ALLGATHER(rex_log%last,1,type,
!     &                 rex_log_size8,1,type,
!     &                 MPI_COMM_STRNG,error)
        call MPI_GATHER(rex_log%last,1,mpiint,                            &
     &                 rex_log_size8,1,mpiint,                            &
     &                  0,MPI_COMM_STRNG,ierror)
        __BROADCAST_STRING(rex_log_size8, nstring, mpiint)
!
        total_size=sum(rex_log_size8)
        rex_log_size4=rex_log_size8 ! type cast to 4 byte int
!     allocate space to hold entire log
        allocate(rex_log_all(total_size))
!     calculate send displacements
        rex_log_disp4(1)=0;
        do i=1,SIZE_STRNG-1
         rex_log_disp4(i+1)=rex_log_disp4(i)+rex_log_size4(i)
        enddo
!      now gather the logs
!        call MPI_ALLGATHERV(rex_log%i,rex_log%last,type,
!     &                  rex_log_all,rex_log_size4,rex_log_disp4,type,
!     &                  MPI_COMM_STRNG,ierror)
        call MPI_GATHERV(rex_log%i,rex_log%last,type,                   &
     &                  rex_log_all,rex_log_size4,rex_log_disp4,type,   &
     &                  0,MPI_COMM_STRNG,ierror)
!
        if (.not.present(fmt)) then
         frm='(2I5,I8)'
        else
         frm=fmt
        endif
!
      if(ME_STRNG.eq.0.and.total_size.gt.0) write(iunit,frm) rex_log_all
!
        call int_vector_init(rex_log) ! erase log
        deallocate(rex_log_all)
       endif ! STRNG
       end subroutine ftsm_rex_print_log
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      end module ftsm_rex
!
__CHARMM_ONLY##ENDIF
