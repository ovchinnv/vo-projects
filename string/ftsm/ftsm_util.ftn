! utility function module for finite-temperature string module
      module ftsm_util
!
#if (defined(__CHARMM) || defined(__PARALLEL) )
__CHARMM_ONLY##IF STRINGM
!
      __CHARMM_ONLY __DEP_KINDS
      use ftsm_var
      __IMPNONE
!
!=====================================================================
!     SUBROUTINES
      public ftsm_check
      public ftsm_copy
      public ftsm_swap
      public ftsm_fill
      public ftsm_save_com
      public ftsm_swap_bc
      public ftsm_define_rtmd_type
      public ftsm_update_overlap_coor
!
!==================================================================================
      contains
!==================================================================================
      function ftsm_check(qorie) result (ok)
      __DEP_PARSER
      int :: error
      bool :: ok, qorie
!
      __IAM(FTSM_CHECK)
      error=0
!
      if (.not.ftsm_initialized) then
       __WRN(whoami,'FTSM NOT INITIALIZED. ABORT.')
       error=1
!
      elseif ( qorie.and.                                               &
     & ( norient.eq.0 .or. .not. associated(r_o)                        &
     &      .or. .not. associated(iatom_o))) then
       __WRN(whoami,'NO ORIENTATION ATOMS FOUND. ABORT.')
       error=2
      elseif (nforced.eq.0 .or. .not. associated(r_f)                   &
     &      .or. .not. associated(iatom_f)) then
       __WRN(whoami,'NO FORCING ATOMS FOUND. ABORT.')
       error=3
      endif
!
      ok=error.eq.0
!
      end function ftsm_check
!=================================================================================
      subroutine ftsm_swap(c1,c2)
!      __DEP_OUTPUT
      __IAM(FTSM_SWAP)
      int :: c1, c2
      float :: com(3)
!
      if (.not.ftsm_check(qorient)) return
!
      if (c1.gt.num_sets.or.c2.gt.num_sets) then
       __WRN(whoami,'INVALID COLUMN SPECIFIED. ABORT.')
       return
      else
       if (qorient) then
        if (qdiffrot) then
         r_o(:,:,dummy)=r_o(:,:,c1)
         r_o(:,:,c1)=r_o(:,:,c2)
         r_o(:,:,c2)=r_o(:,:,dummy)
        endif
! swap COMs
        com       =rcom(:,c1)
        rcom(:,c1)=rcom(:,c2)
        rcom(:,c2)=com
       endif
! forcing atoms
       r_f(:,:,dummy)=r_f(:,:,c1)
       r_f(:,:,c1)   =r_f(:,:,c2)
       r_f(:,:,c2)   =r_f(:,:,dummy)
!
      endif
!
      end subroutine ftsm_swap
!=================================================================================
      subroutine ftsm_copy(c1,c2)
      __DEP_NUMBER
      __IAM(FTSM_COPY)
      int :: c1, c2
!
      if (.not.ftsm_check(qorient)) return
!
      if (c1.gt.num_sets.or.c2.gt.num_sets) then
       __WRN(whoami,'INVALID COLUMN SPECIFIED. ABORT.')
       return
      else
       if (qorient) then
        if (qdiffrot) r_o(:,:,c2)=r_o(:,:,c1)
        rcom(:,c2) =rcom(:,c1)
       endif ! qorient
       r_f(:,:,c2)=r_f(:,:,c1)
      endif
!
      end subroutine ftsm_copy
!
!=================================================================================
      subroutine ftsm_fill(x,y,z)
      __DEP_NUMBER 
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __IAM(FTSM_FILL)
!
      float :: x(:), y(:), z(:)
      int :: i,j,n
!
      n=min(size(x), size(y), size(z))
!
      if (.not.ftsm_check(qorient)) return
!
      if (any(x.eq.__NAN).or.any(y.eq.__NAN).or.any(z.eq.__NAN)) then
       __WRN(whoami,'COORDINATE SET HAS UNDEFINED VALUES. NOTHING DONE.')
       return
      else ! if (qroot) then
       do i=1,nforced
        j=iatom_f(i)
        if (j.le.n) then
         r_f(i,1,center)=x(j)
         r_f(i,2,center)=y(j)
         r_f(i,3,center)=z(j)
        else
         __WRN(whoami,'COORDINATE ARRAY BOUNDS EXCEEDED. ABORT.')
         return
        endif
       enddo
!
       if (qorient.and.qdiffrot) then ! technically, qorient not needed because of norient below
        do i=1,norient
         j=iatom_o(i)
         if (j.le.n) then
          r_o(i,1,center)=x(j)
          r_o(i,2,center)=y(j)
          r_o(i,3,center)=z(j)
         else
          __WRN(whoami,'COORDINATE ARRAY BOUNDS EXCEEDED. ABORT.')
          return
         endif
        enddo
       endif ! qdiffrot
      endif ! x.eq.__NAN
!     remove and save center of mass of orientation atoms
!
      call ftsm_save_com()
!
      call ftsm_swap_bc(.true.) ! .true. : send to slaves
!
      r_f(:,:,left_old:right_old)=r_f(:,:,left:right)
      r_f(:,:,center_new)=r_f(:,:,center)
      if (qorient.and.qdiffrot) then
       r_o(:,:,left_old:right_old)=r_o(:,:,left:right)
       r_o(:,:,center_new)=r_o(:,:,center)
      endif
!
      end subroutine ftsm_fill
!=================================================================================
      subroutine ftsm_swap_bc(qsendo)
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __DEP_NUMBER
      bool :: qroot, qslave, qsend_o
      bool, optional :: qsendo
      float, pointer, dimension(:,:) :: rlf, rcf, rrf, rlo, rco, rro
      int :: me, ierror
      int4mpi :: stat(MPI_STATUS_SIZE)
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qslave=MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1
      if (present(qsendo)) then
        qsend_o=qsendo.and.qorient.and.qdiffrot
      else
        qsend_o=qorient.and.qdiffrot
      endif
!
! note that I can avoid sending the orientation coordinates, since they only evolve through the forced atoms
!
!
      me=mestring+1 ! slaves need me too
!
      if (qroot.and.nstring.gt.1) then
        rcf=>r_f(:,:,center)
        rlf=>r_f(:,:,left)
        rrf=>r_f(:,:,right)
!
        if (qdiffrot) then
         rco=>r_o(:,:,center)
         rlo=>r_o(:,:,left)
         rro=>r_o(:,:,right)
        endif
!     replicas send to the right and receive from the left
        if (me.eq.1) then
         call MPI_SEND(rcf, 3*nforced, MPI_DOUBLE_PRECISION,            &
     &                 me, 0, MPI_COMM_STRNG, ierror)
         if (qsend_o)                                                   &
     &    call MPI_SEND(rco, 3*norient, MPI_DOUBLE_PRECISION,           &
     &                 me, 1, MPI_COMM_STRNG, ierror)
!
        elseif (me.eq.nstring) then
         call MPI_RECV(rlf, 3*nforced, MPI_DOUBLE_PRECISION,            &
     &                 mestring-1, 0, MPI_COMM_STRNG, stat, ierror)
         if (qsend_o)                                                   &
     &    call MPI_RECV(rlo, 3*norient, MPI_DOUBLE_PRECISION,           &
     &                 mestring-1, 1, MPI_COMM_STRNG, stat, ierror)
        else ! inner replicas
         call MPI_SENDRECV(rcf, 3*nforced, MPI_DOUBLE_PRECISION, me, 0, &
     &                     rlf, 3*nforced, MPI_DOUBLE_PRECISION,        &
     &                     mestring-1, 0, MPI_COMM_STRNG, stat,ierror)
         if (qsend_o)                                                   &
     &    call MPI_SENDRECV(rco, 3*norient, MPI_DOUBLE_PRECISION, me, 1,&
     &                      rlo, 3*norient, MPI_DOUBLE_PRECISION,       &
     &                      mestring-1, 1, MPI_COMM_STRNG, stat,ierror)
        endif ! me.eq.1
!    replicas send to the left and receive from the right
        if (me.eq.nstring) then
         call MPI_SEND(rcf, 3*nforced, MPI_DOUBLE_PRECISION,            &
     &                 mestring-1, 0, MPI_COMM_STRNG, ierror)
         if (qsend_o)                                                   &
     &    call MPI_SEND(rco, 3*norient, MPI_DOUBLE_PRECISION,           &
     &                 mestring-1, 1, MPI_COMM_STRNG, ierror)
!
        elseif (me.eq.1) then
         call MPI_RECV(rrf, 3*nforced, MPI_DOUBLE_PRECISION,            &
     &                 me, 0, MPI_COMM_STRNG, stat, ierror)
         if (qsend_o)                                                   &
     &    call MPI_RECV(rro, 3*norient, MPI_DOUBLE_PRECISION,           &
     &                 me, 1, MPI_COMM_STRNG, stat, ierror)
        else ! inner replicas
         call MPI_SENDRECV(rcf, 3*nforced, MPI_DOUBLE_PRECISION,        &
     &                     mestring-1, 0,                               &
     &                     rrf, 3*nforced, MPI_DOUBLE_PRECISION,        &
     &                     me, 0, MPI_COMM_STRNG, stat,ierror)
         if (qsend_o)                                                   &
     &     call MPI_SENDRECV(rco, 3*norient, MPI_DOUBLE_PRECISION,      &
     &                     mestring-1, 1,                               &
     &                     rro, 3*norient, MPI_DOUBLE_PRECISION,        &
     &                     me, 1, MPI_COMM_STRNG, stat,ierror)
        endif ! me.eq.nstring
      endif ! qroot & nstring > 1
!
!    send to slaves
      if (qslave) then
       __BROADCAST_LOCAL_8B(r_f(:,:,left),9*nforced) ! send three sets at once (see ftsm_var)
       if (qsend_o) __BROADCAST_LOCAL_8B(r_o(:,:,left),9*norient)
      endif
!
!     duplicate endpoints for force calculations:
!
      if (me.eq.1) then
       r_f(:,:,left)=r_f(:,:,center)
       if (qsend_o) then
        r_o(:,:,left)=r_o(:,:,center)
       endif
!
      elseif (me.eq.nstring) then
       r_f(:,:,right)=r_f(:,:,center)
       if (qsend_o) then
        r_o(:,:,right)=r_o(:,:,center)
       endif
      endif
!
!    update any orientation coordinates that have changes
      if (qorient.and.qdiffrot) call ftsm_update_overlap_coor(ithree)
!
      end subroutine ftsm_swap_bc
!=================================================================================
      subroutine ftsm_save_com(c)
      __DEP_NUMBER
!      float :: r_com(3)
      float :: w
      float, pointer :: ro_com(:)
      int, optional :: c
      int :: col, i
      float, pointer, dimension(:,:) :: ro, rf
!
! compute and save COM of current reference structure
!
      if (qorient) then
!
        if (present(c)) then ; col=c ; else ; col=center ; endif
        if (col.le.num_sets.and.col.gt.0) then
         ro_com=>rcom(:,col)
!
!         r_com=ro_com ! save old COM
         ro_com=zero   ! will recompute COM using new weights
         ro  => r_o(:,:,col)
         rf  => r_f(:,:,col)
!       compute new COM
         do i=1, norient
          w=orientWeights(i)
          ro_com(1)=ro_com(1) + w * ro(i,1)
          ro_com(2)=ro_com(2) + w * ro(i,2)
          ro_com(3)=ro_com(3) + w * ro(i,3)
         enddo
! translate orientation structure to centroid
         ro(:,1)=ro(:,1) - ro_com(1)
         ro(:,2)=ro(:,2) - ro_com(2)
         ro(:,3)=ro(:,3) - ro_com(3)
! translate forcing structure to centroid
         if (qdiffrot) then
          rf(:,1)=rf(:,1) - ro_com(1)
          rf(:,2)=rf(:,2) - ro_com(2)
          rf(:,3)=rf(:,3) - ro_com(3)
         endif
! centroid relative to original coords:
!         ro_com = ro_com + r_com ! this is no longer useful; VO 1/2013
       endif
      endif
!
      end subroutine ftsm_save_com
!========================================================================================
      subroutine ftsm_lift(x, y, z)
!
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_OUTPUT
      __DEP_NUMBER
!
      float :: x(:), y(:), z(:)
!
! local variables
      float :: u(3,3)= Id3
      float, pointer :: r_com(:), ow(:)
      float, pointer, dimension(:,:) :: roi, roc, rfc, roc_rot, rfc_rot
!
      int :: j, k
!
      int :: natom, ind
!
      __IAM(FTSM_LIFT)
!
! check if the user has made an initialization call to the minimizer
!
      if (.not.ftsm_check(qorient)) return
!
!    create coordinate arrays
!
      ow=>orientWeights
      r_com=>rcom(:,instant)
      roi=>r_o(:,:,instant)
      roc=>r_o(:,:,center)
      rfc=>r_f(:,:,center)
      roc_rot=>r_o(:,:,center_rot)
      rfc_rot=>r_f(:,:,center_rot)
      natom=size(x,1)
! copy string coordinates to corresponding instantaneous coordinates
! first, align string coordinates with the instantaneous coordinates, if needed
!
      if (qorient) then
        do k=1,norient
          ind=iatom_o(k)
          roi(k,1)=x(ind)
          roi(k,2)=y(ind)
          roi(k,3)=z(ind)
        enddo
!
!       translate forced atoms to centroid
!
        r_com(:)=0d0;
        do j=1,3 ; do k=1, norient;
          r_com(j) = r_com(j)+ow(k)*roi(k,j)
        enddo ;    enddo
!
        roi(:,1)=roi(:,1)-r_com(1)
        roi(:,2)=roi(:,2)-r_com(2)
        roi(:,3)=roi(:,3)-r_com(3)
!
      endif ! qorient
!
      if (qorient) then ! orient center image w.r.t. instantaneous coordinates
       call RMSBestFit(roi,roc,ow,u) ! superpose roi onto roc (assuming string is COM-free)
!
       rfc_rot = matmul(rfc, u) !          apply transpose (=inverse) of u to rfc
       rfc_rot(:,1)=rfc_rot(:,1)+r_com(1)
       rfc_rot(:,2)=rfc_rot(:,2)+r_com(2)
       rfc_rot(:,3)=rfc_rot(:,3)+r_com(3)
!
       if (qdiffrot) then
!     move to COM of the instantaneous coordinates
        roc_rot = matmul(roc, u) !          apply transpose (=inverse) of u to roc
        roc_rot(:,1)=roc_rot(:,1)+r_com(1)
        roc_rot(:,2)=roc_rot(:,2)+r_com(2)
        roc_rot(:,3)=roc_rot(:,3)+r_com(3)
!     insert orientation coordinates into all-atom coordinate array
        do k=1,norient
         ind=iatom_o(k)
         x(ind)=roc_rot(k,1)
         y(ind)=roc_rot(k,2)
         z(ind)=roc_rot(k,3)
        enddo
       endif ! qdiffrot
      else ! no orientation
       rfc_rot=>rfc
      endif ! qorient
!
!     insert forced coordinates into all-atom coordinate array
!
      do k=1,nforced
        ind=iatom_f(k)
        x(ind)=rfc_rot(k,1)
        y(ind)=rfc_rot(k,2)
        z(ind)=rfc_rot(k,3)
      enddo
!
      end subroutine ftsm_lift
!===========================================================================
      subroutine ftsm_define_rtmd_type()
      use sm_config, only: sizeofreal
      __DEP_MPI
      __DEP_NUMBER
!
      int4mpi :: error, norient_mpi
      integer(kind=MPI_ADDRESS_KIND) :: lb, extent
!
!    create custom type for gathering array of shape (norient,3), in rows
!    taken from rtmd code
!
      if (MPI_RTMD_TYPE.ne.MPI_DATATYPE_NULL)                           &
     &  call mpi_type_free(MPI_RTMD_TYPE, error)
      if (MPI_RTMD_TYPE_.ne.MPI_DATATYPE_NULL)                          &
     & call mpi_type_free(MPI_RTMD_TYPE_, error)
!
      if (norient.gt.0) then
       lb=0
       extent=sizeofreal
       norient_mpi=norient
       call mpi_type_vector(3, 1, norient_mpi,                         &
     &   MPI_DOUBLE_PRECISION, MPI_RTMD_TYPE_, error)
!    corresponding resized type
       call mpi_type_create_resized(MPI_RTMD_TYPE_,lb,extent,           &
     &   MPI_RTMD_TYPE, error)
       call mpi_type_commit(MPI_RTMD_TYPE, error)
      endif
!
      end subroutine ftsm_define_rtmd_type
!=================================================================
      subroutine ftsm_update_overlap_coor(which)
      int :: which
      int :: i
!    copy overlapping coordinates from one set to another
      if (which.eq.1) then
       do i=1, nboth
        r_o(iatom_both(2,i), :, center)=r_f(iatom_both(1,i), :, center)
       enddo
      elseif (which.eq.2) then
       do i=1, nboth
        r_f(iatom_both(1,i), :, center)=r_o(iatom_both(2,i), :, center)
       enddo
      elseif (which.eq.3) then ! special case of left:right sets all being updated
       do i=1, nboth
        r_o(iatom_both(2,i), :, left:right)=                            &
     &  r_f(iatom_both(1,i), :, left:right)
       enddo
      endif
!
      end subroutine ftsm_update_overlap_coor

__CHARMM_ONLY##ENDIF
#endif
      end module ftsm_util
!
