! finite-temperature string method
      module ftsm ! finite-temperature string method
!
#if (defined(__CHARMM) || defined(__PARALLEL) )
__CHARMM_ONLY##IF STRINGM
!
      __CHARMM_ONLY __DEP_KINDS
      use ftsm_var
      use ftsm_voronoi
      use ftsm_compute
      use ftsmv2_compute
      use ftsm_stats
      use ftsm_io
      use ftsm_util
      use ftsm_rep
      use ftsm_min
      use ftsm_connect
      __DEP_BESTFIT ! , only : RMSBestFit, rmsd
      __IMPNONE
!
      private
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     SUBROUTINES
!
      public ftsm_parse
      public ftsm_main
      private ftsm_compute_fe_fd
      private ftsm_update_overlap_coor
      private ftsm_init
      private ftsm_done
      private ftsm_list_atoms
      private ftsm_set_weights
      private ftsm_lift
      private ftsm_test_grad_fd
      private ftsm_test_parallel
      private ftsm_evolve
      private ftsm_repl_exchange
!
      contains
!
      subroutine ftsm_parse(COMLYN,COMLEN)
      use ftsm_rex, only: ftsm_rex_set_temp
      use ftsm_voronoi, only: ftsm_voronoi_map, ftsm_voronoi_initialized, ftsm_voronoi_whereami
!----------------------------------------------------------------------
! command parser for the finite temperature string
!----------------------------------------------------------------------
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_NUMBER 
      __DEP_MULTICOM
      __DEP_CONST 
      __DEP_MPI 
      __DEP_SELECT
      __DEP_COORDINATES
      __DEP_SIZE
!
#ifdef __CHARMM
      use ctitla
! need BNBND, BIMAG for ftsm_mini
      use bases_fcm, only : BNBND, BIMAG
#endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      character(len=*) :: comlyn
      int :: comlen
! local variables
__CHARMM_ONLY  int :: ivver, ivv2, iorig, ileap, error  ! for dynamics
      int :: klen
!
      __IAM(FTSM)
      character(len=16) :: keyword
      character(len=80) :: fname
      float :: zval, k, step, voro_cut
      int :: ifile, c1, c2, qcor, qdcd, flen,            &
     &           num_ave_samples, irep, i, a,            &
     &           iorie, irmsd, ierror, me
      float :: t, omt
!
#ifdef __CHARMM
      int :: imode
      int :: oldiol, isele
      int :: iselct(natom)
#else
      int :: natom
 __DECLARE_DMOL_SELECT
#endif
      float, pointer :: fd_error(:,:)
!
      bool :: qroot, qslave, qprint, qcomp, voronoi_check_map, ok, &
     &        qangstrom
!
 __DECLARE_MSGBUF
!
#include "../../mpitype.def"
!
      keyword=__NEXTA(comlyn,comlen)
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qslave=((MPI_COMM_LOCAL.ne.MPI_COMM_NULL).and.SIZE_LOCAL.gt.1)
      qprint=qroot.and.ME_STRNG.eq.0
!
! check for smcv initialization; quit if initialized
      if (smcv_initialized) then
       __WRN(whoami,' SMCV IS ON AND CANNOT BE USED WITH FTSM. NOTHING DONE.')
       return
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (__STRNCMP(keyword,'INIT',4)) then
        qver2=(__INDX_RM(comlyn, comlen, 'VER2').gt.0)
        if (.not.qver2) qver2=(__INDX_RM(comlyn, comlen, 'V2').gt.0)
!===== ! check for distance scaling
        ftsm_scaledist = .not.(__INDX_RM(comlyn, comlen, 'NOSC').gt.0) ! distance scaling is on by default
!===== for now, unscaled distances are only supported in version 2
        if (qver2.and..not.ftsm_scaledist) then
         __WRN(whoami, ' ABSOLUTE (UNSCALED) DISTANCES ARE ONLY SUPPORTED IN FTSM VERSION 2. TURNING SCALING ON.')
         ftsm_scaledist=.true.
        endif
!
        call ftsm_init()
        return
      endif
!===================================================================
      if (.not.ftsm_initialized) then
        call ftsm_init()
      endif
!===================================================================
      if (__STRNCMP(keyword,'DONE',4)) then
        call ftsm_done()
!===================================================================
      elseif (__STRNCMP(keyword,'REPA',4)) then
       if (comlen.gt.0) then ! this is an initialization call!
        call ftsm_repa_init(comlyn, comlen)
       else
        if (ftsm_check(qorient)) call ftsm_repa()
       endif
!===================================================================
      elseif (__STRNCMP(keyword,'MINI',4)) then
       if (comlen.gt.0 .or. .not. ftsm_mini_initialized ) then ! this is an initialization call
        call ftsm_mini_init(comlyn, comlen)
       else
        if (ftsm_check(qorient)) then
         if (qorient.and.any(__XX(iatom_o(1:norient)).eq.__NAN)) then
         __WRN(whoami,'MAIN ORIENTATION X-SET HAS UNDEFINED VALUES. NOTHING DONE.')
         else
          call ftsm_mini(__XX(1:natom), __YY(1:natom), __ZZ(1:natom) &
#ifdef __CHARMM
     &                                         ,WMAIN(1:natom), BNBND, BIMAG     &
#endif
     &                                         )
         endif ! qorient
        endif ! ftsm_check
       endif ! comlen
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'RECO',4)) then
       if (comlen.gt.0 .or. .not. ftsm_connect_initialized ) then ! process options or initialize
        call ftsm_reconnect_parse(comlyn, comlen)
       else
        if (ftsm_check(qorient)) call ftsm_reconnect(-ione) ! pass phony time
       endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'ORIE',4)) then
! perform a best-fit orientation of all instantaneous coordinates using 
! specified coordinates for orientation;
! all replica coordinates will be modified; the first replica
! will have its COM removed (computed using selected atoms);
! and the other replicas will in addition be each superposed onto the
! previous replica. I note that this function belongs more naturally
! with the ZTS, and may be moved there.
!
! this _may_ be useful for ftsm without bestfit orientation
       call ftsm_orient(comlyn, comlen)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'STAT',4)) then
       if (comlen.gt.0) then ! this is an initialization call!
        call ftsm_stat_init(comlyn, comlen)
       else
        call ftsm_stat()
       endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'DYNA',4)) then
#ifdef __CHARMM
!ccccc will assume that other distributions specify dynamics elsewhere ccccccc
       ivver=__INDX_RM(comlyn, comlen, 'VVER')
       ivv2=__INDX_RM(comlyn, comlen, 'VV2')
       iorig=__INDX_RM(comlyn, comlen, 'ORIG')
       ileap=__INDX_RM(comlyn, comlen, 'LEAP')
       if ((ivver+ivv2+iorig).gt.0) then
        __WRN( whoami,'ONLY LEAP-FROG DYNAMICS ARE SUPPORTED. NOTHING DONE')
        return
       endif
!      force LEAP DYNAMICS
       call joinwd(comlyn, mxcmsz, comlen, 'LEAP ', 5)
#endif
!ccccccccccccccc PARSE OTHER DYNAMICS OPTIONS
! code from SMCV
       voronoi_hist_on=(__INDX_RM(comlyn,comlen,'VORO').gt.0)
       if (voronoi_hist_on) then
        voronoi_allow_cross=(__INDX_RM(comlyn,comlen, 'VCRS').gt.0)
        if (voronoi_allow_cross) then
         voronoi_update_freq=__GET_RM_I(comlyn,comlen,'VCRF',0)
         if (voronoi_update_freq.le.0) then
          __WRN(whoami,'MUST SPECIFY POSITIVE VCRF. VORONOI CELL CROSSING DISABLED.')
          voronoi_allow_cross=.false.
         elseif (__INDX(comlyn, comlen, 'VINI',4).gt.0) then ! if vini is present
          voronoi_nocross_ini=__GET_RM_I(comlyn,comlen,'VINI',0) ! get it
          if (voronoi_nocross_ini.le.0) then
           __WRN(whoami,'NONPOSITIVE VINI SPECIFIED. WILL SET TO ZERO.')
           voronoi_nocross_ini=0
          endif ! voronoi_nocross_ini>0
         else
          voronoi_nocross_ini=0
         endif ! voronoi_nocross_ini present
        endif ! voronoi_allow_cross
!
!    initialize Voronoi data
        if (.not.ftsm_voronoi_initialized) call ftsm_voronoi_init()
!    standard V. calculation case -- no crossing
        compute_whereami=.false.
        if (.not.voronoi_allow_cross) then
!    create standard map (unless map is present)
         if (all(ftsm_voronoi_map.eq.-1)) then
          ftsm_voronoi_map=(/ (i, i=1, nstring) /)
          compute_whereami=.true. ! will be computed by dynamc routine
         endif
        endif
!
        voronoi_check_map=(__INDX_RM(comlyn,comlen, 'CHCK').gt.0)
!
!    compute whereami
!
        if (voronoi_check_map) then
         if (qprint) then
          write(_MSGBUF, 660) whoami ; __PRINT(_MSGBUF)
         endif
 660  FORMAT(A,' CHECKING VORONOI MAP AGAINST CURRENT COORDINATES.')
!
         compute_whereami=.false.
         call ftsm_voronoi_whereami_compute(__X,__Y,__Z)
!
         if (all(ftsm_voronoi_map.ne.-1)) then ! does the map have valid entries
           me=ftsm_voronoi_map(mestring+1)
!    compare me and whereami:
           if (qroot) then
            if(SIZE_STRNG.gt.1) then
             call MPI_ALLREDUCE(me.eq.ftsm_voronoi_whereami, ok,          &
     &         1, mpibool, MPI_LAND, MPI_COMM_STRNG, ierror)
            else
             ok=me.eq.ftsm_voronoi_whereami
            endif
           endif ! qroot
           if (qslave) then 
            __BROADCAST_LOCAL_4B(ok,1)
           endif
           if (.not.ok) then
            __WRN(whoami,'VORONOI MAP INCONSISTENT WITH CURRENT COORDINATES. ABORTING.')
            return
           endif ! .not. ok
         else ! voronoi map invalid (or was not read); proceed anyway using current whereami
          __WRN( whoami,'VORONOI MAP CONTAINS INVALID ENTRIES.')
         endif ! ftsm_voronoi_map.ne.-1
!
        else
         ftsm_voronoi_whereami=ftsm_voronoi_map(mestring+1)
        endif ! voronoi_check_map
!
       endif ! voronoi_hist_on
!      reset internal interation counter for ftsm_master
       olditeration=0
!
       update_on=(__INDX_RM(comlyn,comlen, 'UPDA').gt.0)
       if (update_on) then
        update_freq=__GET_RM_I(comlyn,comlen,'UPDF',0)
        if (update_freq.le.0) then
         __WRN( whoami,'UPDATE FREQUENCY INVALID OR UNSPECIFIED. WILL NOT UPDATE.')
         update_on=.false.
        else
         repa_on=(__INDX_RM(comlyn,comlen, 'REPA').gt.0)
         ftsm_mini_on=(__INDX_RM(comlyn,comlen, 'MINI').gt.0)
         ftsm_reconnect_on=(__INDX_RM(comlyn,comlen, 'RECO').gt.0)
        endif
       endif
!
       stat_on=(__INDX_RM(comlyn,comlen, 'STAT').gt.0)
       if (stat_on) then
        stat_freq=__GET_RM_I(comlyn,comlen,'STAF',0)
        if (stat_freq.le.0) then
         __WRN( whoami,'STATISTICS FREQUENCY INVALID OR UNSPECIFIED.')
         stat_on=.false.
        endif
       endif ! stat_on
!
       evolve_ftsm_on=(__INDX_RM(comlyn,comlen, 'EVOL').gt.0)
       if (evolve_ftsm_on) then
        evolve_freq=__GET_RM_I(comlyn,comlen,'EVOF',0)
        if (evolve_freq.le.0) then
         __WRN( whoami,'EVOLUTION FREQUENCY INVALID OR UNSPECIFIED. WILL NOT EVOLVE.')
         evolve_ftsm_on=.false.
        endif
       endif ! evolve_ftsm_on
!
       if (evolve_ftsm_on) then ! still on (see above)
        evolve_nskip=__GET_RM_I(comlyn,comlen,'EVOS',0)
!
! ----- types of evolution
!
        evolve_expo_on=(__INDX_RM(comlyn,comlen,'EXPO').gt.0) ! use exponential convolution
        if (evolve_expo_on) then
         evolve_expo_mem=__GET_RM_F(comlyn,comlen,'MEMO',0.999d0)
        endif
!
        evolve_aver_on=(__INDX_RM(comlyn,comlen,'AVER').gt.0) ! r_ref=mean(r_inst)
        if (evolve_aver_on) then
         num_evolve_samples=0
         max_evolve_samples=0
!        setting this large will dampen initial fluctuations
         if (__INDX(comlyn, comlen,'NAVE' ,4).gt.0) then
          num_ave_samples=__GET_RM_I(comlyn,comlen,'NAVE',-1)
          if (num_ave_samples.gt.0) then
            num_evolve_samples=num_ave_samples
          else
           __WRN(whoami, 'INVALID NUMBER OF SAMPLES SPECIFIED. WILL SET TO ZERO.')
          endif ! num_samples
         endif ! NAVE
!
         if (__INDX(comlyn, comlen,'MAXAVE',6).gt.0) then
          num_ave_samples=__GET_RM_I(comlyn,comlen,'MAXAVE',-1)
          if (num_ave_samples.gt.0) then
            max_evolve_samples=num_ave_samples
          else
  __WRN(whoami,'INVALID MAXIMUM NUMBER OF SAMPLES SPECIFIED. WILL SET TO ZERO.')
          endif ! num_samples
         endif ! MAXAVE
        endif ! evolve_aver
!
        i=0
        if (evolve_expo_on)   i=i+1
        if (evolve_aver_on)   i=i+1
!
        if (i.gt.1) then
         __WRN( whoami,'MORE THAN ONE EVOLUTION SCHEME REQUESTED. WILL USE EXPO.')
         evolve_expo_on=.true.
         evolve_aver_on=.false.
        endif
!
        if (i.eq.0) then
         __WRN( whoami,'EVOLUTION SCHEME UNSPECIFIED. WILL USE EXPO.')
         evolve_expo_on=.true.
         evolve_aver_on=.false.
        endif
       endif ! evolve_ftsm_on
!
       if (update_on.and..not.(evolve_ftsm_on.or.repa_on.or.ftsm_mini_on)) then
        __WRN( whoami,'EVOLUTION, REPARAMETRIZATION AND MINIMIZATION ARE ALL DISABLED. UPDATE IS OFF.')
        update_on=.false.
       endif
!
       restrained_on=(__INDX_RM(comlyn,comlen, 'RSTR').gt.0)
       if (restrained_on) then
        restrained_eq_steps=__GET_RM_I(comlyn,comlen,'REEQ',0)
        if (restrained_eq_steps.lt.0) then
          __WRN(whoami,'REEQ CANNOT BE NEGATIVE. WILL SET TO ZERO.')
          restrained_eq_steps=0
        endif
        restrained_eq0=0
! scale force constants and restraint reference values, if necessary
!
        if (.not.ftsm_scaledist.or.  &
&                                  qkpara_angstrom.or.qkperp_angstrom.or.qdperp_angstrom.or.qdperpf_angstrom) then
         call ftsm_compute_arcl_curv(linear)
!writE(0,*) 'DARCL : ', ds ! aa
         zval = sum(ds) / ( max( nstring-1 , 1 ) ) * sqrt3 ; ! sqrt(3) makes the arclength correspond to the RMSD in 3D
!
         if (.not.ftsm_scaledist) then ! need to compute reference distance from string length
          if (mestring.eq.0) then ; dpar0=zero ; else ; dpar0 = zval ; endif ; dpar0i=dpar0 ! left endpoint uses one sided tangent (see ftsm14 paper)
          if (qprint) then ; write(_MSGBUF,6713) whoami, ftoa(zval)
          __PRINT(_MSGBUF) ;
          endif
 6713 format(A,' AVERAGE COMPUTED ARCLENGTH INCREMENT IS ',A,' ANG.')
!
         else ! options valid for scaled version
          zval=two*zval ! gives 2L/(M-1) , i.e. || q-p ||
!
          if (qkpara_angstrom) then
           fname='PARALLEL FORCE CONSTANT (KPAR)' ; kpara = kpara * zval**2 ;
           if (qprint) then ; write(_MSGBUF,6712) whoami, trim(fname), ftoa(zval), ftoa(kpara)
           __PRINT(_MSGBUF) ;
           endif
           qkpara_angstrom=.false. ! make sure no additional scaling will occur if there are multiple runs per initialization
          endif
          if (qkperp_angstrom) then
           fname='PERPENDICULAR FORCE CONSTANT (KPRP)' ; kperp = kperp * zval**2 ;
           if (qprint) then ; write(_MSGBUF,6712) whoami, trim(fname), ftoa(zval), ftoa(kperp)
           __PRINT(_MSGBUF)
           endif
           qkperp_angstrom=.false.
          endif
          if (qdperp_angstrom) then
           fname='REFERENCE TUBE WIDTH (DPRP)' ; dperp0 = dperp0 / zval ; dperp0i = dperp0i / zval ;
           if (qprint) then ; write(_MSGBUF,6712) whoami, trim(fname), ftoa(zval), ftoa(dperp0)
           __PRINT(_MSGBUF)
           endif
           qdperp_angstrom=.false.
          endif
          if (qdperpf_angstrom) then
           fname='FINAL REFERENCE TUBE WIDTH (DPRPF)' ; dperp0f = dperp0f / zval ;
           if (qprint) then ; write(_MSGBUF,6712) whoami, trim(fname), ftoa(zval), ftoa(dperp0f)
           __PRINT(_MSGBUF)
           endif
           qdperpf_angstrom=.false.
          endif
!
         endif ! .not. ftsm_scaledist
!
 6712 format(A,' SCALING ',A,' BY 2 x INTER-REPLICA DS (',A,' ANG). NEW VALUE IS ',A)
        endif ! ftsm_scaledist .or. ...
!
       endif ! if restrained_on
!
! VO 4/14 : taken from SMCV to allow transient unrestrained dynamics for more aggressive path exploration
!
       unrestrained_on=(__INDX_RM(comlyn,comlen, 'URES').gt.0)
       if (unrestrained_on) then
        unrestrained_eq_steps=__GET_RM_I(comlyn,comlen,'UREQ',0)
        unrestrained_eq0=0
        restrained_eq0=0
! currently unrestrained dynamics works as a preliminary step for restrained dynamics, therefore :
        if (.not.restrained_on) then
         __WRN(whoami, 'UNRESTRAINED (EXPLORATION) DYNAMICS REQUIRES EQUILIBRATION WITH RESTRAINTS ("RSTR"). TURNING OFF.');
         unrestrained_on=.false.
        endif
       endif
!
       repl_x_on=(__INDX_RM(comlyn,comlen,'REX').gt.0)
       if (repl_x_on) then
        repl_x_freq=__GET_RM_I(comlyn,comlen,'REXF',0)
        repl_x_temp=__GET_RM_F(comlyn,comlen,'REXT',0d0)
!
        if (repl_x_freq.le.0) then
          __WRN(whoami,'MUST SPECIFY POSITIVE REXF. REPLICA EXCHANGE IS OFF.')
          repl_x_on=.false.
        elseif (repl_x_temp.le.0) then
          __WRN(whoami,'MUST SPECIFY POSITIVE REXT. REPLICA EXCHANGE IS OFF.')
          repl_x_on=.false.
        else
          call ftsm_rex_set_temp(repl_x_temp)
        endif
       endif ! repl_x_on
!
       if (update_on.or.repl_x_on) then ! decrease output
         string_noprint=(__INDX_RM(comlyn,comlen,'NOPR').gt.0)
       endif
!--------------- DONE PARSING DYNAMICS OPTIONS -----
!    print summary
!cccccccccccccccccc STRING METHOD OPTIONS cccccccccccccccccccccc
       if (qprint) then
        WRITE (_MSGBUF,'(2A)') whoami, ' STRING METHOD ENABLED.'; __PRINT(_MSGBUF)
        if (evolve_ftsm_on) then
            WRITE (_MSGBUF,'(/,2A,/,2A,I7,A)')                          &
     &      whoami, ' STRING EVOLUTION ENABLED.',                       &
     &      whoami, ' WILL EVOLVE AFTER EVERY ',                        &
     &      evolve_freq,' ITERATIONS.'; __PRINT(_MSGBUF)
            if (update_on.and.evolve_nskip.gt.0) then
             WRITE (_MSGBUF,'(2A,I7,A)')                                 &
     &       whoami, ' THE FIRST', evolve_nskip,                         &
     &       ' ITERATIONS AFTER IMAGE UPDATE WILL NOT CONTRIBUTE TO STRING EVOLUTION.'; 
             __PRINT(_MSGBUF)
            endif
            if (evolve_expo_on) then
               write(_MSGBUF,671) whoami, whoami, evolve_expo_mem ; __PRINT(_MSGBUF)
 671  format(A,' STRING EVOLUTION WILL BE OF THE FORM:',/,              &
     &       A,' R(N+1)=A*R(N)+(1-A)*RINST, A=',F9.5,'.')
            elseif (evolve_aver_on) then
               write(_MSGBUF,6710) whoami, whoami, num_evolve_samples ; __PRINT(_MSGBUF)
 6710 format(A,' CV EVOLUTION WILL BE OF THE FORM:',/,                  &
     & A,' R(N)=AVERAGE_0^{N}(RINST).  INITIAL NUMBER OF SAMPLES IS ',  &
     & I9,'.')
             if (max_evolve_samples.gt.0)                               &
     &          write(_MSGBUF, 6711) whoami, max_evolve_samples ; __PRINT(_MSGBUF)
 6711 format(A, ' ONLY THE MOST RECENT ', I9,' SAMPLES WILL BE USED.')

            endif
        endif ! evolve_ftsm_on
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (update_on) then
          WRITE (_MSGBUF,666) whoami, update_freq ;      __PRINT(_MSGBUF)
 666  format(A,' WILL UPDATE IMAGES AFTER EVERY ',I7,' ITERATIONS.')
         if (ftsm_mini_on) then
 669  format(A,' WILL MINIMIZE STRING DURING UPDATE ')
          WRITE (_MSGBUF,669) whoami 
          __PRINT(_MSGBUF)
         endif ! mini
         if (repa_on) then
 667  format(A,' WILL REPARAMETRIZE STRING DURING UPDATE ')
          WRITE (_MSGBUF,667) whoami 
          __PRINT(_MSGBUF)
         endif
        endif ! update_on
!===================================================================
        if (restrained_on) then
         WRITE (_MSGBUF,'(2A)') whoami, ' WILL USE RESTRAINED DYNAMICS.'
         __PRINT(_MSGBUF)
!
         if (unrestrained_on) then
          WRITE (_MSGBUF,'(2A)') whoami, ' WILL USE UNRESTRAINED (EXPLORATION) DYNAMICS.'
          __PRINT(_MSGBUF)
          unrestrained_eq0=0
          WRITE (_MSGBUF,664) whoami, unrestrained_eq_steps ; __PRINT(_MSGBUF)
 664  format(A,' WILL EQUILIBRATE UNDER CV RESTRAINTS FOR ', I7, ' STEPS.')
         endif ! unrestrained_on
!
         write(_MSGBUF,665) whoami, restrained_eq_steps
         __PRINT(_MSGBUF)
 665  format(A, ' WILL ADJUST TO NEW RESTRAINTS OVER ',I11, ' STEPS.')
!       proj_on is necessary to compute free energies
         if (proj_on) then
            write (_MSGBUF,'(2A)') whoami,                                 &
     & ' WILL RESTRAIN SYSTEM TO PLANE PERPENDICULAR TO PATH.' ; __PRINT(_MSGBUF)
         else
            write (_MSGBUF,'(2A)') whoami,                                 &
     & ' WILL RESTRAIN SYSTEM TO PATH IMAGE. (FE/MFPT CANNOT BE COMPUTED).' ; __PRINT(_MSGBUF)
         endif ! proj_on
        else
!
        endif !restrained
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (stat_on) then
            write(_MSGBUF,668) whoami, stat_freq ;                __PRINT(_MSGBUF)
 668  format(A, ' WILL OUTPUT STRING STATISTICS AFTER EVERY ',I7, ' STEPS.')
        endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (repl_x_on) then
            write(_MSGBUF,691) whoami, whoami, repl_x_freq, repl_x_temp
            __PRINT(_MSGBUF)
 691  format(A, ' WILL ATTEMPT TO EXCHANGE NEIGHBORING REPLICAS ',/     &
     &       A, ' ONCE IN EVERY ',I6,' ITERATIONS AT ',F11.3, ' K.')
        endif ! repl_x_on
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (voronoi_hist_on) then
            write(_MSGBUF,670) whoami ; __PRINT(_MSGBUF)
 670  format(A, ' WILL COMPUTE FREE ENERGY ALONG STRING USING VORONOI TESSELLATION.' )
         if (voronoi_allow_cross) then
          write(_MSGBUF,601) whoami ; __PRINT(_MSGBUF)
          write(_MSGBUF,602) whoami, whoami, voronoi_update_freq ; __PRINT(_MSGBUF)
          if (voronoi_nocross_ini.gt.0) then
           write(_MSGBUF, 603) whoami, whoami, voronoi_nocross_ini ; __PRINT(_MSGBUF)
          endif
 601  format(A, ' WILL ALLOW REPLICAS TO CROSS BETWEEN V. CELLS.')
 602  format(A, ' WILL UPDATE CROSSING STATISTICS ONCE IN EVERY',/,     &
     &      A, I6, ' ITERATIONS.')
 603  format(A, ' WILL DISALLOW CROSSING DURING THE INITIAL ',/,A,I6,   &
     &       ' ITERATIONS.')
         endif
         if (restrained_on) then 
          write(_MSGBUF,'(2A,/2A)')   &
     &      whoami, ' STRING DYNAMICS SHOULD BE USED WITH CAUTION',     &
     &      whoami, ' DURING VORONOI FE COMPUTATION.' ; __PRINT(_MSGBUF)
         endif
         if (update_on) then
          if (.not.voronoi_allow_cross) then
           write(_MSGBUF,'(2A,/2A)')                                       &
     &    whoami, ' STRING UPDATE DURING VORONOI FE COMPUTATION IS',     &
     &    whoami, ' EXPERIMENTAL AND SHOULD BE USED WITH CAUTION ' ; __PRINT(_MSGBUF)
          else
           write(_MSGBUF,'(2A,/2A,/2A)')                                   &
     &    whoami, ' STRING CANNOT BE UPDATED ON THE FLY',     &
     &    whoami, ' IF VORONOI CELL CROSSING IS ALLOWED.',      &
     &    whoami, ' VORONOI CELL CROSSING WILL BE OFF.' ; __PRINT(_MSGBUF)
           voronoi_allow_cross=.false.
          endif ! voronoi_allow_cross
         endif ! update_on
        endif ! voronoi_hist_on
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       endif ! qprint
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       call ftsm_save_com()       ! recompute COM in case weights changed
       call ftsm_swap_bc(.true.)  ! update boundary replicas (with new COM-free structures)
!      turn on string for dynamics
       ftsm_on=.true.
       ftsm_ini_iteration = -ione ! will be computed by ftsm_main
!      call dynamics parser
       call dynopt(comlyn, comlen)
!cccccc turn off string for regular dynamics ccccccc
       ftsm_on=.false.
       repa_on=.false. ! turn off after dynamics because SM0K also uses this flag; therefore a subsequent minimization would call reparametrization
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccc ADDITIONAL VORONOI OPTIONS cccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'VORO',4)) then
!    get voronoi command
       keyword=__NEXTA(comlyn,comlen)
       if (__STRNCMP(keyword,'VMAP',4)) then
        if (__INDX_RM(comlyn, comlen, 'CALC').gt.0) then
          if (qprint) then ; write(_MSGBUF,6010) whoami ; 
          __PRINT(_MSGBUF) ; endif
 6010 format(A,' WILL CALCULATE VORONOI MAP FROM MAIN COORDINATES.')
          call ftsm_voronoi_whereami_compute(__X,__Y,__Z)
!    put 'whereami' into the map
          if (qroot.and.SIZE_STRNG.gt.1) then
           call MPI_ALLGATHER(ftsm_voronoi_whereami, 1, mpiint,       &
     &      ftsm_voronoi_map, 1, mpiint, MPI_COMM_STRNG, ierror)
          else
           ftsm_voronoi_map(mestring+1)=ftsm_voronoi_whereami
          endif
          if (qslave) then
#ifdef __CHARMM
          __BROADCAST_LOCAL_4B(ftsm_voronoi_map,nstring)  !__CHARMM_ONLY##.not.INTEGER8
          __BROADCAST_LOCAL_8B(ftsm_voronoi_map,nstring)  !__CHARMM_ONLY##INTEGER8
#elif defined (__DMOL)
          __BROADCAST_LOCAL(ftsm_voronoi_map,nstring,mpiint)
#endif
!
          endif
!    print cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        elseif (__INDX_RM(comlyn, comlen, 'PRIN').gt.0) then
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
          if (qroot) then
           if (flen.GT.0) then
            if (qprint) then 
             __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
             write(_MSGBUF,6011) whoami, fname(1:flen) ; __PRINT(_MSGBUF)
            endif
 6011 format(A,' WRITING VORONOI MAP TO FILE ',A,'.')
            call ftsm_voronoi_print_map(ifile)
            if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
           else
            __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
           endif ! flen
          endif ! qroot
!    read ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        elseif (__INDX_RM(comlyn, comlen, 'READ').gt.0) then
          ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
          __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
          if (flen.GT.0) then
            if (qprint) then 
            __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
             write(_MSGBUF,6013) whoami, fname(1:flen) ; __PRINT(_MSGBUF)
            endif
!
 6013 format(A,' READING VORONOI MAP FROM FILE ',A,'.')
            call ftsm_voronoi_read_map(ifile)
            if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
           else
            __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
           endif ! flen
!    clear ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        elseif (__INDX_RM(comlyn, comlen, 'CLEA').gt.0) then
           if (associated(ftsm_voronoi_map)) ftsm_voronoi_map=-ione
        endif ! 'CALC'
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'READ',4)) then
!    read "restart" file that contains (1) crossing_attempt (2) crossing_accepts (3) occupancy
         ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
         __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
         if (flen.GT.0) then
          if (qprint) then
           __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
           write(_MSGBUF,6014) whoami, fname(1:flen) ; __PRINT(_MSGBUF) 
          endif
 6014 format(A,' READING VORONOI CROSSING DATA FROM FILE ',A,'.')
          call ftsm_voronoi_read_data(ifile)
          if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
         else
          __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
         endif ! flen
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       elseif (__STRNCMP(keyword,'PRIN',4)) then
         ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
         __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
         if (flen.gt.0) then
           if (qprint) then
            __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
            write(_MSGBUF,6015) whoami, fname(1:flen) ; __PRINT(_MSGBUF)
 6015 format(A,' WRITING VORONOI CROSSING DATA TO FILE ',A,'.')
           endif
           call ftsm_voronoi_print_data(ifile)
           if (qprint) then ; __CLOSE_FILE(ifile,'KEEP',ierror) ; endif
         else
            __WRN(whoami,'FILE NAME NOT SPECIFIED. NOTHING DONE.')
         endif ! flen
       endif ! VMAP
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'FILL',4)) then ! set path from current coordinates
!
       qcomp=(__INDX_RM(comlyn, comlen, 'COMP').gt.0)
!
       if (qcomp) then
        if (qprint) then ; write(_MSGBUF,6657) whoami ; __PRINT(_MSGBUF) ; endif
 6657 format(/A,' WILL DEFINE PATH FROM COMPARISON COORDINATES.')
        call ftsm_fill(__XCOMP,__YCOMP,__ZCOMP)
       else ! ~qcomp -- use main coordinates
        if (qprint) then ; write(_MSGBUF,6660) whoami ; __PRINT(_MSGBUF) ; endif
 6660 format(/A,' WILL DEFINE PATH FROM MAIN COORDINATES.')
        call ftsm_fill(__X,__Y,__Z)
       endif ! qcomp
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'CALC',4)) then ! calculate parallel and perpendicular distances
!
       qcomp=(__INDX_RM(comlyn, comlen, 'COMP').gt.0)
!
       if (qcomp) then
        if (qprint) then ; write(_MSGBUF,6658) whoami, 'COMPARISON' ; __PRINT(_MSGBUF) ; endif
        if (qorient.and.any(__XXCOMP(iatom_o(1:norient)).eq.__NAN)) then
         __WRN(whoami,'COMPARISON ORIENTATION X-SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         __FTSM_CALC(__XCOMP,__YCOMP,__ZCOMP,.false., t=one)
        endif
       else ! ~qcomp -- use main coordinates
        if (qprint) then ; write(_MSGBUF,6670) whoami, 'MAIN' ; __PRINT(_MSGBUF) ; endif
        if (qorient.and.any(__XX(iatom_o(1:norient)).eq.__NAN)) then
         __WRN(whoami,'MAIN ORIENTATION X-SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         __FTSM_CALC(__X,__Y,__Z, .false., t=one)
        endif
       endif ! qcomp
 6670 format(/A,' WILL COMPUTE DISTANCE FROM STRING IMAGE USING ',A,' COORDINATES.')
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     the option below will be useful to perform usual charmm operations on the STRING (if desired)
      elseif (__STRNCMP(keyword,'LIFT',4)) then ! force string into current coordinates
!
       qcomp=(__INDX_RM(comlyn, comlen, 'COMP').gt.0)
!
       if (qcomp) then
        if (qprint) then ; write(_MSGBUF,6658) whoami ; __PRINT(_MSGBUF) ; endif
 6658 format(/A,' WILL COPY STRING INTO COMPARISON COORDINATES.')
        if (qorient.and.any(__XXCOMP(iatom_o(1:norient)).eq.__NAN)) then
         __WRN(whoami,'COMPARISON ORIENTATION X-SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         call ftsm_lift(__XCOMP,__YCOMP,__ZCOMP)
        endif
       else ! ~qcomp -- use main coordinates
        if (qprint) then ; write(_MSGBUF,6661) whoami ; __PRINT(_MSGBUF) ; endif
 6661 format(/A,' WILL COPY STRING INTO MAIN COORDINATES.')
        if (qorient.and.any(__XX(iatom_o(1:norient)).eq.__NAN)) then
         __WRN(whoami,'MAIN ORIENTATION X-SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         call ftsm_lift(__X,__Y,__Z)
        endif
       endif ! qcomp
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'TEST',4)) then !
       if (__INDX_RM(comlyn,comlen,'GRAD').gt.0) then ! finite-difference gradient test
! check fd spec
        step=__GET_RM_F(comlyn, comlen, 'STEP', finite_difference_d)
        if (qprint) then 
         write(_MSGBUF, 7001) whoami,whoami,step,whoami,whoami 
         __PRINT(_MSGBUF)
 7001  format(/A,' WILL TEST GRADIENTS USING FINITE DIFFERENCES',       &
     &        /A,' USING DX = DY = DZ = ',F15.9,'.',                    &
     &        /A,' MAIN COORDINATE SET MUST BE DEFINED.',               &
     &        /A,' WILL OVERWRITE FORCE/GRAD ARRAYS')
        endif
        if (any(__X.eq.__NAN)) then
         __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         fd_error=>ftsm_test_grad_fd(__X,__Y,__Z,step)
!          write(me_global+100,*) fd_error
         if (qprint) then
          if (proj_on) then
           write(_MSGBUF,7002) whoami, whoami, whoami, whoami ; __PRINT(_MSGBUF)
 7002  format(/A,' TOP:    NORMALIZED PROJECTION ONTO PATH',            &
     &        /A,' BOTTOM: DISTANCE PERPENDICULAR TO PATH',             &
     &        /A,' DGRAD_X_MAX, DGRAD_Y_MAX, DGRAD_Z_MAX',              &
     &        /A,' ======================================')
           do i=1,2
            write(_MSGBUF,'(A,3'//real_format//'F15.9)')                   &
     &                  whoami,fd_error(i,:) ; __PRINT(_MSGBUF)
           enddo
          else ! projection off
           write(_MSGBUF,7013) whoami, whoami, whoami ; __PRINT(_MSGBUF)
 7013  format(/A,' DISTANCE TO PATH POINT:',                            &
     &        /A,' DGRAD_X_MAX, DGRAD_Y_MAX, DGRAD_Z_MAX',              &
     &        /A,' ======================================')
            write(_MSGBUF,'(A,3'//real_format//'F15.9)')                   &
     &                  whoami,fd_error(1,:) ; __PRINT(_MSGBUF)
          endif ! projection
         endif ! qprint
!     decide whether the test was passed
         zval=abs(maxval(fd_error))
         if (zval.lt.abs(step)*one) then
          write(_MSGBUF,7003) whoami, zval, whoami ; __PRINT(_MSGBUF)
         else
          write(_MSGBUF,7004) whoami, zval, whoami ; __PRINT(_MSGBUF)
          __WRN(whoami,'FINITE DERIVATIVE TEST FAILED.')
         endif ! report test result
 7003 format(/A, ' THE MAXIMUM GRADIENT ERROR IS ',F15.9,', ',          &
     &       /A, ' WHICH IS SMALLER THAN STEP. TEST PASSED.')
 7004 format(/A, ' THE MAXIMUM GRADIENT ERROR IS ',F15.9,', ',          &
     &       /A, ' WHICH IS NO SMALLER THAN STEP. TEST FAILED.')
         if (associated(fd_error)) deallocate(fd_error) ! test_grad returns a pointer to an array of abs errors
        endif
       endif ! grad
!
       if (__INDX_RM(comlyn,comlen,'PARA').gt.0) then ! parallel communication test
        if (qprint) write(_MSGBUF, 7005) whoami,whoami,whoami ; __PRINT(_MSGBUF)
 7005  format(/A,' WILL COMPARE PARALLEL AND SERIAL FORCE COMPUTATION', &
     &        /A,' MAIN COORDINATE SET MUST BE DEFINED.',               &
     &        /A,' WILL OVERWRITE FORCE/GRAD ARRAYS')
        if (any(__X.eq.__NAN)) then
         __WRN(whoami,' MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         fd_error=>ftsm_test_parallel(__X,__Y,__Z) ! use the same array as above
         if (qprint) then
          if (proj_on) then
           write(_MSGBUF,7006) whoami, whoami, whoami, whoami ; __PRINT(_MSGBUF)
 7006  format(/A,' TOP:    NORMALIZED PROJECTION ONTO PATH',            &
     &        /A,' BOTTOM: DISTANCE PERPENDICULAR TO PATH',             &
     &        /A,' DGRAD_X_MAX, DGRAD_Y_MAX, DGRAD_Z_MAX, VALUE',       &
     &        /A,' ============================================')
           do i=1, 2
            write(_MSGBUF,'(A,4'//real_format//'F15.9)')                   &
     &                  whoami,fd_error(i,:) ; __PRINT(_MSGBUF)
           enddo
          else ! not proj_on
           write(_MSGBUF,7010) whoami, whoami, whoami ; __PRINT(_MSGBUF)
 7010  format(/A,' DISTANCE TO PATH POINT:',                            &
     &        /A,' DGRAD_X_MAX, DGRAD_Y_MAX, DGRAD_Z_MAX, VALUE',       &
     &        /A,' ============================================')
            write(_MSGBUF,'(A,4'//real_format//'F15.9)')                   &
     &                  whoami,fd_error(1,:) ; __PRINT(_MSGBUF)
          endif ! proj_on
         endif ! qprint
!     decide whether the test was passed
         zval=abs(maxval(fd_error))
         if (zval.lt.parallel_tolerance) then
          write(_MSGBUF,7007) whoami, zval, whoami, parallel_tolerance ; __PRINT(_MSGBUF)
         else
          write(_MSGBUF,7008) whoami, zval, whoami, parallel_tolerance ; __PRINT(_MSGBUF)
          __WRN(whoami,'PARALLEL COMPUTATION TEST FAILED.')
         endif ! report test result
 7007 format(/A, ' THE MAXIMUM ERROR IS ',E12.5,', ',                   &
     &       /A, ' WHICH IS SMALLER THAN ',E12.5,'. TEST PASSED.')
 7008 format(/A, ' THE MAXIMUM ERROR IS ',E12.5,', ',                   &
     &       /A, ' WHICH IS NO SMALLER THAN ',E12.5,'. TEST FAILED.')
         if (associated(fd_error)) deallocate(fd_error) ! pointer to an array of abs errors
        endif
       endif ! para
!
! other tests will go below this line
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! specify parallel calculation options
      elseif (__STRNCMP(keyword,'PARA',4)) then
       do while (comlen .gt. 1)
        keyword=__NEXTA(comlyn, comlen)
        select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_bestfit_grad_para=.true. ; calc_voronoi_para=.true.
            if (qprint) then 
             write(_MSGBUF,7009) whoami, 'FORCES AND VORONOI DISTANCES', keyword ; __PRINT(_MSGBUF)
            endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_bestfit_grad_para=.false. ; calc_voronoi_para=.false.
            if (qprint) then
             write(_MSGBUF,7009) whoami, 'FORCES AND VORONOI DISTANCES', keyword ; __PRINT(_MSGBUF)
            endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED')
          end select
       enddo ! comlen
 7009  format(/A, ' PARALLEL COMPUTATION OF ',A,' ',A)
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! specify whether to use custom allgather hypercube
      elseif (__STRNCMP(keyword,'COMM',4)) then
       do while (comlen .gt. 1)
        keyword=__NEXTA(comlyn, comlen)
        select case(keyword)
           case('allg','ALLG','ALLGATHE','allgathe')
            keyword='ALLGATHER'; allgather_method=allgather_
            if (qprint) then 
             write(_MSGBUF,7012) whoami, keyword ; __PRINT(_MSGBUF)
            endif
           case('hycu','HYCU','HYPER','hyper','hcube','HCUBE')
            keyword='HYPERCUBE' ; allgather_method=hypercube_
            if (qprint) then
             write(_MSGBUF,7012) whoami, keyword ; __PRINT(_MSGBUF)
            endif
           case('gatherb','GATHERB','gather','GATHER','bcast','BCAST')
            keyword='GATHER + BCAST' ; allgather_method=gather_bcast_
            if (qprint) then
             write(_MSGBUF,7012) whoami, keyword ; __PRINT(_MSGBUF)
            endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED')
          end select
       enddo ! comlen
 7012  format(/A, ' WILL COMMUNICATE FTSM FORCES USING ',A)
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'PRIN',4)) then
!      can write both coordinate files and a global dcd file
!      local is specified with 'COR'; global is the default
#ifdef __CHARMM
       qcor=__INDX_RM(comlyn,comlen,'COR'); qcor = min(qcor,1)
#else
       qcor=__INDX_RM(comlyn,comlen,'CHM'); qcor = min(qcor,1)
#endif
       qdcd=__INDX_RM(comlyn,comlen,'DCD'); qdcd = min(qdcd,1)
!
       if ((qcor+qdcd) .gt. 1) then
        __WRN( whoami,' MORE THAN ONE OUTPUT FORMAT REQUESTED. WILL USE DCD.')
        qcor=0; qdcd=1;
       endif
!
!      prepare file
!-----------------------------------------------------------------------------
       ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
       CALL GTRMWD(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
!---------------------------------- OPEN FILE --------------------------------
       if (qroot) then
#ifdef __CHARMM
        oldiol=iolev
#endif
        if (qdcd.eq.0) then ! no dcd -- local write
#ifdef __CHARMM
         iolev=1 ! open file on all nodes
#endif
         if (flen.gt.0) __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
        else
         if (qprint) then ! write one dcd file (root does this)
          if (flen.gt.0) __OPEN_FILE(ifile,fname,'UNFORMATTED','WRITE') ! open binary fle for DCD
         endif
! broadcast ifile so that all roots know whether handle is valid
         __BROADCAST_STRING(ifile,1,mpiint)
        endif
#ifdef __CHARMM
        if (ifile .eq. -1) then
         if (qdcd .eq. 0 ) ifile=__OSTREAM ! write to output stream (rather dirty, but keep for now)
        endif
#endif
        if (ifile.ge.0) then
!---------------------------- assume file is open, write -------------------------
!     check for column spec
         c1=__GET_RM_I(comlyn, comlen, 'COL', -1)
         if (c1.gt.0) then
          if (qprint) then ; write(_MSGBUF,6679) whoami, c1 ; __PRINT(_MSGBUF) ; endif
 6679 format(/A,' WRITING COORDINATES FROM COLUMN ',I3)
          if (qdcd.gt.0) then ; call ftsm_write_dcd(IFILE=ifile,COL=c1) ;
          else ; call ftsm_write_cor(ifile,c1) ; endif
         else
          if (qprint) then ; write(_MSGBUF,6689) whoami ; __PRINT(_MSGBUF) ; endif
 6689 format(/A,' WRITING COORDINATES FROM DEFAULT COLUMN.')
          if (qdcd.gt.0) then ; call ftsm_write_dcd(IFILE=ifile) ;
          else ; call ftsm_write_cor(ifile) ; endif
         endif ! c1
         if (qdcd.eq.0.or.qprint) then
          if (flen.gt.0) __CLOSE_FILE(ifile,'KEEP',error)
         endif
        endif ! ifile
#ifdef __CHARMM
        iolev=oldiol
#endif
       endif ! qroot
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'READ',4)) then
!      can read from both coordinate files and a global dcd file (see above)
!      can also read a frame in the DCD: specify FRAM for frame;
       qcor=__INDX_RM(comlyn,comlen,'COR'); qcor = min(qcor,1)
       qdcd=__INDX_RM(comlyn,comlen,'DCD'); qdcd = min(qdcd,1)
!
       if ((qcor+qdcd) .gt. 1) then
        __WRN( whoami,'MORE THAN ONE INPUT FORMAT REQUESTED. WILL USE DCD.')
        qcor=0; qdcd=1;
       endif
!
!      prepare file
       ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
       __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: flen will be UPPER CASE
!     check for column spec (which coordinate set to read into)
       c1=__GET_RM_I(comlyn, comlen, 'COL', 0)
!cccccccccccccccccccccccccccc OPEN FILE ccccccccccccccccccccccc
       if (qroot) then
#ifdef __CHARMM
        oldiol=iolev
#endif
        if (qdcd.eq.0) then
#ifdef __CHARMM
         iolev=1 ! open file on all processors
#endif
         if (flen.gt.0) __OPEN_FILE(ifile,fname,'FORMATTED','READ')
        else
         if (qprint) then ! binary dcd file
          if (flen.gt.0) __OPEN_FILE(ifile,fname,'UNFORMATTED','READ') ! open binary fle for DCD
         endif
! broadcast ifile so that all roots know whether handle is valid
         __BROADCAST_STRING(ifile,1,mpiint)
        endif
#ifdef __CHARMM
        if(ifile .le. -1 ) then 
         if (qdcd.eq.0 ) then
          ifile=__ISTREAM ! read local files from input file
          call rdtitl(titleb,ntitlb,ifile,0) ! 0 = card format
         endif ! qdcd
        endif ! ifile
#endif
       endif ! qroot
!cccccccccccccccccc assume file is open, read ccccccccccccccccccc
! broadcast ifile so that all slaves also know whether handle is valid
! because they need to enter read_cor
       if (qslave) then ; __BROADCAST_LOCAL(ifile,1,mpiint) ; endif
       if (ifile.ge.0) then
        if (c1.gt.0) then ! column spec
         if (qprint) then ; write(_MSGBUF,6699) whoami, c1 ; __PRINT(_MSGBUF) ; endif
 6699 format(A,' READING COORDINATES INTO COLUMN ',I3)
         if (qdcd.gt.0) then ; if (qroot) call ftsm_read_dcd(ifile, c1);
         else; call ftsm_read_cor(ifile,c1) ;  endif
       else
         if (qprint) then ; write(_MSGBUF,6709) whoami ; __PRINT(_MSGBUF) ; endif
 6709 format(A,' READING COORDINATES INTO DEFAULT COLUMN.')
         if (qdcd.gt.0) then ; if (qroot) call ftsm_read_dcd(ifile);
         else ; call ftsm_read_cor(ifile) ; 
         endif
        endif ! c1
       endif
!cccccccccccccccc close file ccccccccccccccccccccccccccccccccccccc
       if (qroot) then
        if (qdcd.eq.0.or.qprint) then
         if (flen.gt.0) __CLOSE_FILE(ifile,'KEEP',error)
        endif ! qdcd
#ifdef __CHARMM
        iolev=oldiol
#endif
       endif ! qroot
!
!     broadcast to slaves (although cread routine will send coords to slaves, too)
       if (c1.le.0) c1=center ! assume "default column"
       if (c1.eq.center) then
        call ftsm_swap_bc(.true.)
        r_f(:,:,left_old:right_old)=r_f(:,:,left:right)
        r_f(:,:,center_new)=r_f(:,:,center)
        if (qorient.and.qdiffrot) then
         r_o(:,:,left_old:right_old)=r_o(:,:,left:right)
         r_o(:,:,center_new)=r_o(:,:,center)
        endif
       else
        if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
         __BROADCAST_LOCAL_4B(r_f(:,:,c1), 3*nforced) !##SINGLE       ! forcing coordinates
         __BROADCAST_LOCAL_8B(r_f(:,:,c1), 3*nforced) !##.not.SINGLE
#else
         __BROADCAST_LOCAL(r_f(:,:,c1), 3*nforced, mpifloat) ! forcing coordinates
#endif
         if (qorient.and.qdiffrot) then 
#ifdef __CHARMM
          __BROADCAST_LOCAL_8B(r_o(:,:,c1), 3*norient) !##SINGLE      ! send orientation coordinates (only if distinct from forcing)
          __BROADCAST_LOCAL_8B(r_o(:,:,c1), 3*norient) !##.not.SINGLE
#else
          __BROADCAST_LOCAL(r_o(:,:,c1), 3*norient, mpifloat) ! send orientation coordinates (only if distinct from forcing)
#endif
         endif
        endif
       endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'SWAP',4)) then ! swap two columns
!       read column spec
        c1=__NEXTI(comlyn, comlen)
        c2=__NEXTI(comlyn, comlen)
        if (qprint) then ; write(_MSGBUF,6729) whoami, c1, c2 ; __PRINT(_MSGBUF) ; endif
 6729 format(/A,' WILL SWAP COLUMNS ',I3,' AND ',I3,' ')
        call ftsm_swap(c1, c2)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'COPY',4)) then ! copy form c1 to c2
!       read column spec
        c1=__NEXTI(comlyn, comlen)
        c2=__NEXTI(comlyn, comlen)
        if (qprint) then ; write(_MSGBUF,6739) whoami, c1, c2 ; __PRINT(_MSGBUF) ; endif
 6739 format(/A,' WILL COPY COLUMN ',I3,' TO ',I3,' ')
        call ftsm_copy(c1,c2)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'SET ',4)) then ! modify k, etc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        iorie=__INDX_RM(comlyn, comlen, 'ORIE')
        irmsd=__INDX_RM(comlyn, comlen, 'RMSD')
!
        if (iorie.gt.0) then
!    process orientation atom selection
!    determine whether a selection keyword follows orie
         isele=__INDX(comlyn, comlen, 'SELE' ,4)
         if (isele.ge.iorie) then
!
#ifdef __CHARMM
          iselct=0
! process selection
          IMODE=0
          CALL SELRPN(COMLYN,COMLEN,iselct,NATOM,1,IMODE,               &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
          IF(IMODE.NE.0) THEN
           __WRN(whoami,'ORIENTATION ATOMS SELECTION ERROR')
           RETURN
          ENDIF
#elif defined(__DMOL)
#include "../../dmol_select_macro.def"
          if (associated(iselct)) then ; norient=size(iselct) ; else ; norient=0 ; endif
#endif
! deallocate existing orientation arrays
!
          if (qdiffrot) then; if (associated(r_o)) deallocate(r_o)
                              if(associated(iatom_o)) deallocate(iatom_o)
          else              ; nullify(r_o) ; nullify(iatom_o)
          endif
          if (associated(orientWeights)) deallocate(orientWeights)
!
! currently we require at least three atoms for orientation
!
          norient=count( iselct.gt.0 )
          if (norient.lt.3) then
           __WRN(whoami,' FEWER THAN THREE ATOMS SELECTED FOR ORIENTATION. WILL NOT ORIENT.')
           norient=0
           qorient=.false.
           qdiffrot=.true.
           return
          endif
!
          qorient=.true.
!
          allocate(iatom_o(norient)); iatom_o=0
          allocate(orientWeights(norient));
          orientWeights=one/norient ! default behavior
!    build index array
          norient=0
!
#ifdef __CHARMM
          do i=1,natom
           if (iselct(i).gt.0) then
            norient=norient+1
            iatom_o(norient)=i
           endif
          enddo
#else
          iatom_o=iselct
          if (associated(iselct)) deallocate(iselct)
#endif
!
!    determine whether the new orientation set is the same as the existing forcing set
!
          qdiffrot=.not. ( norient .eq. nforced )
          if (.not.qdiffrot)  qdiffrot=.not.(associated(iatom_f))
          if (.not.qdiffrot)  qdiffrot=any(iatom_f.ne.iatom_o)
!
          if (.not.qdiffrot) then
           deallocate(iatom_o); iatom_o=>iatom_f; r_o=>r_f;
          else
           allocate(r_o(norient,3,num_sets)); r_o=__NAN;
           if (nforced.gt.0) call ftsm_compute_overlap_ind()  ! compute overlap indices in iatom_both
          endif
!
          if (.not. associated(rcom)) allocate(rcom(3,num_sets))
          rcom=0d0 ! must be zero initially
!
! print summary
          if (qprint) then
            write(_MSGBUF,100) whoami, norient ; __PRINT(_MSGBUF)
 100  format(A,' WILL ORIENT STRUCTURES BASED ON ',i5,' ATOMS')
            write(_MSGBUF,101) whoami ;  ; __PRINT(_MSGBUF)
 101  format(A,' ORIENTATION WEIGHTS UNIFORM.')
            if (qdiffrot) then
             write(_MSGBUF,102) whoami
            else
             write(_MSGBUF,103) whoami
            endif
            __PRINT(_MSGBUF)
 102  format (A, ' ORIENTATION AND FORCING ATOMS ARE DIFFERENT')
 103  format (A, ' ORIENTATION AND FORCING ATOMS ARE IDENTICAL')
          endif ! qprint
         else
          __WRN(whoami,' ATOM SELECTION MUST BE SPECIFIED AFTER ORIE.')
          return
         endif
         call ftsm_define_rtmd_type()
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        elseif (irmsd.gt.0) then
!    process forcing atom selection
!    determine whether a selection keyword follows 'rmsd'
         isele=__INDX(comlyn, comlen, 'SELE' ,4)
         if (isele.gt.irmsd) then
!
#ifdef __CHARMM
          iselct=0
          IMODE=0
          CALL SELRPN(COMLYN,COMLEN,iselct,NATOM,1,IMODE,               &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
          IF(IMODE.NE.0) THEN
           __WRN(whoami,'RMSD ATOMS SELECTION ERROR')
           RETURN
          ENDIF
          nforced=count( iselct.gt.0 )
#elif defined(__DMOL)
#include "../../dmol_select_macro.def"
          if (associated(iselct)) then ; nforced=size(iselct) ; else ; nforced=0 ; endif
#endif
!
          if (nforced.le.0) then
           __WRN(whoami, 'NO RMSD ATOMS SELECTED. ABORT.')
           return
          endif
!
!
          if (qdiffrot) then; if (associated(r_f)) deallocate(r_f)
                             if(associated(iatom_f)) deallocate(iatom_f)
          else              ; nullify(r_f) ; nullify(iatom_f)
          endif
          if (associated(forcedWeights)) deallocate(forcedWeights)
          if (associated(Mtensor)) deallocate(Mtensor)
!
          allocate(iatom_f(nforced)); iatom_f=0
          allocate(forcedWeights(nforced));
          forcedWeights=1d0/nforced ! default behavior
          allocate(Mtensor(3,3,nforced,nforced,2)); Mtensor=zero ; do a=1,3; do i=1, nforced ; Mtensor(a,a,i,i,:)=one ; enddo ; enddo! allocate & set to I
!
!    build index array
          nforced=0
!
#ifdef __CHARMM
          do i=1,natom
           if (iselct(i).gt.0) then
            nforced=nforced+1
            iatom_f(nforced)=i
           endif
          enddo
#else
          iatom_f=iselct
          if (associated(iselct)) deallocate(iselct)
#endif
!
!    determine whether the new orientation set is the same as the existing forcing set
!
          qdiffrot=.not. ( norient .eq. nforced )
          if (.not.qdiffrot)  qdiffrot=.not.(associated(iatom_o))
          if (.not.qdiffrot)  qdiffrot=any(iatom_f.ne.iatom_o)
!
          if (.not.qdiffrot) then
           deallocate(iatom_f); iatom_f=>iatom_o; r_f=>r_o;
          else
           allocate(r_f(nforced,3,num_sets)); r_f=__NAN;
           if (norient.gt.0) call ftsm_compute_overlap_ind()  ! compute overlap indices in iatom_both
          endif
! print summary
          if (qprint) then
            write(_MSGBUF,104) whoami, nforced ; __PRINT(_MSGBUF)
 104  format(A,' WILL APPLY FORCES TO ',i5,' ATOMS')
            write(_MSGBUF,105) whoami ; __PRINT(_MSGBUF)
 105  format(A,' FORCING WEIGHTS UNIFORM.')
            if (qdiffrot) then
             write(_MSGBUF,102) whoami
             if (.not.qorient) then
              write(_MSGBUF(2),106) whoami
 106  format(A,' BEST-FITTING IS DISABLED (PERHAPS ORIENTATION ATOMS ARE NOT DEFINED).')
             endif
            else
             write(_MSGBUF,103) whoami
            endif
            __PRINT(_MSGBUF)
          endif ! qprint
         else
          __WRN(whoami,'ATOM SELECTION MUST BE SPECIFIED AFTER RMSD.')
          return
         endif
!**************************************************************
!==============================================================
! scaling output macro
#define __IS_DISTANCE_SCALED then;write(_MSGBUF,6758)whoami;else;write(_MSGBUF,6759)whoami;endif;__PRINT(_MSGBUF);
 6758 format(A,'( LENGTH SCALE ASSUMED TO BE IN ANGSTROMS AND WILL BE SCALED INTERNALLY.)')
 6759 format(A,'( LENGTH SCALE ASSUMED TO BE SCALED BY TWICE THE INTER-REPLICA DISTANCE.)')
!==============================================================
!
!      set k parallel to path (for off-path dynamics)
        elseif (__INDX(comlyn,comlen,'KPAR',4).gt.0) then
          k=__GET_RM_F(comlyn,comlen,'KPAR',-1d0)
! check for distance scaling option: if set the force constant is specified as u[k] =  kcal/ mol /A^2
! otherwise, distance is dimensionless (scaled by twice the interimage distance in the default method), so u[k] = kcal/mol
          qkpara_angstrom = __INDX_RM(comlyn, comlen, 'ANGS').gt.0
          if (k.ge.0d0) then
           kpara=k
           if (qprint) then
            write(_MSGBUF,6756) whoami, k ; __PRINT(_MSGBUF)
            if (qkpara_angstrom) __IS_DISTANCE_SCALED
           endif
 6756 format(A,' SETTING PARALLEL RESTRAINT FORCE CONSTANT TO ',F11.5)
          else
           if (qprint) then ; write(_MSGBUF,6757) whoami, k ; __PRINT(_MSGBUF) ; endif
 6757 format(A,' NEGATIVE FORCE CONSTANT SPECIFIED: ',F11.5, '. NOT SET.')
          endif
!*************************************************************
!      set k perpendicular to path (for off-path dynamics)
        elseif (__INDX(comlyn,comlen,'KPRP',4).gt.0) then
          k=__GET_RM_F(comlyn,comlen,'KPRP',-one)
          qkperp_angstrom = __INDX_RM(comlyn, comlen, 'ANGS').gt.0
          if (k.ge.0d0) then
           kperp=k
           if (qprint) then
            write(_MSGBUF,6746) whoami, k ; __PRINT(_MSGBUF)
            if (qkperp_angstrom) __IS_DISTANCE_SCALED
           endif
 6746 format(A,' SETTING PERPENDICULAR RESTRAINT FORCE CONSTANT TO '    &
     &       ,F11.5)
          else
           if (qprint) then ; write(_MSGBUF,6757) whoami, k ; __PRINT(_MSGBUF) ; endif
          endif
!**************************************************************
        elseif (__INDX(comlyn,comlen,'KRMS',4).gt.0) then
          k=__GET_RM_F(comlyn,comlen,'KRMS',-one)
          if (k.ge.0d0) then
           krms=k
           if (qprint) then ; write(_MSGBUF,6752) whoami, k ; __PRINT(_MSGBUF) ; endif
 6752 format(A,' SETTING RMSD RESTRAINT FORCE CONSTANT TO '             &
     &       ,F11.5)
          else
           if (qprint) then ; write(_MSGBUF,6757) whoami, k ; __PRINT(_MSGBUF) ; endif
          endif
!***************************************************************
        elseif (__INDX_RM(comlyn,comlen,'MASS').gt.0) then ! mass-weighting
          keyword=__NEXTA(comlyn, comlen)
          klen=len(keyword)
          __TRIMA(keyword,klen)
#ifndef __CHARMM
 natom=__NATOM
#endif
          select case(keyword(1:klen))
           case('YES','ON','TRUE','T','yes','on','true','t')
            if (qprint) then ; write(_MSGBUF,8001) whoami, 'SET FROM ATOM MASSES' ; __PRINT(_MSGBUF) ; endif
            call ftsm_set_weights(__MASS, natom) ! send masses
           case('NO','OFF','FALSE','F','no','off','false','f')
            if (qprint) then ; write(_MSGBUF,8001) whoami, 'WILL BE UNIFORM'      ; __PRINT(_MSGBUF) ; endif
            call ftsm_set_weights( (/ (1d0, i=1,natom) /), natom) ! uniform
#ifdef __CHARMM
           case('WMAIN', 'wmain')
            if (qprint) then ; write(_MSGBUF,8001) whoami, 'SET FROM WMAIN ARRAY' ; __PRINT(_MSGBUF) ; endif
            call ftsm_set_weights(wmain, natom) ! send masses
           case('WCOMP', 'wcomp')
            if (qprint) then ; write(_MSGBUF,8001) whoami, 'SET FROM WCOMP ARRAY' ; __PRINT(_MSGBUF) ; endif
            call ftsm_set_weights(wcomp, natom) ! send masses
#elif defined (__DMOL)
           case('BFACTOR', 'bfactor', 'BFACT', 'bfact')
            if (qprint) then ; write(_MSGBUF,8001) whoami, 'SET FROM BFACTOR ARRAY' ; __PRINT(_MSGBUF) ; endif
            call ftsm_set_weights(bfactor, natom) ! send masses
           case('OCCU', 'occu','OCCUPANCY', 'occupancy')
            if (qprint) then ; write(_MSGBUF,8001) whoami, 'SET FROM OCCUPANCY ARRAY' ; __PRINT(_MSGBUF) ; endif
            call ftsm_set_weights(occupancy, natom) ! send masses
#endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED')
          end select
 8001 format(A,' WEIGHTS ',A,'.')
!*********************************************************************
        elseif (__INDX_RM(comlyn,comlen,'PROJ').gt.0) then ! mass-weighting
          keyword=__NEXTA(comlyn, comlen)
          klen=len(keyword)
          __TRIMA(keyword,klen)
          select case(keyword(1:klen))
           case('YES','ON','TRUE','T','yes','on','true','t')
            proj_on=.true.
            if (qprint) then ; write (_MSGBUF,'(2A)') whoami,                    &
     & ' WILL RESTRAIN SYSTEM TO PLANE PERPENDICULAR TO PATH.' ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            proj_on=.false.
            if (qprint) then ; write (_MSGBUF,'(2A)') whoami,           &
     & ' WILL RESTRAIN SYSTEM TO PATH IMAGE.'//                         &
     & ' (FE/MFPT CANNOT BE COMPUTED).' ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED')
          end select
!*********************************************************************
        elseif (__INDX(comlyn,comlen,'DPAR',4).gt.0) then ! normalized distance parallel to vector between neighboring replicas at which this system is restrained
          zval=__GET_RM_F(comlyn, comlen, 'DPAR', -1.0d0)
          qkperp_angstrom = __INDX_RM(comlyn, comlen, 'ANGS').gt.0
!    check replica spec
          irep=__GET_RM_I(comlyn, comlen, 'REP', -1)
          if (irep.lt.0.or.irep.ge.nstring) then
           if (qprint) then ; write(_MSGBUF, 6773) whoami, whoami, zval ; __PRINT(_MSGBUF) ; endif
           dpar0=zval
          else
           if (qprint) then ; write(_MSGBUF,6774) whoami, irep, zval ; __PRINT(_MSGBUF) ; endif
           if (mestring.eq.irep) dpar0=zval ! note: permitting any value
          endif ! irep
 6773 format(A,' REPLICA NUMBER INVALID OR UNSPECIFIED.',               &
     &      /A,' WILL SET RERERENCE VALUE FOR PARALLEL RESTRAINT ',     &
     &         '  TO ',F7.3,' ON ALL REPLICAS.')
 6774 format(A,' WILL SET RERERENCE VALUE FOR PARALLEL RESTRAINT ',     &
     &   'ON REPLICA ',I5,' TO ',F7.3,'.')
        ! DPAR
!******************************************************************************************
        elseif (__INDX(comlyn,comlen,'DPRPF',5).gt.0) then ! final perpendicular distance at which the replicas are restrained
          qangstrom = __INDX_RM(comlyn, comlen, 'ANGS').gt.0 ! scaled/unscaled units
!
          zval=__GET_RM_F(comlyn, comlen, 'DPRPF', __NAN)
          if (zval.eq.__NAN) then
           __WRN(whoami,' FINAL OFFSET DISTANCE FOR PERPENDICULAR RESTRAINT NOT SPECIFIED.')
          else
!    check replica spec
           irep=__GET_RM_I(comlyn, comlen, 'REP', -1)
           if (irep.lt.0.or.irep.ge.nstring) then
            qdperpf_angstrom=qangstrom
            if (qprint) then 
             write(_MSGBUF, 67761) whoami, whoami, zval ; __PRINT(_MSGBUF) 
             if (qangstrom) __IS_DISTANCE_SCALED
            endif
            dperp0f=zval
           else
            if (qprint) then ; write(_MSGBUF,67762) whoami, irep, zval ; __PRINT(_MSGBUF) ; 
             if (qangstrom) __IS_DISTANCE_SCALED
            endif
            if (mestring.eq.irep) then ; dperp0f=zval ; qdperpf_angstrom=qangstrom ; endif ! note: permitting any value
           endif ! irep
67761 format(A,' REPLICA NUMBER INVALID OR UNSPECIFIED.',               &
     &      /A,' WILL SET FINAL OFFSET DISTANCE FOR PERPENDICULAR RESTRAINT', &
     &         ' TO ',E10.3,' ON ALL REPLICAS.')
67762 format(A,' WILL SET FINAL OFFSET DISTANCE FOR PERPENDICULAR RESTRAINT ',&
     &   'ON REPLICA ',I5,' TO ',E10.3,'.')
          endif ! zval valid
!******************************************************************************************
        elseif (__INDX(comlyn,comlen,'DPRPITER',8).gt.0) then ! number of iterations to adjust to final perpendicular restraint value
          i=__GET_RM_I(comlyn, comlen, 'DPRPITER', nint(__NAN))
!
          if (i.eq.nint(__NAN)) then
           __WRN(whoami,' NUMBER OF ADJUSTMENT ITERATIONS FOR PERPENDICULAR RESTRAINT NOT SPECIFIED.')
           dperp_adjust_iter=0
          else
!    check replica spec
           irep=__GET_RM_I(comlyn, comlen, 'REP', -1)
           if (irep.lt.0.or.irep.ge.nstring) then
            if (qprint) then ; write(_MSGBUF, 67763) whoami, whoami, i ; __PRINT(_MSGBUF) ; endif
            dperp_adjust_iter=i
           else
            if (qprint) then ; write(_MSGBUF,67764) whoami, irep, i ; __PRINT(_MSGBUF) ; endif
            if (mestring.eq.irep) dperp_adjust_iter=i
           endif ! irep
67763 format(A,' REPLICA NUMBER INVALID OR UNSPECIFIED.',               &
     &      /A,' WILL SET NUMBER OF ADJUSTMENT ITERATIONS FOR PERPENDICULAR RESTRAINT', &
     &         ' TO ',I9,' ON ALL REPLICAS.')
67764 format(A,' WILL SET NUMBER OF ADJUSTMENT ITERATIONS FOR PERPENDICULAR RESTRAINT ',&
     &   'ON REPLICA ',I5,' TO ',I9,'.')
          endif ! i valid
!****************************************************************************************
        elseif (__INDX(comlyn,comlen,'DPRP',4).gt.0) then ! (initial) distance perpendicular to vector between neighboring replicas 
          qangstrom = __INDX_RM(comlyn, comlen, 'ANGS').gt.0 ! scaled/unscaled units
          zval=__GET_RM_F(comlyn, comlen, 'DPRP', __NAN)
!
          if (zval.eq.__NAN) then
           __WRN(whoami,' OFFSET DISTANCE FOR PERPENDICULAR RESTRAINT NOT SPECIFIED.')
          else
!    check replica spec
           irep=__GET_RM_I(comlyn, comlen, 'REP', -1)
           if (irep.lt.0.or.irep.ge.nstring) then
            qdperp_angstrom=qangstrom
            if (qprint) then ; write(_MSGBUF, 67765) whoami, whoami, zval ; __PRINT(_MSGBUF) 
             if (qdperp_angstrom) __IS_DISTANCE_SCALED
            endif
            dperp0=zval ; dperp0i=dperp0
           else
            if (qprint) then ; write(_MSGBUF,67766) whoami, irep, zval ; __PRINT(_MSGBUF)
             if (qangstrom) __IS_DISTANCE_SCALED
            endif
            if (mestring.eq.irep) then  ; dperp0=zval ; dperp0i=dperp0 ; qdperp_angstrom=qangstrom ; endif ! note: permitting any value
           endif ! irep
67765 format(A,' REPLICA NUMBER INVALID OR UNSPECIFIED.',               &
     &      /A,' WILL SET OFFSET DISTANCE FOR PERPENDICULAR RESTRAINT', &
     &         ' TO ',E10.3,' ON ALL REPLICAS.')
67766 format(A,' WILL SET OFFSET DISTANCE FOR PERPENDICULAR RESTRAINT ',&
     &   'ON REPLICA ',I5,' TO ',E10.3,'.')
          endif ! zval valid
!*****************************************************************************************
        elseif (__INDX(comlyn,comlen,'DRMS',4).gt.0) then ! RMS distance between simulation and reference structure
          zval=__GET_RM_F(comlyn, comlen, 'DRMS', -one)
!    check replica spec
          irep=__GET_RM_I(comlyn, comlen, 'REP', -1)
          if (irep.lt.0.or.irep.ge.nstring) then
           if (qprint) then ; write(_MSGBUF, 6777) whoami, whoami, zval ; __PRINT(_MSGBUF) ; endif
           drms0=zval
          else
           if (qprint) then ; write(_MSGBUF,6778) whoami, irep, zval ; __PRINT(_MSGBUF) ; endif
           if (mestring.eq.irep) drms0=zval ! note: permitting any value
          endif ! irep
 6777 format(A,' REPLICA NUMBER INVALID OR UNSPECIFIED.',               &
     &      /A,' WILL SET REFERENCE VALUE FOR RMSD RESTRAINT ',         &
     &         '  TO ',F7.3,' ON ALL REPLICAS.')
 6778 format(A,' WILL SET REFERENCE VALUE FOR RMSD RESTRAINT ',         &
     &   'ON REPLICA ',I5,' TO ',F7.3,'.')
!
!    check upper boundary spec
          qrms_upper_bound = ( __INDX_RM(comlyn,comlen,'UPPE').gt.0 )
          if (qrms_upper_bound.and.qprint) then ; write(_MSGBUF,6781) whoami ; __PRINT(_MSGBUF) ; endif
 6781 format(A,' RESTRAINT WILL BE APPLIED ONLY IF RMSD EXCEEDS REFERENCE VALUE.')
!
!*****************************************************************************************
        elseif (__INDX(comlyn,comlen,'VCUT',4).gt.0) then
         voro_cut=__GET_RM_F(comlyn, comlen, 'VCUT', zero)
! replica spec
         irep=__GET_RM_I(comlyn, comlen, 'REP', -1)
         if (voro_cut.le.zero) then
          __WRN(whoami,'VCUT MUST BE POSITIVE. NOT SET.')
         else
          if (irep.lt.0.or.irep.ge.nstring) then
           if (qprint) then ; write(_MSGBUF, 6779) whoami, whoami, voro_cut ; __PRINT(_MSGBUF) ; endif
           call ftsm_voronoi_set_cutoff(voro_cut)
          else
           if (qprint) then ; write(_MSGBUF, 6780) whoami, irep, voro_cut ; __PRINT(_MSGBUF) ; endif
           if (mestring.eq.irep) call ftsm_voronoi_set_cutoff(voro_cut)
          endif ! irep
 6779 format(A,' REPLICA NUMBER INVALID OR UNSPECIFIED.',/A,' WILL SET VORONOI TUBE CUTOFF ', &
     & '  TO ',F7.3,' ON ALL REPLICAS.')
 6780 format(A,' WILL SET VORONOI TUBE CUTOFF ON REPLICA ',I5,' TO ',F7.3,'.')
         endif ! voro_cut > 0
!
        endif
!
!      done with 'SET' parsing
!==================================== M tensor ======================================
      elseif (__STRNCMP(keyword,'MMAT',4)) then
       if (ftsm_check(qorient)) then
        if (__INDX_RM(comlyn, comlen, 'CALC').gt.0) then
!
         ok=.true.
         if (qorient) then 
          if(any(r_o(:,:,center).eq.__NAN)) then
           __WRN(whoami,'ORIENTATION COORDINATES HAVE UNDEFINED VALUES. NOTHING DONE.')
           ok=.false.
          endif
         endif
!
         if (ok) then
          if (qprint) then ; write(_MSGBUF,6854) whoami ; __PRINT(_MSGBUF) ; endif
 6854 format(A,' COMPUTING M TENSOR FROM ATOMIC COORDINATES.')
          call ftsm_calc_M(__X,__Y,__Z,__MASS,one)
!
          num_M_samples=num_M_samples+1
          omt=one/num_M_samples
          t=one-omt
          Mtensor(:,:,:,:,2) = t * Mtensor(:,:,:,:,2) + omt * Mtensor(:,:,:,:,1) ! add to running average
!
         endif
!
        elseif (__INDX_RM(comlyn, comlen, 'CLEA').gt.0) then
          if (qprint) then ; write(_MSGBUF,6855) whoami ; __PRINT(_MSGBUF) ; endif
 6855 format(A,' CLEARING M TENSOR DATA.')
          num_M_samples=0;
          Mtensor=zero; do a=1,3; do i=1, nforced ; Mtensor(a,a,i,i,:)=one ; enddo ; enddo! reset to I
        endif
       endif
!
!==================================== Jacobian ======================================
      elseif (__STRNCMP(keyword,'JACO',4)) then
       if (ftsm_check(qorient)) then
        if (__INDX_RM(comlyn, comlen, 'CALC').gt.0) then
!
         ok=.true.
         if (qorient) then 
          if(any(r_o(:,:,center).eq.__NAN)) then
           __WRN(whoami,'ORIENTATION COORDINATES HAVE UNDEFINED VALUES. NOTHING DONE.')
           ok=.false.
          endif
         endif
!
         if (ok) then
          if (qprint) then ; write(_MSGBUF,6856) whoami ; __PRINT(_MSGBUF) ; endif
 6856 format(A,' COMPUTING APPROXIMATE JACOBIAN FROM ATOMIC COORDINATES.')
          call ftsm_calc_J(__X,__Y,__Z,one)
!
          num_J_samples=num_J_samples+1
          omt=one/num_J_samples
          t=one-omt
          Jacobian(2) = t * Jacobian(2) + omt * Jacobian(1) ! add to running average
         endif ! not ok
!
        elseif (__INDX_RM(comlyn, comlen, 'CLEA').gt.0) then
          if (qprint) then ; write(_MSGBUF,6857) whoami ; __PRINT(_MSGBUF) ; endif
 6857 format(A,' CLEARING JACOBIAN.')
          num_J_samples=0; Jacobian=one
        endif
       endif
!
!cccccccccccccccccccccccccccccccccccc CV WEIGHTS cccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'LIST',4)) then ! list forcing and orientation atoms
       if (qprint) then ; write(_MSGBUF,6762) whoami ; __PRINT(_MSGBUF) ; endif
 6762 format(/A,' WILL LIST REPLICA ATOMS.')
       call ftsm_list_atoms()
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      else
            __WARN(whoami,'UNRECOGNIZED SUBCOMMAND: ',keyword)
      endif
!
      end subroutine ftsm_parse
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_init()
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_MPI 
      __DEP_NUMBER
!
 __DECLARE_MSGBUF
#include "../../mpitype.def"
      int :: ierror
      bool :: qroot, qslave
!
      __IAM(FTSM_INIT)
!
!      do a basic communicator check:
      if (ME_LOCAL.eq.0.and.ME_STRNG.eq.MPI_UNDEFINED) then
        write(_MSGBUF, 111) whoami, ME_GLOBAL, whoami ; __PRINT(_MSGBUF)
 111  FORMAT(A, ' WORLD REPLICA ',I5, ' HAS ZERO GROUP ID',             &
     & /,A,' BUT INVALID STRING ID (MAY BE OK).')
      elseif (ME_STRNG.ne.MPI_UNDEFINED.and.                            &
     &  (ME_LOCAL.ne.0.or.MPI_COMM_LOCAL.eq.MPI_COMM_NULL)) then
        write(_MSGBUF, 112) whoami, ME_GLOBAL, whoami ; __PRINT(_MSGBUF)
 112  FORMAT(A, ' WORLD REPLICA ',I5, ' HAS A VALID STRING ID',         &
     & /,A,' BUT A NONZERO GROUP ID. ABORTING.')
       return
      endif
!
      qroot=ME_STRNG.ne.MPI_UNDEFINED
      qslave=ME_LOCAL.ne.MPI_UNDEFINED ! (also includes roots)
!
      if (ftsm_initialized) then
       if (qroot) then
        if (ME_STRNG.eq.0) then
          write(_MSGBUF,'(2A)')                                            &
     &    whoami, ' FTSM ALREADY INITIALIZED. CALL "DONE" TO CLEAN UP.' ; __PRINT(_MSGBUF);
        endif ! ME_STRNG
       endif ! qroot
       return
      endif
!
      nstring=1 ! safe (hopefully) default
      mestring=-1 ! safe (hopefully) default
!
      if (qroot) then
        nstring=SIZE_STRNG
        mestring=ME_STRNG
      endif
#ifdef __CHARMM
!      broadcast string size to all slave nodes
      __BROADCAST_LOCAL_8B(nstring, 1)    !##INTEGER8
      __BROADCAST_LOCAL_8B(mestring, 1)   !##INTEGER8
!
      __BROADCAST_LOCAL_4B(nstring, 1)    !##.not.INTEGER8
      __BROADCAST_LOCAL_4B(mestring, 1)   !##.not.INTEGER8
!      set envorinment variable
      call setmsi('NSTRING',nstring)
      call setmsi('MESTRING',mestring)
#else
      __BROADCAST_LOCAL(nstring, 1, mpiint)
      __BROADCAST_LOCAL(mestring, 1, mpiint)
#endif
!
! disabling procedure pointer due to limited compiler compatibility
!      if (qver2) then ; ftsm_calc=>ftsmv2_calc ;  else ; ftsm_calc=>ftsmv1_calc ; endif
!
      if (qroot) then
        if (ME_STRNG.eq.0) then
          write(_MSGBUF,'(2A,I5, A)')                                      &
     &    whoami, ' FOUND ',nstring,' REPLICAS.'
          if (qver2) then
           write(_MSGBUF(2),'(2A)') whoami, ' FTSM VERSION 2 WILL BE USED TO SAMPLE HYPERPLANES.' ; 
          endif
          __PRINT(_MSGBUF)
        endif
      endif
!
      MPI_RTMD_TYPE =MPI_DATATYPE_NULL
      MPI_RTMD_TYPE_=MPI_DATATYPE_NULL
!    initialize free energy arrays
      if (allocated(fe)) deallocate(fe)
      if (allocated(feav)) deallocate(feav)
      if (allocated(ds)) deallocate(ds)
      if (allocated(curv)) deallocate(curv)
      allocate(fe(nstring), feav(nstring),                              &
     &         ds(nstring-1), curv(nstring-2))

      fe=0d0; feav=0d0; avforce=0d0; ds=0d0; curv=0d0
!
      num_evolve_samples=0
      num_force_samples=0
      num_M_samples=0
!    set default restraint positions
!    these will be overwritten later if distances are unscaled (ftsm_scaledist=f)
!
      if (ftsm_scaledist) then
       if (mestring.eq.0) then
        dpar0=zero
       elseif (mestring.eq.nstring-1) then
        dpar0=one
       else
        dpar0=half
       endif
      else
       dpar0=__NAN
      endif
!
      dpar0i=dpar0 ; dpar0f=__NAN ;
!
      dperp0=one ; dperp0i=dperp0 ; dperp0f=__NAN ; dperp_adjust_iter=0
      drms0=zero
!
      qorient=.false.
      qdiffrot=.false.
!
      nullify(Mtensor)
!
      restrained_eq0=0 ; unrestrained_eq0=0
!
      ftsm_initialized=.true.
!
      end subroutine ftsm_init
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_done()
      use ftsm_rex, only: ftsm_rex_done
      use ftsm_voronoi, only : ftsm_voronoi_done
!
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_MPI 
!
      character(len=11), parameter :: whoami=' FTSM_DONE>'
!
 __DECLARE_MSGBUF
!
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0) then 
       write(_MSGBUF,'(2A,I5, A)') whoami, ' CLEANING UP.' ; __PRINT(_MSGBUF)
      endif
!
      nstring=-1
      mestring=-1
#ifdef __CHARMM
!      set envorinment variable
      call setmsi('NSTRING',nstring)
      call setmsi('MESTRING',mestring)
#endif
!
!    deallocate arrays
!
      nforced=0
      __FREE(r_f)
      __FREE(iatom_f)
      __FREE(iatom_a)
      __FREE(orientWeights)
      __FREE(forcedWeights)
      __FREE(Mtensor)
!
      if (qdiffrot) then
       __FREE(r_o)
       __FREE(iatom_o)
       __FREE(iatom_both)
      endif
!
      nullify(r_o)
      nullify(iatom_o)
      norient=0
      nboth=0
!
      nany=0
!
      __FREE(rcom)
      __DEALL(ds)
      __DEALL(curv)
      __DEALL(fe)
      __DEALL(feav)
!
      num_evolve_samples=0
      num_force_samples=0
      num_M_samples=0
!
      qdiffrot=.false.
      qorient=.false.
      qver2=.false.
!
      call ftsm_define_rtmd_type() ! deallocate MPI type for transmitting forces (this is the effect when norient=0)
!
      call ftsm_rex_done()
!
      call ftsm_mini_done() ! deallocate minimization structures (if any)
!
      call ftsm_voronoi_done()
!
      ftsm_initialized=.false.
!
      end subroutine ftsm_done
!=========================================================================
      subroutine ftsm_list_atoms()
      __DEP_OUTPUT
      __DEP_PARSER
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_MPI
      __DEP_ATOMID
!
 __DECLARE_MSGBUF
!
      int :: j
      character(len=8) :: sid, rid, ren, ac
      __IAM(FTSM_LIST_ATOMS)
!
      if (MPI_COMM_STRNG.eq.MPI_COMM_NULL) return ! only replica heads stay
!
      if (ME_STRNG.eq.0) then
!
       write(_MSGBUF,'(A)') '\t ORIENTATION ATOMS:'
        do j=1, norient;
         __ATOMID(iatom_o(j), sid, rid, ren, ac)
         write(_MSGBUF,667) '\t',j, iatom_o(j), sid, rid, ren, ac
        enddo
!
        if (qdiffrot) then
         write(_MSGBUF,'(A)') '\t FORCING ATOMS'
         do j=1, nforced;
          __ATOMID(iatom_f(j), sid, rid, ren, ac)
          write(_MSGBUF,667) '\t',j, iatom_f(j), sid, rid, ren, ac ; __PRINT(_MSGBUF)
         enddo
        else
         write(_MSGBUF,'(A)') '\t FORCING AND ORIENTATION ATOMS ARE THE SAME' ; __PRINT(_MSGBUF)
        endif
      endif ! ME_STRING
!
 667  format(A,2I8,' ',4A)
!
      end subroutine ftsm_list_atoms
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_set_weights(w,n)
      __DEP_OUTPUT
      __DEP_NUMBER
      __DEP_PARSER
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
!
      int :: i, j, n
      float :: w(n), a
      __IAM(FTSM_SET_WEIGHTS)
!
 __DECLARE_MSGBUF
!
      if (qorient.and.ME_STRNG.eq.0.and.ME_LOCAL.eq.0) then
       write(_MSGBUF,668)                                               &
     & whoami,' A CHANGE IN THE ORIENTATION WEIGHTS REQUIRES ',         &
     & whoami,' REDEFINING IMAGES (e.g. USING FILL)' ; __PRINT(_MSGBUF)
      endif
 668  format(/2A,/2A)
!
      if (norient.eq.0.and.nforced.eq.0) then
       __WRN(whoami,'NO STRING ATOMS FOUND. NOTHING DONE.')
       return
      endif
!
!      if (norient.eq.0)
!     & __WRN(whoami,'NO ORIENTATION ATOMS FOUND.')
      if (associated(orientWeights).and.associated(iatom_o)) then
       do i=1,norient
        j=iatom_o(i)
        if (j.le.n) then
         orientWeights(i)=w(j)
        else
         __WRN(whoami,'WEIGHT ARRAY BOUNDS EXCEEDED. ABORT.')
         return
        endif
       enddo
!
       a=sum(orientWeights);
       if (a.gt.__ERRTOL) then ; orientWeights=orientWeights/a;
       else
        __WRN(whoami,'SUM OF ORIENTATION WEIGHTS IS VERY SMALL. ABORT.')
        return
       endif
!
      endif ! weights associated
!
!      if (nforced.eq.0)
!     & __WRN(whoami,'NO FORCED ATOMS FOUND.')
      if (associated(forcedWeights).and.associated(iatom_f)) then
       do i=1,nforced
        j=iatom_f(i)
        if (j.le.n) then
         forcedWeights(i)=w(j)
        else
         __WRN(whoami,'WEIGHT ARRAY BOUNDS EXCEEDED. ABORT.')
         return
        endif
       enddo
!
       a=sum(forcedWeights);
       if (a.gt.__ERRTOL) then ; forcedWeights=forcedWeights/a;
       else
        __WRN(whoami,'SUM OF FORCING WEIGHTS IS VERY SMALL. ABORT.')
        return
       endif
!
      endif ! weights associated
!
      end subroutine ftsm_set_weights
!
!====================================================================================
      subroutine ftsm_compute_overlap_ind() ! compute overlap indices in iatom_both
      int :: i, j
      int, allocatable :: temp(:,:)
!
!   note: both index arrays are assumed to be sorted !
!
      if (associated(iatom_both)) deallocate(iatom_both)
      nboth=0
      if ( .not. ( qorient .and. qdiffrot .and. ftsm_check(qorient))) return
!
      i=1; j=1
      allocate(temp(2,max(nforced, norient)))
      do while (i.le.nforced .and. j.le.norient)
!
       do while (  j.lt.norient .and. ( iatom_f(i) .gt. iatom_o(j) ) ) ! N.B.: looks like indices assumed to be ordered here
        j=j+1
       enddo
       if (iatom_f(i).eq.iatom_o(j)) then
        nboth=nboth+1;
        temp(1,nboth)=i; temp(2,nboth)=j;
        j=j+1; ! i-indices are unique, so safe to increment j
       endif
       i=i+1
      enddo
!
      if (nboth.gt.0) then
       allocate(iatom_both(2,nboth))
       iatom_both(:,1:nboth)=temp(:,1:nboth)
      endif
      deallocate(temp)
!
      end subroutine ftsm_compute_overlap_ind
!================================================================
      function ftsm_test_grad_fd(x,y,z,h) result(error)
      float :: x(:), y(:), z(:)
      float :: h
      float, pointer :: error(:,:)
      int :: i, j, jj
      float :: d, ap, am, bp, bm
      float :: s
!
      __IAM(FTSM_TEST_GRAD_FD)
!
      allocate(error(2,3))
      ap=0d0; am=0d0; bp=0d0; bm=0d0; error(1,1)=9999d0
!
      if (.not.ftsm_check(qorient)) return
!
      if (h.eq.0d0) then
       __WRN(whoami,'COORDINATE PERTURBATION ZERO.')
       return
      endif
!
      s=1d0
!      s=0.5d0
! compute projection and derivatives analytically
      __FTSM_CALC(x,y,z,.true.,s)
!
! IMPORTANT: if the o and f atoms are different and overlapping, the o and f gradient arrays
! will each have partial contributions to the total derivative for the overlapping atoms
! (whereas, the FD calculation will include both contributions)
! therefore, I am "reducing" the different gradient contributions below (which invalidates
! the contents of the arrays); the need to do this arises because I chose to keep two
! possibly overlapping coordinate arrays, even though the corresponding atoms are unique
!
      if (qdiffrot) then
       do i=1, nboth
         r_o(iatom_both(2,i), :, fpar) =                                &
     &   r_o(iatom_both(2,i), :, fpar) + r_f(iatom_both(1,i), :, fpar)
         r_f(iatom_both(1,i), :, fpar) = r_o(iatom_both(2,i), :, fpar)
       enddo
       if (proj_on) then
        do i=1, nboth
         r_o(iatom_both(2,i), :, fperp) =                               &
     &   r_o(iatom_both(2,i), :, fperp) + r_f(iatom_both(1,i), :, fperp)
         r_f(iatom_both(1,i), :, fperp) = r_o(iatom_both(2,i), :, fperp)
        enddo
       endif
      endif
!
! no need for this because not overwriting force arrays
!      r_f(:,:,left_cur)=r_f(:,:,fpar)
!      if (qorient.and.qdiffrot) r_o(:,:,left_cur)=r_o(:,:,fpar)
!      if (proj_on) then
!       r_f(:,:,right_cur)=r_f(:,:,fperp)
!       if (qorient.and.qdiffrot) r_o(:,:,right_cur)=r_o(:,:,fperp)
!      endif
! aa
!        write(mestring+500,*) dpar, dperp
!        write(mestring+500,*) r_f(:,1,fpar)
!        write(mestring+500,*) r_f(:,1,fperp)
!
! loop over all coordinates and compute finite differences
      error=0d0
!
      do jj=1, nforced
       j=iatom_f(jj)
! x-derivatives *******************************************
       d=x(j) ; x(j)=d-h
       __FTSM_CALC(x,y,z,.false.,s)
       if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
       x(j)=d+h
       __FTSM_CALC(x,y,z,.false.,s) ! overwrite zold cv value array (warn about this elsewhere)
       if (proj_on) then; ap=dpar;  bp=dperp; else; ap=drms ; endif
       x(j)=d ! restore correct value
! compute largest absolute error
!         r_f(jj,1,ref)=0.5d0/h*(ap-am) ! aa
!         r_f(jj,1,rave)=0.5d0/h*(bp-bm) ! aa
!
       error(1,1) = max (error(1,1),                                    &
     &         abs(0.5d0/h*(ap-am)-r_f(jj,1,fpar) ) )
       if (proj_on)                                                     &
     & error(2,1) = max (error(2,1),                                    &
     &        abs(0.5d0/h*(bp-bm)-r_f(jj,1,fperp) ) )
! y-derivatives *******************************************
       d=y(j) ; y(j)=d-h
       __FTSM_CALC(x,y,z,.false.,s)
       if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
       y(j)=d+h
       __FTSM_CALC(x,y,z,.false.,s) ! overwrite zold cv value array (warn about this elsewhere)
       if (proj_on) then; ap=dpar;  bp=dperp; else; ap=drms ; endif
       y(j)=d ! restore correct value
! compute largest absolute error
!         r_f(jj,2,ref)=0.5d0/h*(ap-am) ! aa
!         r_f(jj,2,rave)=0.5d0/h*(bp-bm) ! aa
!
       error(1,2) = max (error(1,2),                                    &
     &          abs(0.5d0/h*(ap-am)-r_f(jj,2,fpar) ) )
       if (proj_on)                                                     &
     & error(2,2) = max (error(2,2),                                    &
     &         abs(0.5d0/h*(bp-bm)-r_f(jj,2,fperp) ) )
! z-derivatives *******************************************
       d=z(j) ; z(j)=d-h
       __FTSM_CALC(x,y,z,.false.,s)
       if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
       z(j)=d+h
       __FTSM_CALC(x,y,z,.false.,s) ! overwrite zold cv value array (warn about this elsewhere)
       if (proj_on) then; ap=dpar;  bp=dperp; else; ap=drms ; endif
       z(j)=d ! restore correct value
! compute largest absolute error
!         r_f(jj,3,ref)=0.5d0/h*(ap-am) ! aa
!         r_f(jj,3,rave)=0.5d0/h*(bp-bm) ! aa
!
       error(1,3) = max (error(1,3),                                    &
     &         abs(0.5d0/h*(ap-am)-r_f(jj,3,fpar) ) )
       if (proj_on)                                                     &
     & error(2,3) = max (error(2,3),                                    &
     &         abs(0.5d0/h*(bp-bm)-r_f(jj,3,fperp) ) )
      enddo ! forced atoms
!
!        write(mestring+500,*) r_f(:,1,ref) ! aa
!        write(mestring+500,*) r_f(:,1,rave) ! aa
!           close(mestring+500)
! orientation atoms:
      if (qorient.and.qdiffrot) then
       do jj=1, norient
        j=iatom_o(jj)
! x-derivatives *******************************************
        d=x(j) ; x(j)=d-h
        __FTSM_CALC(x,y,z,.false.,s)
        if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
        x(j)=d+h
        __FTSM_CALC(x,y,z,.false.,s) ! overwrite zold cv value array (warn about this elsewhere)
        if (proj_on) then; ap=dpar;  bp=dperp; else; ap=drms ; endif
        x(j)=d ! restore correct value
! compute largest absolute error
        error(1,1) = max(error(1,1),                                    &
     &         abs(0.5d0/h*(ap-am)-r_o(jj,1,fpar) ) )
        if (proj_on)                                                    &
     &  error(2,1) = max(error(2,1),                                    &
     &         abs(0.5d0/h*(bp-bm)-r_o(jj,1,fperp) ) )
! y-derivatives *******************************************
        d=y(j) ; y(j)=d-h
        __FTSM_CALC(x,y,z,.false.,s)
        if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
        y(j)=d+h
        __FTSM_CALC(x,y,z,.false.,s) ! overwrite zold cv value array (warn about this elsewhere)
        if (proj_on) then; ap=dpar;  bp=dperp; else; ap=drms ; endif
        y(j)=d ! restore correct value
! compute largest absolute error
        error(1,2) = max (error(1,2),                                   &
     &         abs(0.5d0/h*(ap-am)-r_o(jj,2,fpar) ) )
        if (proj_on)                                                    &
     &  error(2,2) = max (error(2,2),                                   &
     &         abs(0.5d0/h*(bp-bm)-r_o(jj,2,fperp) ) )
! z-derivatives *******************************************
        d=z(j) ; z(j)=d-h
        __FTSM_CALC(x,y,z,.false.,s)
        if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
        z(j)=d+h
        __FTSM_CALC(x,y,z,.false.,s) ! overwrite zold cv value array (warn about this elsewhere)
        if (proj_on) then; ap=dpar;  bp=dperp; else; ap=drms ; endif
        z(j)=d ! restore correct value
! compute largest absolute error
        error(1,3) = max (error(1,3),                                   &
     &         abs(0.5d0/h*(ap-am)-r_o(jj,3,fpar) ) )
        if (proj_on)                                                    &
     &  error(2,3) = max (error(2,3),                                   &
     &         abs(0.5d0/h*(bp-bm)-r_o(jj,3,fperp) ) )
       enddo ! orientation atoms
      endif ! qdiffrot and qorient
!
      end function ftsm_test_grad_fd
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function ftsm_test_parallel(x,y,z) result(error)
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
!
      float :: x(:), y(:), z(:)
      float, pointer :: error(:,:)
      float :: am, bm
!
      bool :: qpara
      bool :: qgrp
!
      __IAM(FTSM_TEST_PARALLEL)
      allocate(error(2,4)) ! first column contains the CV values; then maximum derivative error (x,y,z)
      error(2,:)=0d0; error(1,:)=9999d0
!
      if (.not.ftsm_check(qorient)) return
!
      qgrp=(MPI_COMM_LOCAL.ne.MPI_COMM_NULL)                            &
     & .and.(SIZE_LOCAL.gt.1)
      if (.not. qgrp) then ! quit if cannot run in parallel
       __WRN(whoami,'CANNOT PERFORM TEST ON 1-PROCESSOR GROUPS')
       return
      endif
! save values & force a serial calculation
      qpara=calc_bestfit_grad_para; calc_bestfit_grad_para=.false.
!
! 1) compute serially
      __FTSM_CALC(x,y,z,.true.)
! using left_cur array : it should not be used unless an additional parameter is passed to calc
! save gradients
      r_f(:,:,left_cur)=r_f(:,:,fpar); r_f(:,:,fpar)=0d0;
      if (qorient.and.qdiffrot) then
       r_o(:,:,left_cur)=r_o(:,:,fpar); r_o(:,:,fpar)=0d0
      endif
!
      if (proj_on) then
       r_f(:,:,right_cur)=r_f(:,:,fperp); r_f(:,:,fperp)=0d0
       if (qorient.and.qdiffrot) then
        r_o(:,:,right_cur)=r_o(:,:,fperp); r_o(:,:,fperp)=0d0
       endif
      endif
!        write(me_GLOBAL+500,*) drms, dpar, dperp
!        write(me_GLOBAL+500,*) r_o(:,2,left_cur)
! save projections
      if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
!
! 2) compute in (fully) parallel
      calc_bestfit_grad_para=.true.
!
      __FTSM_CALC(x,y,z,.true.)
!        write(me_GLOBAL+500,*) drms, dpar, dperp
!        write(me_GLOBAL+500,*) r_o(:,2,fpar)
!         close(me_GLOBAL+500)
! compute largest absolute error
! parallel component (or drms)
      error(1,1) = maxval ( abs (r_f(:,1,left_cur)-r_f(:,1,fpar) ) )
      error(1,2) = maxval ( abs (r_f(:,2,left_cur)-r_f(:,2,fpar) ) )
      error(1,3) = maxval ( abs (r_f(:,3,left_cur)-r_f(:,3,fpar) ) )
      if (proj_on) then
       error(2,1) = maxval ( abs (r_f(:,1,right_cur)-r_f(:,1,fperp) ) )
       error(2,2) = maxval ( abs (r_f(:,2,right_cur)-r_f(:,2,fperp) ) )
       error(2,3) = maxval ( abs (r_f(:,3,right_cur)-r_f(:,3,fperp) ) )
       error(2,4) = abs ( dperp - bm )
       error(1,4) = abs ( dpar  - am )
      else
       error(1,4) = abs ( drms  - am )
      endif
!
      if (qdiffrot.and.qorient) then
       error(1,1) = max(error(1,1),                                     &
     &              maxval ( abs (r_o(:,1,left_cur)-r_o(:,1,fpar) ) ) )
       error(1,2) = max(error(1,2),                                     &
     &              maxval ( abs (r_o(:,2,left_cur)-r_o(:,2,fpar) ) ) )
       error(1,3) = max(error(1,3),                                     &
     &              maxval ( abs (r_o(:,3,left_cur)-r_o(:,3,fpar) ) ) )
       if (proj_on) then
        error(2,1) = max(error(2,1),                                    &
     &              maxval ( abs (r_o(:,1,right_cur)-r_o(:,1,fperp) ) ))
        error(2,2) = max(error(2,2),                                    &
     &              maxval ( abs (r_o(:,2,right_cur)-r_o(:,2,fperp) ) ))
        error(2,3) = max(error(2,3),                                    &
     &              maxval ( abs (r_o(:,3,right_cur)-r_o(:,3,fperp) ) ))
       endif
      endif
! restore original option
      calc_bestfit_grad_para=qpara
!
      end function ftsm_test_parallel
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! VO 1/2013 modifying function call to include string minimization option
      subroutine ftsm_main(x,y,z,xcomp,ycomp,zcomp,fx,fy,fz,mass,iteration           & ! include comparison set for voronoi calculations
#ifdef __CHARMM
     &                    , wmain, nbond_data, image_data     & ! to be passed on to ftsm_mini
#endif
     &                    )
!
      __DEP_PARSER
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_MPI
      __DEP_OUTPUT
      __DEP_NUMBER
      __CHARMM_ONLY use chm_types, only : nonbondDataStructure, imageDataStructure
      use tsp ! traveling salesman module
!
!
      __DECLARE_MSGBUF
!
      float, dimension(:) :: x, y, z, xcomp, ycomp, zcomp, fx, fy, fz, mass
      int :: iteration ! MD iteration
!
#ifdef __CHARMM
! CHARMM - dependent energy evaluation routines/vars
      float :: wmain(:)
      type(nonbondDataStructure) :: nbond_data
      type(imageDataStructure)   :: image_data
#endif
!     locals
      float :: s=zero, t, omt
      bool :: qgrp
!
      __IAM(FTSM_MAIN)
!==========================================================================
      if (ftsm_ini_iteration.lt.0) ftsm_ini_iteration=iteration
!
      qgrp=(MPI_COMM_LOCAL.ne.MPI_COMM_NULL).and.(SIZE_LOCAL.gt.1)
!==========================================================================
!     evolution of dperp, if requested
      if (dperp_adjust_iter.gt.0) then
       if (dperp0f.ne.__NAN) then
        s=one*(iteration-ftsm_ini_iteration)/dperp_adjust_iter ; s=min(max(s,zero),one); ! limit s to range [0,1]
        dperp0 = s * dperp0f + (one-s) * dperp0i
       endif
      endif
! aa
!       write(me_global+600,*) dperp0, dperp0i, dperp0f, dperp_adjust_iter
!
      restraint_force_on=.false.
!
      if (restrained_on) then ! impose restraints
!
       if (.not.unrestrained_on .or.                                    & ! if unrestrained dynamics is off
     &    (unrestrained_on.and.                                         & ! or: unrestrained dyn. is on, BUT we are equilibrating w/ res.
     &    ((iteration-unrestrained_eq0).lt.unrestrained_eq_steps))) then  ! first equilibrate with restraints on, then release restraints
!
        restraint_force_on=.true.
!
!    limit s to range [0,1], even though calc works fine with s>1
        if (restrained_eq_steps.gt.0) then
         s=one*(iteration-restrained_eq0)/restrained_eq_steps ; s=min(max(s,zero),one)
        else
         s=one
        endif
!aa
! write(600+ME_GLOBAL,*) iteration, restrained_eq0, restrained_eq_steps, s ; ! close(600+ME_GLOBAL)
!
!     evolution of dpar if necessary (used during string evolution in unscaled version of code)
        if (dpar0f.ne.__NAN) then
         dpar0 = s * dpar0f + (one-s) * dpar0i
        endif
!
        __FTSM_CALC(x,y,z,.true.,s)             ! compute gradients
        call ftsm_addforce(fx,fy,fz,s.ge.one)      ! add restraint forces to global force arrays
!
       endif ! unrestrained_on
      endif ! restrained_on
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     the following only gets executed if iteration > olditeration;
!     this is because CHARMM executes frequent 'restarts' at the least frequency
!     that is common to all output counters; a restart will require two calls to this routine;
!     to avoid duplicating statistics + evolution etc (since the step # is the same!) I keep track
!     of the iteration counter, and proceed only if the iteration counter has increased.
      if (iteration.gt.olditeration) then
       if (evolve_ftsm_on.and.evolve_freq.gt.0) then
!
        if ( mod(iteration,evolve_freq).eq.0 .and.                      &
     &       (iteration-restrained_eq0.gt.evolve_nskip)) then 
! note that e_nskip is relevant even with restraints off, i.e. not protected by "restrained_on"; when restraints are off we are still using
! restrained_eq0 (which gets reset after each update)
         call ftsm_evolve(x,y,z) ;
!------------------------------------------------------------------------
! compute M tensor : NB, currently computed as a statistic only; no functional role (no compelling reason to do otherwise)
         if (output_M) then
          call ftsm_calc_M(x,y,z,mass,s) ! computes instantaneous M (Mtensor(:,:,:,:,1))
          num_M_samples=num_M_samples+1
          omt=one/num_M_samples
          t=one-omt
          Mtensor(:,:,:,:,2) = t * Mtensor(:,:,:,:,2) + omt * Mtensor(:,:,:,:,1) ! add to running average
!aa
!         if (ME_STRNG.eq.0) then
!          write(700+ME_STRNG,*) '% ',s, olditeration, iteration, evolve_freq
!          write(700+ME_STRNG,'(30F12.6)') ( (Mtensor(:,a,:,k,1), a=1,3), k=1,nforced ) ;              close(700+me_strng) 
!          write(800+ME_STRNG,'(30F12.6)') ( (Mtensor(:,a,:,k,2), a=1,3), k=1,nforced ) ;              close(800+me_strng) 
!         endif
!         call MPI_BARRIER(MPI_COMM_GLOBAL,i)
!         stop
!aa
         endif ! output_M
!
! compute approximate Jacobian : NB, currently computed as a statistic only; no functional role
         if (output_J) then
          call ftsm_calc_J(x,y,z,s) ! computes instantaneous J
          num_J_samples=num_J_samples+1
          omt=one/num_J_samples
          t=one-omt
          Jacobian(2) = t * Jacobian(2) + omt * Jacobian(1) ! add to running average
         endif ! output_J
        endif ! evolve_freq
       endif ! evolve
!------------------------------------------------------------------------
       if (update_on.and.update_freq.gt.0) then
        if (mod(iteration,update_freq).eq.0) then
         if (.not.string_noprint) then 
          write(_MSGBUF,'(2A,I10)') whoami,' UPDATING STRING AT STEP ',iteration ; __PRINTL(_MSGBUF,3)
         endif
! VO 4.2014 : see if image reconnection requested
         if (ftsm_reconnect_on) then 
          if (.not.string_noprint) then 
             write(_MSGBUF,'(2A)') whoami,' RECONNECTING IMAGES TO MINIMIZE ATH LENGTH.' ; __PRINTL(_MSGBUF,3)
          endif
          call ftsm_reconnect(iteration)
         endif
!
         if (proj_on) then
!    save old reference coordinates
          r_f(:,:,left_old:right_old)=r_f(:,:,left:right)
          r_f(:,:,center)=r_f(:,:,center_new)
          if (qorient.and.qdiffrot) then
           r_o(:,:,left_old:right_old)=r_o(:,:,left:right)
           r_o(:,:,center)=r_o(:,:,center_new)
!    make sure orientation coordinates are current
           call ftsm_update_overlap_coor(ione) ! r_f --> r_o
          endif
         else  ! not proj_on (voronoi tessellation should also be covered in this case)
!    save old reference coordinates and switch to new reference coordinates
          if (.not.string_noprint) then 
           write(_MSGBUF,'(2A)') whoami,' UPDATING REFERENCE IMAGES.' 
           __PRINTL(_MSGBUF,3)
          endif
          r_f(:,:,center_old)=r_f(:,:,center)
          r_f(:,:,center)=r_f(:,:,center_new)
          if (qorient.and.qdiffrot) then
           r_o(:,:,center_old)=r_o(:,:,center)
           r_o(:,:,center)=r_o(:,:,center_new)
!    make sure orientation coordinates are current
           call ftsm_update_overlap_coor(ione) ! r_f --> r_o
          endif
         endif ! proj_on
!
! VO 1.2013 : see if image minimization is requested
         if (ftsm_mini_on) then
            if (.not.string_noprint) then 
             write(_MSGBUF,'(2A)') whoami,' MINIMIZING IMAGE ENERGY.' ; __PRINTL(_MSGBUF,3)
            endif
            call ftsm_mini(x, y, z                           &
#ifdef __CHARMM
     &                    ,wmain, nbond_data, image_data     &
     &                    ,fx, fy, fz                        & ! to make sure forces are not overwritten 
#endif
     &                    )
         endif ! ftsm_mini_on
!    see if reparametrization requested
         if (repa_on) then
          if (.not.string_noprint) then 
             write(_MSGBUF,'(2A)') whoami,' REPARAMETRIZING IMAGES.' 
             __PRINTL(_MSGBUF,3)
          endif
          call ftsm_repa(.not.proj_on) ! reparametrize string, proj_on: do not broadcast to slaves b/c ftsm_swap_bc ; removes COM
         else
!    recompute and remove centers of mass (which will change due to repa)
           call ftsm_save_com()
         endif ! repa_on
!    update reference coordinates
         if (proj_on) then
          if (.not.string_noprint) then 
           write(_MSGBUF,'(2A)') whoami,' UPDATING NEIGHBOR IMAGES.' ; __PRINTL(_MSGBUF,3)
          endif
          call ftsm_swap_bc(.true.) ! VO changed from false to true 1/2013 (why was it false? problem only in parallel)
         endif ! proj_on
!------------------------------------------------------------------------
!    Voronoi tessellation:
!    smart-update voronoi data: if update too aggressive and some replicas end up in a wrong v. cell, string coords will be rolled back; 
         if (voronoi_hist_on) call ftsm_voronoi_smart_update(x,y,z,xcomp,ycomp,zcomp) 
!
!    reset arrays for updating reference structure
         r_f(:,:,center_new)=r_f(:,:,center)
         if (qorient.and.qdiffrot) r_o(:,:,center_new)=r_o(:,:,center)
!
         if (unrestrained_on) unrestrained_eq0=iteration
         restrained_eq0=iteration
!
!    if we are working in unscaled coordinates, string length changes due to evolution/repa/mini; therefore we need to update the reference distance
!    however, this is not so simple because the string adjusts gradually to avoid instability; this means that we have to adjust dpara gradually also
!    to do this, I will introduce dpar0f in analogy with dperp0f
         dpar0i=dpar0 ; ! current target becomes initial target
         dpar0f= sum(ds) / ( max( nstring-1 , 1 ) ) * sqrt3 ; ! sqrt(3) makes the arclength correspond to the RMSD in 3D
!
        endif ! update_on
       endif ! update_on
!
       if (repl_x_on.and.repl_x_freq.gt.0) then
        if (mod(iteration, repl_x_freq).eq.0) then
         if (.not.string_noprint) then 
          write(_MSGBUF,'(2A)') whoami,' ATTEMPTING EXCHANGE OF NEIGHBORING REPLICAS.' ; __PRINTL(_MSGBUF,3)
         endif
         call ftsm_repl_exchange(x, y, z, iteration)
        endif
       endif
!
       if (stat_on.and.stat_freq.gt.0) then
         if (mod(iteration,stat_freq).eq.0) then
           write(_MSGBUF,'(2A)') whoami,' CALLING STRING STATISTICS.' ; __PRINTL(_MSGBUF,3)
           call ftsm_stat() ! output statistics
         endif
       endif ! stat_on
      endif ! iteration > olditeration
!     update internal iteration counter
      olditeration=iteration
!
      end subroutine ftsm_main
!===========================================================================
      subroutine ftsm_evolve(x,y,z)
      __DEP_NUMBER
      float :: x(:), y(:), z(:)
      int :: ind, j, k
      float :: t, omt
      float :: u (3,3)= Id3
      float, pointer :: r_com(:), ow(:)
      float, pointer, dimension(:,:) :: roi, roc, rfi, rfc
!
      roi=>r_o(:,:,instant)
      ow=>orientWeights
      rfi=>r_f(:,:,instant)
      r_com=>rcom(:,instant)
!
      roc=>r_o(:,:,center_new)
      rfc=>r_f(:,:,center_new)
!
      if (evolve_aver_on) then
       if (num_evolve_samples.lt.max_evolve_samples.or.                 &
     &     max_evolve_samples.le.0)                                     &
     &                num_evolve_samples=num_evolve_samples+1
       omt=1d0/num_evolve_samples
       t=1d0-omt
      elseif (evolve_expo_on) then
       t=evolve_expo_mem
       omt=1d0-t
      endif
!
      if (.not. restraint_force_on) then ! load coordinates unless restraints on, in which case they are loaded
!
       do k=1,nforced
        ind=iatom_f(k)
        rfi(k,1)=x(ind)
        rfi(k,2)=y(ind)
        rfi(k,3)=z(ind)
       enddo
!
       if (qorient) then
        if (qdiffrot) then
         do k=1,norient
          ind=iatom_o(k)
          roi(k,1)=x(ind)
          roi(k,2)=y(ind)
          roi(k,3)=z(ind)
         enddo
        endif ! qdiffrot (otherwise rfi and roi point to the same thing)
!
!       translate forced atoms to centroid
        r_com(:)=0d0;
        do j=1,3 ; do k=1, norient;
          r_com(j) = r_com(j)+ow(k)*roi(k,j)
        enddo ;    enddo
!
        rfi(:,1)=rfi(:,1)-r_com(1)
        rfi(:,2)=rfi(:,2)-r_com(2)
        rfi(:,3)=rfi(:,3)-r_com(3)
!
        if (qdiffrot) then
         roi(:,1)=roi(:,1)-r_com(1)
         roi(:,2)=roi(:,2)-r_com(2)
         roi(:,3)=roi(:,3)-r_com(3)
        endif ! qdiffrot
!
       endif ! qorient
      endif ! .not. restrained on
!
      if (qorient) then ! orient w.r.t. center image
       call RMSBestFit(roc,roi,ow,u) ! superpose roc onto roi
       rfc = t * rfc + omt * matmul(rfi, u) !          apply transpose (=inverse) of u to rfi
      else
!    evolve image using instantaneous structure
       rfc = t * rfc + omt *rfi
      endif
!    NOTE that if the forcing set overlaps with orientation set, we also need to
!    update some atom coords in the orientation set; this is done elsewhere to save CPU time
!    NOTE also that rfi is not rotated
      end subroutine ftsm_evolve
!============================================================================
      subroutine ftsm_compute_fe_fd()
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI
      __DEP_NUMBER
!
#include "../../mpitype.def"
!
      float :: avforces(3,nstring), qcurv
      int :: ierror, i
      __IAM(FTSM_COMPUTE_FE_FD)
!
      if (proj_on) then
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.                         &
     &                         SIZE_STRNG.gt.1) then

        call MPI_GATHER(avforce, 3, mpifloat,               &
     &                 avforces, 3, mpifloat,               &
     &                 0, MPI_COMM_STRNG, ierror)
        fe(1)=0d0
!
        if (fe_curvature) then ; qcurv=one ; else ; qcurv=zero ; endif
!
        if (ftsm_scaledist) then
         do i=2, nstring
          fe(i)  =fe(i-1) - half * ( avforces(1,i-1) + avforces(1,i) + qcurv*( avforces(2,i-1) + avforces(2,i) ) )
!          fe(i-1)=fe(i-1) - ( avforces(2,i-1) - avforces(2,1) )
         enddo
!        fe(nstring)=fe(nstring) - ( avforces(2,nstring) - avforces(2,1))
        else ! integrate along curve using arclength in ds
         do i=2, nstring
          fe(i)  =fe(i-1) - ds(i-1) * half * ( avforces(1,i-1) + avforces(1,i) + qcurv*( avforces(2,i-1) + avforces(2,i) ) )
         enddo
        endif
!
       endif ! qroot
      endif ! proj_on
!
!      send free energy to slaves -- no need at present time
!       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.
!     &                         SIZE_LOCAL.gt.1) then
!        call __BROADCAST_LOCAL_8B(fe,nstring)
!       endif
!
      end subroutine ftsm_compute_fe_fd
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_orient(comlyn, comlen)
! based on sm0k_repa_init
      __DEP_OUTPUT
      __DEP_SIZE
      __DEP_PARSER
      __DEP_COORDINATES
      __DEP_SELECT
      __DEP_NUMBER
      __DEP_MULTICOM
#ifdef __CHARMM
      use sm0k, only:sm0k_fixed_atoms
#endif
!
      __IMPNONE
 __DECLARE_MSGBUF
!
      character(len=*) :: comlyn
      int :: comlen
!
#ifdef __CHARMM
      int, pointer :: iselct(:), ifixed(:)
      int :: imode
#elif defined(__DMOL)
  __DECLARE_DMOL_SELECT
#endif
      float, pointer :: rcurrent_o(:,:), rref_o(:,:), ow(:) ! coordinates and orientation weights
      int :: norient
      float :: orient_mass, wsum
      float :: u(3,3)= RESHAPE( (/one,zero,zero,zero,one,zero,zero,zero,one/), (/3,3/) ) ! rotation matrix
      float :: rcurrent_com(3)=(/zero,zero,zero/) ! COM vector
      int :: i, j, me, ncpu, ierror, stat(MPI_STATUS_SIZE)
      bool :: qroot, qslave
!
#ifdef __DMOL
      int :: natom
#endif
!
#include "../../mpitype.def"
!
      __IAM(FTSM_ORIENT)
!
!===== begin
      qroot =MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.SIZE_STRNG.gt.1
      qslave=MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1
!
#ifdef __CHARMM
      allocate(iselct(natom)) ; iselct=1
       IMODE=0
      CALL SELRPN(COMLYN,COMLEN,iselct,NATOM,1,IMODE,                  &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
      if (IMODE.NE.0) then
       __WRN(whoami,'ATOM SELECTION ERROR.')
       deallocate(iselct)
       return
      endif
#elif defined(__DMOL)
#include "../../dmol_select_macro.def"
#endif
!     check for mass weighting
      if (__INDX_RM(comlyn,comlen,'MASS').gt.0) then ; orient_mass=one; else ; orient_mass=zero; endif
!
#ifdef __CHARMM
      norient=count( iselct(1:natom).gt.0 ) ! total number of orientation atoms
#elif defined(__DMOL)
      if (associated(iselct)) then ; norient=size(iselct) ; else ; norient=0 ; endif 
#endif
!
      if (norient.eq.0) then
        __WRN(whoami,'NO ATOMS SELECTED FOR ORIENTATION. NOTHING DONE.')
__CHARMM_ONLY       deallocate(iselct)
       return
      elseif (norient.lt.3) then
        __WRN(whoami,'FEWER THAN THREE ATOMS SELECTED FOR ORIENTATION. NOTHING DONE.')
__CHARMM_ONLY       deallocate(iselct)
       return
      endif
!
        write(_MSGBUF,670) whoami, itoa(norient) ; __PRINTL(_MSGBUF,3)
 670  format(A,' INSTANTANEOUS (STRING) COORDINATES WILL BE ORIENTED BASED ON ',A,' ATOMS')
        if (orient_mass.eq.1) then ; write(_MSGBUF,671) whoami ; __PRINTL(_MSGBUF,3) ; endif
 671  format(A,' ORIENTATION WILL USE MASS-WEIGHTING')
!=== check for fixed atoms (allowed, but warrant a warning)
#ifdef __CHARMM
      ifixed=>sm0k_fixed_atoms()
      if (size(ifixed).gt.0) then
       __WRN(whoami,'FIXED ATOMS FOUND. ALL COORDINATES WILL BE MODIFIED BY ORIENTATION.')
      endif
      deallocate(ifixed)
#endif
!
      allocate(rcurrent_o(norient,3), rref_o(norient,3), ow(norient))
!
      rcurrent_com=zero
#ifdef __CHARMM
      j=1
      do i=1, natom
       if (iselct(i).gt.0) then
        rcurrent_o(j,1)=__XX(i);       rcurrent_o(j,2)=__YY(i);        rcurrent_o(j,3)=__ZZ(i);
        ow(j)= one-orient_mass + __MASS(i) * orient_mass
        rcurrent_com = rcurrent_com + ow(j)*rcurrent_o(j,:)
        wsum=wsum+ow(j)
!
        j=j+1;
       endif
      enddo
! aa
! write(700+ME_STRNG,*) ow, wsum, norient
! write(700+ME_STRNG,*) orient_mass, rcurrent_com
! write(700+ME_STRNG,*) rcurrent_o
! write(700+ME_STRNG,*) natom,size(__X), __XX(1:natom)
! write(700+ME_STRNG,*) natom,size(__Y), __YY(1:natom)
! write(700+ME_STRNG,*) natom,size(__Z), __YY(1:natom)
! close(700+ME_STRNG)
#elif defined(__DMOL)
      do j=1, norient
        i=iselct(j)
        rcurrent_o(j,1)=__XX(i);       rcurrent_o(j,2)=__YY(i);        rcurrent_o(j,3)=__ZZ(i);
        ow(j)= one-orient_mass + __MASS(i) * orient_mass
        rcurrent_com = rcurrent_com + ow(j)*rcurrent_o(j,:)
        wsum=wsum+ow(j)
      enddo
#endif
      if (wsum.gt.__ERRTOL) then ; wsum=one/wsum ; else ; wsum=1; endif
      ow=ow*wsum
      rcurrent_com=rcurrent_com*wsum
! subtract COM : note that all nodes compute it, which is why we do not need to broadcast it below
       rcurrent_o(:,1)=rcurrent_o(:,1)-rcurrent_com(1)
       rcurrent_o(:,2)=rcurrent_o(:,2)-rcurrent_com(2)
       rcurrent_o(:,3)=rcurrent_o(:,3)-rcurrent_com(3)
!
! compute rotation matrices
      if (qroot) then
!      send/receive orientation structure
        me=ME_STRNG
        ncpu=SIZE_STRNG
        if (me.gt.0) then
         call mpi_recv(rref_o,3*norient,mpifloat,me-1,1,                   &
     &        MPI_COMM_STRNG, stat, ierror)
!       orient rcurrent based on rref
!       no checking for undefined coordinates here
         call RMSBestFit(rref_o,rcurrent_o,ow,u) ! superpose rref onto rcurrent
!       transform current structure to overlap with reference
         rref_o=matmul(rcurrent_o, u) ! this should be safer than overwriting rcurrent_o
        else
         rref_o=rcurrent_o
        endif ! me
        if (me.lt.ncpu-1) then
         call mpi_send(rref_o,norient*3,mpifloat,me+1,1,               &
     &        MPI_COMM_STRNG, ierror)
        endif ! me
      endif ! root
!
! broadcast COM and rotation matrix to slaves
!
      if (qslave) then 
#ifdef __CHARMM
       __BROADCAST_LOCAL_4B(u,9) !##SINGLE
       __BROADCAST_LOCAL_8B(u,9) !##.not.SINGLE
#else
       __BROADCAST_LOCAL(u,9,mpifloat)
#endif
      endif
! perform rotation of all coordinates
#ifdef __DMOL
      natom=__NATOM
#endif
!
!aa write(600+me,*) u, rcurrent_com
! close(600+me)
      do i=1, natom
! reuse rref array
        rref_o(1,1)=__XX(i)-rcurrent_com(1);
        rref_o(1,2)=__YY(i)-rcurrent_com(2);
        rref_o(1,3)=__ZZ(i)-rcurrent_com(3);
        rref_o(2,:)=matmul(rref_o(1,:),u); ! rotate and place into rref(2) -- there must be at least 3 o. atoms
        __XX(i)=rref_o(2,1)
        __YY(i)=rref_o(2,2)
        __ZZ(i)=rref_o(2,3)
      enddo
!
! done !
      if (associated(iselct)) deallocate(iselct)
      if (associated(rcurrent_o)) deallocate(rcurrent_o)
      if (associated(ow)) deallocate(ow)
!
      end subroutine ftsm_orient
!=================================================================
      subroutine ftsm_repl_exchange(x,y,z,itime)
!     attempt to swap restraints that correspond to two adjacent replicas
      use multicom, only: multicom_permute_string_ranks
      use ftsm_rex, only: ftsm_rex_init, rex_initialized, rex_map,      &
     &   rex_log, rex_beta, rex_string_datatype, rex_string_data_mpi
      use ivector, only: int_vector_add
!
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_CONST 
      __DEP_NUMBER
      __DEP_RANDOM
      __DEP_MDOUT
      __DEP_PARSER
      __DEP_MPI
!
#include "../../mpitype.def"
!
      float :: x(:), y(:), z(:) ! mass(size(x,1))
      int :: itime
!
      int :: i, j, stat(MPI_STATUS_SIZE)
      int4mpi :: ierror
      integer(KIND=MPI_ADDRESS_KIND) :: lb, extent
      bool :: deriv, qendpoint, qgrp, qvalid
!
      int :: which   ! replica with which the exchange was attempted
      bool :: success ! whether the exchange attempt was successful
      int :: nodelist(nstring) ! holds new string replica order after exchange attempt
!      int :: itype ! MPI_INTEGER type
      int :: ndata, nfiles
!
!     variables for exchanging string-dependent properties
      type(rex_string_datatype) :: rex_string_data, rex_string_data_new
      float :: dE_me, dE, s, dpar_ori, dperp_ori, drms_ori, fac
!
      character(len=200) :: fnames(5)              ! for storing output  file names
      character(len=200) :: new_fnames(5)          ! for storing swapped file names
#ifndef __DMOL
      bool :: openun(5), qform, qwrite
      int :: oldiol
#endif
!
      float, pointer, dimension(:,:,:) :: r_f2, r_o2, r_f3, r_o3
!
      __IAM(FTSM_REPL_EXCHANGE)
!
      if (.not.rex_initialized) call ftsm_rex_init()
!
      if (.not.ftsm_check(qorient)) return
      if (      ( .not. restrained_on ) & ! restraints are off
&         .or.  ( restrained_on .and. unrestrained_on .and. ( (itime-unrestrained_eq0) .ge. unrestrained_eq_steps ) ) ) & ! unrestrained exploration
&      return
!
      qgrp=(MPI_COMM_LOCAL.ne.MPI_COMM_NULL)                            &
     &  .and.(SIZE_LOCAL.gt.1)
!
      deriv=.false. ! do not compute derivatives
      dE=zero
      success=.false.
!
!     determine exchange partner
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
       if (ME_STRNG.eq.0) which=INT(__RANDOMU(__SEED)*2d0) ! either 0 or 1
       call MPI_BCAST(which, 1, mpiint, 0, MPI_COMM_STRNG, ierror)     ! string root broadcasts to all replicas
!    determine whether swapping w. left (-1) or w. right (+1) neighbor & calculate rank of neighbor
       which=ME_STRNG + (mod(ME_STRNG + which, itwo)*itwo - ione)
!      if which == 0, then: -1, 2, 1, 4, 3, ...
!      if which == 1, then:  1, 0, 3, 2, ...
!      communicate:
       qvalid=(which.ge.0).and.(which.lt.SIZE_STRNG)
       if (qvalid) then
!     store reference values in dummy
!     need to store all replica-dependent parameters
        rex_string_data%dpar0 = dpar0;
        rex_string_data%dperp0= dperp0;
        rex_string_data%drms0 = drms0;
        rex_string_data%qrms_upper_bound=qrms_upper_bound
        rex_string_data%kpara = kpara;
        rex_string_data%kperp = kperp;
        rex_string_data%krms  = krms;
        rex_string_data%evolve_expo_mem = evolve_expo_mem;
        rex_string_data%num_evolve_samples = num_evolve_samples;
        rex_string_data%avforce = avforce
        rex_string_data%ftsm_mini_on = ftsm_mini_on
        rex_string_data%evolve_expo_on = evolve_expo_on
        rex_string_data%evolve_aver_on = evolve_aver_on
!
!     send/receive
!     allocate storage for new restraints
        allocate(r_f2(nforced,3,num_sets))
        ndata=3*(nforced*9) ! number of reals to send
        call MPI_SENDRECV(r_f, ndata, mpifloat,             & ! send almost everything
     &   which, which, r_f2, ndata, mpifloat,               & ! put into the same array, starting at position 11
     &   which, ME_STRNG, MPI_COMM_STRNG, stat, ierror)
        if (qorient) then
         if (qdiffrot) then ! orientation atoms
!     allocate storage for new restraints
          allocate(r_o2(nforced,3,num_sets))
          ndata=27*norient
          call MPI_SENDRECV(r_o, ndata, mpifloat,           &
     &    which, which, r_o2, ndata, mpifloat,              &
     &    which, ME_STRNG, MPI_COMM_STRNG, stat, ierror)
         else
          r_o2=>r_f2
         endif ! qdiffrot
        endif ! qorient
! also exchange string image properties
        call MPI_SENDRECV(rex_string_data, 1, rex_string_data_mpi, which, which, & 
     &                    rex_string_data_new, 1, rex_string_data_mpi, which, ME_STRNG,&
     &                    MPI_COMM_STRNG, stat, ierror)

! NOTE: in the above communication it is essential to have certain sets adjacent, as indicated by numbering in fts_var; do not break this
!     calculate new string energies
        dpar_ori=dpar; dperp_ori=dperp; drms_ori=drms; ! first, save this replica`s projection values
!     swap arrays:
        r_f3=>r_f; r_o3=>r_o ! save in case move is rejected
        r_f=>r_f2; r_o=>r_o2 ! point to new array
!    call calculation
!    consider the possibility that equilibration is underway:
        if (restrained_eq_steps.gt.0) then
         s=one*(itime-restrained_eq0)/restrained_eq_steps ; s=min(one,max(zero,s))
        else
         s=one
        endif ! restrained equilibration is on
!
        deriv=.false. ! skip derivative calculation
        __FTSM_CALC(x,y,z,deriv,s) ! will compute new dpar, dperp, drms
!
!    calculate energies (adapted from _addforce):
!
        if (proj_on) then
! restraint force parallel to string
         qendpoint=(which.eq.0.or.which.eq.nstring-1)
         if (qendpoint) then ; fac=half ; else ; fac=one  ; endif
! compare energies (NOTE: in this version of REX, I am sending reference values, NOT coordinates)
!    new energy
         dE_me =  rex_string_data_new%kpara * fac * fac * ( dpar-rex_string_data_new%dpar0 )**2               & ! scale down the force constant of endpoints (one for d, one for gradients)
     &         +  rex_string_data_new%kperp * fac * max   ( fac * dperp - rex_string_data_new%dperp0, zero )**2 ! ignore negative values; dperp0 criterion in inner-replica d-metric
!    old energy
         qendpoint=(mestring.eq.0.or.mestring.eq.nstring-1)
         if (qendpoint) then ; fac=half ; else ; fac=one  ; endif
!
         dE_me =  dE_me                                                 &
     &        - kpara * fac * fac * ( dpar_ori-dpar0 )**2               &
     &        - kperp * fac * max   ( fac * dperp_ori - dperp0, zero )**2

        else ! .not.  proj_on
         dE_me = zero ; 
         if (rex_string_data_new%qrms_upper_bound) then ; dE_me =  max ( drms-rex_string_data_new%drms0, zero ) **2 ; 
         else ; dE_me =  ( drms-rex_string_data_new%drms0 ) **2 ;
         endif
!
         if (qrms_upper_bound) then ; dE_me = dE_me - max ( drms_ori-drms0, zero ) **2 ;
         else ; dE_me = dE_me - ( drms_ori-drms0 ) **2 ;
         endif
!    do not forget to scale by force constant (half applied below)
         dE_me = rex_string_data_new%krms * dE_me
        endif
!
!    combine energies from two replicas:
        call MPI_SENDRECV(dE_me, 1, mpifloat,               &
     &   which, which, dE, 1, mpifloat,                     &
     &   which, ME_STRNG, MPI_COMM_STRNG, stat, ierror)
        dE = half * ( dE+dE_me )
!    5) apply Metropolis criterion
        if (dE.le.0d0) then
         success=.true.
        else
!    the higher-rank replica draws random number
!    this may not be correct because the random numbers will not come from the same sequence;
!    may change this later
         if (which.lt.ME_STRNG) then
          success=(__RANDOMU(__SEED).le.exp(-rex_beta*dE))
!     send to othe replica
          call MPI_SEND(success, 1, mpibool, which, which,          &
     &    MPI_COMM_STRNG, ierror)
         else
          call MPI_RECV(success, 1, mpibool, which, ME_STRNG,       &
     &    MPI_COMM_STRNG, stat, ierror)
         endif ! which lt ME_STRNG
        endif ! apply Metropolis
!
       endif ! qvalid ...
!    all root nodes continue (success=false for idle node(s)) :
       if (success) then
        call MPI_ALLGATHER(which, 1, mpiint,                             &
     &       nodelist, 1, mpiint, MPI_COMM_STRNG, ierror)
!
!     make entry in REX log (only lower-rank replica does this)
        if (ME_STRNG.lt.which) then
          j=ME_STRNG ! possible cast i4=>i8 accommodates in8 compilations
          i=int_vector_add(rex_log, j) ! this replica
          i=int_vector_add(rex_log, which)    ! exchanged with this replica
          i=int_vector_add(rex_log, itime + rextime_offset)    ! at this time
        endif ! ME_STRNG
!
!********************************************************************************************
!     swap restart & traj file info; otherwise restart files will correspond to wrong replica
!#ifdef __CHARMM
!        oldiol=iolev
!        iolev=1 ! so that vinqre works
!#endif
!
#ifndef __DMOL
        nfiles=2
!      can add others here
        if (__RESTART_FILE_UNIT.gt.0)                                                &
!    CHARMM VINQUIRE gives problems, did not bother to debug, since that code is obsolete anyway
     &    INQUIRE(UNIT=__RESTART_FILE_UNIT, OPENED=openun(1), NAME=fnames(1))
!     &   CALL VINQRE('UNIT',fnames(1),i,j,
!     &                    OPENUN(1),QFORM,QWRITE,iunwri)
        if (__TRAJ_FILE_UNIT.gt.0)                                                &
     &    INQUIRE(UNIT=__TRAJ_FILE_UNIT, OPENED=openun(2), NAME=fnames(2))
!     &   CALL VINQRE('UNIT',fnames(2),i,j,
!     &                    OPENUN(2),QFORM,QWRITE,iuncrd)
! aa
!         write(600+ME_STRNG,*) iunwri, fnames(1), iuncrd, fnames(2)
!
#else
! DYNAMOL does not store restart fid;
! furthermore, files are not kept open (so that they are complete in the case of a crash)
! all we have to do is exchange the file names
        nfiles=3
        fnames(1)=trajectoryoutname
        fnames(2)=restartoutname
        fnames(3)=statisticsoutname
#endif
!
        i=nfiles*len(fnames(1)) ! length of broadcast buffer
#ifndef __DMOL
        if ( __RESTART_FILE_UNIT .gt. 0 .or. __TRAJ_FILE_UNIT .gt. 0 )&
#endif
         call MPI_SENDRECV(fnames, i, MPI_BYTE,                     &
     &   which, which, new_fnames, i, MPI_BYTE,                     &
     &   which, ME_STRNG, MPI_COMM_STRNG, stat, ierror)
!         write(600+ME_STRNG,*) iunwri, new_fnames(1),
!     &            iuncrd, new_fnames(2)
!         close(600+ME_STRNG)
! assuming that the restart file is formatted (might change this later)
#ifndef __DMOL
        if (__RESTART_FILE_UNIT.gt.0.and.openun(1)) then
         close(__RESTART_FILE_UNIT)
         i=len(new_fnames(1))
         __TRIMA(new_fnames(1), i)
         open(UNIT=__RESTART_FILE_UNIT, FILE=new_fnames(1)(1:i), FORM='FORMATTED',   &
     &    STATUS='OLD', ACCESS='SEQUENTIAL')
        endif
! assuming that dcd file is unformatted
        if (__TRAJ_FILE_UNIT.gt.0.and.openun(2)) then
         close(__TRAJ_FILE_UNIT)
         i=len(new_fnames(2))
         __TRIMA(new_fnames(2), i)
         open(UNIT=__TRAJ_FILE_UNIT, FILE=new_fnames(2)(1:i), FORM='UNFORMATTED', &
!     &    STATUS='OLD', ACCESS='APPEND')
     &    STATUS='OLD', POSITION='APPEND')
        endif
#else
        trajectoryoutname=new_fnames(1)
        restartoutname   =new_fnames(2)
        statisticsoutname=new_fnames(3)
#endif
!#ifdef __CHARMM
!        iolev=oldiol
!#endif
!     done with swap output file info
!********************************************************************************************
!
         deallocate(r_f3); nullify(r_f2);
         if (qorient) then
          nullify(r_o2);
          if (qdiffrot) then ; deallocate(r_o3);
          else ; nullify(r_o3); endif
         endif ! qorient
       else ! success ( move rejected )
        call MPI_ALLGATHER(ME_STRNG, 1, mpiint,                          &
     &       nodelist, 1, mpiint, MPI_COMM_STRNG, ierror)
!
!    move rejected, so restore string
!
        if (qvalid) then
         r_f=>r_f3; deallocate(r_f2); nullify(r_f3);
         if (qorient) then
          r_o=>r_o3; nullify(r_o3);
          if (qdiffrot) then ; deallocate(r_o2);
          else ; nullify(r_o2); endif
         endif ! qorient
        endif ! qvalid
       endif ! success
! aa
!        dE=exp(-rex_beta*dE)
!        call MPI_ALLGATHER(dE, 1, MPI_DOUBLE_PRECISION,
!     &   dEG, 1, MPI_DOUBLE_PRECISION, MPI_COMM_STRNG, bug)
!
      endif ! MPI_COMM_STRNG
!    from here on all nodes continue:
!    broadcast success to all slave nodes
      if (qgrp) then
#ifdef __CHARMM
       __BROADCAST_LOCAL_4B(success,1)
       __BROADCAST_LOCAL_4B(nodelist,nstring)       !__CHARMM_ONLY##.not.INTEGER8
       __BROADCAST_LOCAL_8B(nodelist,nstring)       !__CHARMM_ONLY##INTEGER8
#else
       __BROADCAST_LOCAL(success,1,mpibool)
       __BROADCAST_LOCAL(nodelist,nstring,mpiint)
#endif
!    broadcast new reference to slaves (what about dperp0, dpar0, drms0?) 
       if (success) then
#ifdef __CHARMM
        __BROADCAST_LOCAL_4B(r_f,27*nforced)       !__CHARMM_ONLY##SINGLE
        __BROADCAST_LOCAL_8B(r_f,27*nforced)       !__CHARMM_ONLY##.not.SINGLE
#else
        __BROADCAST_LOCAL(r_f,27*nforced,mpifloat)
#endif
        if (qorient.and.qdiffrot) then ; 
#ifdef __CHARMM
         __BROADCAST_LOCAL_4B(r_o,27*norient) ;   !__CHARMM_ONLY##SINGLE
         __BROADCAST_LOCAL_8B(r_o,27*norient) ;   !__CHARMM_ONLY##.not.SINGLE
#else
         __BROADCAST_LOCAL(r_o,27*norient,mpifloat) ; 
#endif
        endif
!
!       broadcast reference values
!       command below does not work in NERSC with pathscale
!        __BROADCAST_LOCAL(rex_string_data_new,1,rex_string_data_mpi) ! broadcast to slaves
        call mpi_type_get_extent(rex_string_data_mpi, lb, extent, ierror)
#ifdef __CHARMM
         __BROADCAST_LOCAL_4B(rex_string_data_new,extent/4)
#else
        __BROADCAST_LOCAL(rex_string_data_new,extent,MPI_BYTE)
#endif
!
       endif ! success
      endif ! qgrp
!
!        write(600+ME_GLOBAL, *) ME_STRNG
!     if replica order has changed, switch communicator
!        if (ME_GLOBAL.eq.0) write(600,*) nodelist !aa
!        if (ME_GLOBAL.eq.0) write(600,*) dEG !aa
!        if (ME_GLOBAL.eq.0) write(600,*) '***************', cv%rex_beta !aa
!        close(600)
!
! modify replica map (assumes that only adjacent switches are possible)
      j=1
      do while (j.lt.nstring)
        if (nodelist(j).gt.nodelist(j+1)) then ! node numbers start at 0
          i=rex_map(j)
          rex_map(j)=rex_map(j+1)
          rex_map(j+1)=i
          j=j+1
        endif
        j=j+1
      enddo
!
      if (any(nodelist.ne.(/ (i, i=0,nstring-1) /)))                    &
     &  call multicom_permute_string_ranks(nodelist+1) ! special-purpose routine to reorder ranks in order of string replicas
!                                                        added 1 because in multicom node indices start from 1
      if (success) then
!    finish updating reference values
       dpar0 =rex_string_data_new%dpar0
       dperp0=rex_string_data_new%dperp0
       drms0 =rex_string_data_new%drms0
       kpara =rex_string_data_new%kpara
       kperp =rex_string_data_new%kperp
       krms  =rex_string_data_new%krms
       qrms_upper_bound  =rex_string_data_new%qrms_upper_bound
       evolve_expo_mem   =rex_string_data_new%evolve_expo_mem
       num_evolve_samples=rex_string_data_new%num_evolve_samples
       avforce           =rex_string_data_new%avforce
       ftsm_mini_on      =rex_string_data_new%ftsm_mini_on
       evolve_expo_on    =rex_string_data_new%evolve_expo_on
       evolve_aver_on    =rex_string_data_new%evolve_aver_on

!
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) mestring=ME_STRNG
!      broadcast string size to all slave nodes
       if (qgrp) then
#ifdef __CHARMM
        __BROADCAST_LOCAL_4B(mestring,1)             !__CHARMM_ONLY##.not.INTEGER8
        __BROADCAST_LOCAL_8B(mestring,1)             !__CHARMM_ONLY##INTEGER8
        call setmsi('MESTRING',mestring)
#else
        __BROADCAST_LOCAL(mestring,1,mpiint)
#endif
       endif ! qgrp
      endif ! success
!        write(600+ME_GLOBAL, *) ME_STRNG
!           close(600+ME_GLOBAL)
!
      end subroutine ftsm_repl_exchange
!=================================================================================
__CHARMM_ONLY##ENDIF
#endif
      end module ftsm
!
