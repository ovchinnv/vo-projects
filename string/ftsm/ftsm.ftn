!CHARMM Element source/stringm/ftsm.src $Revision: 0 $
!
! finite-temperature string / NEB code
! documentation will be provided in stringm.doc
!
__CHARMM_ONLY##IF STRINGM
!
      module ftsm ! finite-temperature string method
      __CHARMM_ONLY __DEP_KINDS
      use ftsm_var
      __DEP_BESTFIT ! , only : RMSBestFit, rmsd
!
      private
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     SUBROUTINES
!
      public ftsm_parse
      public ftsm_main
      private ftsm_calc
      private ftsm_compute_fe_fd
      private ftsm_repa
      private ftsm_mini
      private ftsm_swap_bc
      private ftsm_update_overlap_coor
      private ftsm_save_com
      private ftsm_init
      private ftsm_done
      private ftsm_repa_init
      private ftsm_mini_init
      private ftsm_list_atoms
      private ftsm_set_weights
      private ftsm_swap
      private ftsm_fill
      private ftsm_lift
      private ftsm_compute_overlap_ind
      private ftsm_define_rtmd_type
      private ftsm_write_dcd
      private ftsm_read_dcd
      private ftsm_write_cor
      private ftsm_read_cor
      private ftsm_stat_init
      private ftsm_stat
      private ftsm_test_grad
      private ftsm_test_parallel
      private ftsm_check
      private ftsm_addforce
      private ftsm_evolve
      private ftsm_repl_exchange
!
      contains
!
      subroutine ftsm_parse(COMLYN,COMLEN)
      use ftsm_rex, only: ftsm_rex_set_temp
!----------------------------------------------------------------------
! command parser for the finite temperature string
!----------------------------------------------------------------------
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_NUMBER 
      __DEP_MULTICOM
      __DEP_CONST 
      __DEP_MPI 
      __DEP_SELECT
      __DEP_COORDINATES
      __DEP_SIZE
!
#ifdef __CHARMM
      use ctitla 
! need BNBND, BIMAG for ftsm_mini
      use bases_fcm, only : BNBND, BIMAG
#endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      __IMPNONE
!
      character(len=*) :: comlyn
      int :: comlen
! local variables
      int :: ivver, ivv2, iorig, ileap ! for dynamics
      int :: error, klen, strl
!
      character(len=8) :: keyword
      character(len=80) :: fname
      character(len=6) :: whoami
      float :: zval, k, step
      int :: ifile, c1, c2, qcor, qdcd, flen,            &
     &           num_ave_samples, irep, i, imode,        &
     &           iorie, irmsd, ierror
!
#ifdef __CHARMM
      int :: oldiol, isele
      int :: iselct(natom)
#else
      int :: natom
 __DECLARE_DMOL_SELECT
#endif
      float, pointer :: fd_error(:,:)
!
      bool :: qroot, qslave, qprint, qcomp
!
 __DECLARE_MSGBUF
!
#include "../../mpitype.def"
!
      data whoami /' FTSM>'/
!
      keyword=__NEXTA(comlyn,comlen)
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qslave=((MPI_COMM_LOCAL.ne.MPI_COMM_NULL).and.SIZE_LOCAL.gt.1)
      qprint=qroot.and.ME_STRNG.eq.0
!
! check for smcv initialization; quit if initialized
      if (smcv_initialized) then
       __WRN(whoami,' SMCV IS ON AND CANNOT BE USED WITH FTSM. NOTHING DONE.')
       return
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (__STRNCMP(keyword,'INIT',4)) then
        call ftsm_init()
        return
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (.not.ftsm_initialized) then
        call ftsm_init()
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (__STRNCMP(keyword,'DONE',4)) then
        call ftsm_done()
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'REPA',4)) then
       if (comlen.gt.0) then ! this is an initialization call!
        call ftsm_repa_init(comlyn, comlen)
       else
        if (ftsm_check(qorient)) call ftsm_repa()
       endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'MINI',4)) then
       if (comlen.gt.0 .or. .not. ftsm_mini_initialized ) then ! this is an initialization call
        call ftsm_mini_init(comlyn, comlen)
       else
        if (ftsm_check(qorient)) then
         if (qorient.and.any(__XX(iatom_o).eq.__NAN)) then
         __WRN(whoami,'MAIN ORIENTATION X-SET HAS UNDEFINED VALUES. NOTHING DONE.')
         else
          call ftsm_mini(__XX(1:natom), __YY(1:natom), __ZZ(1:natom) &
#ifdef __CHARMM
     &                                         ,WMAIN(1:natom), BNBND, BIMAG     &
#endif
     &                                         )
         endif ! qorient
        endif ! ftsm_check
       endif ! comlen
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'STAT',4)) then
       if (comlen.gt.0) then ! this is an initialization call!
        call ftsm_stat_init(comlyn, comlen)
       else
        call ftsm_stat()
       endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'DYNA',4)) then
#ifdef __CHARMM
!ccccc will assume that other distributions specify dynamics elsewhere ccccccc
       ivver=__INDX_RM(comlyn, comlen, 'VVER')
       ivv2=__INDX_RM(comlyn, comlen, 'VV2')
       iorig=__INDX_RM(comlyn, comlen, 'ORIG')
       ileap=__INDX_RM(comlyn, comlen, 'LEAP')
       if ((ivver+ivv2+iorig).gt.0) then
        __WRN( whoami,'ONLY LEAP-FROG DYNAMICS ARE SUPPORTED. NOTHING DONE')
        return
       endif
!      force LEAP DYNAMICS
       call joinwd(comlyn, mxcmsz, comlen, 'LEAP ', 5)
#endif
!ccccccccccccccc PARSE OTHER DYNAMICS OPTIONS
!      reset internal interation counter for ftsm_master
       olditeration=0
!
       update_on=(__INDX_RM(comlyn,comlen, 'UPDA').gt.0)
       if (update_on) then
        update_freq=__GET_RM_I(comlyn,comlen,'UPDF',0)
        if (update_freq.le.0) then
         __WRN( whoami,'UPDATE FREQUENCY INVALID OR UNSPECIFIED. WILL NOT UPDATE.')
         update_on=.false.
        else
         repa_on=(__INDX_RM(comlyn,comlen, 'REPA').gt.0)
         ftsm_mini_on=(__INDX_RM(comlyn,comlen, 'MINI').gt.0)
        endif
       endif
!
       stat_on=(__INDX_RM(comlyn,comlen, 'STAT').gt.0)
       if (stat_on) then
        stat_freq=__GET_RM_I(comlyn,comlen,'STAF',0)
        if (stat_freq.le.0) then
         __WRN( whoami,'STATISTICS FREQUENCY INVALID OR UNSPECIFIED.')
         stat_on=.false.
        endif
       endif ! stat_on
!
       evolve_ftsm_on=(__INDX_RM(comlyn,comlen, 'EVOL').gt.0)
       if (evolve_ftsm_on) then
        evolve_freq=__GET_RM_I(comlyn,comlen,'EVOF',0)
        if (evolve_freq.le.0) then
         __WRN( whoami,'EVOLUTION FREQUENCY INVALID OR UNSPECIFIED. WILL NOT EVOLVE.')
         evolve_ftsm_on=.false.
        endif
       endif ! evolve_ftsm_on
!
       if (evolve_ftsm_on) then ! still on (see above)
        evolve_nskip=__GET_RM_I(comlyn,comlen,'EVOS',0)
!
! ----- types of evolution
!
        evolve_expo_on=(__INDX_RM(comlyn,comlen,'EXPO').gt.0) ! use exponential convolution
        if (evolve_expo_on) then
         evolve_expo_mem=__GET_RM_F(comlyn,comlen,'MEMO',0.999d0)
        endif
!
        evolve_aver_on=(__INDX_RM(comlyn,comlen,'AVER').gt.0) ! r_ref=mean(r_inst)
        if (evolve_aver_on) then
         num_evolve_samples=0
         max_evolve_samples=0
!        setting this large will dampen initial fluctuations
         if (__INDX(comlyn, comlen,'NAVE' ,4).gt.0) then
          num_ave_samples=__GET_RM_I(comlyn,comlen,'NAVE',-1)
          if (num_ave_samples.gt.0) then
            num_evolve_samples=num_ave_samples
          else
           __WRN(whoami, 'INVALID NUMBER OF SAMPLES SPECIFIED. WILL SET TO ZERO.')
          endif ! num_samples
         endif ! NAVE
!
         if (__INDX(comlyn, comlen,'MAXAVE',6).gt.0) then
          num_ave_samples=__GET_RM_I(comlyn,comlen,'MAXAVE',-1)
          if (num_ave_samples.gt.0) then
            max_evolve_samples=num_ave_samples
          else
  __WRN(whoami,'INVALID MAXIMUM NUMBER OF SAMPLES SPECIFIED. WILL SET TO ZERO.')
          endif ! num_samples
         endif ! MAXAVE
        endif ! evolve_aver
!
        i=0
        if (evolve_expo_on)   i=i+1
        if (evolve_aver_on)   i=i+1
!
        if (i.gt.1) then
         __WRN( whoami,'MORE THAN ONE EVOLUTION SCHEME REQUESTED. WILL USE EXPO.')
         evolve_expo_on=.true.
         evolve_aver_on=.false.
        endif
!
        if (i.eq.0) then
         __WRN( whoami,'EVOLUTION SCHEME UNSPECIFIED. WILL USE EXPO.')
         evolve_expo_on=.true.
         evolve_aver_on=.false.
        endif
       endif ! evolve_ftsm_on
!
       if (update_on.and..not.(evolve_ftsm_on.or.repa_on.or.ftsm_mini_on)) then
        __WRN( whoami,'EVOLUTION, REPARAMETRIZATION AND MINIMIZATION ARE ALL DISABLED. UPDATE IS OFF.')
        update_on=.false.
       endif
!
       restrained_on=(__INDX_RM(comlyn,comlen, 'RSTR').gt.0)
       if (restrained_on) then
        restrained_eq_steps=__GET_RM_I(comlyn,comlen,'REEQ',0)
        if (restrained_eq_steps.lt.0) then
          __WRN(whoami,'REEQ CANNOT BE NEGATIVE. WILL SET TO ZERO.')
          restrained_eq_steps=0
        endif
        restrained_eq0=0
       endif
!
       repl_x_on=(__INDX_RM(comlyn,comlen,'REX').gt.0)
       if (repl_x_on) then
        repl_x_freq=__GET_RM_I(comlyn,comlen,'REXF',0)
        repl_x_temp=__GET_RM_F(comlyn,comlen,'REXT',0d0)
!
        if (repl_x_freq.le.0) then
          __WRN(whoami,'MUST SPECIFY POSITIVE REXF. REPLICA EXCHANGE IS OFF.')
          repl_x_on=.false.
        elseif (repl_x_temp.le.0) then
          __WRN(whoami,'MUST SPECIFY POSITIVE REXT. REPLICA EXCHANGE IS OFF.')
          repl_x_on=.false.
        else
          call ftsm_rex_set_temp(repl_x_temp)
        endif
       endif ! repl_x_on
!
       if (update_on.or.repl_x_on) then ! decrease output
         string_noprint=(__INDX_RM(comlyn,comlen,'NOPR').gt.0)
       endif
!--------------- DONE PARSING DYNAMICS OPTIONS -----
!    print summary
!cccccccccccccccccc STRING METHOD OPTIONS cccccccccccccccccccccc
       if (qprint) then
        WRITE (_MSGBUF,'(2A)') whoami, ' STRING METHOD ENABLED.'; __PRINT(_MSGBUF)
        if (evolve_ftsm_on) then
            WRITE (_MSGBUF,'(/,2A,/,2A,I7,A)')                          &
     &      whoami, ' STRING EVOLUTION ENABLED.',                       &
     &      whoami, ' WILL EVOLVE AFTER EVERY ',                        &
     &      evolve_freq,' ITERATIONS.'; __PRINT(_MSGBUF)
            WRITE (_MSGBUF,'(2A,I7,A)')                                 &
     &      whoami, ' THE FIRST', evolve_nskip,                         &
     &      ' ITERATIONS WILL NOT CONTRIBUTE TO AVERAGES.'; __PRINT(_MSGBUF)
            if (evolve_expo_on) then
               write(_MSGBUF,671) whoami, whoami, evolve_expo_mem ; __PRINT(_MSGBUF)
 671  format(A,' STRING EVOLUTION WILL BE OF THE FORM:',/,              &
     &       A,' R(N+1)=A*R(N)+(1-A)*RINST, A=',F9.5,'.')
            elseif (evolve_aver_on) then
               write(_MSGBUF,6710) whoami, whoami, num_evolve_samples ; __PRINT(_MSGBUF)
 6710 format(A,' CV EVOLUTION WILL BE OF THE FORM:',/,                  &
     & A,' R(N)=AVERAGE_0^{N}(RINST).  INITIAL NUMBER OF SAMPLES IS ',  &
     & I5,'.')
             if (max_evolve_samples.gt.0)                               &
     &          write(_MSGBUF, 6711) whoami, max_evolve_samples ; __PRINT(_MSGBUF)
 6711 format(A, ' ONLY THE MOST RECENT ', I5,' SAMPLES WILL BE USED.')

            endif
        endif ! evolve_ftsm_on
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (update_on) then
          WRITE (_MSGBUF,666) whoami, update_freq ;      __PRINT(_MSGBUF)
 666  format(A,' WILL UPDATE IMAGES AFTER EVERY ',I7,' ITERATIONS.')
         if (ftsm_mini_on) then
 669  format(A,' WILL MINIMIZE STRING DURING UPDATE ')
          WRITE (_MSGBUF,669) whoami 
          __PRINT(_MSGBUF)
         endif ! mini
         if (repa_on) then
 667  format(A,' WILL REPARAMETRIZE STRING DURING UPDATE ')
          WRITE (_MSGBUF,667) whoami 
          __PRINT(_MSGBUF)
         endif
        endif ! update_on
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (restrained_on) then
            WRITE (_MSGBUF,'(2A)')                                         &
     &      whoami, ' WILL USE RESTRAINED DYNAMICS.' ;   __PRINT(_MSGBUF)
!
            write(_MSGBUF,665) whoami, restrained_eq_steps ;   __PRINT(_MSGBUF)
 665  format(A, ' WILL ADJUST TO NEW RESTRAINTS OVER ',I11, ' STEPS.')
        endif ! restrained
!
!       proj_on is necessary to compute free energies
        if (proj_on) then
            write (_MSGBUF,'(2A)') whoami,                                 &
     & ' WILL RESTRAIN SYSTEM TO PLANE PERPENDICULAR TO PATH.' ; __PRINT(_MSGBUF)
        else
            write (_MSGBUF,'(2A)') whoami,                                 &
     & ' WILL RESTRAIN SYSTEM TO PATH IMAGE.'//                         &
     & ' (FE/MFPT CANNOT BE COMPUTED).' ; __PRINT(_MSGBUF)
        endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (stat_on) then
            write(_MSGBUF,668) whoami, stat_freq ;                __PRINT(_MSGBUF)
 668  format(A, ' WILL OUTPUT STRING STATISTICS AFTER EVERY ',I7, ' STEPS.')
        endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if (repl_x_on) then
            write(_MSGBUF,691) whoami, whoami, repl_x_freq, repl_x_temp
            __PRINT(_MSGBUF)
 691  format(A, ' WILL ATTEMPT TO EXCHANGE NEIGHBORING REPLICAS ',/     &
     &       A, ' ONCE IN EVERY ',I6,' ITERATIONS AT ',F11.3, ' K.')
        endif ! repl_x_on
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       endif ! qprint
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       call ftsm_save_com()       ! recompute COM in case weights changed
       call ftsm_swap_bc(.true.)  ! update boundary replicas (with new COM-free structures)
!      turn on string for dynamics
       ftsm_on=.true.
!      call dynamics parser
       call dynopt(comlyn, comlen)
!cccccc turn off string for regular dynamics ccccccc
       ftsm_on=.false.
       repa_on=.false. ! turn off after dynamics because SM0K also uses this flag; therefore a subsequent minimization would call reparametrization
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'FILL',4)) then ! set path from current coordinates
!
       qcomp=(__INDX_RM(comlyn, comlen, 'COMP').gt.0)
!
       if (qcomp) then
        if (qprint) then ; write(_MSGBUF,6657) whoami ; __PRINT(_MSGBUF) ; endif
 6657 format(/A,' WILL DEFINE PATH FROM COMPARISON COORDINATES.')
        call ftsm_fill(__XCOMP,__YCOMP,__ZCOMP)
       else ! ~qcomp -- use main coordinates
        if (qprint) then ; write(_MSGBUF,6660) whoami ; __PRINT(_MSGBUF) ; endif
 6660 format(/A,' WILL DEFINE PATH FROM MAIN COORDINATES.')
        call ftsm_fill(__X,__Y,__Z)
       endif ! qcomp
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     the option below will be useful to perform usual charmm operations on the STRING (if desired)
      elseif (__STRNCMP(keyword,'LIFT',4)) then ! force string into current coordinates
!
       qcomp=(__INDX_RM(comlyn, comlen, 'COMP').gt.0)
!
       if (qcomp) then
        if (qprint) then ; write(_MSGBUF,6658) whoami ; __PRINT(_MSGBUF) ; endif
 6658 format(/A,' WILL COPY STRING INTO COMPARISON COORDINATES.')
        if (qorient.and.any(__XXCOMP(iatom_o).eq.__NAN)) then
         __WRN(whoami,'COMPARISON ORIENTATION X-SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         call ftsm_lift(__XCOMP,__YCOMP,__ZCOMP)
        endif
       else ! ~qcomp -- use main coordinates
        if (qprint) then ; write(_MSGBUF,6661) whoami ; __PRINT(_MSGBUF) ; endif
 6661 format(/A,' WILL COPY STRING INTO MAIN COORDINATES.')
        if (qorient.and.any(__XX(iatom_o).eq.__NAN)) then
         __WRN(whoami,'MAIN ORIENTATION X-SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         call ftsm_lift(__X,__Y,__Z)
        endif
       endif ! qcomp
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'TEST',4)) then !
       if (__INDX_RM(comlyn,comlen,'GRAD').gt.0) then ! finite-difference gradient test
! check fd spec
        step=__GET_RM_F(comlyn, comlen, 'STEP', finite_difference_d)
        if (qprint) then 
         write(_MSGBUF, 7001) whoami,whoami,step,whoami,whoami 
         __PRINT(_MSGBUF)
 7001  format(/A,' WILL TEST GRADIENTS USING FINITE DIFFERENCES',       &
     &        /A,' USING DX = DY = DZ = ',F15.9,'.',                    &
     &        /A,' MAIN COORDINATE SET MUST BE DEFINED.',               &
     &        /A,' WILL OVERWRITE FORCE/GRAD ARRAYS')
        endif
        if (any(__X.eq.__NAN)) then
         __WRN(whoami,'MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         fd_error=>ftsm_test_grad_fd(__X,__Y,__Z,step)
!          write(me_global+100,*) fd_error
         if (qprint) then
          if (proj_on) then
           write(_MSGBUF,7006) whoami, whoami, whoami, whoami ; __PRINT(_MSGBUF)
 7002  format(/A,' TOP:    NORMALIZED PROJECTION ONTO PATH',            &
     &        /A,' BOTTOM: DISTANCE PERPENDICULAR TO PATH',             &
     &        /A,' DGRAD_X_MAX, DGRAD_Y_MAX, DGRAD_Z_MAX',              &
     &        /A,' ======================================')
           do i=1,2
            write(_MSGBUF,'(A,3'//real_format//'F15.9)')                   &
     &                  whoami,fd_error(i,:) ; __PRINT(_MSGBUF)
           enddo
          else ! projection off
           write(_MSGBUF,7013) whoami, whoami, whoami ; __PRINT(_MSGBUF)
 7013  format(/A,' DISTANCE TO PATH POINT:',                            &
     &        /A,' DGRAD_X_MAX, DGRAD_Y_MAX, DGRAD_Z_MAX',              &
     &        /A,' ======================================')
            write(_MSGBUF,'(A,3'//real_format//'F15.9)')                   &
     &                  whoami,fd_error(1,:) ; __PRINT(_MSGBUF)
          endif ! projection
         endif ! qprint
!     decide whether the test was passed
         zval=abs(maxval(fd_error))
         if (zval.lt.abs(step)*1d0) then
          write(_MSGBUF,7003) whoami, zval, whoami ; __PRINT(_MSGBUF)
         else
          write(_MSGBUF,7004) whoami, zval, whoami ; __PRINT(_MSGBUF)
          __WRN(whoami,'FINITE DERIVATIVE TEST FAILED.')
         endif ! report test result
 7003 format(/A, ' THE MAXIMUM GRADIENT ERROR IS ',F15.9,', ',          &
     &       /A, ' WHICH IS SMALLER THAN STEP. TEST PASSED.')
 7004 format(/A, ' THE MAXIMUM GRADIENT ERROR IS ',F15.9,', ',          &
     &       /A, ' WHICH IS NO SMALLER THAN STEP. TEST FAILED.')
         if (associated(fd_error)) deallocate(fd_error) ! test_grad returns a pointer to an array of abs errors
        endif
       endif ! grad
!
       if (__INDX_RM(comlyn,comlen,'PARA').gt.0) then ! parallel communication test
        if (qprint) write(_MSGBUF, 7005) whoami,whoami,whoami ; __PRINT(_MSGBUF)
 7005  format(/A,' WILL COMPARE PARALLEL AND SERIAL FORCE COMPUTATION', &
     &        /A,' MAIN COORDINATE SET MUST BE DEFINED.',               &
     &        /A,' WILL OVERWRITE FORCE/GRAD ARRAYS')
        if (any(__X.eq.__NAN)) then
         __WRN(whoami,' MAIN X SET HAS UNDEFINED VALUES. NOTHING DONE.')
        else
         fd_error=>ftsm_test_parallel(__X,__Y,__Z) ! use the same array as above
         if (qprint) then
          if (proj_on) then
           write(_MSGBUF,7006) whoami, whoami, whoami, whoami ; __PRINT(_MSGBUF)
 7006  format(/A,' TOP:    NORMALIZED PROJECTION ONTO PATH',            &
     &        /A,' BOTTOM: DISTANCE PERPENDICULAR TO PATH',             &
     &        /A,' DGRAD_X_MAX, DGRAD_Y_MAX, DGRAD_Z_MAX, VALUE',       &
     &        /A,' ============================================')
           do i=1, 2
            write(_MSGBUF,'(A,4'//real_format//'F15.9)')                   &
     &                  whoami,fd_error(i,:) ; __PRINT(_MSGBUF)
           enddo
          else ! not proj_on
           write(_MSGBUF,7010) whoami, whoami, whoami ; __PRINT(_MSGBUF)
 7010  format(/A,' DISTANCE TO PATH POINT:',                            &
     &        /A,' DGRAD_X_MAX, DGRAD_Y_MAX, DGRAD_Z_MAX, VALUE',       &
     &        /A,' ============================================')
            write(_MSGBUF,'(A,4'//real_format//'F15.9)')                   &
     &                  whoami,fd_error(1,:) ; __PRINT(_MSGBUF)
          endif ! proj_on
         endif ! qprint
!     decide whether the test was passed
         zval=abs(maxval(fd_error))
         if (zval.lt.parallel_tolerance) then
          write(_MSGBUF,7007) whoami, zval, whoami, parallel_tolerance ; __PRINT(_MSGBUF)
         else
          write(_MSGBUF,7008) whoami, zval, whoami, parallel_tolerance ; __PRINT(_MSGBUF)
          __WRN(whoami,'PARALLEL COMPUTATION TEST FAILED.')
         endif ! report test result
 7007 format(/A, ' THE MAXIMUM ERROR IS ',E12.5,', ',                   &
     &       /A, ' WHICH IS SMALLER THAN ',E12.5,'. TEST PASSED.')
 7008 format(/A, ' THE MAXIMUM ERROR IS ',E12.5,', ',                   &
     &       /A, ' WHICH IS NO SMALLER THAN ',E12.5,'. TEST FAILED.')
         if (associated(fd_error)) deallocate(fd_error) ! pointer to an array of abs errors
        endif
       endif ! para
!
! other tests will go below this line
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! specify parallel calculation options
      elseif (__STRNCMP(keyword,'PARA',4)) then
       do while (comlen .gt. 1)
        keyword=__NEXTA(comlyn, comlen)
        select case(keyword)
           case('YES','ON','TRUE','T','yes','on','true','t')
            keyword='ENABLED '; calc_bestfit_grad_para=.true.
            if (qprint) then 
             write(_MSGBUF,7009) whoami, 'FORCES', keyword ; __PRINT(_MSGBUF)
            endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            keyword='DISABLED' ; calc_bestfit_grad_para=.false.
            if (qprint) then
             write(_MSGBUF,7009) whoami, 'FORCES', keyword ; __PRINT(_MSGBUF)
            endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED')
          end select
       enddo ! comlen
 7009  format(/A, ' PARALLEL COMPUTATION OF ',A,' ',A)
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'PRIN',4)) then
!      can write both coordinate files and a global dcd file
!      local is specified with 'COR'; global is the default
#ifdef __CHARMM
       qcor=__INDX_RM(comlyn,comlen,'COR'); qcor = min(qcor,1)
#else
       qcor=__INDX_RM(comlyn,comlen,'CHM'); qcor = min(qcor,1)
#endif
       qdcd=__INDX_RM(comlyn,comlen,'DCD'); qdcd = min(qdcd,1)
!
       if ((qcor+qdcd) .gt. 1) then
        __WRN( whoami,' MORE THAN ONE OUTPUT FORMAT REQUESTED. WILL USE DCD.')
        qcor=0; qdcd=1;
       endif
!
!      prepare file
!-----------------------------------------------------------------------------
       ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
       CALL GTRMWD(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: FNAME will be UPPER CASE
!---------------------------------- OPEN FILE --------------------------------
       if (qroot) then
#ifdef __CHARMM
        oldiol=iolev
#endif
        if (qdcd.eq.0) then ! no dcd -- local write
#ifdef __CHARMM
         iolev=1 ! open file on all nodes
#endif
         if (flen.gt.0) __OPEN_FILE(ifile,fname,'FORMATTED','WRITE')
        else
         if (qprint) then ! write one dcd file (root does this)
          if (flen.gt.0) __OPEN_FILE(ifile,fname,'UNFORMATTED','WRITE') ! open binary fle for DCD
         endif
! broadcast ifile so that all roots know whether handle is valid
         __BROADCAST_STRING(ifile,1,mpiint)
        endif
#ifdef __CHARMM
        if (ifile .eq. -1) then
         if (qdcd .eq. 0 ) ifile=__OSTREAM ! write to output stream (rather dirty, but keep for now)
        endif
#endif
        if (ifile.ge.0) then
!---------------------------- assume file is open, write -------------------------
!     check for column spec
         c1=__GET_RM_I(comlyn, comlen, 'COL', -1)
         if (c1.gt.0) then
          if (qprint) then ; write(_MSGBUF,6679) whoami, c1 ; __PRINT(_MSGBUF) ; endif
 6679 format(/A,' WRITING COORDINATES FROM COLUMN ',I3)
          if (qdcd.gt.0) then ; call ftsm_write_dcd(IFILE=ifile,COL=c1) ;
          else ; call ftsm_write_cor(ifile,c1) ; endif
         else
          if (qprint) then ; write(_MSGBUF,6689) whoami ; __PRINT(_MSGBUF) ; endif
 6689 format(/A,' WRITING COORDINATES FROM DEFAULT COLUMN.')
          if (qdcd.gt.0) then ; call ftsm_write_dcd(IFILE=ifile) ;
          else ; call ftsm_write_cor(ifile) ; endif
         endif ! c1
         if (qdcd.eq.0.or.qprint) then
          if (flen.gt.0) __CLOSE_FILE(ifile,'KEEP',error)
         endif
        endif ! ifile
#ifdef __CHARMM
        iolev=oldiol
#endif
       endif ! qroot
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'READ',4)) then
!      can read from both coordinate files and a global dcd file (see above)
!      can also read a frame in the DCD: specify FRAM for frame;
       qcor=__INDX_RM(comlyn,comlen,'COR'); qcor = min(qcor,1)
       qdcd=__INDX_RM(comlyn,comlen,'DCD'); qdcd = min(qdcd,1)
!
       if ((qcor+qdcd) .gt. 1) then
        __WRN( whoami,'MORE THAN ONE INPUT FORMAT REQUESTED. WILL USE DCD.')
        qcor=0; qdcd=1;
       endif
!
!      prepare file
       ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
       __GET_RM_A(COMLYN,COMLEN,'NAME',4,FNAME,80,FLEN)
!        note: flen will be UPPER CASE
!     check for column spec (which coordinate set to read into)
       c1=__GET_RM_I(comlyn, comlen, 'COL', 0)
!cccccccccccccccccccccccccccc OPEN FILE ccccccccccccccccccccccc
       if (qroot) then
#ifdef __CHARMM
        oldiol=iolev
#endif
        if (qdcd.eq.0) then
#ifdef __CHARMM
         iolev=1 ! open file on all processors
#endif
         if (flen.gt.0) __OPEN_FILE(ifile,fname,'FORMATTED','READ')
        else
         if (qprint) then ! binary dcd file
          if (flen.gt.0) __OPEN_FILE(ifile,fname,'UNFORMATTED','READ') ! open binary fle for DCD
         endif
! broadcast ifile so that all roots know whether handle is valid
         __BROADCAST_STRING(ifile,1,mpiint)
         __BROADCAST_LOCAL(ifile,1,mpiint)
        endif
#ifdef __CHARMM
        if(ifile .le. -1 ) then 
         if (qdcd.eq.0 ) then
          ifile=__ISTREAM ! read local files from input file
          call rdtitl(titleb,ntitlb,ifile,0) ! 0 = card format
         endif ! qdcd
        endif ! ifile
#endif
       endif ! qroot
!cccccccccccccccccc assume file is open, read ccccccccccccccccccc
! broadcast ifile so that all slaves also know whether handle is valid
! because they need to enter read_cor
         __BROADCAST_LOCAL(ifile,1,mpiint)
       if (ifile.ge.0) then
        if (c1.gt.0) then ! column spec
         if (qprint) then ; write(_MSGBUF,6699) whoami, c1 ; __PRINT(_MSGBUF) ; endif
 6699 format(A,' READING COORDINATES INTO COLUMN ',I3)
         if (qdcd.gt.0) then ; if (qroot) call ftsm_read_dcd(ifile, c1);
         else; call ftsm_read_cor(ifile,c1) ;  endif
       else
         if (qprint) then ; write(_MSGBUF,6709) whoami ; __PRINT(_MSGBUF) ; endif
 6709 format(A,' READING COORDINATES INTO DEFAULT COLUMN.')
         if (qdcd.gt.0) then ; if (qroot) call ftsm_read_dcd(ifile);
         else ; call ftsm_read_cor(ifile) ; 
         endif
        endif ! c1
       endif
!cccccccccccccccc close file ccccccccccccccccccccccccccccccccccccc
       if (qroot) then
        if (qdcd.eq.0.or.qprint) then
         if (flen.gt.0) __CLOSE_FILE(ifile,'KEEP',error)
        endif ! qdcd
#ifdef __CHARMM
        iolev=oldiol
#endif
       endif ! qroot
!
!     broadcast to slaves (although cread routine will send coords to slaves, too)
       if (c1.le.0) c1=center ! assume "default column"
       if (c1.eq.center) then
        call ftsm_swap_bc(.true.)
        r_f(:,:,left_old:right_old)=r_f(:,:,left:right)
        r_f(:,:,center_new)=r_f(:,:,center)
        if (qorient.and.qdiffrot) then
         r_o(:,:,left_old:right_old)=r_o(:,:,left:right)
         r_o(:,:,center_new)=r_o(:,:,center)
        endif
       else
        if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1) then
#ifdef __CHARMM
         __BROADCAST_LOCAL_4B(r_f(:,:,c1), 3*nforced) !##SINGLE       ! forcing coordinates
         __BROADCAST_LOCAL_8B(r_f(:,:,c1), 3*nforced) !##.not.SINGLE
#else
         __BROADCAST_LOCAL(r_f(:,:,c1), 3*nforced, mpifloat) ! forcing coordinates
#endif
         if (qdiffrot) then 
#ifdef __CHARMM
          __BROADCAST_LOCAL_8B(r_o(:,:,c1), 3*norient) !##SINGLE      ! send orientation coordinates (only if distinct from forcing)
          __BROADCAST_LOCAL_8B(r_o(:,:,c1), 3*norient) !##.not.SINGLE
#else
          __BROADCAST_LOCAL(r_o(:,:,c1), 3*norient, mpifloat) ! send orientation coordinates (only if distinct from forcing)
#endif
         endif
        endif
       endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'SWAP',4)) then ! swap two columns
!       read column spec
        c1=__NEXTI(comlyn, comlen)
        c2=__NEXTI(comlyn, comlen)
        if (qprint) then ; write(_MSGBUF,6729) whoami, c1, c2 ; __PRINT(_MSGBUF) ; endif
 6729 format(/A,' WILL SWAP COLUMNS ',I3,' AND ',I3,' ')
        call ftsm_swap(c1, c2)
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'COPY',4)) then ! copy form c1 to c2
!       read column spec
        c1=__NEXTI(comlyn, comlen)
        c2=__NEXTI(comlyn, comlen)
        if (qprint) then ; write(_MSGBUF,6739) whoami, c1, c2 ; __PRINT(_MSGBUF) ; endif
 6739 format(/A,' WILL COPY COLUMN ',I3,' TO ',I3,' ')
        call ftsm_copy(c1,c2)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'SET ',4)) then ! modify k, etc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        iorie=__INDX_RM(comlyn, comlen, 'ORIE')
        irmsd=__INDX_RM(comlyn, comlen, 'RMSD')
!
        if (iorie.gt.0) then
!    process orientation atom selection
!    determine whether a selection keyword follows orie
         isele=__INDX(comlyn, comlen, 'SELE' ,4)
         if (isele.ge.iorie) then
!
#ifdef __CHARMM
          iselct=0
! process selection
          IMODE=0
          CALL SELRPN(COMLYN,COMLEN,iselct,NATOM,1,IMODE,               &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
          IF(IMODE.NE.0) THEN
           __WRN(whoami,'ORIENTATION ATOMS SELECTION ERROR')
           RETURN
          ENDIF
          norient=count( iselct.gt.0 )
#elif defined(__DMOL)
#include "../../dmol_select_macro.def"
          if (associated(iselct)) then ; norient=size(iselct) ; else ; norient=0 ; endif
#endif
!
! currently we require at least three atoms for orientation
!
          if (norient.lt.3) then
           __WRN(whoami,' FEWER THAN THREE ATOMS SELECTED FOR ORIENTATION. ABORT.')
           return
          endif
!
          qorient=.true.
!
          if (qdiffrot) then; if (associated(r_o)) deallocate(r_o)
                             if(associated(iatom_o)) deallocate(iatom_o)
          else              ; nullify(r_o) ; nullify(iatom_o)
          endif
          if (associated(orientWeights)) deallocate(orientWeights)
!
          allocate(iatom_o(norient)); iatom_o=0
          allocate(orientWeights(norient));
          orientWeights=1d0/norient ! default behavior
!    build index array
          norient=0
!
#ifdef __CHARMM
          do i=1,natom
           if (iselct(i).gt.0) then
            norient=norient+1
            iatom_o(norient)=i
           endif
          enddo
#else
          iatom_o=iselct
          if (associated(iselct)) deallocate(iselct)
#endif
!
!    determine whether the new orientation set is the same as the existing forcing set
!
          qdiffrot=.not. ( norient .eq. nforced )
          if (.not.qdiffrot)  qdiffrot=.not.(associated(iatom_f))
          if (.not.qdiffrot)  qdiffrot=any(iatom_f.ne.iatom_o)
!
          if (.not.qdiffrot) then
           deallocate(iatom_o); iatom_o=>iatom_f; r_o=>r_f;
          else
           allocate(r_o(norient,3,num_sets)); r_o=__NAN;
           if (nforced.gt.0) call ftsm_compute_overlap_ind()  ! compute overlap indices in iatom_both
          endif
!
          if (.not. associated(rcom)) allocate(rcom(3,num_sets))
          rcom=0d0 ! must be zero initially
!
! print summary
          if (qprint) then
            write(_MSGBUF,100) whoami, norient ; __PRINT(_MSGBUF)
 100  format(A,' WILL ORIENT STRUCTURES BASED ON ',i5,' ATOMS')
            write(_MSGBUF,101) whoami ;  ; __PRINT(_MSGBUF)
 101  format(A,' ORIENTATION WEIGHTS UNIFORM.')
            if (qdiffrot) then
             write(_MSGBUF,102) whoami
            else
             write(_MSGBUF,103) whoami
            endif
            __PRINT(_MSGBUF)
 102  format (A, ' ORIENTATION AND FORCING ATOMS ARE DIFFERENT')
 103  format (A, ' ORIENTATION AND FORCING ATOMS ARE IDENTICAL')
          endif ! qprint
         else
          __WRN(whoami,' ATOM SELECTION MUST BE SPECIFIED AFTER ORIE.')
          return
         endif
         call ftsm_define_rtmd_type()
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        elseif (irmsd.gt.0) then
!    process forcing atom selection
!    determine whether a selection keyword follows 'rmsd'
         isele=__INDX(comlyn, comlen, 'SELE' ,4)
         if (isele.gt.irmsd) then
!
#ifdef __CHARMM
          iselct=0
          IMODE=0
          CALL SELRPN(COMLYN,COMLEN,iselct,NATOM,1,IMODE,               &
     &      .FALSE.,1,' ',0,RESID,RES,IBASE,SEGID,NICTOT,NSEG,          &
     &      .TRUE.,X,Y,Z,.TRUE.,1,WMAIN)
          IF(IMODE.NE.0) THEN
           __WRN(whoami,'RMSD ATOMS SELECTION ERROR')
           RETURN
          ENDIF
          nforced=count( iselct.gt.0 )
#elif defined(__DMOL)
#include "../../dmol_select_macro.def"
          if (associated(iselct)) then ; nforced=size(iselct) ; else ; nforced=0 ; endif
#endif
!
          if (nforced.le.0) then
           __WRN(whoami, 'NO RMSD ATOMS SELECTED. ABORT.')
           return
          endif
!
!
          if (qdiffrot) then; if (associated(r_f)) deallocate(r_f)
                             if(associated(iatom_f)) deallocate(iatom_f)
          else              ; nullify(r_f) ; nullify(iatom_f)
          endif
          if (associated(forcedWeights)) deallocate(forcedWeights)
!
          allocate(iatom_f(nforced)); iatom_f=0
          allocate(forcedWeights(nforced));
          forcedWeights=1d0/nforced ! default behavior
!    build index array
          nforced=0
!
#ifdef __CHARMM
          do i=1,natom
           if (iselct(i).gt.0) then
            nforced=nforced+1
            iatom_f(nforced)=i
           endif
          enddo
#else
          iatom_f=iselct
          if (associated(iselct)) deallocate(iselct)
#endif
!
!    determine whether the new orientation set is the same as the existing forcing set
!
          qdiffrot=.not. ( norient .eq. nforced )
          if (.not.qdiffrot)  qdiffrot=.not.(associated(iatom_o))
          if (.not.qdiffrot)  qdiffrot=any(iatom_f.ne.iatom_o)
!
          if (.not.qdiffrot) then
           deallocate(iatom_f); iatom_f=>iatom_o; r_f=>r_o;
          else
           allocate(r_f(nforced,3,num_sets)); r_f=__NAN;
           if (norient.gt.0) call ftsm_compute_overlap_ind()  ! compute overlap indices in iatom_both
          endif
! print summary
          if (qprint) then
            write(_MSGBUF,104) whoami, nforced ; __PRINT(_MSGBUF)
 104  format(A,' WILL APPLY FORCES TO ',i5,' ATOMS')
            write(_MSGBUF,105) whoami ; __PRINT(_MSGBUF)
 105  format(A,' FORCING WEIGHTS UNIFORM.')
            if (qdiffrot) then
             write(_MSGBUF,102) whoami
            else
             write(_MSGBUF,103) whoami
            endif
            __PRINT(_MSGBUF)
          endif ! qprint
         else
          __WRN(whoami,'ATOM SELECTION MUST BE SPECIFIED AFTER RMSD.')
          return
         endif
!*************************************************************
!      set k parallel to path (for off-path dynamics)
        elseif (__INDX(comlyn,comlen,'KPAR',4).gt.0) then
          k=__GET_RM_F(comlyn,comlen,'KPAR',-1d0)
          if (k.ge.0d0) then
           kpara=k
           if (qprint) then ; write(_MSGBUF,6756) whoami, k ; __PRINT(_MSGBUF) ; endif
 6756 format(A,' SETTING PARALLEL RESTRAINT FORCE CONSTANT TO ',F11.5)
          else
           if (qprint) then ; write(_MSGBUF,6757) whoami, k ; __PRINT(_MSGBUF) ; endif
 6757 format(A,' INVALID FORCE CONSTANT SPECIFIED: ',F11.5)
          endif
!*************************************************************
!      set k perpendicular to path (for off-path dynamics)
        elseif (__INDX(comlyn,comlen,'KPRP',4).gt.0) then
          k=__GET_RM_F(comlyn,comlen,'KPRP',-1d0)
          if (k.ge.0d0) then
           kperp=k
           if (qprint) then  ; write(_MSGBUF,6746) whoami, k ; __PRINT(_MSGBUF) ; endif
 6746 format(A,' SETTING PERPENDICULAR RESTRAINT FORCE CONSTANT TO '    &
     &       ,F11.5)
          else
           if (qprint) then ; write(_MSGBUF,6757) whoami, k ; __PRINT(_MSGBUF) ; endif
          endif
!**************************************************************
        elseif (__INDX(comlyn,comlen,'KRMS',4).gt.0) then
          k=__GET_RM_F(comlyn,comlen,'KRMS',-1d0)
          if (k.ge.0d0) then
           krms=k
           if (qprint) then ; write(_MSGBUF,6752) whoami, k ; __PRINT(_MSGBUF) ; endif
 6752 format(A,' SETTING RMSD RESTRAINT FORCE CONSTANT TO '             &
     &       ,F11.5)
          else
           if (qprint) then ; write(_MSGBUF,6757) whoami, k ; __PRINT(_MSGBUF) ; endif
          endif
!***************************************************************
        elseif (__INDX_RM(comlyn,comlen,'MASS').gt.0) then ! mass-weighting
          keyword=__NEXTA(comlyn, comlen)
          klen=len(keyword)
          __TRIMA(keyword,klen)
#ifndef __CHARMM
 natom=__NATOM
#endif
          select case(keyword(1:klen))
           case('YES','ON','TRUE','T','yes','on','true','t')
            if (qprint) then ; write(_MSGBUF,8001) whoami, 'SET FROM ATOM MASSES' ; __PRINT(_MSGBUF) ; endif
            call ftsm_set_weights(__MASS, natom) ! send masses
           case('NO','OFF','FALSE','F','no','off','false','f')
            if (qprint) then ; write(_MSGBUF,8001) whoami, 'WILL BE UNIFORM'      ; __PRINT(_MSGBUF) ; endif
            call ftsm_set_weights( (/ (1d0, i=1,natom) /), natom) ! uniform
#ifdef __CHARMM
           case('WMAIN', 'wmain')
            if (qprint) then ; write(_MSGBUF,8001) whoami, 'SET FROM WMAIN ARRAY' ; __PRINT(_MSGBUF) ; endif
            call ftsm_set_weights(wmain, natom) ! send masses
           case('WCOMP', 'wcomp')
            if (qprint) then ; write(_MSGBUF,8001) whoami, 'SET FROM WCOMP ARRAY' ; __PRINT(_MSGBUF) ; endif
            call ftsm_set_weights(wcomp, natom) ! send masses
#elif defined (__DMOL)
           case('BFACTOR', 'bfactor', 'BFACT', 'bfact')
            if (qprint) then ; write(_MSGBUF,8001) whoami, 'SET FROM BFACTOR ARRAY' ; __PRINT(_MSGBUF) ; endif
            call ftsm_set_weights(bfactor, natom) ! send masses
           case('OCCU', 'occu','OCCUPANCY', 'occupancy')
            if (qprint) then ; write(_MSGBUF,8001) whoami, 'SET FROM OCCUPANCY ARRAY' ; __PRINT(_MSGBUF) ; endif
            call ftsm_set_weights(occupancy, natom) ! send masses
#endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED')
          end select
 8001 format(A,' WEIGHTS ',A,'.')
!*********************************************************************
        elseif (__INDX_RM(comlyn,comlen,'PROJ').gt.0) then ! mass-weighting
          keyword=__NEXTA(comlyn, comlen)
          klen=len(keyword)
          __TRIMA(keyword,klen)
          select case(keyword(1:klen))
           case('YES','ON','TRUE','T','yes','on','true','t')
            proj_on=.true.
            if (qprint) then ; write (_MSGBUF,'(2A)') whoami,                    &
     & ' WILL RESTRAIN SYSTEM TO PLANE PERPENDICULAR TO PATH.' ; __PRINT(_MSGBUF) ; endif
           case('NO','OFF','FALSE','F','no','off','false','f')
            proj_on=.false.
            if (qprint) then ; write (_MSGBUF,'(2A)') whoami,           &
     & ' WILL RESTRAIN SYSTEM TO PATH IMAGE.'//                         &
     & ' (FE/MFPT CANNOT BE COMPUTED).' ; __PRINT(_MSGBUF) ; endif
           case default
            __WRN(whoami,'UNKNOWN OPTION SPECIFIED')
          end select
!*********************************************************************
        elseif (__INDX(comlyn,comlen,'DPAR',4).gt.0) then ! normalized distance parallel to vector between neighboring replicas at which this system is restrained
          zval=__GET_RM_F(comlyn, comlen, 'DPAR', -1.0d0)
!    check replica spec
          irep=__GET_RM_I(comlyn, comlen, 'REP', -1)
          if (irep.lt.0.or.irep.ge.nstring) then
           if (qprint) then ; write(_MSGBUF, 6773) whoami, whoami, zval ; __PRINT(_MSGBUF) ; endif
           dpar0=zval
          else
           if (qprint) then ; write(_MSGBUF,6774) whoami, irep, zval ; __PRINT(_MSGBUF) ; endif
           if (mestring.eq.irep) dpar0=zval ! note: permitting any value
          endif ! irep
 6773 format(A,' REPLICA NUMBER INVALID OR UNSPECIFIED.',               &
     &      /A,' WILL SET RERERENCE VALUE FOR PARALLEL RESTRAINT ',     &
     &         '  TO ',F7.3,' ON ALL REPLICAS.')
 6774 format(A,' WILL SET RERERENCE VALUE FOR PARALLEL RESTRAINT ',     &
     &   'ON REPLICA ',I5,' TO ',F7.3,'.')
        ! DPAR
!********************************************************************
        elseif (__INDX(comlyn,comlen,'DPRP',4).gt.0) then ! distance perpendicular to vector between neighboring replicas at which this system is restrained
          zval=__GET_RM_F(comlyn, comlen, 'DPRP', -1.0d0)
!    check replica spec
          irep=__GET_RM_I(comlyn, comlen, 'REP', -1)
          if (irep.lt.0.or.irep.ge.nstring) then
           if (qprint) then ; write(_MSGBUF, 6776) whoami, whoami, zval ; __PRINT(_MSGBUF) ; endif
           dperp0=zval
          else
           if (qprint) then ; write(_MSGBUF,6775) whoami, irep, zval ; __PRINT(_MSGBUF) ; endif
           if (mestring.eq.irep) dperp0=zval ! note: permitting any value
          endif ! irep
 6776 format(A,' REPLICA NUMBER INVALID OR UNSPECIFIED.',               &
     &      /A,' WILL SET OFFSET DISTANCE FOR PERPENDICULAR RESTRAINT', &
     &         ' TO ',E10.3,' ON ALL REPLICAS.')
 6775 format(A,' WILL SET OFFSET DISTANCE FOR PERPENDICULAR RESTRAINT ',&
     &   'ON REPLICA ',I5,' TO ',E10.3,'.')
!********************************************************************
        elseif (__INDX(comlyn,comlen,'DRMS',4).gt.0) then ! RMS distance between simulation and reference structure
          zval=__GET_RM_F(comlyn, comlen, 'DRMS', -1.0d0)
!    check replica spec
          irep=__GET_RM_I(comlyn, comlen, 'REP', -1)
          if (irep.lt.0.or.irep.ge.nstring) then
           if (qprint) then ; write(_MSGBUF, 6777) whoami, whoami, zval ; __PRINT(_MSGBUF) ; endif
           drms0=zval
          else
           if (qprint) then ; write(_MSGBUF,6778) whoami, irep, zval ; __PRINT(_MSGBUF) ; endif
           if (mestring.eq.irep) drms0=zval ! note: permitting any value
          endif ! irep
 6777 format(A,' REPLICA NUMBER INVALID OR UNSPECIFIED.',               &
     &      /A,' WILL SET REFERENCE VALUE FOR RMSD RESTRAINT ',         &
     &         '  TO ',F7.3,' ON ALL REPLICAS.')
 6778 format(A,' WILL SET REFERENCE VALUE FOR RMSD RESTRAINT ',         &
     &   'ON REPLICA ',I5,' TO ',F7.3,'.')
        endif
!
!      done with 'SET' parsing
!cccccccccccccccccccccccccccccccccccc CV WEIGHTS cccccccccccccccccccccccccccccccccccc
      elseif (__STRNCMP(keyword,'LIST',4)) then ! list forcing and orientation atoms
       if (qprint) then ; write(_MSGBUF,6762) whoami ; __PRINT(_MSGBUF) ; endif
 6762 format(/A,' WILL LIST REPLICA ATOMS.')
       call ftsm_list_atoms()
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      else
            __WARN(whoami,'UNRECOGNIZED SUBCOMMAND: ',keyword)
      endif
!
      end subroutine ftsm_parse
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_init()
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_MPI 
!
      __IMPNONE
 __DECLARE_MSGBUF
#include "../../mpitype.def"
      int :: ierror
      bool :: qroot, qslave
      character(len=11) :: whoami
!
      data whoami /' FTSM_INIT>'/
!
!      do a basic communicator check:
      if (ME_LOCAL.eq.0.and.ME_STRNG.eq.MPI_UNDEFINED) then
        write(_MSGBUF, 111) whoami, ME_GLOBAL, whoami ; __PRINT(_MSGBUF)
 111  FORMAT(A, ' WORLD REPLICA ',I5, ' HAS ZERO GROUP ID',             &
     & /,A,' BUT INVALID STRING ID (MAY BE OK).')
      elseif (ME_STRNG.ne.MPI_UNDEFINED.and.                            &
     &  (ME_LOCAL.ne.0.or.MPI_COMM_LOCAL.eq.MPI_COMM_NULL)) then
        write(_MSGBUF, 112) whoami, ME_GLOBAL, whoami ; __PRINT(_MSGBUF)
 112  FORMAT(A, ' WORLD REPLICA ',I5, ' HAS A VALID STRING ID',         &
     & /,A,' BUT A NONZERO GROUP ID. ABORTING.')
       return
      endif
!
      qroot=ME_STRNG.ne.MPI_UNDEFINED
      qslave=ME_LOCAL.ne.MPI_UNDEFINED ! (also includes roots)
!
      if (ftsm_initialized) then
       if (qroot) then
        if (ME_STRNG.eq.0) then
          write(_MSGBUF,'(2A)')                                            &
     &    whoami, ' FTSM ALREADY INITIALIZED. CALL "DONE" TO CLEAN UP.' ; __PRINT(_MSGBUF);
        endif ! ME_STRNG
       endif ! qroot
       return
      endif
!
      nstring=1 ! safe (hopefully) default
      mestring=-1 ! safe (hopefully) default
!
      if (qroot) then
        nstring=SIZE_STRNG
        mestring=ME_STRNG
      endif
#ifdef __CHARMM
!      broadcast string size to all slave nodes
      __BROADCAST_LOCAL_8B(nstring, 1)    !##INTEGER8
      __BROADCAST_LOCAL_8B(mestring, 1)   !##INTEGER8
!
      __BROADCAST_LOCAL_4B(nstring, 1)    !##.not.INTEGER8
      __BROADCAST_LOCAL_4B(mestring, 1)   !##.not.INTEGER8
!      set envorinment variable
      call setmsi('NSTRING',nstring)
      call setmsi('MESTRING',mestring)
#else
      __BROADCAST_LOCAL(nstring, 1, mpiint)
      __BROADCAST_LOCAL(mestring, 1, mpiint)
#endif
!
      if (qroot) then
        if (ME_STRNG.eq.0) then
          write(_MSGBUF,'(2A,I5, A)')                                      &
     &    whoami, ' FOUND ',nstring,' REPLICAS.' ; __PRINT(_MSGBUF)
        endif
      endif
!
      MPI_RTMD_TYPE =MPI_DATATYPE_NULL
      MPI_RTMD_TYPE_=MPI_DATATYPE_NULL
!    initialize free energy arrays
      if (allocated(fe)) deallocate(fe)
      if (allocated(feav)) deallocate(feav)
      if (allocated(ds)) deallocate(ds)
      if (allocated(curv)) deallocate(curv)
      allocate(fe(nstring), feav(nstring),                              &
     &         ds(nstring-1), curv(nstring-2))

      fe=0d0; feav=0d0; avforce=0d0; ds=0d0; curv=0d0
!
      num_evolve_samples=0
      num_fe_samples=0
      num_force_samples=0
!    set default restraint positions
!
      if (mestring.eq.0) then
       dpar0=0d0
      elseif (mestring.eq.nstring-1) then
       dpar0=1d0
      else
       dpar0=0.5d0
      endif
!
      dperp0=0.5d0
      drms0=0d0
!
      qorient=.false.
      qdiffrot=.false.
!
      ftsm_initialized=.true.
!
      end subroutine ftsm_init
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_done()
      use ftsm_rex, only: ftsm_rex_done
!
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_MPI 
!
 __DECLARE_MSGBUF
!
      character(len=11) :: whoami
!
      data whoami /' FTSM_DONE>'/
!
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0) then 
       write(_MSGBUF,'(2A,I5, A)') whoami, ' CLEANING UP.' ; __PRINT(_MSGBUF)
      endif
!
      nstring=-1
      mestring=-1
#ifdef __CHARMM
!      set envorinment variable
      call setmsi('NSTRING',nstring)
      call setmsi('MESTRING',mestring)
#endif
!
!    deallocate arrays
!
      nforced=0
      if (associated(r_f)) deallocate(r_f)
      if (associated(iatom_f)) deallocate(iatom_f)
      if (associated(iatom_a)) deallocate(iatom_a)
      if (associated(orientWeights)) deallocate(orientWeights)
      if (associated(forcedWeights)) deallocate(forcedWeights)
!
      if (qdiffrot) then
       if (associated(r_o)) deallocate(r_o);
       if (associated(iatom_o)) deallocate(iatom_o);
       if (associated(iatom_both)) deallocate(iatom_both)
      endif
!
      nullify(r_o)
      nullify(iatom_o)
      norient=0
      nboth=0
!
      if (associated(iatom_a)) deallocate(iatom_a)
      nany=0
!
      if (associated(rcom)) deallocate(rcom)
      if (allocated(ds)) deallocate(ds)
      if (allocated(curv)) deallocate(curv)
      if (allocated(fe)) deallocate(fe)
      if (allocated(feav)) deallocate(feav)
!
      num_evolve_samples=0
      num_fe_samples=0
      num_force_samples=0
!
      qdiffrot=.false.
      qorient=.false.
!
      call ftsm_define_rtmd_type() ! deallocate MPI type for transmitting forces (this is the effect when norient=0)
!
      call ftsm_rex_done()
!
      call ftsm_mini_done() ! deallocate minimization structures (if any)
!
      ftsm_initialized=.false.
!
      end subroutine ftsm_done
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_repa_init(comlyn, comlen)
!
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_MPI 
      __IMPNONE
!
 __DECLARE_MSGBUF
!
      CHARACTER(LEN=*) :: COMLYN
      int :: COMLEN
      character(len=16) :: whoami
      bool :: qprint, qroot
!
      data whoami /' FTSM_REPA_INIT>'/
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qprint=qroot.and.ME_STRNG.eq.0
!
      if (qprint) then ; write(_MSGBUF,8002) whoami ; __PRINT(_MSGBUF) ; endif
      call smcv_repa_init(comlyn, comlen)
!
 8002 format(/A,' USING SMCV INITIALIZATION ROUTINE')
!
      end subroutine ftsm_repa_init
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_mini_init(comlyn, comlen)
      use ftsm_var
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __DEP_NUMBER
#ifdef __CHARMM
      use datstr
#endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      __IMPNONE
!
      character(len=*) :: comlyn
      int :: comlen
!
      character(len=16) :: whoami
      character(len=8) :: keyword
!
      int :: isd=0, iconj=0, mlen
!
!
      bool :: qroot, qprint
!
 __DECLARE_MSGBUF
!
      character(len=20) :: methods(2), method
      data methods/ 'STEEPEST DESCENT','CONJUGATE GRADIENT'/

      data whoami /' FTSM_MINI_INIT>'/
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qprint=qroot.and.ME_STRNG.eq.0
!
      ftsm_mini_method=0
      ftsm_mini_initialized=.false.
!
      isd=__INDX_RM(comlyn, comlen, 'SD') ; if (isd.gt.0) ftsm_mini_method=sd
      iconj=__INDX_RM(comlyn, comlen, 'CONJ') ; if (iconj.gt.0) ftsm_mini_method=conj
!
      if ((iconj).gt.0) then
        __WRN(whoami,' ONLY SD MINIMIZATION IS CURRENTLY SUPPORTED. NOTHING DONE')
        return
      endif
!ccccccc CHECK FOR MULTIPLE OR MISSING OPTIONS
      if ((abs(isd)+abs(iconj)) .eq. 0) then
       if (qprint) then  ; write(_MSGBUF,665) whoami ; __PRINT(_MSGBUF) ; endif ! qprint
 665   FORMAT(A,' MINIMIZATION METHOD NOT SPECIFIED. WILL USE STEEPEST DESCENT.')
       ftsm_mini_method=sd
      elseif ((isd+iconj) .gt. 1) then
       __WRN(whoami,'MORE THAN ONE MINIMIZATION METHOD SPECIFIED. NOTHING DONE')
       return
      endif
!
      ftsm_mini_step=__GET_RM_F(comlyn, comlen, 'STEP', one*0.01) ! cast to correct kind
      if (ftsm_mini_step.lt.zero) then
         __WRN(whoami,'MINIMIZATION STEP MUST NOT BE NEGATIVE. SET TO 0.01 .')
         ftsm_mini_step=0.01
      endif
!     number of minimization steps
      ftsm_mini_bath_iterations=__GET_RM_I(comlyn, comlen, 'BITER', ione*50)
      if (ftsm_mini_bath_iterations.lt.0) then
         __WRN(whoami,'NUMBER OF MINIMIZATION ITERATIONS CANNOT BE NEGATIVE. NOTHING DONE.')
         return
      endif
!
      ftsm_mini_forced_iterations=__GET_RM_I(comlyn, comlen, 'SITER', ione*10)
      if (ftsm_mini_forced_iterations.lt.0) then
         __WRN(whoami,'NUMBER OF MINIMIZATION ITERATIONS CANNOT BE NEGATIVE. NOTHING DONE.')
         return
      endif
!
!     print summary
!
      if (qprint) then
       mlen=len_trim(methods(ftsm_mini_method))
       write(_MSGBUF(1),667) whoami, methods(ftsm_mini_method)(1:mlen)
       write(_MSGBUF(3),669) whoami, ftsm_mini_bath_iterations, ftsm_mini_forced_iterations
       write(_MSGBUF(2),668) whoami, ftsm_mini_step
       __PRINT(_MSGBUF)
!
 667  format(A,'  WILL MINIMIZE STRING USING ',A,' MINIMIZATION')
 669  format(A,'  FOR ',I5,' BATH ITERATIONS AND ',I5,' STRING ITERATIONS')
 668  format(A,'  WITH INITIAL STEP ',F10.5)
!
      endif
!
      ftsm_mini_initialized=.true.
      __CHARMM_ONLY ftsm_nbond_image_data_initialized=.false. ! data for computing energy using CHARMM
!
      end subroutine ftsm_mini_init
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_mini_done()
#ifdef __CHARMM
      use datstr, only : FREEDT_nbond, FREEDT_image
      call FREEDT_nbond(ftsm_nbond_copy)
      call FREEDT_image(ftsm_image_copy)
      ftsm_nbond_image_data_initialized=.false.
#endif
      ftsm_mini_method=0
      ftsm_mini_initialized=.false.
      end subroutine ftsm_mini_done
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_list_atoms()
      __DEP_OUTPUT
      __DEP_PARSER 
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_MPI 
      __DEP_ATOMID
!
      __IMPNONE
 __DECLARE_MSGBUF
!
      int :: j
      character(len=8) :: sid, rid, ren, ac
      character(len=17) :: whoami
!
      data whoami /' FTSM_LIST_ATOMS>'/
!
      if (MPI_COMM_STRNG.eq.MPI_COMM_NULL) return ! only replica heads stay
!
      if (ME_STRNG.eq.0) then
!
       write(_MSGBUF,'(A)') '\t ORIENTATION ATOMS:'
        do j=1, norient;
         __ATOMID(iatom_o(j), sid, rid, ren, ac)
         write(_MSGBUF,667) '\t',j, iatom_o(j), sid, rid, ren, ac
        enddo
!
        if (qdiffrot) then
         write(_MSGBUF,'(A)') '\t FORCING ATOMS'
         do j=1, nforced;
          __ATOMID(iatom_f(j), sid, rid, ren, ac)
          write(_MSGBUF,667) '\t',j, iatom_f(j), sid, rid, ren, ac ; __PRINT(_MSGBUF)
         enddo
        else
         write(_MSGBUF,'(A)') '\t FORCING AND ORIENTATION ATOMS ARE THE SAME' ; __PRINT(_MSGBUF)
        endif
      endif ! ME_STRING
!
 667  format(A,2I8,' ',4A)
!
      end subroutine ftsm_list_atoms
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_set_weights(w,n)
      __DEP_OUTPUT
      __DEP_NUMBER
      __DEP_PARSER
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
!
      __IMPNONE
      float :: w(n), a
      character(len=18) :: whoami
      int :: i, j, n
!
 __DECLARE_MSGBUF
!
      data whoami /' FTSM_SET_WEIGHTS>'/
!
      if (ME_STRNG.eq.0.and.ME_LOCAL.eq.0) then
       write(_MSGBUF,668)                                               &
     & whoami,' A CHANGE IN THE ORIENTATION WEIGHTS REQUIRES ',         &
     & whoami,' REDEFINING IMAGES (e.g. USING FILL)' ; __PRINT(_MSGBUF)
      endif
 668  format(/2A,/2A)
!
      if (norient.eq.0.and.nforced.eq.0) then
       __WRN(whoami,'NO STRING ATOMS FOUND. NOTHING DONE.')
       return
      endif
!
!      if (norient.eq.0)
!     & __WRN(whoami,'NO ORIENTATION ATOMS FOUND.')
      if (associated(orientWeights).and.associated(iatom_o)) then
       do i=1,norient
        j=iatom_o(i)
        if (j.le.n) then
         orientWeights(i)=w(j)
        else
         __WRN(whoami,'WEIGHT ARRAY BOUNDS EXCEEDED. ABORT.')
         return
        endif
       enddo
!
       a=sum(orientWeights);
       if (a.gt.__ERRTOL) then ; orientWeights=orientWeights/a;
       else
        __WRN(whoami,'SUM OF ORIENTATION WEIGHTS IS VERY SMALL. ABORT.')
        return
       endif
!
      endif ! weights associated
!
!      if (nforced.eq.0)
!     & __WRN(whoami,'NO FORCED ATOMS FOUND.')
      if (associated(forcedWeights).and.associated(iatom_f)) then
       do i=1,nforced
        j=iatom_f(i)
        if (j.le.n) then
         forcedWeights(i)=w(j)
        else
         __WRN(whoami,'WEIGHT ARRAY BOUNDS EXCEEDED. ABORT.')
         return
        endif
       enddo
!
       a=sum(forcedWeights);
       if (a.gt.__ERRTOL) then ; forcedWeights=forcedWeights/a;
       else
        __WRN(whoami,'SUM OF FORCING WEIGHTS IS VERY SMALL. ABORT.')
        return
       endif
!
      endif ! weights associated
!
      end subroutine ftsm_set_weights
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_swap(c1,c2)
!      __DEP_OUTPUT
      __IMPNONE
      int :: c1, c2
      float :: com(3)
      character(len=11) :: whoami
      int :: i,j
!
      data whoami /' FTSM_SWAP>'/
!
      if (.not.ftsm_check(qorient)) return
!
      if (c1.gt.num_sets.or.c2.gt.num_sets) then
       __WRN(whoami,'INVALID COLUMN SPECIFIED. ABORT.')
       return
      else
       if (qdiffrot) then
        r_o(:,:,dummy)=r_o(:,:,c1)
        r_o(:,:,c1)=r_o(:,:,c2)
        r_o(:,:,c2)=r_o(:,:,dummy)
       endif
       r_f(:,:,dummy)=r_f(:,:,c1)
       r_f(:,:,c1)   =r_f(:,:,c2)
       r_f(:,:,c2)   =r_f(:,:,dummy)
!
       com       =rcom(:,c1)
       rcom(:,c1)=rcom(:,c2)
       rcom(:,c2)=com
!
      endif
!
      end subroutine ftsm_swap
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_copy(c1,c2)
      __DEP_NUMBER 
!
      __IMPNONE
      int :: c1, c2
      character(len=11) :: whoami
      int :: i,j
!
      data whoami /' FTSM_COPY>'/
!
      if (.not.ftsm_check(qorient)) return
!
      if (c1.gt.num_sets.or.c2.gt.num_sets) then
       __WRN(whoami,'INVALID COLUMN SPECIFIED. ABORT.')
       return
      else
       if (qdiffrot) r_o(:,:,c2)=r_o(:,:,c1)
       r_f(:,:,c2)=r_f(:,:,c1)
       rcom(:,c2) =rcom(:,c1)
      endif
!
      end subroutine ftsm_copy
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_fill(x,y,z)
      __DEP_NUMBER 
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
!      __DEP_MPI 
!
      __IMPNONE
!
      float :: x(:), y(:), z(:)
      character(len=11) :: whoami
      int :: i,j,n
      bool :: qroot, qslave
      float, pointer, dimension(:,:) :: rl, rc, rr
      int :: me
!
      data whoami /' FTSM_FILL>'/
!
      n=min(size(x), size(y), size(z))
!
!      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
!      qslave=((MPI_COMM_LOCAL.ne.MPI_COMM_NULL).and.SIZE_LOCAL.gt.1)
!
      if (.not.ftsm_check(qorient)) return
!
      if (any(x.eq.__NAN).or.any(y.eq.__NAN).or.any(z.eq.__NAN)) then
       __WRN(whoami,'COORDINATE SET HAS UNDEFINED VALUES. NOTHING DONE.')
       return
      else ! if (qroot) then
       do i=1,nforced
        j=iatom_f(i)
        if (j.le.n) then
         r_f(i,1,center)=x(j)
         r_f(i,2,center)=y(j)
         r_f(i,3,center)=z(j)
        else
         __WRN(whoami,'COORDINATE ARRAY BOUNDS EXCEEDED. ABORT.')
         return
        endif
       enddo
!
       if (qdiffrot) then
        do i=1,norient
         j=iatom_o(i)
         if (j.le.n) then
          r_o(i,1,center)=x(j)
          r_o(i,2,center)=y(j)
          r_o(i,3,center)=z(j)
         else
          __WRN(whoami,'COORDINATE ARRAY BOUNDS EXCEEDED. ABORT.')
          return
         endif
        enddo
       endif ! qdiffrot
      endif ! x.eq.__NAN
!     remove and save center of mass of orientation atoms
!
      call ftsm_save_com()
!
      call ftsm_swap_bc(.true.) ! .true. : send to slaves
!
      r_f(:,:,left_old:right_old)=r_f(:,:,left:right)
      r_f(:,:,center_new)=r_f(:,:,center)
      if (qdiffrot) then
       r_o(:,:,left_old:right_old)=r_o(:,:,left:right)
       r_o(:,:,center_new)=r_o(:,:,center)
      endif
!
!     now send to slaves
!
!      if (qslave) then
!       call __BROADCAST_LOCAL_8B(r_f,9*nforced) ! send three adjacent sets
!       if (qdiffrot) call __BROADCAST_LOCAL_8B(r_o,9*norient)
!      endif ! qslave
!
      end subroutine ftsm_fill
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_compute_overlap_ind() ! compute overlap indices in iatom_both
      __IMPNONE
      int :: i, j
      int, allocatable :: temp(:,:)
!
!   note: both index arrays are assumed to be sorted !
!
      if (associated(iatom_both)) deallocate(iatom_both)
      nboth=0
      if ( .not. ( qorient .and. qdiffrot .and. ftsm_check(qorient))) return
!
      i=1; j=1
      allocate(temp(2,max(nforced, norient)))
      do while (i.le.nforced .and. j.le.norient)
!
       do while (  j.lt.norient .and. ( iatom_f(i) .gt. iatom_o(j) ) )
        j=j+1
       enddo
       if (iatom_f(i).eq.iatom_o(j)) then
        nboth=nboth+1;
        temp(1,nboth)=i; temp(2,nboth)=j;
        j=j+1; ! i-indices are unique, so safe to increment j
       endif
       i=i+1
      enddo
!
      if (nboth.gt.0) then
       allocate(iatom_both(2,nboth))
       iatom_both(:,1:nboth)=temp(:,1:nboth)
      endif
      deallocate(temp)
!
      end subroutine ftsm_compute_overlap_ind
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_define_rtmd_type()
      use sm_config, only: sizeofreal
      __DEP_MPI 
      __DEP_NUMBER
!
      __IMPNONE
!
      int4mpi :: error, norient_mpi
      integer(kind=MPI_ADDRESS_KIND) :: lb, extent
!
!    create custom type for gathering array of shape (norient,3), in rows
!    taken from rtmd code
!
      if (MPI_RTMD_TYPE.ne.MPI_DATATYPE_NULL)                           &
     &  call mpi_type_free(MPI_RTMD_TYPE, error)
      if (MPI_RTMD_TYPE_.ne.MPI_DATATYPE_NULL)                          &
     & call mpi_type_free(MPI_RTMD_TYPE_, error)
!
      if (norient.gt.0) then
       lb=0
       extent=sizeofreal
       norient_mpi=norient
       call mpi_type_vector(3, 1, norient_mpi,                         &
     &   MPI_DOUBLE_PRECISION, MPI_RTMD_TYPE_, error)
!    corresponding resized type
       call mpi_type_create_resized(MPI_RTMD_TYPE_,lb,extent,           &
     &   MPI_RTMD_TYPE, error)
       call mpi_type_commit(MPI_RTMD_TYPE, error)
      endif
!
      end subroutine ftsm_define_rtmd_type
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function ftsm_test_grad_fd(x,y,z,h) result(error)
      __IMPNONE
      float :: x(:), y(:), z(:)
      float :: h
      float, pointer :: error(:,:)
      int :: i, j, jj
      float :: d, ap, am, bp, bm
      float :: s
!
      character(len=19) :: whoami
      data whoami /' FTSM_TEST_GRAD_FD>'/
!
      allocate(error(2,3))
      ap=0d0; am=0d0; bp=0d0; bm=0d0; error(1,1)=9999d0
!
      if (.not.ftsm_check(qorient)) return
!
      if (h.eq.0d0) then
       __WRN(whoami,'COORDINATE PERTURBATION ZERO.')
       return
      endif
!
      s=1d0
!      s=0.5d0
! compute projection and derivatives analytically
      call ftsm_calc(x,y,z,.true.,s)
!
! IMPORTANT: if the o and f atoms are different and overlapping, the o and f gradient arrays
! will each have partial contributions to the total derivative for the overlapping atoms
! (whereas, the FD calculation will include both contributions)
! therefore, I am "reducing" the different gradient contributions below (which invalidates
! the contents of the arrays); the need to do this arises because I chose to keep two
! possibly overlapping coordinate arrays, even though the corresponding atoms are unique
!
      if (qdiffrot) then
       do i=1, nboth
         r_o(iatom_both(2,i), :, fpar) =                                &
     &   r_o(iatom_both(2,i), :, fpar) + r_f(iatom_both(1,i), :, fpar)
         r_f(iatom_both(1,i), :, fpar) = r_o(iatom_both(2,i), :, fpar)
       enddo
       if (proj_on) then
        do i=1, nboth
         r_o(iatom_both(2,i), :, fperp) =                               &
     &   r_o(iatom_both(2,i), :, fperp) + r_f(iatom_both(1,i), :, fperp)
         r_f(iatom_both(1,i), :, fperp) = r_o(iatom_both(2,i), :, fperp)
        enddo
       endif
      endif
!
! no need for this because not overwriting force arrays
!      r_f(:,:,left_cur)=r_f(:,:,fpar)
!      if (qdiffrot) r_o(:,:,left_cur)=r_o(:,:,fpar)
!      if (proj_on) then
!       r_f(:,:,right_cur)=r_f(:,:,fperp)
!       if (qdiffrot) r_o(:,:,right_cur)=r_o(:,:,fperp)
!      endif
!
!        write(mestring+500,*) dpar, dperp
!        write(mestring+500,*) r_f(:,2,fpar)
!
! loop over all coordinates and compute finite differences
      error=0d0
!
      do jj=1, nforced
       j=iatom_f(jj)
! x-derivatives *******************************************
       d=x(j) ; x(j)=d-h
       call ftsm_calc(x,y,z,.false.,s)
       if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
       x(j)=d+h
       call ftsm_calc(x,y,z,.false.,s) ! overwrite zold cv value array (warn about this elsewhere)
       if (proj_on) then; ap=dpar;  bp=dperp; else; ap=drms ; endif
       x(j)=d ! restore correct value
! compute largest absolute error
!         r_f(jj,1,dummy)=0.5d0/h*(bp-bm) ! aa
!
       error(1,1) = max (error(1,1),                                    &
     &         abs(0.5d0/h*(ap-am)-r_f(jj,1,fpar) ) )
       if (proj_on)                                                     &
     & error(2,1) = max (error(2,1),                                    &
     &        abs(0.5d0/h*(bp-bm)-r_f(jj,1,fperp) ) )
! y-derivatives *******************************************
       d=y(j) ; y(j)=d-h
       call ftsm_calc(x,y,z,.false.,s)
       if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
       y(j)=d+h
       call ftsm_calc(x,y,z,.false.,s) ! overwrite zold cv value array (warn about this elsewhere)
       if (proj_on) then; ap=dpar;  bp=dperp; else; ap=drms ; endif
       y(j)=d ! restore correct value
! compute largest absolute error
!         r_f(jj,2,dummy)=0.5d0/h*(ap-am) ! aa
!
       error(1,2) = max (error(1,2),                                    &
     &          abs(0.5d0/h*(ap-am)-r_f(jj,2,fpar) ) )
       if (proj_on)                                                     &
     & error(2,2) = max (error(2,2),                                    &
     &         abs(0.5d0/h*(bp-bm)-r_f(jj,2,fperp) ) )
! z-derivatives *******************************************
       d=z(j) ; z(j)=d-h
       call ftsm_calc(x,y,z,.false.,s)
       if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
       z(j)=d+h
       call ftsm_calc(x,y,z,.false.,s) ! overwrite zold cv value array (warn about this elsewhere)
       if (proj_on) then; ap=dpar;  bp=dperp; else; ap=drms ; endif
       z(j)=d ! restore correct value
! compute largest absolute error
       error(1,3) = max (error(1,3),                                    &
     &         abs(0.5d0/h*(ap-am)-r_f(jj,3,fpar) ) )
       if (proj_on)                                                     &
     & error(2,3) = max (error(2,3),                                    &
     &         abs(0.5d0/h*(bp-bm)-r_f(jj,3,fperp) ) )
      enddo ! forced atoms
!
!        write(mestring+500,*) r_f(:,2,dummy) ! aaa
!           close(mestring+500)
! orientation atoms:
      if (qorient.and.qdiffrot) then
       do jj=1, norient
        j=iatom_o(jj)
! x-derivatives *******************************************
        d=x(j) ; x(j)=d-h
        call ftsm_calc(x,y,z,.false.,s)
        if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
        x(j)=d+h
        call ftsm_calc(x,y,z,.false.,s) ! overwrite zold cv value array (warn about this elsewhere)
        if (proj_on) then; ap=dpar;  bp=dperp; else; ap=drms ; endif
        x(j)=d ! restore correct value
! compute largest absolute error
        error(1,1) = max(error(1,1),                                    &
     &         abs(0.5d0/h*(ap-am)-r_o(jj,1,fpar) ) )
        if (proj_on)                                                    &
     &  error(2,1) = max(error(2,1),                                    &
     &         abs(0.5d0/h*(bp-bm)-r_o(jj,1,fperp) ) )
! y-derivatives *******************************************
        d=y(j) ; y(j)=d-h
        call ftsm_calc(x,y,z,.false.,s)
        if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
        y(j)=d+h
        call ftsm_calc(x,y,z,.false.,s) ! overwrite zold cv value array (warn about this elsewhere)
        if (proj_on) then; ap=dpar;  bp=dperp; else; ap=drms ; endif
        y(j)=d ! restore correct value
! compute largest absolute error
        error(1,2) = max (error(1,2),                                   &
     &         abs(0.5d0/h*(ap-am)-r_o(jj,2,fpar) ) )
        if (proj_on)                                                    &
     &  error(2,2) = max (error(2,2),                                   &
     &         abs(0.5d0/h*(bp-bm)-r_o(jj,2,fperp) ) )
! z-derivatives *******************************************
        d=z(j) ; z(j)=d-h
        call ftsm_calc(x,y,z,.false.,s)
        if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
        z(j)=d+h
        call ftsm_calc(x,y,z,.false.,s) ! overwrite zold cv value array (warn about this elsewhere)
        if (proj_on) then; ap=dpar;  bp=dperp; else; ap=drms ; endif
        z(j)=d ! restore correct value
! compute largest absolute error
        error(1,3) = max (error(1,3),                                   &
     &         abs(0.5d0/h*(ap-am)-r_o(jj,3,fpar) ) )
        if (proj_on)                                                    &
     &  error(2,3) = max (error(2,3),                                   &
     &         abs(0.5d0/h*(bp-bm)-r_o(jj,3,fperp) ) )
       enddo ! orientation atoms
      endif ! qdiffrot and qorient
!
      end function ftsm_test_grad_fd
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function ftsm_test_parallel(x,y,z) result(error)
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __IMPNONE
!
      float :: x(:), y(:), z(:)
      float, pointer :: error(:,:)
      float :: am, bm
!
      int :: i
      bool :: qpara
      bool :: qgrp
!
      character(len=20) :: whoami
      data whoami /' FTSM_TEST_PARALLEL>'/
      allocate(error(2,4)) ! first column contains the CV values; then maximum derivative error (x,y,z)
      error(2,:)=0d0; error(1,:)=9999d0
!
      if (.not.ftsm_check(qorient)) return
!
      qgrp=(MPI_COMM_LOCAL.ne.MPI_COMM_NULL)                            &
     & .and.(SIZE_LOCAL.gt.1)
      if (.not. qgrp) then ! quit if cannot run in parallel
       __WRN(whoami,'CANNOT PERFORM TEST ON 1-PROCESSOR GROUPS')
       return
      endif
! save values & force a serial calculation
      qpara=calc_bestfit_grad_para; calc_bestfit_grad_para=.false.
!
! 1) compute serially
      call ftsm_calc(x,y,z,.true.)
! using left_cur array : it should not be used unless an additional parameter is passed to calc
! save gradients
      r_f(:,:,left_cur)=r_f(:,:,fpar); r_f(:,:,fpar)=0d0;
      if (qdiffrot) then
       r_o(:,:,left_cur)=r_o(:,:,fpar); r_o(:,:,fpar)=0d0
      endif
!
      if (proj_on) then
       r_f(:,:,right_cur)=r_f(:,:,fperp); r_f(:,:,fperp)=0d0
       if (qdiffrot) then
        r_o(:,:,right_cur)=r_o(:,:,fperp); r_o(:,:,fperp)=0d0
       endif
      endif
!        write(me_GLOBAL+500,*) drms, dpar, dperp
!        write(me_GLOBAL+500,*) r_o(:,2,left_cur)
! save projections
      if (proj_on) then; am=dpar;  bm=dperp; else; am=drms ; endif
!
! 2) compute in (fully) parallel
      calc_bestfit_grad_para=.true.
!
      call ftsm_calc(x,y,z,.true.)
!        write(me_GLOBAL+500,*) drms, dpar, dperp
!        write(me_GLOBAL+500,*) r_o(:,2,fpar)
!         close(me_GLOBAL+500)
! compute largest absolute error
! parallel component (or drms)
      error(1,1) = maxval ( abs (r_f(:,1,left_cur)-r_f(:,1,fpar) ) )
      error(1,2) = maxval ( abs (r_f(:,2,left_cur)-r_f(:,2,fpar) ) )
      error(1,3) = maxval ( abs (r_f(:,3,left_cur)-r_f(:,3,fpar) ) )
      if (proj_on) then
       error(2,1) = maxval ( abs (r_f(:,1,right_cur)-r_f(:,1,fperp) ) )
       error(2,2) = maxval ( abs (r_f(:,2,right_cur)-r_f(:,2,fperp) ) )
       error(2,3) = maxval ( abs (r_f(:,3,right_cur)-r_f(:,3,fperp) ) )
       error(2,4) = abs ( dperp - bm )
       error(1,4) = abs ( dpar  - am )
      else
       error(1,4) = abs ( drms  - am )
      endif
!
      if (qdiffrot.and.qorient) then
       error(1,1) = max(error(1,1),                                     &
     &              maxval ( abs (r_o(:,1,left_cur)-r_o(:,1,fpar) ) ) )
       error(1,2) = max(error(1,2),                                     &
     &              maxval ( abs (r_o(:,2,left_cur)-r_o(:,2,fpar) ) ) )
       error(1,3) = max(error(1,3),                                     &
     &              maxval ( abs (r_o(:,3,left_cur)-r_o(:,3,fpar) ) ) )
       if (proj_on) then
        error(2,1) = max(error(2,1),                                    &
     &              maxval ( abs (r_o(:,1,right_cur)-r_o(:,1,fperp) ) ))
        error(2,2) = max(error(2,2),                                    &
     &              maxval ( abs (r_o(:,2,right_cur)-r_o(:,2,fperp) ) ))
        error(2,3) = max(error(2,3),                                    &
     &              maxval ( abs (r_o(:,3,right_cur)-r_o(:,3,fperp) ) ))
       endif
      endif
! restore original option
      calc_bestfit_grad_para=qpara
!
      end function ftsm_test_parallel
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_write_dcd(ifile, col, ibeg, iend)
!
#ifdef __CHARMM
      __DEP_PSF 
      use cveloci_mod      !##CVELOCI
#endif
!
      __DEP_SIZE
      __DEP_COORDINATES
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_PARSER 
      __DEP_COORIO
      __DEP_MPI 
      __DEP_NUMBER
!
!    will use fixed atom arrays to print only the path atoms
!
      __IMPNONE
      character(len=16) :: whoami
#ifdef __CHARMM
      character(len=80) :: title(maxtit)
      int :: ntitle, ncv
#endif
#ifndef __CHARMM
      int :: natom
#endif
      float, pointer :: r3(:,:)  ! coordinates
      int, pointer :: stringatoms(:), string_inds(:)
      int :: i, j, k
      int :: ifile
      int, optional :: col, ibeg, iend
      int :: c, ierror, stat(MPI_STATUS_SIZE), ibg, ie, ind
      int :: rtype=MPI_DOUBLE_PRECISION
      bool :: qroot
!
      data whoami /' FTSM_WRITE_DCD>'/
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
!
#ifdef __CHARMM
      title(1) = '* FINITE TEMPERATURE STRING IMAGE FILE'
      ntitle=1
#endif
!
      if (.not. ftsm_check(qorient)) return
      if (present(col)) then ; c=col; else; c=center; endif
      if (c.lt.1.or.c.gt.num_sets) then
       __WRN( whoami, 'INVALID COLUMN. ABORT.')
       return
      endif
!
      if (present(ibeg)) then ; ibg=ibeg; else; ibg=1; endif
      if (present(iend)) then ; ie=iend; else; ie=nstring; endif
!
      if (ibg.lt.1.or.ibg.gt.ie) then
       __WRN( whoami, 'INVALID FRAMES REQUESTED. ABORT.')
       return
      endif
!
      nullify(stringatoms, string_inds, r3)
!
      if (qroot) then
!
      if (ME_STRNG.eq.0) then
!
#ifndef __CHARMM
 natom=__NATOM
#endif
!
       allocate(stringatoms(natom), string_inds(natom))
       stringatoms=0
!
       stringatoms(iatom_f)=1
       if (qdiffrot) stringatoms(iatom_o)=1
       k=0
       do i = 1, natom
        if (stringatoms(i).gt.0) then; k=k+1; string_inds(k)=i; endif ! need this array for dcd writer below
       enddo
#ifdef __CHARMM
       ncv=ncvel ; ncvel=0  !__CHARMM_ONLY##CVELOCI ! exclude constant velocity atoms also
#endif
!      for first frame, output all coordinates: take from instantaneous set
       allocate(r3(natom,3)) ; r3=0d0
#ifdef __CHARMM
       r3(:,1)=x(1:natom)-rcom(1,instant) ! bring all coordinates to zero COM for convenience (assume rcom(:,instant) is reasonably accurate)
       r3(:,2)=y(1:natom)-rcom(2,instant)
       r3(:,3)=z(1:natom)-rcom(3,instant)
#elif defined (__DMOL)
       r3(:,1)=r(:,1)-rcom(1,instant)
       r3(:,2)=r(:,2)-rcom(2,instant)
       r3(:,3)=r(:,3)-rcom(3,instant)
#endif
!
       call ftsm_update_overlap_coor(ione)
       do j=1,nforced;ind=iatom_f(j);r3(ind,:)=r_f(j,:,c);enddo
       if (qdiffrot) then
       do j=1,norient;ind=iatom_o(j);r3(ind,:)=r_o(j,:,c);enddo
       endif
! call trajectory writer
#ifdef __CHARMM
       call writcv(r3(:,1), r3(:,2), r3(:,3),                           &
     &  r3(:,1), .false.,                                               & !__CHARMM_ONLY##CHEQ
     &  natom,                                                          &
     &  string_inds, k, ibg, ibg, 3*k, 0d0, 1, ie, title,ntitle,ifile,  &
     &  .false., .false., stringatoms(1:20), .false., r3(:,1))       ! whew...
#elif defined(__DMOL)
       call dcd_write_frame(ifile,r3,(ibg.eq.1),FREEATOMS=string_inds(1:k))
#endif
!from dynio.src
!      SUBROUTINE WRITCV(X,Y,Z,
!     $                  CG,QCG,                             !__CHARMM_ONLY##CHEQ
!     $                  NATOM,FREEAT,NFREAT,NPRIV,ISTEP,NDEGF,
!     $                  DELTA,NSAVC,NSTEP,TITLE,NTITLE,IUNCRD,QVEL,
!     $                  QINCT,JCNTRL,DIM4,FDIM)
!C
!C     WRITES A SET OF COORDINATES FOR A SINGLE DYNAMICS STEP. THE FORMAT
!C     FOR THE TRAJECTORY FILE VARIES WITH WHETHER ANY ATOMS ARE FIXED.
!C     ICNTRL(9) STORES THE NUMBER OF FIXED ATOMS WHICH WILL BE ZERO FOR
!C     ALL PREVIOUS TRAJECTORY FILES SO COMPATIBILITY IS ASSURED.
!C
!C     Authors: S. Swaminathan
!C              Robert Bruccoleri
!
!    repeat a few times to write out entire string
       do i=2, nstring
!
        call MPI_RECV(r_f(:,:,dummy),3*nforced,rtype,i-1,i-1,           &
     &       MPI_COMM_STRNG,stat,ierror)
        if (qdiffrot.and.qorient)                                       &
     &       call MPI_RECV(r_o(:,:,dummy),3*norient,rtype,i-1,i-1,      &
     &       MPI_COMM_STRNG,stat,ierror)
!    extract coordinates
        do j=1, nforced; ind=iatom_f(j); r3(ind,:)=r_f(j,:,dummy); enddo
        if (qdiffrot.and.qorient) then
         do j=1, norient; ind=iatom_o(j); r3(ind,:)=r_o(j,:,dummy);enddo
        endif
!    write next frame
#ifdef __CHARMM
        call writcv(r3(:,1), r3(:,2), r3(:,3),                          &
     &   r3(:,1), .false.,                                              & !__CHARMM_ONLY##CHEQ
     &   natom,                                                         &
     &   string_inds, k, ibg, ibg+i-1, 3*k, 0d0, 1, ie, title, 1, ifile,&
     &   .false., .false., stringatoms(1:20), .false., r3(:,1))
#elif defined(__DMOL)
       call dcd_write_frame(ifile,r3,.false.,FREEATOMS=string_inds(1:k))
#endif
       enddo
!
#ifdef __CHARMM
       ncvel=ncv !##CVELOCI
#endif
      else
       call MPI_SEND(r_f(:,:,c),3*nforced,rtype,0,ME_STRNG,             &
     &                      MPI_COMM_STRNG, ierror)
       if (qdiffrot.and.qorient)                                        &
     &  call MPI_SEND(r_o(:,:,c),3*norient,rtype,0,ME_STRNG,            &
     &                      MPI_COMM_STRNG, ierror)
      endif
!
      endif ! qroot
!
      if (associated(stringatoms)) deallocate(stringatoms)
      if (associated(string_inds)) deallocate(string_inds)
      if (associated(r3)) deallocate(r3)
!
      end subroutine ftsm_write_dcd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_read_dcd(ifile, col)
#ifdef __CHARMM
      __DEP_PSF
#endif
      __DEP_SIZE
      __DEP_COORDINATES
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_PARSER 
      __DEP_MPI
      __DEP_COORIO
!
      __IMPNONE
      character(len=15) :: whoami
      float, pointer :: r3(:,:)
      int, pointer :: stringatoms(:), string_inds(:)
      int :: i, j, k, ind, ifile
      int, optional :: col
      int :: c, ierror, stat(MPI_STATUS_SIZE)
      int :: rtype=MPI_DOUBLE_PRECISION
!
#ifdef __CHARMM
      character(len=80) :: title(maxtit)
      real*4 :: trash4(natom) ! scratch array for ugly routine
      float :: trash8(natom) ! scratch array for ugly routine
!     some dummy vars for coordinate read
      int :: nfile, istep, istats, ndof, begin_, stop_,             &
     &           skip_, nsavv_, satoms, ntitle
      float :: delta
      bool :: qdim4, qcg
#else
      int :: natom
#endif
!
      data whoami /' FTSM_READ_DCD>'/
!
      if (.not. ftsm_check(qorient)) return
      if (present(col)) then ; c=col; else; c=center; endif
      if (c.lt.1.or.c.gt.num_sets) then
       __WRN( whoami, 'INVALID COLUMN. ABORT.')
       return
      endif
!
#ifndef __CHARMM
 natom=__NATOM
#endif
!
      allocate(r3(natom,3))
      allocate(stringatoms(natom), string_inds(natom))
!
      r3=0d0; stringatoms=0
!
      stringatoms(iatom_f)=1
      if (qdiffrot) stringatoms(iatom_o)=1
      k=0
!
      do i = 1, natom
       if (stringatoms(i).gt.0) then ; k=k+1 ; string_inds(k)=i ; endif ! need this array for dcd reader below
      enddo
!
      if (ME_STRNG.eq.0) then
!
!    call trajectory reader
!
#ifdef __CHARMM
       istats=1
       qcg=.false.
       qdim4=.false.
       begin_=0 ! note begin <=0 forces a strange "reset" with begin=istep (which is zero below); this is to support trajectories
                ! made with VMD
       skip_=1
       stop_=nstring
       ntitle=0
       istep=0
!
       call readcv(r3(:,1), r3(:,2), r3(:,3),                              &
     &  trash8, qcg,                                                    & !__CHARMM_ONLY##CHEQ
     &  trash4, natom,                                                  &
     &  stringatoms, satoms, ifile, 1, ifile, nfile,                    &
     &  istep, istats, ndof, delta, begin_, stop_, skip_,               &
     &  nsavv_, 'CORD', 'CORD', title, ntitle, qdim4, trash8, .false.)
#elif defined(__DMOL)
       if (associated(stringatoms)) deallocate(stringatoms)
       call dcd_read_frame(ifile, r3, .true., FREEATOMS=stringatoms)
#endif
!
       if ( &
#ifdef __CHARMM
&       satoms &
#else
&      size(stringatoms) &
#endif
&       .eq.k) then
        if ( any(stringatoms(1:k).ne.string_inds(1:k)) )                &
     &   __WRN(whoami,'INVALID STRING ATOM INDICES. BEWARE.')
       else
        __WRN(whoami,'INCORRECT NUMBER OF STRING ATOMS. BEWARE.')
       endif
!
!
!      SUBROUTINE READCV(X,Y,Z,
!     $                  CG,QCG,                         !__CHARMM_ONLY##CHEQ
!     $                  TEMP,NATOM,FREEAT,NFREAT,
!     $                  FIRSTU,NUNIT,IUNIT,NFILE,
!     $                  ISTEP,ISTATS,NDEGF,DELTA,
!     $                  BEGIN,STOP,SKIP,NSAVV,HDR1,HDR2,
!     $                  TITLE,NTITLE,DIM4,FDIM,Q_PLL)
! FREEAT WILL BE READ IF NFREAT IS NOT EQUAL TO NATOM.
! ISTATS IS A FLAG WITH THE FOLLOWING FUNCTIONS:
!CC             ON CALL
!C             1 - OPEN A NEW UNIT FOR READING THE INFORMATION
!C             2 - USE THE UNIT THAT IS ALREADY OPEN ON IUNIT
!C             ON RETURN
!C            -1 - THE REQUESTED INFORMATION HAS BEEN READ
!C             1 - NOT DONE READING, BUT THIS FILE IS FINISHED
!C             2 - NOT DONE READING, AND THIS FILE IS IS NOT DONE.
!C     HDR1 AND HDR2 ARE OPTIONS FOR THE FILE HEADER THAT IS READ.
!C     RECORDS WILL BE USED IF MOD(ISTEP,SKIP)=0 AND BEGIN<=ISTEP<=STOP.
!C     DJS 1/25/81
!C
!C     Authors: S. Swaminathan
!C              David Perahia
!C              Dave States
!C              Robert Bruccoleri
!C
!C    Q_PLL    mfc added bool variable to signal whether
!C             the calling routine is being done in parallel or not.
!C             When calling routine is not parallel, master hangs
!C             trying to send data to slaves that are not receiving.
!C
!
!
       do j=1, nforced
        ind=iatom_f(j);   r_f(j,:,c)=r3(ind,:)
       enddo
!
       if (qdiffrot) then
        do j=1, norient
         ind=iatom_o(j);  r_o(j,:,c)=r3(ind,:)
        enddo
       endif
!
!    repeat a few times to read entire string
       do i=2, nstring
#ifdef __CHARMM
        call readcv(r3(:,1), r3(:,2), r3(:,3),                          &
     &   trash8, qcg,                                                   & !__CHARMM_ONLY##CHEQ
     &   trash4, natom,                                                 &
     &   stringatoms, satoms, ifile, 1, ifile, nfile,                   &
     &   istep, istats, ndof, delta, begin_, stop_, skip_,              &
     &   nsavv_, 'CORD', 'CORD', title, ntitle, qdim4, trash8, .false.)
#elif defined (__DMOL)
        call dcd_read_frame(ifile, r3, .false., FREEATOMS=stringatoms)
#endif
!
        call MPI_SEND(r3,3*natom,rtype,i-1,i-1,                          &
     &                      MPI_COMM_STRNG, ierror)
       enddo ! i
!
      else ! me_string == 0
!
       call MPI_RECV(r3,3*natom,rtype,0,ME_STRNG,                        &
     &                MPI_COMM_STRNG,stat,ierror)
!
       do j=1, nforced
         ind=iatom_f(j);   r_f(j,:,c)=r3(ind,:)
       enddo
!
       if (qdiffrot) then
        do j=1, norient
          ind=iatom_o(j);  r_o(j,:,c)=r3(ind,:)
        enddo
       endif
      endif
!
      call ftsm_save_com(c) ! compute and remove center of mass
!
      if (associated(stringatoms)) deallocate(stringatoms)
      if (associated(string_inds)) deallocate(string_inds)
      if (associated(r3)) deallocate(r3)
!
      end subroutine ftsm_read_dcd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_write_cor(ifile, col)
#ifdef __CHARMM
      __DEP_PSF 
#endif
      __DEP_COORDINATES
      __DEP_SIZE
      __DEP_PARSER
      __DEP_COORIO
      __DEP_NUMBER
!
      __IMPNONE
      character(len=16) :: whoami
#ifdef __CHARMM
      character(len=80) :: title(maxtit)
      int :: ntitle
!     compatibility variables for coordinate reading/writing
      float :: wdum(natom+1)
      int :: icntrl(20)=0, modew
#else
      int :: natom
#endif
      float, pointer :: r3(:,:)
      int, pointer :: stringatoms(:) 
      int :: i, j, k, ind
      int, optional :: col
      int :: c, ifile
!
      data whoami /' FTSM_WRITE_COR>'/
!
#ifdef __CHARMM
      ntitle = 1
      title(1) = '* FINITE TEMPERATURE STRING IMAGE FILE'
#endif
!
      if (.not. ftsm_check(qorient)) return
      if (present(col)) then ; c=col; else; c=center; endif
      if (c.lt.1.or.c.gt.num_sets) then
       __WRN( whoami, 'INVALID COLUMN. ABORT.')
       return
      endif
!
#ifndef __CHARMM
 natom=__NATOM
#endif
!
      allocate(r3(natom,3),stringatoms(natom))
      r3=0d0; stringatoms=0
!
      stringatoms(iatom_f)=1
      if (qdiffrot) stringatoms(iatom_o)=1
!      k=sum(stringatoms)
!
      call ftsm_update_overlap_coor(ione)
      do j=1, nforced
       ind=iatom_f(j);   r3(ind,:)=r_f(j,:,c)
      enddo
!
      if (qdiffrot) then
       do j=1, norient
        ind=iatom_o(j);   r3(ind,:)=r_o(j,:,c)
       enddo
      endif
!
#ifdef __CHARMM
!    call writer
!    formatted coor card files
      modew=2
      wdum=0d0
!
      call cwrite(ifile,title,ntitle,icntrl,                            &
     &              r3(:,1),r3(:,2),r3(:,3),wdum,                       &
     &              res,atype,ibase,                                    &
     &              nres,natom,stringatoms,modew,0,0,.false.)
#elif defined (__DMOL)
      call ch_coor_write(ifile, r3, MASK=stringatoms)
#endif
!
      if (associated(stringatoms)) deallocate(stringatoms)
      if (associated(r3)) deallocate(r3)
!
      end subroutine ftsm_write_cor
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_read_cor(ifile, col)
!
      __DEP_SIZE 
      __DEP_COORDINATES
      __DEP_PARSER 
!
#ifdef __CHARMM
      __DEP_PSF 
      use ctitla 
#endif
      __DEP_NUMBER 
      __DEP_COORIO
!
      __IMPNONE
      character(len=15) :: whoami
      float, pointer :: r3(:,:)
      int, pointer :: stringatoms(:) 
      int :: i, j, k, ind
      int, optional :: col
      int :: c, ifile
!
#ifdef __CHARMM
      character(len=80) :: title(maxtit), cdummy=''
!     compatibility variables for coordinate reading/writing
      float :: xdum(natom+1), ydum(natom+1), zdum(natom+1),            &
     &          wdum(natom+1)
!
      int :: icntrl(20), moder, ntitle=0
      int :: ifree(natom)
#else
      int :: natom
#endif
!
      data whoami /' FTSM_READ_COR>'/
!
      if (.not. ftsm_check(qorient)) return
      if (present(col)) then ; c=col; else; c=center; endif
      if (c.lt.1.or.c.gt.num_sets) then
       __WRN( whoami, 'INVALID COLUMN. ABORT.')
       return
      endif
!
#ifndef __CHARMM
 natom=__NATOM
#endif
!
      allocate(r3(natom,3),stringatoms(natom))
      r3=0d0; stringatoms=0
!
      stringatoms(iatom_f)=1
      if (qdiffrot) stringatoms(iatom_o)=1
!      k=sum(stringatoms)
!    call reader
!    formatted coor card files
#ifdef __CHARMM
      moder=1
      xdum=__NAN; ydum=__NAN; zdum=__NAN; wdum=__NAN
!
      call cread(ifile, title, ntitle, icntrl,                          &
     &        r3(:,1), r3(:,2), r3(:,3),                                & ! pass by reference ?
     &        wdum, natom, moder, stringatoms,                          &
     &        0, res, nres, atype, ibase, 1, ifree,                     &
     &        segid, resid, nictot, nseg, .false., .false.,             &
     &        cdummy, 80, 0, .false.)
!
!
! from coor.io
!      SUBROUTINE CREAD(IUNIT,TITLE,NTITL,ICNTRL,X,Y,Z,WMAIN,NATOM,
!     &  NINPUT,ISLCT,IOFFS,RES,NRES,TYPE,IBASE,
!     &  IFILE,FREEAT,SEGID,RESID,NICTOT,NSEG,LRSID,LFREE,LYN,MXLEN,
!     &  MODEL,OFFICIAL)
!
#elif defined(__DMOL)
      call ch_coor_read(ifile, r3, MASK=stringatoms)
#endif
!
      do j=1, nforced
         ind=iatom_f(j);   r_f(j,:,c)=r3(ind,:)
      enddo
!
      if (qdiffrot) then
        do j=1, norient
          ind=iatom_o(j);  r_o(j,:,c)=r3(ind,:)
        enddo
      endif
!
      call ftsm_save_com(c) ! compute remove center of mass
!
      if (associated(stringatoms)) deallocate(stringatoms)
      if (associated(r3)) deallocate(r3)
!
      end subroutine ftsm_read_cor
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_stat_init(comlyn, comlen)
!
      use ftsm_var
      use ftsm_rex, only: ftsm_rex_read_map
      __DEP_OUTPUT
      __DEP_SIZE
      __DEP_PARSER 
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_MPI 
!cccccccccccccccccccccccccccccccccccccccccccccccccc
      __IMPNONE
!
 __DECLARE_MSGBUF
!
      CHARACTER(LEN=*) :: COMLYN
      int :: COMLEN
!
      character(len=80) :: rex_fname_old
      int :: rex_flen_old, oldiol, error
!
      character(len=8) :: keyword
      character(len=16) :: whoami
      data whoami/' FTSM_STAT_INIT>'/
!
      bool :: qroot, qprint
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qprint=qroot.and.ME_STRNG.eq.0
#ifdef __CHARMM
      if (qprint) then; oldiol=iolev; iolev=0; endif
#endif
!     begin
!     reset iteration counter
!     did the user specify it?
      stat_iteration_counter=__GET_RM_I(comlyn, comlen, 'COUN', -1)
      stat_iteration_counter=max(stat_iteration_counter,0)
      if (stat_iteration_counter.gt.0) then
       if (qprint) then ; write(_MSGBUF,639) whoami, stat_iteration_counter ; __PRINT(_MSGBUF) ; endif
 639  format(A,' SETTING ITERATION COUNTER TO ',I7)
      endif
!
      forces_fname=''
      output_forces=.false.
!
      rmsd0_fname=''
      output_rmsd0=.false.
!
      c_fname=''
      output_curvature=.false.
!
      s_fname=''
      output_arclength=.false.
!
      fe_fname=''
      output_fe=.false.
!
      centers_fname=''
      output_centers=.false.
!
      rex_fname_old=''
      rex_fname=''
      output_rex_log=.false.
      output_rex_map=.false.
!
!ccccccccccccccccc first process the RMSD-related commands
!!!!!!!!!!!!!! RMSD from static structure in comp (zts/fts)
      if (__INDX_RM(comlyn,comlen,'RMSD').gt.0) then ! request for RMSD
       output_rmsd0=.true.
       __GET_RM_A(COMLYN,COMLEN,'RNAM',4,rmsd0_fname,80,rmsd0_flen)
       if (rmsd0_flen.eq.0) then
         __WRN(whoami,'NO RMSD FILE NAME SPECIFIED. WILL WRITE TO STDOUT.')
         rmsd0_funit=__OSTREAM
       else
         if (__INDX_RM(comlyn,comlen,'RAPP').gt.0) then ! APPEND?
           rform='APPEND'
         else
           rform='WRITE'
         endif
       endif
!cccccccccccc print summary
       if (qprint) then
         if (rmsd0_flen.gt.0) then
          write(_MSGBUF,660 ) whoami,rmsd0_fname(1:rmsd0_flen) ; __PRINT(_MSGBUF)
         else
          write(_MSGBUF,661 ) whoami ; __PRINT(_MSGBUF)
         endif
       endif
 660  format(A,' WILL WRITE STRING RMSD TO FILE ',A)
 661  format(A,' WILL WRITE STRING RMSD TO STDOUT.')
!
      endif !! RMSD
!!!!!!!!!!!!!! ARCLENGTH
      if (__INDX_RM(comlyn,comlen,'ARCL').gt.0) then
        output_arclength=.true.
        __GET_RM_A(COMLYN,COMLEN,'ANAM',4,s_fname,80,s_flen)
        if (s_flen.eq.0) then
         __WRN(whoami,'STRING LENGTH FILE NAME NOT SPECIFIED. WILL WRITE TO STDOUT.')
         s_funit=__OSTREAM
        else
         if (__INDX_RM(comlyn,comlen,'AAPP').gt.0) then ! APPEND?
           sform='APPEND'
         else
           sform='WRITE'
         endif
        endif
!ccccccccccc print summary
        if (qprint) then
         if (s_flen.gt.0) then
          write(_MSGBUF,652) whoami,s_fname(1:s_flen) ; __PRINT(_MSGBUF)
         else
          write(_MSGBUF,653) whoami ; __PRINT(_MSGBUF)
         endif
        endif
 652  format(A,' WILL WRITE STRING LENGTH TO FILE ',A)
 653  format(A,' WILL WRITE STRING LENGTH TO STDOUT.')
!
      endif ! ARCLENGTH
!!!!!!!!!!!!!! CURVATURE
      if (__INDX_RM(comlyn,comlen,'CURV').gt.0) then
        output_curvature=.true.
        __GET_RM_A(COMLYN,COMLEN,'CVNM',4,c_fname,80,c_flen)
        if (c_flen.eq.0) then
         __WRN(whoami,'CURVATURE FILE NAME NOT SPECIFIED. WILL WRITE TO STDOUT.')
         c_funit=__OSTREAM
        else
         if (__INDX_RM(comlyn,comlen,'CAPP').gt.0) then ! APPEND?
           cform='APPEND'
         else
           cform='WRITE'
         endif
        endif
!ccccccccccc print summary
        if (qprint) then
         if (c_flen.gt.0) then
          write(_MSGBUF,6521) whoami,c_fname(1:c_flen) ; __PRINT(_MSGBUF)
         else
          write(_MSGBUF,6531) whoami ; __PRINT(_MSGBUF)
         endif
        endif
 6521 format(A,' WILL WRITE CURVATURE TO FILE ',A)
 6531 format(A,' WILL WRITE CURVATURE TO STDOUT.')
!
      endif ! CURVATURE
!!!!!!!!!!!!!! FREE ENERGY
      if (__INDX_RM(comlyn,comlen,'FREE').gt.0) then
        output_fe=.true.
        __GET_RM_A(COMLYN,COMLEN,'FENM',4,fe_fname,80,fe_flen)
        if (fe_flen.eq.0) then
         __WRN(whoami,'NO F.E. FILE NAME SPECIFIED. WILL WRITE TO STDOUT.')
         fe_funit=__OSTREAM
        else
         if (__INDX_RM(comlyn,comlen,'FAPP').gt.0) then ! APPEND?
           feform='APPEND'
         else
           feform='WRITE'
         endif
        endif
!ccccccccccc print summary cccccccccccccccccccccccccccccccccccccc
        if (qprint) then
         if (fe_flen.gt.0) then
          write(_MSGBUF,6520) whoami,fe_fname(1:fe_flen) ; __PRINT(_MSGBUF)
         else
          write(_MSGBUF,6530) whoami ; __PRINT(_MSGBUF)
         endif
        endif
 6520 format(A,' WILL WRITE FREE ENERGY TO FILE ',A)
 6530 format(A,' WILL WRITE FREE ENERGY TO STDOUT.')
!
      endif ! F.E.
!cccccccccc process PATH CENTERS output options ccccccccccccccccccccccc
      if (__INDX_RM(comlyn,comlen,'CENT').gt.0) then
!       get file name
        __GET_RM_A(COMLYN,COMLEN,'CNAM',4,centers_fname,80,centers_flen)
!cccccccccccc print summary
        if (centers_flen.gt.0) then
         output_centers=.true.
         if (qprint) then
          write(_MSGBUF,6620 ) whoami,centers_fname(1:centers_flen) ;__PRINT(_MSGBUF)
         endif
         if (__INDX_RM(comlyn,comlen,'CEAP').gt.0) then ! APPEND?
           cenform='APPEND' ! note: if appending, should not duplicate DCD header !
         else
           cenform='WRITE'
         endif
        else
          __WRN(whoami,'NO FILE NAME GIVEN. WILL NOT WRITE PATH CENTERS.')
        endif
 6620 format(A,' WILL WRITE PATH CENTERS TO FILE ',A,'.')
!
      endif ! centers output
!ccccccccccccc replica exchange map cccccccccccccc
      rex_flen=0
      if (__INDX_RM(comlyn,comlen,'REXM').gt.0) then
!       get file name
        __GET_RM_A(COMLYN,COMLEN,'RXNM',4,rex_fname,80,rex_flen)
!       check if user specified an custom map (e.g. from an older run)
        __GET_RM_A(COMLYN,COMLEN,'RXOL',4,rex_fname_old,80,rex_flen_old)
!
        if (rex_flen.gt.0) then
         output_rex_map=.true.
         if (qprint) then
          write(_MSGBUF,6721) whoami,rex_fname(1:rex_flen) ; __PRINT(_MSGBUF)
         endif
         if (rex_flen_old.gt.0) then
          if (qprint) then
             write(_MSGBUF,6722) whoami,rex_fname_old(1:rex_flen_old) ; __PRINT(_MSGBUF)
             rex_funit=-1
             __OPEN_FILE(rex_funit,rex_fname_old(1:rex_flen_old),'FORMATTED','READ')
          endif
!
          call ftsm_rex_read_map(rex_funit)
!
          if (qprint) __CLOSE_FILE(rex_funit, 'KEEP', error)
         endif
!
        else
          __WRN(whoami,'NO FILE NAME GIVEN. WILL NOT WRITE REPLICA EXCHANGE MAP.')
        endif
 6721 format(A,' WILL WRITE REPLICA EXCHANGE MAP TO FILE ',A,'.MAP')
 6722 format(A,' WILL RESTART FROM REPLICA EXCHANGE MAP IN FILE ',A)
!
      endif ! replica exchange map
!cccccccccccccc replica exchange log cccccccccccccccccccccccccccccccccccccccc
      if (__INDX_RM(comlyn,comlen,'REXL').gt.0) then
!       get file name
        if (rex_flen.eq.0) then ! in the case that name was read above
         __GET_RM_A(COMLYN,COMLEN,'RXNM',4,rex_fname,80,rex_flen)
        endif
!       check for timestep offset
        rextime_offset=__GET_RM_I(comlyn, comlen, 'ROFF', 0);
        if (rextime_offset.gt.0) then
         if (qprint) then ; write(_MSGBUF,6724) whoami, whoami,rextime_offset ; __PRINT(_MSGBUF) ; endif
 6724 format(A,' WILL OFFSET STEP COUNTER IN REPLICA EXCHANGE LOG BY '  &
     &       /,A,' ',I10)
        endif
!
        if (rex_flen.gt.0) then
         output_rex_log=.true.
         if (qprint) then
          write(_MSGBUF,6723) whoami,whoami,rex_fname(1:rex_flen) ; __PRINT(_MSGBUF)
         endif
         if (__INDX_RM(comlyn,comlen,'RXAP').gt.0) then ! APPEND?
           rxlform='APPEND'
         else
           rxlform='WRITE'
         endif ! rxap
        else
          __WRN(whoami,'NO FILE NAME GIVEN. WILL NOT WRITE REPLICA EXCHANGE LOG.')
        endif ! rex_flen.gt.0
 6723 format(A,' WILL WRITE REPLICA EXCHANGE LOG TO FILE ',/,           &
     & A,' ',A,'.DAT')
!
      endif ! replica exchange log
!cccccccccccccccccc process forces output options cccccccccccccccccc
      if (__INDX_RM(comlyn,comlen,'FORC').gt.0) then
!       get nergy file name
        __GET_RM_A(COMLYN,COMLEN,'FCNM',4,forces_fname,80,forces_flen)
!ccccccccccc print summary
        if (forces_flen.gt.0) then
         output_forces=.true.
         if (qprint) then
          write(_MSGBUF,6625) whoami,forces_fname(1:forces_flen) ; __PRINT(_MSGBUF)
         endif
         if (__INDX_RM(comlyn,comlen,'FCAP').gt.0) then ! APPEND?
           fform='APPEND'
         else
           fform='WRITE'
         endif
        else
         __WRN(whoami,'NO FILE NAME GIVEN. WILL NOT WRITE AVERAGE FORCE.')
        endif
 6625 format(A,' WILL WRITE AVERAGE FORCE TO FILE ',A,'.')
      endif ! forces
!
#ifdef __CHARMM
      if (qprint) iolev=oldiol
#endif
!
!      if we got this far, we are probably OK
      stat_initialized=.true.
!
      end subroutine ftsm_stat_init
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_stat()
      use ftsm_rex, only: ftsm_rex_print_map,  ftsm_rex_print_log
      __DEP_OUTPUT
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_PARSER
      __DEP_MPI
      __DEP_NUMBER
!
      __IMPNONE
      int :: i, fmt_len
!
#ifdef __CHARMM
      int :: oldiol
#endif
!
      character(len=80) :: fmt_real, fmt_int, fmt
      float :: r_com(3)
      float :: u (3,3)= RESHAPE( (/1,0,0,0,1,0,0,0,1/), (/3,3/) ) ! rotation matrix
      float :: rmsd0, rmsd0_all(nstring), fc_all(2,nstring)
!
      int :: error
      character(len=11) :: whoami
      data whoami/' FTSM_STAT>'/
!
      bool :: qroot, qprint, qgrp
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qprint=qroot.and.ME_STRNG.eq.0
      qgrp=MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1
!
#ifdef __CHARMM
!     ad hoc fix for REX :
!     when string ranks are permuted, it might happen that a new root is silent
      if (qprint) then ; oldiol=iolev; iolev=0; endif
#endif
!ccccccccccccccccccccccc begin ccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! check if the user has made an initialization call
      if (.not.ftsm_initialized) call ftsm_init()
      if (.not.stat_initialized) then
       __WRN(whoami,'NO OUTPUT OPTIONS SELECTED. NOTHING DONE')
       return
      endif
!
      stat_iteration_counter=stat_iteration_counter+1
      if (qroot) then
!     define number format strings for output
       write(fmt_int,'(I5)') stat_iteration_counter
       write(fmt_real,*) nstring
       fmt_len=len(fmt_real)
       __TRIMA(fmt_real,fmt_len)
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_rmsd0) then
!    compute rmsd
       if (qorient) then
        if (qdiffrot) call ftsm_update_overlap_coor(ione) ! just in case, make sure orientation coordiantes are up-to-date
        call RMSBestFit( r_o(:,:,ref), r_o(:,:,center),                 &
     &                                orientWeights, u )  ! superpose ref onto center
       endif
       rmsd0=rmsd( r_f(:,:,ref), matmul ( r_f(:,:,center), u ),         & ! rotate center using transpose of u
     &  forcedWeights ) ! note: I am assuming that COMs have been removed, which should be true
!
          if (qroot) call mpi_gather(rmsd0,1,MPI_DOUBLE_PRECISION       & ! heads communicate
     &                ,rmsd0_all,1,MPI_DOUBLE_PRECISION,0,              &
     &                 MPI_COMM_STRNG, error)
          if (qprint) then ! root writes
           if (rmsd0_funit.eq.__OSTREAM) then
            fmt='("RMSD0> '//fmt_int(1:5)//' ",'                        &
     &                //fmt_real(1:fmt_len)//real_format//')'
           else
            rmsd0_funit=-1
            __OPEN_FILE(rmsd0_funit, rmsd0_fname,'FORMATTED',rform)
            fmt='("'//fmt_int(1:5)//' ",'                               &
     &                //fmt_real(1:fmt_len)//real_format//')'
           endif
           write(rmsd0_funit,fmt) (rmsd0_all(i),i=1,nstring)
!
           if (rmsd0_funit.ne.__OSTREAM) then
            __CLOSE_FILE(rmsd0_funit, 'KEEP', error)
           endif
          endif ! qprint
          rform='APPEND'
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_arclength) then
       if (qprint) then
        if (repa_initialized) then ! proceed only if arclength defined
!
         if (s_funit.eq.__OSTREAM) then
          fmt='("ARCL> '//fmt_int(1:5)//' ",'                           &
     &                //fmt_real(1:fmt_len)//real_format//')'
         else
          s_funit=-1
          __OPEN_FILE(s_funit, s_fname,'FORMATTED',sform)
          fmt='("'//fmt_int(1:5)//' ",'//fmt_real(1:fmt_len)            &
     &                                 //real_format//')'
         endif
!
         write(s_funit, fmt) ds * sqrt(3d0) ! correction factor for consistency with atomic RMSD
!     flush unit: close and reopen later
         if (s_funit.ne.__OSTREAM) then
          __CLOSE_FILE(s_funit, 'KEEP', error)
         endif
        else ! repa
          __WRN(whoami,'NO REPARAMETRIZATION OPTIONS SELECTED. SKIPPING ARCLENGTH.')
        endif
       endif ! qprint
       sform='APPEND'
      endif ! output_arclength
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_curvature) then
       if (qprint) then
        if (repa_initialized) then ! proceed only if arclength defined
!
         if (c_funit.eq.__OSTREAM) then
          fmt='("CURV> '//fmt_int(1:5)//' ",'                           &
     &                //fmt_real(1:fmt_len)//real_format//')'
         else
          c_funit=-1
          __OPEN_FILE(c_funit, c_fname,'FORMATTED',cform)
          fmt='("'//fmt_int(1:5)//' ",'//fmt_real(1:fmt_len)            &
     &                                 //real_format//')'
         endif
!
         write(s_funit, fmt) curv / sqrt(3d0) ! correction factor for consistency with atomic RMSD
!     flush unit: close and reopen later
         if (c_funit.ne.__OSTREAM) then
          __CLOSE_FILE(c_funit, 'KEEP', error)
         endif
        else
          __WRN(whoami,'NO REPARAMETRIZATION OPTIONS SELECTED. SKIPPING CURVATURE.')
        endif
       endif
       cform='APPEND'
      endif ! output_curvature
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_fe) then
!    compute free energy
       call ftsm_compute_fe_fd()
       if (qprint) then
         if (fe_funit.eq.__OSTREAM) then
          fmt='("FE> '//fmt_int(1:5)//' ",'                             &
     &                //fmt_real(1:fmt_len)//real_format//')'
         else
          fe_funit=-1
          __OPEN_FILE(fe_funit, fe_fname,'FORMATTED',feform)
          fmt='("'//fmt_int(1:5)//' ",'//fmt_real(1:fmt_len)            &
     &                                 //real_format//')'
         endif
!
!    print
         write(fe_funit, fmt) fe
!     flush unit: close and reopen later
         if (fe_funit.ne.__OSTREAM) then
          __CLOSE_FILE(fe_funit, 'KEEP', error)
         endif
       endif ! qprint
       feform='APPEND'
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_rex_map) then ! output replica exchange map
       if (rex_flen.eq.0) then
        __WRN(whoami,'NO FILE NAME SPECIFIED. WILL NOT WRITE REPLICA EXCHANGE MAP.')
       else
        if (qprint) then
         rex_funit=-1
         rex_fname(rex_flen+1:rex_flen+4)='.map' ! append to name
         __OPEN_FILE(rex_funit,rex_fname(1:rex_flen+4), 'FORMATTED','WRITE')
         rex_fname(rex_flen+1:)='' ! erase extension
         call ftsm_rex_print_map(rex_funit) ! all processes enter
!
         __CLOSE_FILE(rex_funit, 'KEEP', error)
        endif ! qprint
       endif
      endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_rex_log) then
       if (rex_flen.eq.0) then
         __WRN(whoami,'NO FILE NAME SPECIFIED. WILL NOT WRITE REPLICA EXCHANGE LOG.')
       else
        if (qprint) then
         rex_funit=-1
         rex_fname(rex_flen+1:rex_flen+4)='.dat' ! append to name
         __OPEN_FILE(rex_funit,rex_fname(1:rex_flen+4),'FORMATTED', rxlform)
         rex_fname(rex_flen+1:)='' ! erase extension
        endif
        rxlform='APPEND'
!
        call ftsm_rex_print_log(rex_funit)
!    flush unit:
        if (qprint) __CLOSE_FILE(rex_funit,'KEEP',error)
       endif
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_centers) then
        if (qprint) then
         centers_funit=-1
         __OPEN_FILE(centers_funit, centers_fname,'UNFORMATTED', cenform)
        endif
!    write current centers as a trajectory frame (adopted from write_dcd)
!--------------------------------------------------------------------
! header will be written only if IBEG=1, so be careful, or will have a corrupt file
! however, if header missing, can cat file to another trajectory file w header (e.g. "cat path1.dcd path2.dcd > path1-2.dcd" )
! VO 10.2012 : "cheat" by looking at whether the append option is set
        if (cenform.eq.'APPEND') then ; i=(stat_iteration_counter-1) * nstring + 1 ; else ; i=1 ; endif
        call ftsm_write_dcd(IFILE=centers_funit,                        &
     &       IBEG=i,                                                    &
!     &       IBEG=(stat_iteration_counter-1) * nstring + 1,             &
!     &       IEND=2**31-1) ! largest 4-byte int     
     &       IEND= ione*(-1 + 2**30 + 2**30)) ! possible i4 => i8 cast
!    NOTE: should write the correct number of records to header at the end of calculation
!--------------------------------------------------------------------
!    flush unit:
        if (qprint) __CLOSE_FILE(centers_funit, 'KEEP', error)
        cenform='APPEND'
      endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (output_forces) then ! NOTE: these are the forces acting on the projection variables
!    gather on root processor
       if (qroot) then
        call mpi_gather(avforce,2,MPI_DOUBLE_PRECISION,                 & ! heads communicate
     &                 fc_all,2,MPI_DOUBLE_PRECISION,0,                 &
     &                 MPI_COMM_STRNG, error)
!
        fmt='('//fmt_real(1:fmt_len)//real_format//')'
        if (qprint) then
         if (forces_funit.eq.__OSTREAM) then
          write(forces_funit,'("FORCES> ",I8)') stat_iteration_counter ! % is a MATLAB comment
         else
          forces_funit=-1
          __OPEN_FILE(forces_funit, forces_fname,'FORMATTED',fform)
          write(forces_funit,'("% ",I8)') stat_iteration_counter ! % is a MATLAB comment
         endif
!
!    print
         write(forces_funit, fmt) fc_all(1,:) ! parallel forces
         write(forces_funit, fmt) fc_all(2,:) ! perpendicular forces
!
!     flush unit: close and reopen later
         if (forces_funit.ne.__OSTREAM)                                      &
     &     __CLOSE_FILE(forces_funit, 'KEEP', error)
        endif ! qprint
        fform='APPEND'
       endif ! qroot
!
      endif ! output_force
!
#ifdef __CHARMM
!     ad hoc fix for REX
      if (qprint) iolev=oldiol
#endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!    reset force averages -- relevant for f.e.
      num_force_samples=0
!
      end subroutine ftsm_stat
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function ftsm_check(qorie) result (ok)
      __DEP_PARSER
      __IMPNONE
      character(len=12) :: whoami
      int :: error
      bool :: ok, qorie
!
 __DECLARE_MSGBUF
!
      data whoami /' FTSM_CHECK>'/
!
      error=0
!
      if (.not.ftsm_initialized) then
       __WRN(whoami,'FTSM NOT INITIALIZED. ABORT.')
       error=1
!
      elseif ( qorie.and.                                               &
     & ( norient.eq.0 .or. .not. associated(r_o)                        &
     &      .or. .not. associated(iatom_o))) then
       __WRN(whoami,'NO ORIENTATION ATOMS FOUND. ABORT.')
       error=2
      elseif (nforced.eq.0 .or. .not. associated(r_f)                   &
     &      .or. .not. associated(iatom_f)) then
       __WRN(whoami,'NO FORCING ATOMS FOUND. ABORT.')
       error=3
      endif
!
      ok=error.eq.0
!
      end function ftsm_check
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! VO 1/2013 modifying function call to include string minimization option
      subroutine ftsm_main(x,y,z,fx,fy,fz,iteration           &
#ifdef __CHARMM
     &                    , wmain, nbond_data, image_data     & ! to be passed on to ftsm_mini
#endif
     &                    )
!
      __DEP_PARSER 
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_MPI 
      __DEP_OUTPUT
      __DEP_NUMBER
      __CHARMM_ONLY use chm_types, only : nonbondDataStructure, imageDataStructure
!
      __IMPNONE
!
      __DECLARE_MSGBUF
!
      float :: x(:), y(:), z(:),                                       &
     &          fx(:), fy(:), fz(:)
      int :: iteration ! MD iteration
!
#ifdef __CHARMM
! CHARMM - dependent energy evaluation routines/vars
      float :: wmain(:)
      type(nonbondDataStructure) :: nbond_data
      type(imageDataStructure)   :: image_data
#endif
!     locals
      float :: s
      character(len=11) :: whoami
      bool :: qgrp
      int :: i, bug, qfac
!
      data whoami /' FTSM_MAIN>'/
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      qgrp=(MPI_COMM_LOCAL.ne.MPI_COMM_NULL)                            &
     & .and.(SIZE_LOCAL.gt.1)
!
      if (restrained_on) then ! impose restraints
        if (restrained_eq_steps.gt.0) then
         s=1.0d0*(iteration-restrained_eq0)/restrained_eq_steps ; s=min(max(s,zero),one); ! limit s to range [0,1]
        else
         s=1d0
        endif ! restrained equilibration is on
!aa
! write(600+ME_GLOBAL,*) iteration, restrained_eq0, restrained_eq_steps, s ; ! close(600+ME_GLOBAL)
        call ftsm_calc(x,y,z,.true.,s)             ! compute gradients
        call ftsm_addforce(fx,fy,fz,s.ge.one)      ! add restraint forces to global force arrays
!
      endif ! restrained_on
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!     the following only gets executed if iteration > olditeration;
!     this is because CHARMM executes frequent 'restarts' at the least frequency
!     that is common to all output counters; a restart will require two calls to smcv_master;
!     to avoid duplicating statistics + evolution etc (since the step # is the same!) I keep track
!     of the iteration counter, and proceed only if the iteration counter has increased.
      if (iteration.gt.olditeration) then
       if (evolve_ftsm_on.and.evolve_freq.gt.0) then
!
        if ( mod(iteration,evolve_freq).eq.0 .and.                      &
     &       (iteration-restrained_eq0.gt.evolve_nskip))                &
     &       call ftsm_evolve(x,y,z)
       endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       if (update_on.and.update_freq.gt.0) then
        if (mod(iteration,update_freq).eq.0) then
         if (.not.string_noprint) then 
          write(_MSGBUF,'(2A)') whoami,' UPDATING STRING.' ; __PRINTL(_MSGBUF,3)
         endif
!
         if (proj_on) then
!    save old reference coordinates
          r_f(:,:,left_old:right_old)=r_f(:,:,left:right)
          if (qdiffrot) then
           r_o(:,:,left_old:right_old)=r_o(:,:,left:right)
!    make sure orientation coordinates are current
           call ftsm_update_overlap_coor(ione) ! r_f --> r_o
          endif
! VO 1.2013 : see if image minimization is requested
          if (ftsm_mini_on) then
            if (.not.string_noprint) then 
             write(_MSGBUF,'(2A)') whoami,' MINIMIZING IMAGE ENERGY.' ; __PRINTL(_MSGBUF,3)
            endif
            call ftsm_mini(x, y, z                           &
#ifdef __CHARMM
     &                    ,wmain, nbond_data, image_data     &
#endif
     &                    )
          endif ! ftsm_mini_on
!    see if reparametrization requested
          if (repa_on) then
            if (.not.string_noprint) then 
             write(_MSGBUF,'(2A)') whoami,' REPARAMETRIZING IMAGES.' ; __PRINTL(_MSGBUF,3)
            endif
            call ftsm_repa(.false.) ! reparametrize string, do not broadcast to slaves; removes COM
          else
!    recompute and remove centers of mass (which will change due to repa)
           call ftsm_save_com()
          endif ! repa_on
!    update reference coordinates
          if (.not.string_noprint) then 
           write(_MSGBUF,'(2A)') whoami,' UPDATING NEIGHBOR IMAGES.' ; __PRINTL(_MSGBUF,3)
          endif
          call ftsm_swap_bc(.true.) ! VO changed from false to true 1/2013 (why was it false? problem only in parallel)
!------------------------------------------------------------------------
         else ! not proj_on
!    save old reference coordinates and switch to new reference coordinates
          if (.not.string_noprint) then 
           write(_MSGBUF,'(2A)') whoami,' UPDATING REFERENCE IMAGES.' ; __PRINTL(_MSGBUF,3)
          endif
          r_f(:,:,center_old)=r_f(:,:,center)
          r_f(:,:,center)=r_f(:,:,center_new)
          if (qdiffrot) then
           r_o(:,:,center_old)=r_o(:,:,center)
           r_o(:,:,center)=r_o(:,:,center_new)
!    make sure orientation coordinates are current
           call ftsm_update_overlap_coor(ione) ! r_f --> r_o
          endif
!
! VO 1.2013 : see if image minimization is requested
          if (ftsm_mini_on) then
            if (.not.string_noprint) then 
             write(_MSGBUF,'(2A)') whoami,' MINIMIZING IMAGE ENERGY.' ; __PRINTL(_MSGBUF,3)
            endif
            call ftsm_mini(x, y, z                           &
#ifdef __CHARMM
     &                    ,wmain, nbond_data, image_data     &
#endif
     &                    )
          endif ! ftsm_mini_on
!    see if reparametrization requested
          if (repa_on) then
            if (.not.string_noprint) then 
             write(_MSGBUF,'(2A)') whoami,' REPARAMETRIZING IMAGES.' ; __PRINTL(_MSGBUF,3)
            endif
            call ftsm_repa(.true.) ! reparametrize string and broadcast to slaves
!    recompute centers of mass (which will change due to repa or regular evolution)
!          call ftsm_save_com() ! moved to repa routine
          else
           call ftsm_save_com()
          endif ! repa_on
!    reset arrays for updating reference structure
          r_f(:,:,center_new)=r_f(:,:,center)
          if (qdiffrot) r_o(:,:,center_new)=r_o(:,:,center)
!
         endif
         restrained_eq0=iteration
        endif ! update_on
       endif ! update_on
!
       if (repl_x_on.and.repl_x_freq.gt.0) then
        if (mod(iteration, repl_x_freq).eq.0) then
         if (.not.string_noprint) then 
          write(_MSGBUF,'(2A)') whoami,' ATTEMPTING EXCHANGE OF NEIGHBORING REPLICAS.' ; __PRINTL(_MSGBUF,3)
         endif
         call ftsm_repl_exchange(x, y, z, iteration)
        endif
       endif
!
       if (stat_on.and.stat_freq.gt.0) then
         if (mod(iteration,stat_freq).eq.0) then
           write(_MSGBUF,'(2A)') whoami,' CALLING STRING STATISTICS.' ; __PRINTL(_MSGBUF,3)
           call ftsm_stat() ! output statistics
         endif
       endif ! stat_on
      endif ! iteration > olditeration
!     update internal iteration counter
      olditeration=iteration
!
      end subroutine ftsm_main
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_calc(x,y,z,deriv,t)
!
      __DEP_NUMBER 
      __DEP_MULTICOM       __CHARMM_ONLY !##MULTICOM
      __DEP_MPI 
!
      __IMPNONE
!
      float :: x(:), y(:), z(:)
      bool :: deriv, qgrp, qcombine
      float, optional :: t
      float :: s, oms ! this value indicates how much of the old reference set to take
!
      int :: ind, i, j, k, obeg, oend, p, q, ierror
!
      float :: u (3,3), u1(3,3), u2(3,3), u3(3,3)
      float, pointer :: r_com(:)
      float :: rho, rho1, rho2, r1(3), r2(3), r3(3), d, d1, d2, d3,    &
     &                                                d4, d5, d6, w
      float :: omdpar
      float :: a11, a12, a13, a21, a22, a23, a31, a32, a33
      float :: b11, b12, b13, b21, b22, b23, b31, b32, b33
      float, dimension(:,:,:,:), pointer :: ugrad, ugrad1, ugrad2
      float, pointer, dimension(:,:) :: roi,rol,ror,roc,rol_rot,ror_rot&
     &   ,rol_old,roc_old,ror_old,rol_cur,roc_cur,ror_cur
      float, pointer, dimension(:,:) :: rfi,rfl,rfr,rfc,rfl_rot,rfr_rot&
     &   ,rfl_old,rfc_old,rfr_old,rfl_cur,rfc_cur,rfr_cur
      float, pointer, dimension(:,:) :: fopar, foprp, ffpar, ffprp
      float, pointer, dimension(:,:) :: rfpar, rfprp
      float, pointer :: M(:,:)
!
      int4mpi, allocatable :: orient_count(:), orient_displ(:) ! if declared as int*8 parallelization will break
!
      float :: tol
!
      float, pointer :: ow(:), fw(:)
!
      interface
       subroutine hypercube_allgatherv(message,count,displ,type,        &
     &                                comm, ierror, rank, size)
      __CHARMM_ONLY __DEP_KINDS
       float :: message(*)
       int :: ierror
       int4mpi :: comm, rank, size, type, count(size), displ(size)
       end subroutine hypercube_allgatherv
      end interface
!
      tol=__ERRTOL
!
      if (present(t)) then ; s=min(max(t,zero),one); else ; s=1d0 ; endif
!
      qcombine=s.lt.1d0
!
      qgrp=( SIZE_LOCAL.gt.1.and.MPI_COMM_LOCAL.ne.MPI_COMM_NULL        &
     &       .and.calc_bestfit_grad_para)
! shorthand
      ow=>orientWeights
      r_com=>rcom(:,instant)
      roi=>r_o(:,:,instant);
      rol=>r_o(:,:,left); ror=>r_o(:,:,right); roc=>r_o(:,:,center);
      rol_rot=>r_o(:,:,left_rot); ror_rot=>r_o(:,:,right_rot)
      fopar=>r_o(:,:,fpar);  foprp=>r_o(:,:,fperp) ! parallel forces
!--------------------------------------------------------------------------------------
      fw=>forcedWeights
      rfi=>r_f(:,:,instant);
      rfl=>r_f(:,:,left); rfr=>r_f(:,:,right); rfc=>r_f(:,:,center);
      rfl_rot=>r_f(:,:,left_rot);  rfr_rot=>r_f(:,:,right_rot)
      ffpar=>r_f(:,:,fpar);  ffprp=>r_f(:,:,fperp) ! forces
      rfpar=>r_f(:,:,vpar);  rfprp=>r_f(:,:,vperp) ! displacement vectors
!
!      load coordinates
      do k=1,nforced
       ind=iatom_f(k)
       rfi(k,1)=x(ind)
       rfi(k,2)=y(ind)
       rfi(k,3)=z(ind)
      enddo
!
      if (qorient) then
       if (qdiffrot) then
        do k=1,norient ! when qorient false, norient zero
         ind=iatom_o(k)
         roi(k,1)=x(ind)
         roi(k,2)=y(ind)
         roi(k,3)=z(ind)
        enddo
       endif ! qdiffrot (otherwise rfi and roi point to the same thing)
!
!       translate forced atoms to centroid
       r_com(:)=0d0;
       do j=1,3 ; do k=1, norient;
          r_com(j) = r_com(j)+ow(k)*roi(k,j)
       enddo ;    enddo
!
       rfi(:,1)=rfi(:,1)-r_com(1)
       rfi(:,2)=rfi(:,2)-r_com(2)
       rfi(:,3)=rfi(:,3)-r_com(3)
!
       if (qdiffrot) then ! also use orientation atoms (otherwise, they are the same -- see above!)
         roi(:,1)=roi(:,1)-r_com(1)
         roi(:,2)=roi(:,2)-r_com(2)
         roi(:,3)=roi(:,3)-r_com(3)
       endif ! qdiffrot
!
      else
       u = RESHAPE( (/1,0,0,0,1,0,0,0,1/), (/3,3/) ) ! rotation matrix
       u1= u
       u2= u
       u3= u
      endif ! qorient
!
      if (qcombine) then ! use a combination of old and new reference structures for mild restart
       oms=1d0-s
!
       rfl_old=>r_f(:,:,left_old); rfr_old=>r_f(:,:,right_old);
       rfc_old=>r_f(:,:,center_old);
       rfl_cur=>r_f(:,:,left_cur); rfr_cur=>r_f(:,:,right_cur);
       rfc_cur=>r_f(:,:,center_cur);
!
       rol_old=>r_o(:,:,left_old); ror_old=>r_o(:,:,right_old);
       roc_old=>r_o(:,:,center_old);
       rol_cur=>r_o(:,:,left_cur); ror_cur=>r_o(:,:,right_cur);
       roc_cur=>r_o(:,:,center_cur);
!
       if (proj_on) then
        if (qorient) then
         call RMSBestFit(rol,roi,ow,u)
         call RMSBestFit(rol_old,roi,ow,u1)
         call RMSBestFit(ror,roi,ow,u2)
         call RMSBestFit(ror_old,roi,ow,u3)
!    combine rotated structures
!    left
!
         u=u*s; u1=u1*oms;
         u2=u2*s; u3=u3*oms;
         rfl_cur=0d0; rfr_cur=0d0;
         do k=1,3; do j=1,3
           rfl_cur(:,j)=rfl_cur(:,j) + rfl(:,k)     * u(j,k) +          &
     &                                 rfl_old(:,k) * u1(j,k)
           rfr_cur(:,j)=rfr_cur(:,j) + rfr(:,k)     * u2(j,k) +         &
     &                                 rfr_old(:,k) * u3(j,k)
         enddo;    enddo
!
         if (qdiffrot) then
          rol_cur=0d0; ror_cur=0d0
          do k=1,3; do j=1,3
           rol_cur(:,j)=rol_cur(:,j) + rol(:,k)     * u(j,k) +          &
     &                                 rol_old(:,k) * u1(j,k)
           ror_cur(:,j)=ror_cur(:,j) + ror(:,k)     * u2(j,k) +         &
     &                                 ror_old(:,k) * u3(j,k)
          enddo;    enddo
         endif
!
        else ! not qorient
!
         do j=1,3
           rfl_cur(:,j)=s*rfl(:,j)+oms*rfl_old(:,j)
           rfr_cur(:,j)=s*rfr(:,j)+oms*rfr_old(:,j)
         enddo;
!
        endif ! qorient
!    point to combined reference structures
        rfl=>rfl_cur
        rfr=>rfr_cur
        rol=>rol_cur
        ror=>ror_cur
!
       else ! .not. proj
        rfc_cur=0d0;
        if (qorient) then
         call RMSBestFit(roc,roi,ow,u)
         call RMSBestFit(roc_old,roi,ow,u1)
!    combine rotated structures
!    left
!
         u=u*s;  u1=u1*oms;
         do k=1,3; do j=1,3
           rfc_cur(:,j)=rfc_cur(:,j) + rfc(:,k)     * u(j,k) +          &
     &                                 rfc_old(:,k) * u1(j,k)
         enddo;    enddo
!
         if (qdiffrot) then
          roc_cur=0d0;
          do k=1,3; do j=1,3
           roc_cur(:,j)=roc_cur(:,j) + roc(:,k)     * u(j,k) +          &
     &                                 roc_old(:,k) * u1(j,k)
          enddo;    enddo
         endif
!
        else ! not qorient
!
         do j=1,3
           rfc_cur(:,j)=rfc_cur(:,j) + s*rfc(:,j)+oms*rfc_old(:,j)
         enddo;
!
        endif ! qorient
!    point to combined reference structures
        rfc=>rfc_cur
        roc=>roc_cur
!
       endif ! proj_on
      endif ! qcombine
!
!!                write(600+me_global,*) matmul(ow,rol) ! correct (0)
!!                write(600+me_global,*) matmul(ow,roc)
!!                write(600+me_global,*) matmul(ow,ror)
!!                write(600+me_global,*) matmul(ow,roi)
!
      if (qorient) then
!     compute rotation matrices (and gradients, if needed)
!
       if (deriv) then
!%%%%%%%%%%%%%%%%%%% set up indices %%%%%%%%%%%%%%%%%%%
         if (qgrp) then
!
          j=ceiling(1.0d0*norient/SIZE_LOCAL)
!
          allocate(orient_displ(SIZE_LOCAL), orient_count(SIZE_LOCAL))
!
          do i=1,SIZE_LOCAL
           orient_displ(i)=min((i-1)*j,norient-1)
           orient_count(i)=max(0,min(j,norient-j*(i-1)))
          enddo
!
          obeg=orient_displ(ME_LOCAL+1) + 1
          oend=obeg - 1 + orient_count(ME_LOCAL+1)
!
         else ! not qgrp
          obeg=1; oend=norient
         endif ! qgrp
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         if (proj_on) then
          allocate(ugrad (3,3,3,norient),                               &
     &             ugrad1(3,3,3,norient),                               &
     &             ugrad2(3,3,3,norient) )
!
          call RMSBestFit(rol,roi,ow,u, obeg,oend,ugrad)
          call RMSBestFit(ror,roi,ow,u1,obeg,oend,ugrad1)
         elseif (qdiffrot) then ! not proj_on but need derivatives of rotations
          allocate(ugrad (3,3,3,norient))
          call RMSBestFit(roc,roi,ow,u, obeg,oend,ugrad)
         else ! no need to calculatte gradients
          call RMSBestFit(roc,roi,ow,u)
         endif ! proj_on
!
       else
         if (proj_on) then
          call RMSBestFit(rol,roi,ow,u)
          call RMSBestFit(ror,roi,ow,u1)
         else  ! not proj_on
          call RMSBestFit(roc,roi,ow,u) ! orientation between center image and current coords
         endif ! proj_on
       endif ! deriv

!     rotate target structures to overlap with current
!     conventional way (might be faster)
       rfl_rot=0d0;
       if (proj_on) then
        rfr_rot=0d0;
        do k=1,3; do j=1,3
           rfl_rot(:,j)=rfl_rot(:,j)+rfl(:,k)*u(j,k)
           rfr_rot(:,j)=rfr_rot(:,j)+rfr(:,k)*u1(j,k)
        enddo;    enddo
       else
        do k=1,3; do j=1,3
           rfl_rot(:,j)=rfl_rot(:,j)+rfc(:,k)*u(j,k)
        enddo;    enddo
       endif
!
      else ! not qorient
       if (proj_on) then
        rfl_rot=>rfl; rfr_rot=>rfr ! no rotation
       else
        rfl_rot=>rfc
       endif
      endif ! qorient
!
      if (proj_on) then
!     compute projection (delta)
       rho=0d0
       rho1=0d0
       rho2=0d0
!
       if (deriv) then
!
        r1=0d0;
        do k=1,3 ; do j=1,nforced
                     d = rfi(j,k)    -rfl_rot(j,k)
                     d1= rfr_rot(j,k)-rfl_rot(j,k)
!
                     rfpar(j,k) = d    ! displacement to first reference
                     rfprp(j,k) = d-d1 ! displacement to second reference
!
                     rho1=rho1 + d1*d1 *fw(j) ! denominator in dpar
                     d1 = d1 * fw(j)
                     rho =rho  + d *d1        ! numerator
!
!     COM contribution to gradient for orientation atoms:
                     r1(k)=r1(k)+d1 ! will only be used if (qdiffrot)
!     derivative components from the forcing atoms:
                     ffpar(j,k)=d1 !
        enddo ;    enddo
        if (rho1.le.tol) then ; rho1=1d0 ; else ; rho1=1d0/rho1 ; endif ! a rather unlikely event
        dpar=rho*rho1 ! length projection along line connecting left and right structures
        rho=sqrt(rho1)! for normalization of perpendicular derivatives
        omdpar=1d0-dpar
        d5=dpar*omdpar
! the next loop is required for the perpendicular component
        r2=0d0;
        do k=1,3 ; do j=1,nforced
                     d1 = dpar * rfprp(j,k) + omdpar * rfpar(j,k)
                     rfprp(j,k)=d1            ! true perpendicular component
                     rho2=rho2 + d1*d1 *fw(j) ! squared length of perpendicular vector
!
                     d1=d1 * fw(j)
!     COM contribution to gradient for orientation atoms:
                     r2(k)=r2(k) + d1
!     derivative components from the forcing atoms:
                     ffprp(j,k)=d1
        enddo ;    enddo
!
        d6=d5+rho1*rho2  ! rho1*rho2 is then normalized perp. component squared
        dperp=sqrt(rho2) ! unnormalized perp component
        if (dperp.le.tol) then; rho2=1d0; else; rho2=1d0/dperp; endif ! a rather unlikely event
        dperp=dperp*rho ! normalize perp component
!
        if (qorient) then ! this part nonzero only if orientation is on
!
         w=omdpar-dpar ! (1-2d)
         if (qdiffrot) then
!
          do k=obeg, oend
!    COM contribution to gradients on orientation atoms
            fopar(k,:)=-r1*ow(k) ! parallel
            foprp(k,:)=-r2*ow(k) ! perpendicular
!    in this loop we also compute the gradients of [transpose(A) B ]
            do j=1,3
!    multiplications `by hand'
             M=>ugrad(:,:,j,k)
             a11=M(1,1); a21=M(2,1); a31=M(3,1);
             a12=M(1,2); a22=M(2,2); a32=M(3,2);
             a13=M(1,3); a23=M(2,3); a33=M(3,3);
             M=>ugrad1(:,:,j,k)
             b11=M(1,1); b21=M(2,1); b31=M(3,1);
             b12=M(1,2); b22=M(2,2); b32=M(3,2);
             b13=M(1,3); b23=M(2,3); b33=M(3,3);
             M=>ugrad2(:,:,j,k)
!
             M(1,1)=a11*u1(1,1) + a21*u1(2,1) + a31*u1(3,1) +           &
     &              u(1,1)*b11 + u(2,1)*b21 + u(3,1)*b31
             M(2,1)=a12*u1(1,1) + a22*u1(2,1) + a32*u1(3,1) +           &
     &              u(1,2)*b11 + u(2,2)*b21 + u(3,2)*b31
             M(3,1)=a13*u1(1,1) + a23*u1(2,1) + a33*u1(3,1) +           &
     &              u(1,3)*b11 + u(2,3)*b21 + u(3,3)*b31
!
             M(1,2)=a11*u1(1,2) + a21*u1(2,2) + a31*u1(3,2) +           &
     &              u(1,1)*b12 + u(2,1)*b22 + u(3,1)*b32
             M(2,2)=a12*u1(1,2) + a22*u1(2,2) + a32*u1(3,2) +           &
     &              u(1,2)*b12 + u(2,2)*b22 + u(3,2)*b32
             M(3,2)=a13*u1(1,2) + a23*u1(2,2) + a33*u1(3,2) +           &
     &              u(1,3)*b12 + u(2,3)*b22 + u(3,3)*b32
!
             M(1,3)=a11*u1(1,3) + a21*u1(2,3) + a31*u1(3,3) +           &
     &              u(1,1)*b13 + u(2,1)*b23 + u(3,1)*b33
             M(2,3)=a12*u1(1,3) + a22*u1(2,3) + a32*u1(3,3) +           &
     &              u(1,2)*b13 + u(2,2)*b23 + u(3,2)*b33
             M(3,3)=a13*u1(1,3) + a23*u1(2,3) + a33*u1(3,3) +           &
     &              u(1,3)*b13 + u(2,3)*b23 + u(3,3)*b33
! aa: this is what we are doing above:
!            ugrad2(:,:,j,k)=matmul(transpose(ugrad(:,:,j,k)),u1)+
!     &                      matmul(transpose(u),ugrad1(:,:,j,k))
           enddo ! j
          enddo ! k
!    contribution from quadratics (3 terms)
          do j=1, nforced
           r1=fw(j)*rfi(j,:)
           r2=fw(j)*rfl(j,:)
!           r3=d5*r2
           r3=d6*r2 ! for normalized distance
           r2=w*r2
!
           do k=obeg, oend
!
            do p=1,3
             do q=1,3
!
              d =r1(p)
              d1=rfl(j,q)
              d2=rfr(j,q)
              d3=r2(p)*d2
              d4=r3(p)*d2
! not sure how to compute this more efficiently
              fopar(k,:)=fopar(k,:) +                                   &
     &          d  * ( ugrad1(p,q,:,k) * d2 - ugrad(p,q,:,k) * d1 ) -   &
     &          d3 * ( ugrad2(p,q,:,k) )
!
              foprp(k,:)=foprp(k,:) -                                   &
     &          d  * (   dpar * ugrad1(p,q,:,k) * d2 +                  &
     &                 omdpar * ugrad (p,q,:,k) * d1 ) +                &
     &          d4 * ( ugrad2(p,q,:,k) )
!
             enddo ! q
            enddo ! p
           enddo ! k (orientation atoms)
          enddo ! j (forcing atoms)
!
!    scale orientation atoms derivatives
          fopar=rho1*fopar
          foprp=rho*rho2*foprp
!
         else ! not qdiffrot
! NOTE: in this case, the forces on the f and o atoms are stored in the same location, so that below we are adding to the f forces
          do k=obeg, oend
!    compute the gradients of [transpose(A) B ]
           do j=1,3
!    multiplications `by hand'
             M=>ugrad(:,:,j,k)
             a11=M(1,1); a21=M(2,1); a31=M(3,1);
             a12=M(1,2); a22=M(2,2); a32=M(3,2);
             a13=M(1,3); a23=M(2,3); a33=M(3,3);
             M=>ugrad1(:,:,j,k)
             b11=M(1,1); b21=M(2,1); b31=M(3,1);
             b12=M(1,2); b22=M(2,2); b32=M(3,2);
             b13=M(1,3); b23=M(2,3); b33=M(3,3);
             M=>ugrad2(:,:,j,k)
!
             M(1,1)=a11*u1(1,1) + a21*u1(2,1) + a31*u1(3,1) +           &
     &              u(1,1)*b11 + u(2,1)*b21 + u(3,1)*b31
             M(2,1)=a12*u1(1,1) + a22*u1(2,1) + a32*u1(3,1) +           &
     &              u(1,2)*b11 + u(2,2)*b21 + u(3,2)*b31
             M(3,1)=a13*u1(1,1) + a23*u1(2,1) + a33*u1(3,1) +           &
     &              u(1,3)*b11 + u(2,3)*b21 + u(3,3)*b31
!
             M(1,2)=a11*u1(1,2) + a21*u1(2,2) + a31*u1(3,2) +           &
     &              u(1,1)*b12 + u(2,1)*b22 + u(3,1)*b32
             M(2,2)=a12*u1(1,2) + a22*u1(2,2) + a32*u1(3,2) +           &
     &              u(1,2)*b12 + u(2,2)*b22 + u(3,2)*b32
             M(3,2)=a13*u1(1,2) + a23*u1(2,2) + a33*u1(3,2) +           &
     &              u(1,3)*b12 + u(2,3)*b22 + u(3,3)*b32
!
             M(1,3)=a11*u1(1,3) + a21*u1(2,3) + a31*u1(3,3) +           &
     &              u(1,1)*b13 + u(2,1)*b23 + u(3,1)*b33
             M(2,3)=a12*u1(1,3) + a22*u1(2,3) + a32*u1(3,3) +           &
     &              u(1,2)*b13 + u(2,2)*b23 + u(3,2)*b33
             M(3,3)=a13*u1(1,3) + a23*u1(2,3) + a33*u1(3,3) +           &
     &              u(1,3)*b13 + u(2,3)*b23 + u(3,3)*b33
! aa: this is what we are doing above:
!            ugrad2(:,:,j,k)=matmul(transpose(ugrad(:,:,j,k)),u1)+
!     &                      matmul(transpose(u),ugrad1(:,:,j,k))
           enddo ! j
          enddo ! k
!    contribution from quadratics
!   aa
!           write(0,*) 'U: ', u
!           write(0,*) 'U1: ', u1
!
          do j=1, nforced
           r2=fw(j)*rfl(j,:)
!           r3=d5*r2
           r3=d6*r2
           r2=w*r2
!
           do k=obeg, oend
!
            do p=1,3
             do q=1,3
              d3=r2(p)*rfr(j,q)
              d4=r3(p)*rfr(j,q)
              fopar(k,:)=fopar(k,:) - d3 * ugrad2(p,q,:,k) ! parallel
              foprp(k,:)=foprp(k,:) + d4 * ugrad2(p,q,:,k) ! perpendicular
             enddo ! q
            enddo ! p
           enddo ! k (orientation atoms)
          enddo ! j (forcing atoms)
!
         endif ! qdiffrot
!
!    NOTE: when diffrot false, fopar and ffpar point to the same thing; gather below should still work fine
         if (qgrp) then ! gather orientation forces
          if (mod(SIZE_LOCAL,2).eq.0) then ! use hypercube allgather
           call hypercube_allgatherv(                                   &
     &         fopar, orient_count, orient_displ, MPI_RTMD_TYPE,        &
     &         MPI_COMM_LOCAL, ierror, ME_LOCAL, SIZE_LOCAL )
           call hypercube_allgatherv(                                   &
     &         foprp, orient_count, orient_displ, MPI_RTMD_TYPE,        &
     &         MPI_COMM_LOCAL, ierror, ME_LOCAL, SIZE_LOCAL )
          else ! regular gather
           call MPI_GATHERV(fopar(obeg,1),                              &
     &         orient_count(ME_LOCAL+1),MPI_RTMD_TYPE,                  &
     &         fopar, orient_count, orient_displ, MPI_RTMD_TYPE,        &
     &         0, MPI_COMM_LOCAL, ierror)
           call MPI_GATHERV(foprp(obeg,1),                              &
     &         orient_count(ME_LOCAL+1),MPI_RTMD_TYPE,                  &
     &         foprp, orient_count, orient_displ, MPI_RTMD_TYPE,        &
     &         0, MPI_COMM_LOCAL, ierror)
! send to slaves
           __BROADCAST_LOCAL_8B(r_o(1,1,fpar),6*norient) ! perp follows par in memory, so send both by doubling data count
          endif ! powers of two
         endif
!
!    free memory
         deallocate(ugrad, ugrad1, ugrad2)
         if (qgrp) deallocate(orient_count, orient_displ)
!
        endif ! qorient
!    scale forcing atoms derivatives
        ffpar=rho1*ffpar
        ffprp=rho*rho2*ffprp
!----------------------------------------------------------------------------------------------
       else ! derivative calculation not requested
         do k=1,3 ; do j=1,nforced
                    d = rfi(j,k)    -rfl_rot(j,k)
                    d1= rfr_rot(j,k)-rfl_rot(j,k)
!
                    rfpar(j,k) = d    ! displacement to first reference
                    rfprp(j,k) = d-d1 ! displacement to second reference
!
                    rho =rho  + d *d1 *fw(j) ! numerator
                    rho1=rho1 + d1*d1 *fw(j) ! denominator
         enddo ;    enddo
         if (rho1.le.tol) then ; rho1=1d0 ; else ; rho1=1d0/rho1 ; endif ! a very unlikely event
         dpar=rho*rho1 ! length projection along line connecting left and right structures
         omdpar=1d0-dpar
! the next loop is required for the perpendicular component
         do k=1,3 ; do j=1,nforced
                     d1 = dpar * rfprp(j,k) + omdpar * rfpar(j,k) !
                     rfprp(j,k)=d1                           ! true perpendicular component
                     rho2=rho2 + d1*d1 *fw(j)                ! length of perpendicular vector
         enddo ;    enddo
!
        dperp=sqrt(rho2*rho1) ! normalized perpendicular length
!
       endif ! deriv
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      else ! not proj_on
!    NOTE: will put forces into parallel force array; fperp is unused
!    compute the RMSD
        drms=rmsd(rfi, rfl_rot, fw)
!
        if (deriv) then
!    to scale derivatives by 1/drms
         if (drms.gt.tol) then
           rho=1d0/drms
         else
           rho=1d0 ! avoid singularity at near zero separation
         endif
!
         if (qdiffrot.and.qorient) then
!     compute COM contribution to gradient for orientation atoms:
!     and add forces on forcing atoms
          r1(:)=0d0;
          do k=1, nforced
           ffpar(k,:) = rho * fw(k) * (rfi(k,:)-rfl_rot(k,:))
           r1(:)      = r1(:) + ffpar(k,:)
          enddo
          do j=obeg, oend
           fopar(j,:)=-r1(:)*ow(j)
          enddo
!
          do j=1, nforced
           r2=fw(j)*rfi(j,:)  * rho
           do k=obeg, oend
            do p=1,3
             do q=1,3
              d=r2(p)*rfc(j,q)
!
              fopar(k,:)=fopar(k,:) - ugrad(p,q,:,k) * d
             enddo ! q
            enddo ! p
           enddo ! k (orientation atoms)
          enddo ! j (forcing atoms)
!
          deallocate(ugrad)
!
          if (qgrp) then ! gather orientation forces
           if (mod(SIZE_LOCAL,2).eq.0) then ! use hypercube allgather
           call hypercube_allgatherv(                                   &
     &         fopar, orient_count, orient_displ, MPI_RTMD_TYPE,        &
     &         MPI_COMM_LOCAL, ierror, ME_LOCAL, SIZE_LOCAL )
           else
            call MPI_GATHERV(fopar(obeg,1),                             &
     &         orient_count(ME_LOCAL+1),MPI_RTMD_TYPE,                  &
     &         fopar, orient_count, orient_displ, MPI_RTMD_TYPE,        &
     &         0, MPI_COMM_LOCAL, ierror)
! send to slaves
            __BROADCAST_LOCAL_8B(fopar,3*norient)
           endif
          endif ! qgrp
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         else ! not qdiffrot .or. not qorient
!     apply forces to the forcing atoms
          do j=1,nforced
           ffpar(j,:)=rho * fw(j) * (rfi(j,:)-rfl_rot(j,:))
          enddo
         endif ! qdiffrot.and.qorient
!
         if (qgrp) deallocate(orient_count, orient_displ)
        endif ! deriv
!
      endif ! proj_on
!
      end subroutine ftsm_calc
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_addforce(fx,fy,fz,addforce)

      __IMPNONE
!    note: boundary points require special treatment: x0.25 force constant and x2 dperp0
!    this is because distance between replicas is halved for the endpoints, but still corresponds to 1 (as for the inner pts)
      float :: fx(:), fy(:), fz(:)
      float, pointer, dimension(:,:) :: ffpar, ffprp, fopar, foprp
      float :: pre1, pre2
      float :: fac, fac2, t, omt
      int :: i, ind
      bool :: addforce  ! whether to add forces to running force average
      bool :: qendpoint
!
      qendpoint=(mestring.eq.0.or.mestring.eq.nstring-1)
!
      ffpar=>r_f(:,:,fpar);  ffprp=>r_f(:,:,fperp) ! forcing forces
      fopar=>r_o(:,:,fpar);  foprp=>r_o(:,:,fperp) ! orientation forces
!
      if (addforce) then
       num_force_samples=num_force_samples+1
       omt=1d0/num_force_samples
       t=1d0-omt
      else
       t=1d0; omt=0d0
      endif
! lowering the force constants for endpoints is necessary to get the equivalent fluctuations
! can think of either scaling the force constants, or scaling the distances (and gradients) by 0.5 and keeping the same force constans
! perpendicular component normalized by physical interimage dist. (which is halved for endpoints); so it appears too large, and is halved below
!
! for the internal points, integrating the force through one inter-image distance is equivalent to multiplying
! the force by 0.5 (0.5 is the scaled distance between adjacent inner images)
! for the endpoints, the distance between adjacent images is 1, so take the force (scaled down) and multiply by 1
      if (qendpoint) then ; fac=0.5d0 ; fac2=1d0
                     else ; fac=1.0d0 ; fac2=0.5d0
      endif
!
      if (proj_on) then
! restraint force parallel to string
       pre1 = kpara * fac * fac * ( dpar-dpar0 )                ! scale down the force constant of endpoints (one for d, one for gradients)
       pre2 = kperp * fac * max   ( fac * dperp - dperp0, 0d0 ) ! ignore negative values; dperp0 criterion in inner-replica d-metric
! update force: for inner points, multiply force by 0.5; for boundary use 1d0; the FE is then simply the sum of the forces along the string
       avforce(1) = t * avforce(1) + omt * pre1 * fac2 ! force acting on dpar0 is pre1 (integrate negative to get f.e.)
       avforce(2) = t * avforce(2) + omt * pre2 * fac2 ! force acting on derp0 is pre2 ( NOTE: this is not a true force along the path)
!                                                      ! even if I am treating it here as such; it is an orthogonal `correction'
       if (pre2 .gt. 0d0) then
!
        do i=1, nforced
         ind=iatom_f(i)
         fx(ind) = fx(ind) + pre1 * ffpar(i,1) + pre2 * ffprp(i,1)
         fy(ind) = fy(ind) + pre1 * ffpar(i,2) + pre2 * ffprp(i,2)
         fz(ind) = fz(ind) + pre1 * ffpar(i,3) + pre2 * ffprp(i,3)
        enddo
        if (qorient.and.qdiffrot) then
         do i=1, norient
          ind=iatom_o(i)
          fx(ind) = fx(ind) + pre1 * fopar(i,1) + pre2 * foprp(i,1)
          fy(ind) = fy(ind) + pre1 * fopar(i,2) + pre2 * foprp(i,2)
          fz(ind) = fz(ind) + pre1 * fopar(i,3) + pre2 * foprp(i,3)
         enddo
        endif
       else ! parallel force only
        do i=1, nforced
         ind=iatom_f(i)
         fx(ind) = fx(ind) + pre1 * ffpar(i,1)
         fy(ind) = fy(ind) + pre1 * ffpar(i,2)
         fz(ind) = fz(ind) + pre1 * ffpar(i,3)
        enddo
        if (qorient.and.qdiffrot) then
         do i=1, norient
          ind=iatom_o(i)
          fx(ind) = fx(ind) + pre1 * fopar(i,1)
          fy(ind) = fy(ind) + pre1 * fopar(i,2)
          fz(ind) = fz(ind) + pre1 * fopar(i,3)
         enddo
        endif
       endif
      else ! .not.  proj_on
       pre1 = krms * ( drms-drms0 )
! update force (which will not likely be used)
!
       avforce(1) = t * avforce(1) + omt * pre1 ! force acting on dpar0 is pre1 (integrate negative to get f.e.)
!
       do i=1, nforced
        ind=iatom_f(i)
        fx(ind) = fx(ind) + pre1 * ffpar(i,1)
        fy(ind) = fy(ind) + pre1 * ffpar(i,2)
        fz(ind) = fz(ind) + pre1 * ffpar(i,3)
       enddo
       if (qorient.and.qdiffrot) then
        do i=1, norient
          ind=iatom_o(i)
          fx(ind) = fx(ind) + pre1 * fopar(i,1)
          fy(ind) = fy(ind) + pre1 * fopar(i,2)
          fz(ind) = fz(ind) + pre1 * fopar(i,3)
        enddo
       endif
!
      endif
!
      end subroutine ftsm_addforce
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_evolve(x,y,z)
      __IMPNONE
      float :: x(:), y(:), z(:)
      int :: ind, j, k
      float :: t, omt
      float :: u (3,3)= RESHAPE( (/1,0,0,0,1,0,0,0,1/), (/3,3/) ) ! rotation matrix
      float, pointer :: r_com(:), ow(:), fw(:)
      float, pointer, dimension(:,:) :: roi, roc, rfi, rfc
!
      roi=>r_o(:,:,instant)
      ow=>orientWeights
      rfi=>r_f(:,:,instant)
      r_com=>rcom(:,instant)
      if (proj_on) then
       roc=>r_o(:,:,center)
       rfc=>r_f(:,:,center)
      else
       roc=>r_o(:,:,center_new)
       rfc=>r_f(:,:,center_new)
      endif
!
      if (evolve_aver_on) then
       if (num_evolve_samples.lt.max_evolve_samples.or.                 &
     &     max_evolve_samples.le.0)                                     &
     &                num_evolve_samples=num_evolve_samples+1
       omt=1d0/num_evolve_samples
       t=1d0-omt
      elseif (evolve_expo_on) then
       t=evolve_expo_mem
       omt=1d0-t
      endif
!
      if (.not. restrained_on) then ! load coordinates, unless restraints on, in which case, they are loaded
!
       do k=1,nforced
        ind=iatom_f(k)
        rfi(k,1)=x(ind)
        rfi(k,2)=y(ind)
        rfi(k,3)=z(ind)
       enddo
!
       if (qorient) then
        if (qdiffrot) then
         do k=1,norient
          ind=iatom_o(k)
          roi(k,1)=x(ind)
          roi(k,2)=y(ind)
          roi(k,3)=z(ind)
         enddo
        endif ! qdiffrot (otherwise rfi and roi point to the same thing)
!
!       translate forced atoms to centroid
        r_com(:)=0d0;
        do j=1,3 ; do k=1, norient;
          r_com(j) = r_com(j)+ow(k)*roi(k,j)
        enddo ;    enddo
!
        rfi(:,1)=rfi(:,1)-r_com(1)
        rfi(:,2)=rfi(:,2)-r_com(2)
        rfi(:,3)=rfi(:,3)-r_com(3)
!
        if (qdiffrot) then
         roi(:,1)=roi(:,1)-r_com(1)
         roi(:,2)=roi(:,2)-r_com(2)
         roi(:,3)=roi(:,3)-r_com(3)
        endif ! qdiffrot
!
       endif ! qorient
      endif ! .not. restrained on
!
      if (qorient) then ! orient w.r.t. center image
       call RMSBestFit(roc,roi,ow,u) ! superpose roc onto roi
       rfc = t * rfc + omt * matmul(rfi, u) !          apply transpose (=inverse) of u to rfi
      else
!    evolve image using instantaneous structure
       rfc = t * rfc + omt *rfi
      endif
!    NOTE that if the forcing set overlaps with orientation set, we also need to
!    update some atom coords in the orientation set; this is done elsewhere to save CPU time
!    NOTE also that rfi is not rotated
      end subroutine ftsm_evolve
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_compute_fe_fd()
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __IMPNONE
!
      float :: avforces(2,nstring)
      int :: ierror, i
      character(len=20) :: whoami
      data whoami /' FTSM_COMPUTE_FE_FD>'/
!
      if (proj_on) then
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.                         &
     &                         SIZE_STRNG.gt.1) then

        call MPI_GATHER(avforce, 2, MPI_DOUBLE_PRECISION,               &
     &                 avforces, 2, MPI_DOUBLE_PRECISION,               &
     &                 0, MPI_COMM_STRNG, ierror)
        fe(1)=0d0
        do i=2, nstring
         fe(i)  =fe(i-1) - 0.5d0 * ( avforces(1,i-1) + avforces(1,i) )
         fe(i-1)=fe(i-1) - ( avforces(2,i-1) - avforces(2,1) )
        enddo
        fe(nstring)=fe(nstring) - ( avforces(2,nstring) - avforces(2,1))
       endif ! qroot
      endif ! proj_on
!
!      send free energy to slaves -- no need at present time
!       if (MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.
!     &                         SIZE_LOCAL.gt.1) then
!        call __BROADCAST_LOCAL_8B(fe,nstring)
!       endif
!
      end subroutine ftsm_compute_fe_fd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_save_com(c)
      __DEP_NUMBER
      __IMPNONE
!      float :: r_com(3)
      float :: w
      float, pointer :: ro_com(:)
      int, optional :: c
      int :: col, i
      float, pointer, dimension(:,:) :: ro, rf
!
! compute and save COM of current reference structure
!
      if (qorient) then
!
        if (present(c)) then ; col=c ; else ; col=center ; endif
        if (col.le.num_sets.and.col.gt.0) then
         ro_com=>rcom(:,col)
!
!         r_com=ro_com ! save old COM
         ro_com=zero   ! will recompute COM using new weights
         ro  => r_o(:,:,col)
         rf  => r_f(:,:,col)
!       compute new COM
         do i=1, norient
          w=orientWeights(i)
          ro_com(1)=ro_com(1) + w * ro(i,1)
          ro_com(2)=ro_com(2) + w * ro(i,2)
          ro_com(3)=ro_com(3) + w * ro(i,3)
         enddo
! translate orientation structure to centroid
         ro(:,1)=ro(:,1) - ro_com(1)
         ro(:,2)=ro(:,2) - ro_com(2)
         ro(:,3)=ro(:,3) - ro_com(3)
! translate forcing structure to centroid
         if (qdiffrot) then
          rf(:,1)=rf(:,1) - ro_com(1)
          rf(:,2)=rf(:,2) - ro_com(2)
          rf(:,3)=rf(:,3) - ro_com(3)
         endif
! centroid relative to original coords:
!         ro_com = ro_com + r_com ! this is no longer useful; VO 1/2013
       endif
      endif
!
      end subroutine ftsm_save_com
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_swap_bc(qsendo)
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __DEP_NUMBER
      __IMPNONE
      bool :: qroot, qslave, qsend_o
      bool, optional :: qsendo
      float, pointer, dimension(:,:) :: rlf, rcf, rrf, rlo, rco, rro
      int :: me, ierror
      int4mpi :: stat(MPI_STATUS_SIZE)
!
      qroot=MPI_COMM_STRNG.ne.MPI_COMM_NULL
      qslave=MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1
      if (present(qsendo)) then
        qsend_o=qsendo.and.qorient.and.qdiffrot
      else
        qsend_o=qorient.and.qdiffrot
      endif
!
! note that I can avoid sending the orientation coordinates, since they only evolve through the forced atoms
!
!
      me=mestring+1 ! slaves need me too
!
      if (qroot.and.nstring.gt.1) then
        rcf=>r_f(:,:,center)
        rlf=>r_f(:,:,left)
        rrf=>r_f(:,:,right)
!
        if (qdiffrot) then
         rco=>r_o(:,:,center)
         rlo=>r_o(:,:,left)
         rro=>r_o(:,:,right)
        endif
!     replicas send to the right and receive from the left
        if (me.eq.1) then
         call MPI_SEND(rcf, 3*nforced, MPI_DOUBLE_PRECISION,            &
     &                 me, 0, MPI_COMM_STRNG, ierror)
         if (qsend_o)                                                   &
     &    call MPI_SEND(rco, 3*norient, MPI_DOUBLE_PRECISION,           &
     &                 me, 1, MPI_COMM_STRNG, ierror)
!
        elseif (me.eq.nstring) then
         call MPI_RECV(rlf, 3*nforced, MPI_DOUBLE_PRECISION,            &
     &                 mestring-1, 0, MPI_COMM_STRNG, stat, ierror)
         if (qsend_o)                                                   &
     &    call MPI_RECV(rlo, 3*norient, MPI_DOUBLE_PRECISION,           &
     &                 mestring-1, 1, MPI_COMM_STRNG, stat, ierror)
        else ! inner replicas
         call MPI_SENDRECV(rcf, 3*nforced, MPI_DOUBLE_PRECISION, me, 0, &
     &                     rlf, 3*nforced, MPI_DOUBLE_PRECISION,        &
     &                     mestring-1, 0, MPI_COMM_STRNG, stat,ierror)
         if (qsend_o)                                                   &
     &    call MPI_SENDRECV(rco, 3*norient, MPI_DOUBLE_PRECISION, me, 1,&
     &                      rlo, 3*norient, MPI_DOUBLE_PRECISION,       &
     &                      mestring-1, 1, MPI_COMM_STRNG, stat,ierror)
        endif ! me.eq.1
!    replicas send to the left and receive from the right
        if (me.eq.nstring) then
         call MPI_SEND(rcf, 3*nforced, MPI_DOUBLE_PRECISION,            &
     &                 mestring-1, 0, MPI_COMM_STRNG, ierror)
         if (qsend_o)                                                   &
     &    call MPI_SEND(rco, 3*norient, MPI_DOUBLE_PRECISION,           &
     &                 mestring-1, 1, MPI_COMM_STRNG, ierror)
!
        elseif (me.eq.1) then
         call MPI_RECV(rrf, 3*nforced, MPI_DOUBLE_PRECISION,            &
     &                 me, 0, MPI_COMM_STRNG, stat, ierror)
         if (qsend_o)                                                   &
     &    call MPI_RECV(rro, 3*norient, MPI_DOUBLE_PRECISION,           &
     &                 me, 1, MPI_COMM_STRNG, stat, ierror)
        else ! inner replicas
         call MPI_SENDRECV(rcf, 3*nforced, MPI_DOUBLE_PRECISION,        &
     &                     mestring-1, 0,                               &
     &                     rrf, 3*nforced, MPI_DOUBLE_PRECISION,        &
     &                     me, 0, MPI_COMM_STRNG, stat,ierror)
         if (qsend_o)                                                   &
     &     call MPI_SENDRECV(rco, 3*norient, MPI_DOUBLE_PRECISION,      &
     &                     mestring-1, 1,                               &
     &                     rro, 3*norient, MPI_DOUBLE_PRECISION,        &
     &                     me, 1, MPI_COMM_STRNG, stat,ierror)
        endif ! me.eq.nstring
      endif ! qroot & nstring > 1
!
!    send to slaves
      if (qslave) then
       __BROADCAST_LOCAL_8B(r_f(:,:,left),9*nforced) ! send three sets at once (see ftsm_var)
       if (qsend_o) __BROADCAST_LOCAL_8B(r_o(:,:,left),9*norient)
      endif
!
!     duplicate endpoints for force calculations:
!
      if (me.eq.1) then
       r_f(:,:,left)=r_f(:,:,center)
       if (qdiffrot) then
        r_o(:,:,left)=r_o(:,:,center)
       endif
!
      elseif (me.eq.nstring) then
       r_f(:,:,right)=r_f(:,:,center)
       if (qdiffrot) then
        r_o(:,:,right)=r_o(:,:,center)
       endif
      endif
!
!    update any orientation coordinates that have changes
      if (qdiffrot) call ftsm_update_overlap_coor(ithree)
!
      end subroutine ftsm_swap_bc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_mini(x, y, z &
#ifdef __CHARMM
     &                    , wmain, nbond_data, image_data     &
#endif
     &                    )

      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_OUTPUT
      __DEP_NUMBER
#ifdef __CHARMM
      use chm_types, only : nonbondDataStructure, imageDataStructure
      use datstr, only : DUPLDT_nbond, DUPLDT_image
      use energym, only : eprop, epot
#endif
!
      __IMPNONE
      float :: x(:), y(:), z(:)
      float :: dummy(0)
!
! local variables
      character(len=11) :: whoami
      bool :: qprint
!      bool :: qroot, qslave
!
      float :: u(3,3)= RESHAPE( (/1,0,0,0,1,0,0,0,1/), (/3,3/) ) ! rotation matrix
      float, pointer :: r_com(:), ow(:)
      float, pointer, dimension(:,:) :: roi, roc, rfc, roc_rot, rfc_rot
      float :: w
!
      int :: i, j, k, ierror
!
! temporary coordinate and force arrays
      float :: xt(size(x,1))
      float :: yt(size(x,1))
      float :: zt(size(x,1))
      float :: dxt(size(x,1))
      float :: dyt(size(x,1))
      float :: dzt(size(x,1))
      int :: stringatoms(size(x,1))
      int :: natom, ind, iter, nbath, nfree, ibeg
!    other variables for minimization
      float :: oonbath, oonfree, gradnorm, mini_step, norm_step, energy_new, energy_old, energy_restore
!
 __DECLARE_MSGBUF
!
#ifdef __CHARMM
! CHARMM - dependent energy evaluation routines/vars
      float :: wmain(:), wt(size(x,1))
      type(nonbondDataStructure) :: nbond_data
      type(imageDataStructure)   :: image_data
!
      interface ! to subroutines which compute gradients
!
!*************************************************************
! straight from CHARMM code v. c37a1
 SUBROUTINE ENERGY(X, Y, Z, DX, DY, DZ, BNBND, BIMAG, &
     NDD1, DD1, QSECD, ICALL)
  !-----------------------------------------------------------------------
  !       CALCULATES THE ENERGY AND FORCES FOR A STRUCTURE.
  !     The total energy and individual energy contributions are
  !     returned in the ENERGY.FCM common block.
  !
  !      X,Y,Z         - Coordinates
  !      DX,DY,DZ      - Forces returned
  !      BNBND,BIMAG   - Nonbond and Images data structure bases
  !      NDD1            The dimension of the second derivative matrix.
  !      DD1           - Second derivative arrays
  !      QSECD         - Second derivative flags
  !      ICALL         - ECALLS increment
!
  use chm_types, only : nonbondDataStructure, imageDataStructure
  use chm_kinds
!
  real(chm_real) X(*),Y(*),Z(*)
  real(chm_real) DX(*),DY(*),DZ(*)
!
  type(nonbondDataStructure) BNBND
  type(imageDataStructure) BIMAG
!
  INTEGER NDD1, ICALL
  real(chm_real) DD1(*)
  LOGICAL QSECD
!
 END SUBROUTINE ENERGY
!***************************************************************
      SUBROUTINE UPDECI(ISTEP,X,Y,Z,WMAIN, &
                        LDYNAM,XOLD,YOLD,ZOLD,VX,VY,VZ)
!-----------------------------------------------------------------------
! By Stefan Fischer.
!
! Makes the decision whether to update the various non-bond lists.
!
! UPDECI() is controled through INBFRQ (in CONTRL.FCM)
!  and ISTEP as follows :
!
! If INBFRQ = +n --> non-bond list is performed when MOD(ISTEP,n) == 0
!                    Image and H-bond lists are updated according to
!                    IMGFRQ and IHBFRQ.
! If INBFRQ =  0 --> non-bond list update is not performed. Image and
!                    H-bond lists are updated according to IMGFRQ
!                    and IHBFRQ.
! If INBFRQ = -n --> non-bond list is updated when necessary (heuristic
!                    test) if n=-1. If n < -1, then update-testing is done
!                    every n steps (not recommended !). Heuristic will
!                    be used for Image and H-bond list-updates, but only
!                    if IMGFRQ and IHBFRQ are also = -1 .
!
! Passed variables
      use chm_kinds
!
      INTEGER ISTEP
      real(chm_real) X(*),Y(*),Z(*),WMAIN(*)
      INTEGER LDYNAM
      real(chm_real) XOLD(*),YOLD(*),ZOLD(*),VX(*),VY(*),VZ(*)
!
      END SUBROUTINE UPDECI
!***************************************************************
!
      end interface
#endif
!
      data whoami/' FTSM_MINI>'/
!
! check if the user has made an initialization call to the minimizer
!
      if (.not.ftsm_mini_initialized) then
       __WRN( whoami,'NO MINIMIZATION OPTIONS SELECTED. NOTHING DONE.')
       return
      endif
!
!      qroot =MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.SIZE_STRNG.gt.1
!      qslave=MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1
      qprint=MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0
!
#ifdef __CHARMM
! initialize nbond data structure on first use
      if (.not.ftsm_nbond_image_data_initialized) then
       call DUPLDT_nbond(ftsm_nbond_copy, nbond_data)
       call DUPLDT_image(ftsm_image_copy, image_data)
       ftsm_nbond_image_data_initialized=.true.
      endif
#endif
!
      if (qprint) then
       write(_MSGBUF,691) whoami ; __PRINTL(_MSGBUF,5)
      endif
 691  format(/A,' PERFORMING STRING MINIMIZATION.')
!
!    create coordinate arrays
!
      ow=>orientWeights
      r_com=>rcom(:,instant)
      roi=>r_o(:,:,instant)
      roc=>r_o(:,:,center)
      rfc=>r_f(:,:,center)
      roc_rot=>r_o(:,:,center_rot)
      rfc_rot=>r_f(:,:,center_rot)
      natom=size(x,1)
! write(0,*) 'natom:', natom
! use instantaneous coordinates to fill missing coords
      do i=1, natom ;  xt(i)=x(i) ;  yt(i)=y(i) ;  zt(i)=z(i) ; enddo
      stringatoms=0;
! copy string coordinates to corresponding instantaneous coordinates
! first, align string coordinates with the instantaneous coordinates, if needed
!
      if (.not. restrained_on) then ! load coordinates, unless restraints on, in which case, they are loaded
!
       if (qorient) then
        do k=1,norient
          ind=iatom_o(k)
          roi(k,1)=x(ind)
          roi(k,2)=y(ind)
          roi(k,3)=z(ind)
        enddo
!
!       translate forced atoms to centroid
!
        r_com(:)=0d0;
        do j=1,3 ; do k=1, norient;
          r_com(j) = r_com(j)+ow(k)*roi(k,j)
        enddo ;    enddo
!
        roi(:,1)=roi(:,1)-r_com(1)
        roi(:,2)=roi(:,2)-r_com(2)
        roi(:,3)=roi(:,3)-r_com(3)
!
       endif ! qorient
      endif ! .not. restrained on
!
      if (qorient) then ! orient center image w.r.t. instantaneous coordinates
       call RMSBestFit(roi,roc,ow,u) ! superpose roi onto roc (assuming string is COM-free)
!
       rfc_rot = matmul(rfc, u) !          apply transpose (=inverse) of u to rfc
       rfc_rot(:,1)=rfc_rot(:,1)+r_com(1)
       rfc_rot(:,2)=rfc_rot(:,2)+r_com(2)
       rfc_rot(:,3)=rfc_rot(:,3)+r_com(3)
!
       if (qdiffrot) then
        roc_rot = matmul(roc, u) !          apply transpose (=inverse) of u to roc
!     move to COM of the instantaneous coordinates
        roc_rot(:,1)=roc_rot(:,1)+r_com(1)
        roc_rot(:,2)=roc_rot(:,2)+r_com(2)
        roc_rot(:,3)=roc_rot(:,3)+r_com(3)
!     insert orientation coordinates into all-atom coordinate array
        do k=1,norient
         ind=iatom_o(k)
         xt(ind)=roc_rot(k,1)
         yt(ind)=roc_rot(k,2)
         zt(ind)=roc_rot(k,3)
         stringatoms(ind)=-1 ! these coordinates are fixed through all minimization (unless they are also forced atoms)
        enddo
       endif ! qdiffrot
      else ! no orientation
       rfc_rot=>rfc
      endif ! qorient
!
!     insert forced coordinates into all-atom coordinate array
!
      do k=1,nforced
       ind=iatom_f(k)
       xt(ind)=rfc_rot(k,1)
       yt(ind)=rfc_rot(k,2)
       zt(ind)=rfc_rot(k,3)
       stringatoms(ind)=1 ! these coordinates will be minimized (but at the end)
      enddo
!
! perform minimization with string coordinates fixed
!
      __CHARMM_ONLY wt=wmain
!
      mini_step=ftsm_mini_step ! initial minimization step
!
      nbath=ithree*count(stringatoms.eq.0) ;  if (nbath.gt.0) oonbath=one/nbath ; 
      nfree=ithree*count(stringatoms.ne.-1) ; if (nfree.gt.0) oonfree=one/nfree ; 
!
      if (nbath.eq.0) then ; ibeg = ftsm_mini_bath_iterations+1 ; else ; ibeg=1 ; endif ! skip bath iterations is there are no bath atoms
!
__CHARMM_ONLY   energy_restore=eprop(epot)  ! save current energy value, since CHARMM uses it to determine stability
!
      do iter=ibeg, ftsm_mini_bath_iterations+ftsm_mini_forced_iterations
#ifdef __CHARMM
       call UPDECI(iter, xt, yt, zt, wt, 0, dummy, dummy, dummy, dummy, dummy, dummy) ! following calling format in SD
       call ENERGY(xt, yt, zt, dxt, dyt, dzt, ftsm_nbond_copy, ftsm_image_copy, 0, dummy, .false., ione)
       energy_new=eprop(epot)
#endif
! SD hardwired for now:
!    adaptive minimization strategy  (a la CHARMM)
!
       if (energy_new .lt. energy_old .and. iter .gt. ibeg) then 
        mini_step=mini_step*1.5d0 ! accelerate
       else
        mini_step=mini_step*half  ! decelerate
       endif
       energy_old=energy_new
!
! note that the evolution is not parallel
       if (iter.le.ftsm_mini_bath_iterations) then
! first, minimize the instantaneous atoms with the string atoms fixed
        where(stringatoms.ne.0) ! zero out gradients corresponding to string atoms
         dxt=zero ; dyt=zero; dzt=zero
        endwhere
        gradnorm  = sqrt ( ( dot_product(dxt,dxt)+dot_product(dyt,dyt)+dot_product(dzt,dzt) ) * oonbath)
!
       else ! now minimize all coordinates except the string orientation coordinates
        where(stringatoms.eq.-1) ! gradients on orientation atoms zero-ed
         dxt=zero ; dyt=zero; dzt=zero
        endwhere
        gradnorm  = sqrt ( ( dot_product(dxt,dxt)+dot_product(dyt,dyt)+dot_product(dzt,dzt) ) * oonfree)
       endif
!
       norm_step = mini_step/max(gradnorm,__ERRTOL) ! using __ERRTOL might lead to oscillations
       xt = xt - norm_step * dxt
       yt = yt - norm_step * dyt
       zt = zt - norm_step * dzt
!
!write(0,*) 'step: ', iter, mini_step, norm_step, oonfree, oonbath
!
      enddo ! iterations
!
!     put minimized string coordinates back into r_f array
      do k=1,nforced
        ind=iatom_f(k)
        rfc_rot(k,1)=xt(ind)
        rfc_rot(k,2)=yt(ind)
        rfc_rot(k,3)=zt(ind)
      enddo
!
      if (qorient) then
        u=transpose(u)
        rfc = matmul(rfc_rot, u) ! rotate back for consistency
        if (qdiffrot) call ftsm_update_overlap_coor(ione) ! update orientation coordinates
      endif
!
      call ftsm_save_com() !   remove COM from center coordinates
!
__CHARMM_ONLY      eprop(epot)=energy_restore  ! restore current energy value
!
      end subroutine ftsm_mini
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_lift(x, y, z)
!
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_OUTPUT
      __DEP_NUMBER
!
      __IMPNONE
      float :: x(:), y(:), z(:)
!
! local variables
      character(len=11) :: whoami
!
      float :: u(3,3)= RESHAPE( (/1,0,0,0,1,0,0,0,1/), (/3,3/) ) ! rotation matrix
      float, pointer :: r_com(:), ow(:)
      float, pointer, dimension(:,:) :: roi, roc, rfc, roc_rot, rfc_rot
      float :: w
!
      int :: i, j, k, ierror
!
      int :: natom, ind, iter
!
 __DECLARE_MSGBUF
!
      data whoami/' FTSM_LIFT>'/
!
! check if the user has made an initialization call to the minimizer
!
      if (.not.ftsm_check(qorient)) return
!
!    create coordinate arrays
!
      ow=>orientWeights
      r_com=>rcom(:,instant)
      roi=>r_o(:,:,instant)
      roc=>r_o(:,:,center)
      rfc=>r_f(:,:,center)
      roc_rot=>r_o(:,:,center_rot)
      rfc_rot=>r_f(:,:,center_rot)
      natom=size(x,1)
! copy string coordinates to corresponding instantaneous coordinates
! first, align string coordinates with the instantaneous coordinates, if needed
!
      if (qorient) then
        do k=1,norient
          ind=iatom_o(k)
          roi(k,1)=x(ind)
          roi(k,2)=y(ind)
          roi(k,3)=z(ind)
        enddo
!
!       translate forced atoms to centroid
!
        r_com(:)=0d0;
        do j=1,3 ; do k=1, norient;
          r_com(j) = r_com(j)+ow(k)*roi(k,j)
        enddo ;    enddo
!
        roi(:,1)=roi(:,1)-r_com(1)
        roi(:,2)=roi(:,2)-r_com(2)
        roi(:,3)=roi(:,3)-r_com(3)
!
      endif ! qorient
!
      if (qorient) then ! orient center image w.r.t. instantaneous coordinates
       call RMSBestFit(roi,roc,ow,u) ! superpose roi onto roc (assuming string is COM-free)
!
       rfc_rot = matmul(rfc, u) !          apply transpose (=inverse) of u to rfc
       rfc_rot(:,1)=rfc_rot(:,1)+r_com(1)
       rfc_rot(:,2)=rfc_rot(:,2)+r_com(2)
       rfc_rot(:,3)=rfc_rot(:,3)+r_com(3)
!
       if (qdiffrot) then
!     move to COM of the instantaneous coordinates
        roc_rot = matmul(roc, u) !          apply transpose (=inverse) of u to roc
        roc_rot(:,1)=roc_rot(:,1)+r_com(1)
        roc_rot(:,2)=roc_rot(:,2)+r_com(2)
        roc_rot(:,3)=roc_rot(:,3)+r_com(3)
!     insert orientation coordinates into all-atom coordinate array
        do k=1,norient
         ind=iatom_o(k)
         x(ind)=roc_rot(k,1)
         y(ind)=roc_rot(k,2)
         z(ind)=roc_rot(k,3)
        enddo
       endif ! qdiffrot
      else ! no orientation
       rfc_rot=>rfc
      endif ! qorient
!
!     insert forced coordinates into all-atom coordinate array
!
      do k=1,nforced
        ind=iatom_f(k)
        x(ind)=rfc_rot(k,1)
        y(ind)=rfc_rot(k,2)
        z(ind)=rfc_rot(k,3)
      enddo
!
      end subroutine ftsm_lift
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_repa(qbcast)
      __DEP_PARSER 
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_MPI 
      __DEP_OUTPUT
      __DEP_NUMBER
!
      __IMPNONE
! local variables
      character(len=11) :: whoami
      bool :: qroot, qslave, qprint
      bool, optional :: qbcast
      float :: u(3,3)= RESHAPE( (/1,0,0,0,1,0,0,0,1/), (/3,3/) ) ! rotation matrix
      float, pointer :: r_o_com(:) ! COM vector
      float, pointer, dimension(:,:) :: ro, rf, ro1, rf1
      float :: w
      float :: weights(nforced,3) ! assuming nforced is reasonably defined
      int4mpi :: RTYPE=MPI_DOUBLE_PRECISION
      int4mpi :: stat(MPI_STATUS_SIZE)
      int :: i, ierror
!
 __DECLARE_MSGBUF
!
      interface
        subroutine interp_driver_sci(rin,rout,wgt,n,                    &
     &   interp_method,tol,max_iterations,d_arclength, curvature,       &
     &   dst_cutoff, dr,r_bc_0, r_bc_1)
      __CHARMM_ONLY __DEP_KINDS
      __DEP_OUTPUT
        int n
        float rin(n), rout(n), wgt(n)
        int, intent(in) ::  interp_method
        int max_iterations
        float :: tol, d_arclength(:), curvature(:)
        float, optional :: dst_cutoff
        float, optional :: dr(n) ,r_bc_0(n), r_bc_1(n)
        end subroutine interp_driver_sci
!
        subroutine interp_linear_exact(rin,rout,wgt,n,                  &
     &   d_arclength, curvature,                                        &
     &   drout,                                                         &
     &   r_bc_0, r_bc_1)
      __CHARMM_ONLY __DEP_KINDS
        int :: n
        float :: rin(n), rout(n), wgt(n)
        float :: d_arclength(:), curvature(:)
        float, optional :: drout(n) ! optional computation of tangent
        float , optional :: r_bc_0(n), r_bc_1(n)   ! optional fixed bc data
       end subroutine interp_linear_exact
!
      end interface
!
      data whoami/' FTSM_REPA>'/
!
!
      qroot =MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.SIZE_STRNG.gt.1
      qslave=MPI_COMM_LOCAL.ne.MPI_COMM_NULL.and.SIZE_LOCAL.gt.1
      qprint=MPI_COMM_STRNG.ne.MPI_COMM_NULL.and.ME_STRNG.eq.0
!
      if (present(qbcast)) qslave=qslave.and.qbcast ! in case qbcast false do not broadcast to slaves
!
! check if the user has made an initialization call
!
      if (.not.repa_initialized) then
       __WRN( whoami,'NO REPARAMETRIZATION OPTIONS SELECTED. NOTHING DONE.')
       return
      endif
      if (qprint) then
       write(_MSGBUF,690) whoami ; __PRINTL(_MSGBUF,5)
      endif
 690  format(/A,' PERFORMING STRING REPARAMETRIZATION.')
!
! shorthand
      rf => r_f(:,:,center)
      ro  => r_o(:,:,center)
      ro1 => r_o(:,:,dummy)
      r_o_com=>rcom(:,center)
!
      if (qroot) then
!
       if (qorient) then
!       translate structure to centroid
        r_o_com=zero
        do i=1, norient
         w=orientWeights(i)
         r_o_com(1)=r_o_com(1) + w * ro(i,1)
         r_o_com(2)=r_o_com(2) + w * ro(i,2)
         r_o_com(3)=r_o_com(3) + w * ro(i,3)
        enddo
! orientation atoms ! comment out to preserve ro
!        ro(:,1)=ro(:,1)-r_o_com(1)
!        ro(:,2)=ro(:,2)-r_o_com(2)
!        ro(:,3)=ro(:,3)-r_o_com(3)
! forced atoms
        if (qdiffrot) then
         rf(:,1)=rf(:,1)-r_o_com(1)
         rf(:,2)=rf(:,2)-r_o_com(2)
         rf(:,3)=rf(:,3)-r_o_com(3)
        endif
!
!ccccccccccc orientation ccccccc
!      send/receive orientation structure
!      this is a slow procedure, as the orientation is done
!      sequentially
!
        if (mestring.gt.0) then
         call MPI_RECV(ro1,3*norient,rtype,mestring-1, 1,               &
     &        MPI_COMM_STRNG, stat, ierror)
!       orient current structure
         call RMSBestFit(ro,ro1,orientWeights,u)
!       transform current structure to overlap with reference
!       (if orientation is off, u=I)
         ro1(:,1)=ro(:,1)-r_o_com(1)
         ro1(:,2)=ro(:,2)-r_o_com(2)
         ro1(:,3)=ro(:,3)-r_o_com(3)
!
         u=transpose(u)
         ro1=matmul(ro1,u)
         if (qdiffrot) then ; rf=matmul(rf,u)
         else ;               rf=ro1         ; endif
!
        else
         ro1=>ro ! make sure 1st replica sends the center, not dummy coords
        endif ! me
!
        if (mestring.lt.nstring-1) then
         call mpi_send(ro1,3*norient,rtype,mestring+1, 1,               &
     &        MPI_COMM_STRNG, ierror)
        endif ! me
       endif ! qorient
!cccccccccccccc now call the appropriate interpolation subroutine
       weights(:,1)=forcedWeights
       weights(:,2)=forcedWeights
       weights(:,3)=forcedWeights
!
       if (interp_method.eq.linear_exact) then
        call interp_linear_exact(rf,rf,weights,3*nforced,ds,curv)
       else
        call interp_driver_sci(rf,rf,weights,3*nforced,                 &
     &   interp_method,def,iterations,ds,curv,dst_cutoff)
       endif
!
       if (qorient) then
        u=transpose(u)  ! STOPPED HERE
        rf=matmul(rf, u)      ! rotate back
!     restore original COM
        rf(:,1)=rf(:,1)+r_o_com(1)
        rf(:,2)=rf(:,2)+r_o_com(2)
        rf(:,3)=rf(:,3)+r_o_com(3)
!
       endif ! orient
      endif ! root
!
!    broadcast coordinates to slaves
      if (qslave) __BROADCAST_LOCAL_8B(rf,3*nforced)
!    update any orientation coordinates that have changes
      if (qdiffrot) call ftsm_update_overlap_coor(ione)
!
      call ftsm_save_com()
!
      end subroutine ftsm_repa
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_update_overlap_coor(which)
      __IMPNONE
      int :: which
      int :: i
!    copy overlapping coordinates from one set to another
      if (which.eq.1) then
       do i=1, nboth
        r_o(iatom_both(2,i), :, center)=r_f(iatom_both(1,i), :, center)
       enddo
      elseif (which.eq.2) then
       do i=1, nboth
        r_f(iatom_both(1,i), :, center)=r_o(iatom_both(2,i), :, center)
       enddo
      elseif (which.eq.3) then ! special case of left:right sets all being updated
       do i=1, nboth
        r_o(iatom_both(2,i), :, left:right)=                            &
     &  r_f(iatom_both(1,i), :, left:right)
       enddo
      endif
!
      end subroutine ftsm_update_overlap_coor
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ftsm_repl_exchange(x,y,z,itime)
!     attempt to swap restraints that correspond to two adjacent replicas
      use multicom, only: multicom_permute_string_ranks
      use ftsm_rex, only: ftsm_rex_init, rex_initialized, rex_map,      &
     &   rex_log, rex_beta
      use ivector, only: int_vector_add
!
      __DEP_MULTICOM       !__CHARMM_ONLY##MULTICOM
      __DEP_CONST 
      __DEP_NUMBER
      __DEP_RANDOM
      __DEP_MDOUT
      __DEP_PARSER 
      __DEP_MPI 
!
      __IMPNONE
#include "../../mpitype.def"
!
      float :: x(:), y(:), z(:) ! mass(size(x,1))
      int :: itime
!
      int :: i, j, ibeg, iend, ierror, stat(MPI_STATUS_SIZE)
      bool :: deriv, qendpoint, qgrp, qvalid
!
      int :: which   ! replica with which the exchange was attempted
      bool :: success ! whether the exchange attempt was successful
      int :: nodelist(nstring) ! holds new string replica order after excahnge attempt
      int :: itype ! MPI_INTEGER type
      int :: ndata, nfiles
!
      float :: dE_me, dE, s, dpar0i, dperp0i, drms0i, dpar_ori,        &
     &                                 dperp_ori, drms_ori, fac, fac2
!
      character(len=150) :: fnames(5)              ! for storing output file names
      character(len=150) :: new_fnames(5)          ! for storing swapped file names
      bool :: openun(5), qform, qwrite
      int :: oldiol
!
      float, pointer, dimension(:,:,:) :: r_f2, r_o2, r_f3, r_o3
!
      character(len=20) :: whoami
      data whoami /' FTSM_REPL_EXCHANGE>'/
!
      if (.not.rex_initialized) call ftsm_rex_init()
!
      if (.not.ftsm_check(qorient)) return
      if (.not.restrained_on) return      ! restrained dynamics required
!
      qgrp=(MPI_COMM_LOCAL.ne.MPI_COMM_NULL)                            &
     &  .and.(SIZE_LOCAL.gt.1)
!
      deriv=.false. ! do not compute derivatives
      dE=0d0
      success=.false.
!
!     determine exchange partner
      if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) then
       if (ME_STRNG.eq.0) which=INT(__RANDOMU(__SEED)*2d0) ! either 0 or 1
       call MPI_BCAST(which, 1, mpiint, 0, MPI_COMM_STRNG, ierror)     ! string root broadcasts to all replicas
!    determine whether swapping w. left (-1) or w. right (+1) neighbor & calculate rank of neighbor
       which=ME_STRNG + (mod(ME_STRNG + which, 2)*2 - 1)
!      if which == 0, then: -1, 2, 1, 4, 3, ...
!      if which == 1, then:  1, 0, 3, 2, ...
!      communicate:
       qvalid=(which.ge.0).and.(which.lt.SIZE_STRNG)
       if (qvalid) then
!     store reference values in dummy
        r_f(1,1,dummy)=dpar0; r_f(2,1,dummy)=dperp0; r_f(3,1,dummy)=drms0
!     send/receive
!     allocate storage for new restraints
        allocate(r_f2(nforced,3,num_sets))
        ndata=3*(nforced*9+1) ! number of reals to send
        call MPI_SENDRECV(r_f, ndata, MPI_DOUBLE_PRECISION,             &      ! send almost everything
     &   which, which, r_f2, ndata, MPI_DOUBLE_PRECISION,               & ! put into the same array, starting at position 11
     &   which, ME_STRNG, MPI_COMM_STRNG, stat, ierror)
        if (qorient) then
         if (qdiffrot) then ! orientation atoms
!     allocate storage for new restraints
          allocate(r_o2(nforced,3,num_sets))
          ndata=27*norient
          call MPI_SENDRECV(r_o, ndata, MPI_DOUBLE_PRECISION,           &
     &    which, which, r_o2, ndata, MPI_DOUBLE_PRECISION,              &
     &    which, ME_STRNG, MPI_COMM_STRNG, stat, ierror)
         else
          r_o2=>r_f2
         endif ! qdiffrot
        endif ! qorient
! NOTE: in the above communication it is essential to have certain sets adjacent, as indicated by numbering in fts_var; do not break this
!     calculate new string energies
        dpar0i=r_f2(1,1,dummy); dperp0i=r_f2(2,1,dummy);
        drms0i=r_f2(3,1,dummy) ! copy new reference values
!
        dpar_ori=dpar; dperp_ori=dperp; drms_ori=drms; ! save this replica's projection values
!     swap arrays:
        r_f3=>r_f; r_o3=>r_o ! save in case move is rejected
        r_f=>r_f2; r_o=>r_o2 ! point to new array
!    call calculation
!    consider the possibility that equilibration is underway:
        if (restrained_eq_steps.gt.0) then
         s=one*(itime-restrained_eq0)/restrained_eq_steps ; s=min(one,max(zero,s))
        else
         s=one
        endif ! restrained equilibration is on
!
        deriv=.false. ! skip derivative calculation
        call ftsm_calc(x,y,z,deriv,s)
!
!    calculate energies (adopted from _addforce):
!
        if (proj_on) then
! restraint force parallel to string
         qendpoint=(which.eq.0.or.which.eq.nstring-1)
         if (qendpoint) then ; fac=0.5d0 ; fac2=1d0
                        else ; fac=1.0d0 ; fac2=0.5d0
         endif
!    new energy
         dE_me =  kpara * fac * fac * ( dpar-dpar0i )**2                &                ! scale down the force constant of endpoints (one for d, one for gradients)
     &         +  kperp * fac * max   ( fac * dperp - dperp0i, 0d0 )**2 ! ignore negative values; dperp0 criterion in inner-replica d-metric
!    old energy
         qendpoint=(mestring.eq.0.or.mestring.eq.nstring-1)
         if (qendpoint) then ; fac=0.5d0 ; fac2=1d0
                        else ; fac=1.0d0 ; fac2=0.5d0
         endif
         dE_me =  dE_me                                                 &
     &        - kpara * fac * fac * ( dpar_ori-dpar0 )**2               &
     &        - kperp * fac * max   ( fac * dperp_ori - dperp0, 0d0 )**2

        else ! .not.  proj_on
         dE_me = krms * ( ( drms-drms0i )**2 - ( drms_ori-drms0 )**2 )
        endif
!
!    combine energies from two replicas:
        call MPI_SENDRECV(dE_me, 1, MPI_DOUBLE_PRECISION,               &
     &   which, which, dE, 1, MPI_DOUBLE_PRECISION,                     &
     &   which, ME_STRNG, MPI_COMM_STRNG, stat, ierror)
        dE = 0.5d0 * ( dE+dE_me )
!    5) apply Metropolis criterion
        if (dE.le.0d0) then
         success=.true.
        else
!    the higher-rank replica draws random number
!    this may not be correct because the random numbers will not come from the same sequence;
!    may change this later
         if (which.lt.ME_STRNG) then
          success=(__RANDOMU(__SEED).le.exp(-rex_beta*dE))
!     send to othe replica
          call MPI_SEND(success, 1, MPI_LOGICAL, which, which,          &
     &    MPI_COMM_STRNG, ierror)
         else
          call MPI_RECV(success, 1, MPI_LOGICAL, which, ME_STRNG,       &
     &    MPI_COMM_STRNG, stat, ierror)
         endif ! which lt ME_STRNG
        endif ! apply Metropolis
!
       endif ! qvalid ...
!    all root nodes continue (success=false for idle node(s)) :
       if (success) then
        call MPI_ALLGATHER(which, 1, mpiint,                             &
     &       nodelist, 1, mpiint, MPI_COMM_STRNG, ierror)
!
!     make entry in REX log (only lower-rank replica does this)
        if (ME_STRNG.lt.which) then
          j=ME_STRNG ! possible cast i4=>i8 accommodates in8 compilations
          i=int_vector_add(rex_log, j) ! this replica
          i=int_vector_add(rex_log, which)    ! exchanged with this replica
          i=int_vector_add(rex_log, itime + rextime_offset)    ! at this time
        endif ! success
!
!********************************************************************************************
!     swap restart & traj file info; otherwise restart files will correspond to wrong replica
!#ifdef __CHARMM
!        oldiol=iolev
!        iolev=1 ! so that vinqre works
!#endif
!
#ifndef __DMOL
        nfiles=2
!      can add others here
        if (__RESTART_FILE_UNIT.gt.0)                                                &
!    CHARMM VINQUIRE gives problems, did not bother to debug, since that code is obsolete anyway
     &    INQUIRE(UNIT=__RESTART_FILE_UNIT, OPENED=openun(1), NAME=fnames(1))
!     &   CALL VINQRE('UNIT',fnames(1),i,j,
!     &                    OPENUN(1),QFORM,QWRITE,iunwri)
        if (__TRAJ_FILE_UNIT.gt.0)                                                &
     &    INQUIRE(UNIT=__TRAJ_FILE_UNIT, OPENED=openun(2), NAME=fnames(2))
!     &   CALL VINQRE('UNIT',fnames(2),i,j,
!     &                    OPENUN(2),QFORM,QWRITE,iuncrd)
! aa
!         write(600+ME_STRNG,*) iunwri, fnames(1), iuncrd, fnames(2)
!
#else
! DYNAMOL does not store restart fid;
! furthermore, files are not kept open (so that they are complete in the case of a crash)
! all we have to do is exchange the file names
        nfiles=3
        fnames(1)=trajectoryoutname
        fnames(2)=restartoutname
        fnames(3)=statisticsoutname
#endif
!
        i=nfiles*len(fnames(1)) ! length of broadcast buffer
#ifndef __DMOL
        if ( __RESTART_FILE_UNIT .gt. 0 .or. __TRAJ_FILE_UNIT .gt. 0 )&
#endif
         call MPI_SENDRECV(fnames, i, MPI_BYTE,                     &
     &   which, which, new_fnames, i, MPI_BYTE,                     &
     &   which, ME_STRNG, MPI_COMM_STRNG, stat, ierror)
!         write(600+ME_STRNG,*) iunwri, new_fnames(1),
!     &            iuncrd, new_fnames(2)
!         close(600+ME_STRNG)
! assuming that the restart file is formatted (might change this later)
#ifndef __DMOL
        if (__RESTART_FILE_UNIT.gt.0.and.openun(1)) then
         close(__RESTART_FILE_UNIT)
         i=len(new_fnames(1))
         __TRIMA(new_fnames(1), i)
         open(UNIT=__RESTART_FILE_UNIT, FILE=new_fnames(1)(1:i), FORM='FORMATTED',   &
     &    STATUS='OLD', ACCESS='SEQUENTIAL')
        endif
! assuming that dcd file is unformatted
        if (__TRAJ_FILE_UNIT.gt.0.and.openun(2)) then
         close(__TRAJ_FILE_UNIT)
         i=len(new_fnames(2))
         __TRIMA(new_fnames(2), i)
         open(UNIT=__TRAJ_FILE_UNIT, FILE=new_fnames(2)(1:i), FORM='UNFORMATTED', &
!     &    STATUS='OLD', ACCESS='APPEND')
     &    STATUS='OLD', POSITION='APPEND')
        endif
#else
        trajectoryoutname=new_fnames(1)
        restartoutname   =new_fnames(2)
        statisticsoutname=new_fnames(3)
#endif
!#ifdef __CHARMM
!        iolev=oldiol
!#endif
!     done with swap output file info
!********************************************************************************************
!       finish updating reference values
        if (qvalid) then
         dpar0=dpar0i ; dperp0=dperp0i ; drms0=drms0i
         deallocate(r_f3); nullify(r_f2);
         if (qorient) then
          nullify(r_o2);
          if (qdiffrot) then ; deallocate(r_o3);
          else ; nullify(r_o3); endif
         endif
        endif ! qvalid
       else
        call MPI_ALLGATHER(ME_STRNG, 1, mpiint,                          &
     &       nodelist, 1, mpiint, MPI_COMM_STRNG, ierror)
!
!    move rejected, so restore reference values
!
        if (qvalid) then
         dpar=dpar_ori ; dperp=dperp_ori ; drms=drms_ori
         r_f=>r_f3; deallocate(r_f2); nullify(r_f3);
         if (qorient) then
          r_o=>r_o3; nullify(r_o3);
          if (qdiffrot) then ; deallocate(r_o2);
          else ; nullify(r_o2); endif
         endif ! qorient
        endif ! qvalid
       endif ! success
! aa
!        dE=exp(-rex_beta*dE)
!        call MPI_ALLGATHER(dE, 1, MPI_DOUBLE_PRECISION,
!     &   dEG, 1, MPI_DOUBLE_PRECISION, MPI_COMM_STRNG, bug)
!
      endif ! MPI_COMM_STRNG
!    from here on all nodes continue:
!    broadcast success to all slave nodes
      if (qgrp) then
#ifdef __CHARMM
       __BROADCAST_LOCAL_4B(success,1)
       __BROADCAST_LOCAL_4B(nodelist,nstring)       !__CHARMM_ONLY##.not.INTEGER8
       __BROADCAST_LOCAL_8B(nodelist,nstring)       !__CHARMM_ONLY##INTEGER8
#else
       __BROADCAST_LOCAL(success,1,mpibool)
       __BROADCAST_LOCAL(nodelist,nstring,mpiint)
#endif
!    broadcast new cv to slaves
       if (success) then
#ifdef __CHARMM
        __BROADCAST_LOCAL_4B(r_f,27*nforced)       !__CHARMM_ONLY##SINGLE
        __BROADCAST_LOCAL_8B(r_f,27*nforced)       !__CHARMM_ONLY##.not.SINGLE
#else
        __BROADCAST_LOCAL(r_f,27*nforced,mpifloat)
#endif
        if (qorient.and.qdiffrot) then ; 
#ifdef __CHARMM
         __BROADCAST_LOCAL_4B(r_o,27*norient) ;   !__CHARMM_ONLY##SINGLE
         __BROADCAST_LOCAL_8B(r_o,27*norient) ;   !__CHARMM_ONLY##.not.SINGLE
#else
         __BROADCAST_LOCAL(r_o,27*norient,mpifloat) ; 
#endif
        endif
       endif
      endif ! qgrp
!
!        write(600+ME_GLOBAL, *) ME_STRNG
!     if replica order has changed, switch communicator
!        if (ME_GLOBAL.eq.0) write(600,*) nodelist !aa
!        if (ME_GLOBAL.eq.0) write(600,*) dEG !aa
!        if (ME_GLOBAL.eq.0) write(600,*) '***************', cv%rex_beta !aa
!        close(600)
!
! modify replica map (assumes that only adjacent switches are possible)
      j=1
      do while (j.lt.nstring)
        if (nodelist(j).gt.nodelist(j+1)) then ! node numbers start at 0
          i=rex_map(j)
          rex_map(j)=rex_map(j+1)
          rex_map(j+1)=i
          j=j+1
        endif
        j=j+1
      enddo
!
      if (any(nodelist.ne.(/ (i, i=0,nstring-1) /)))                    &
     &  call multicom_permute_string_ranks(nodelist+1) ! special-purpose routine to reorder ranks in order of string replicas
!                                                        added 1 because in multicom node indices start from 1
      if (success) then
       if (MPI_COMM_STRNG.ne.MPI_COMM_NULL) mestring=ME_STRNG
!      broadcast string size to all slave nodes
#ifdef __CHARMM
       __BROADCAST_LOCAL_4B(mestring,1)             !__CHARMM_ONLY##.not.INTEGER8
       __BROADCAST_LOCAL_8B(mestring,1)             !__CHARMM_ONLY##INTEGER8
       call setmsi('MESTRING',mestring)
#else
       __BROADCAST_LOCAL(mestring,1,mpiint)
#endif
      endif
!        write(600+ME_GLOBAL, *) ME_STRNG
!           close(600+ME_GLOBAL)
!
      end subroutine ftsm_repl_exchange
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      end module ftsm
!
__CHARMM_ONLY##ENDIF
