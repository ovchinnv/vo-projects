#define __INITCTX SMCV_INIT
#define __FIRSTCTX SMCV_FIRST
#define __DONECTX SMCV_DONE
!
#define __CBIND use, intrinsic :: iso_c_binding
!
module smcv_namd
 use minimal_system
 __DEP_OUTPUT
 __DEP_CONST
 __CBIND

 __IMPNONE

 private

 bool, save :: initialized=.false.
 int, save :: iteration
 int(__FCINT), save, allocatable, target :: atomlist(:)
 float, save, pointer, dimension(:) :: x, y, z, xc, yc, zc, fx, fy, fz
!
 interface
  subroutine smcv_exec(ctx)
  character(len=*) :: ctx
  end subroutine smcv_exec
 end interface
!
 contains
! a collection of subroutines to call the SMCV code from NAMD GlobalMasterSMCV
! module encapsulation allows storage
!
#define __CSUB(__NAME, ...) subroutine __NAME (__VA_ARGS__) bind(c, name=__STRING(__NAME))
#define __CFUN(__NAME, ...) function __NAME (__VA_ARGS__) bind(c, name=__STRING(__NAME))
!
#define _ME smcv_init_from_namd
 __CFUN(_ME, n, mass, charge, inputname, il, outputname, ol, alist)
 __DEP_VECTORS
 __DEP_PARSER
 __DEP_FILES
 __DEP_MPI
 use cv_common, only : cv
 int(__FCINT) :: _ME
 type(c_ptr), intent(out) :: alist ! send back a list of atom indices
 type (c_ptr), value, intent(in) :: inputname, outputname
 real(__FCFLOAT), intent(in), dimension(n) :: mass, charge
 int( __FCINT), intent(in), value :: n, il, ol
!
 character(len=il), pointer :: ifname
 character(len=ol), pointer :: ofname

 int :: i, fid, ierr
 __IAM(_ME)
 _ME=1
!
 call c_f_pointer(inputname, ifname)
 call c_f_pointer(outputname, ofname)
!
 call output_init(ofname)
!
 if (n<0) then
  __WRN(whoami, 'NUMBER OF ATOMS MUST BE POSITIVE (RECEIVED '//itoa(n)//')')
  return
 else
  call smcv_done_from_namd()
  __MESSAGE(whoami, 'INITIALIZING SMCV PLUGIN WITH '//itoa(n)//' ATOMS');
  allocate(r(n,3), rcomp(n,3), f(n,3), m(n), q(n)) ! note transposed dimensions relative to acemd plugin + dynamol
  x =>r(:,1); y =>r(:,2); z =>r(:,3);
  fx=>f(:,1); fy=>f(:,2); fz=>f(:,3);
  xc =>rcomp(:,1); yc =>rcomp(:,2); zc =>rcomp(:,3);
  minimal_system_natom=n
  m=mass
  q=charge
  r=__NAN
  rcomp=__NAN
! open input file
  fid=-1
  call files_open(fid, ifname, 'FORMATTED', 'READ')
! parse input file
  call parse_file(fid, MPI_COMM_NULL, quiet_=.false.)
  call files_close(fid)
!
! Note : we need to tell NAMD which atom coordinates will be needed; therefore
! we will parse cv definitions here, even though coordinates, masses or charges are
! not available, all that is passed in is the total number of atoms
! the user bears the burden of computing cv values correctly
! to help with this, an additional context smcv_first{} will be provided
!
  __MESSAGE(whoami, 'EXECUTING INITIALIZATION STACK');
  if (noexec(__STRING(__INITCTX))) then
   call warning(whoami, 'CONTEXT "'//__STRING(__INITCTX)//'" DOES NOT CONTAIN EXECUTABLE STATEMENTS.', -1);
  else
   call smcv_exec(__STRING(__INITCTX))
  endif
  if (fatal_warning()) return
  call parser_clear_context(__STRING(__INITCTX))
! compute atomlist
  i=cv%amap%last
  allocate(atomlist(i+1)) ; ! include number of elements as first entry
  atomlist(1)=i ; atomlist(2:)=cv%amap%i(1:i)
  call isort('i', i, atomlist(2), ierr) ! pass second element b/c 1st contains the list size
  alist=c_loc(atomlist)
 endif ! n
!
 iteration=-abs(__NAN)
 initialized=.true.
 _ME=0
!
end function _ME
#undef _ME
!===================================================================
#define _ME smcv_dyna_from_namd
 __CFUN(_ME, iteration_, r_namd, f_namd, e)
 use cv_common, only : cv
 use smcv_master, only : smcv_main
 __DEP_PARSER
!
 int(C_LONG), value, intent(in) :: iteration_
 real(__FCFLOAT), intent(in), dimension(minimal_system_natom, 3) :: r_namd
 real(C_FLOAT), intent(out), dimension(minimal_system_natom, 3) :: f_namd
 real(__FCFLOAT), intent(out) :: e
 int(__FCINT) :: _ME
 int :: i, ierr
!
 __IAM(_ME)
!
 _ME=1 ! default return is failure
!
 e=zero ; ! not computed yet
! load coordinates
 r(atomlist(2:),:)=r_namd(atomlist(2:),:)
 iteration=iteration_
 f(atomlist(2:),:)=zero ! start from zero force
!
 if (.not.initialized) then ! execute first-iteration stack, if present
! complete initialization
  if (.not.noexec(__STRING(__FIRSTCTX))) then
   __MESSAGE(whoami, 'EXECUTING FIRST ITERATION STACK');
   call smcv_exec(__STRING(__FIRSTCTX))
   call parser_clear_context(__STRING(__FIRSTCTX))
  else
   call warning(whoami, 'CONTEXT "'//__STRING(__FIRSTCTX)//'" DOES NOT CONTAIN EXECUTABLE STATEMENTS.', 0);
  endif
  if (fatal_warning()) return
  initialized=.true.
 endif
!
 call smcv_main( x, y, z, xc, yc, zc, m, fx, fy, fz, iteration)
! update namd forces
! note that per CHARMM convention, which the plugin code inherits, forces correspond to grad V, not -grad V !
 f_namd(atomlist(2:),:) = - f(atomlist(2:),:)
! update energy
 _ME=0
!
end function _ME
#undef _ME
!===================================================================
#define _ME smcv_done_from_namd
 __CSUB(_ME)
 use sm_var, only : smcv_initialized
 __DEP_PARSER, only : parser_done, parser_clear_context
!
 call smcv_exec(__STRING(__DONECTX))
 call parser_clear_context(__STRING(__DONECTX))
!
 call parser_done()
 if (smcv_initialized) call smcv_done()
!
 __FREE(r)
 __FREE(rcomp)
 __FREE(m)
 __FREE(q)
 nullify(x,y,z,xc,yc,zc,fx,fy,fz)
!
 __DEALL(atomlist)
 initialized=.false.
end
end module smcv_namd
