#!/bin/bash
# create directory with string method code for charmm 39
# this directory contains "stringm", which has a Makefile to generate .src files and a patching script
# the user will put this directory into the charmm tree, run "make" to generate the .src files
# and run the "patch_xx.sh" script.  After these steps the CHARMM installation proceeds as usual;
# the keyword STRINGM must be added to the parameter line to install.com
#
CHARMM_MAJOR_VERSION=39
CHARMM_MINOR_VERSION=a2
CHARMM_VERSION=${CHARMM_MAJOR_VERSION}${CHARMM_MINOR_VERSION}
PREFLX2CPP=0 ; # indicate whether to replace charmm preflx macros with CPP macros
CHARMM_DISTRIB_DIR="c"$CHARMM_VERSION
CHARMM_SOURCE_DIR=$CHARMM_DISTRIB_DIR"/source"
CHARMM_STRING_DIR=$CHARMM_SOURCE_DIR"/stringm"

OUT="===>";
BREAK="===================================================================================";

CHARMM_DIRS="bestfit lu multicom multidiag confcons parselist string string/ftsm string/sm0k string/smcv vectors"
RM_NONCH_FILES="bestfit/bfit.ftn bestfit/test.ftn bestfit/bestfit_c.ftn"

function get_rules_from_makefile() {
 tgt=$1
 mf=$2
 awk -v tgt="$tgt" \
 ' BEGIN {rules=""; rule_active=0;}
 { if ( index ( $0, tgt ) >0 ) { 
    rules=rules""$0"\n"
    rule_active=1;
   } else if ( (rule_active==1) && ( (substr($0,1,1)=="\t") || (substr($0,1,2)~/["if"|"el"|"en"]/) ) ) {
    rules=rules""$0"\n"
   } else {
    rule_active=0;
   }
 }
 END { print rules;}
 ' < $mf
}

echo $BREAK
echo "$OUT Will prepare string source code package for CHARMM version $CHARMM_VERSION"
echo "$OUT Creating directory \"$CHARMM_STRING_DIR\""
#create string directory
rm -fr $CHARMM_DISTRIB_DIR
mkdir -p $CHARMM_SOURCE_DIR
#create subdirectories and copy files
for d in $CHARMM_DIRS; do
 locald=${d##*/}
 newd=$CHARMM_STRING_DIR/$locald
 echo $BREAK
 echo $OUT Creating directory \"$newd\"
 mkdir -p $newd
# copy files
 for f in `ls $d/*ftn`; do
  newf=${f##*/}
  echo "$OUT Copying $f ===> $newd/$newf"
  cp $f $newd/$newf
 done
# copy def files, if any
 for f in `ls $d/*def* 2> /dev/null`; do
  newf=${f##*/}
  echo "$OUT Copying $f ===> $newd/$newf"
  cp $f $newd/$newf
 done
# copy Makefile
 oldm=$d/Makefile
 newm=$newd/Makefile
 echo -n > $newm
 echo "$OUT Writing $newm"
 echo -n > $newm
 echo "# THIS MAKEFILE IS GENERATED AUTOMATICALLY FROM A MASTER SOURCE CODE TREE" >> $newm
 echo "ROOT=.." >> $newm
 echo "COMMON=\$(ROOT)/scommon" >> $newm
 n1=`grep "OBJ" $oldm -n |head -n1`
 n1=${n1%:*} ;# first line
 n2=`grep "NAME=" $oldm -n |head -n1`
 n2=${n2%:*} ;# second line
 dn=$(($n2-$n1))
 tail -n +$n1 $oldm | head -n $dn >> $newm
 grep "LOCAL[^\+]*=" $oldm >> $newm
 echo "CHARMM_SOURCES=\$(OBJS:%.o=%.src)" >> $newm
 grep "^include.*ROOT*" $oldm >> $newm
 echo "#### RULES:####" >> $newm
  echo "charmm : \$(CHARMM_SOURCES)" >> $newm
# add rules from makefile
 get_rules_from_makefile ".src:" $oldm >> $newm
 get_rules_from_makefile ".tmp:" $oldm >> $newm
 echo "clean ::" >> $newm
 echo "	rm -f \$(CHARMM_SOURCES) *tmp" >> $newm
done
# remove some files that were copied unnecessarily (done automatically above)
# rename string to string_common
stringdir=$CHARMM_STRING_DIR/scommon
rm -rf $stringdir
mv -f $CHARMM_STRING_DIR/string $stringdir
#
for f in $RM_NONCH_FILES; do
 fname=$CHARMM_STRING_DIR/$f
 echo "$OUT Removing unnecessary file "$fname
 rm -f $fname
done
# create $(ROOT)/Makefile.inc
oldm=Makefile.inc
newd=$CHARMM_STRING_DIR
newm=$newd/Makefile.inc
 echo "$OUT Writing $newm"
echo "SHELL=/bin/sh" > $newm
grep "GLOBALMACROS[^\+]*=" $oldm >> $newm
grep "^MSG=" $oldm >> $newm
grep "CHMSG=" $oldm >> $newm
grep "FPP=" $oldm >> $newm
grep "FPPFLAGS[^[A-Za-z]]*=" $oldm >> $newm
echo "CHARMM_MAJOR_VERSION=$CHARMM_MAJOR_VERSION" >> $newm
echo "#### RULES:####" >> $newm
get_rules_from_makefile ".src:" $oldm >> $newm
# copy aux. files to main source directory
files="source.defs charmm.msg mpitype.def prefx2cpp"
echo $OUT" Copying auxiliary files "$files" to "$newd
cp -L $files $newd/
#
# now create root Makefile
newm=$newd/Makefile
 echo "$OUT Writing $newm"
dirs="";
for d in $CHARMM_DIRS; do
 locald=${d##*/}
 dirs=$dirs" "$locald
done
dirs=`echo $dirs | sed -e "s/string/${stringdir##*/}/"` ; # replace string by scommon
echo "SUBDIRS="$dirs > $newm
echo "CHARMM_DIR=." >> $newm
if [ $PREFLX2CPP -gt "0" ]; then
 echo "PREFLX2CPP=./prefx2cpp" >> $newm
else
 echo "PREFLX2CPP=cat" >> $newm
fi
#
get_rules_from_makefile "charmm:" string/Makefile | sed 's/charmm:/charmm::/'>> $newm ;# this rule fits our need
# add additional rules for CHARMM source code
echo "
charmm::
	/bin/sh -c 'for file in \`ls *.src 2>/dev/null\`;\\
	do \\
	flag=\`grep -i \"! automatically protect all code\" \$\$file\`;\\
	if [ -z \"\$\$flag\" ];then \\
	echo \"##IF STRINGM ! automatically protect all code\" > _tmp;\\
	cat \$\$file >>_tmp;\\
	echo \"##ENDIF ! automatically protect all code\" >> _tmp;\\
	\$(PREFLX2CPP) _tmp > \$\$file;\\
	rm -f _tmp __tmp;\\
	fi;\\
	done ;'\\

install : charmm
all : install
" >> $newm

get_rules_from_makefile "clean:" string/Makefile >> $newm
#
# add an INSTALL
#
readme=$newd"/INSTALL"
echo "$OUT Writing file $readme"
echo -n > $readme
date >> $readme
echo $BREAK>> $readme
echo "\
This directory contains the necessary source code to compile the string
method with CHARMM. This distribution targets CHARMM version
c$CHARMM_VERSION, but may work with other versions that are not \`too
different' (e.g. the same major version but different minor version). To
compile, follow the steps below: 

1) Copy the present directory tree into the CHARMM source tree, possibly
replacing the existing \`stringm' directory. (The string documentation
will be placed in doc/stringm.doc, and the test cases, in test/c$CHARMM_VERSION ) 

2) In the stringm directory, type 'make'. This will
generate CHARMM-compatible source code files (*.src extension)

3) Patch the source code by executing the shell script \`patch_${CHARMM_VERSION}'.

CHARMM can now be compiled as usual, including the additional keyword
'STRINGM' passed to the installation script install.com. Make certain
that install.com executes \`setmk.com', which is required to generate
the correct dependencies between source code files (this is typically
the default behavior in CHARMM). Note, also, that the string method uses
a special communication scheme, which needs to be invoked at runtime
using the flag '-stringm' (i.e. mpirun charmm
-stringm <simulation parameters>)"\
\
>> $readme
echo $BREAK>> $readme
