#ifdef __PARALLEL
#define __MAINCOMM PARSER
#//
#define __COMM __CONCAT(MPI_COMM_,__MAINCOMM )
#define __ME   __CONCAT(ME_,__MAINCOMM )
#define __NCPU __CONCAT(SIZE_,__MAINCOMM )
#define _COMMA ,
#else
#define __COMM
#define __ME 0
#define _COMMA
#endif
#define __QPRINT qprint=(__ME.eq.0)
!
!
PROGRAM MUPHEN ! MUlti-PHysics-ENvironment
!
! 2013 Victor Ovchinnikov (ovchinnv_at_georgetown_dot_edu)
!
  __DEP_PARSER
  __DEP_OUTPUT
#ifdef __TIMER
  use timer
#endif
!
#ifdef __PARALLEL
  __DEP_MPI
  __DEP_MULTICOM
  use multicom
#endif
#ifdef __CHES
  use ches
#endif
!
  use files
  use SIZE
  use grid
  use state
!
  __IMPNONE
!======================= variables
  __IAM(MPE Manager)
  int :: i
  int :: numarg
  character(len=80) :: filename, fname
  int :: flen
  int :: fid=-1 
!
#ifdef __TIMER
  int :: mpe_timer
  float :: time(10)
#endif
!

#ifdef __PARALLEL
  bool :: mpiinit
  __DECLARE_MSGBUF

#ifdef __TIMER
  call timer_init()
  mpe_timer=timer_start()
#endif
!
  call mpi_initialized(mpiinit,i)
  if (.not.mpiinit) call mpi_init(i)
!
! initialize multicom; the first communicator is mpi_comm_world
  call multicom_init()      ! basic initializtion of multicom before parsing input file(s)
  _MSGBUF(1)='SET GLOBAL 1'
  i=len_trim(_MSGBUF(1))
  call multicom_main(_MSGBUF(1), i) ! set global communicator to world
!
  _MSGBUF(1)='PARSE WORLD'  ! set parser communicator to global ;  this means that every node will have the same parser list
  i=len_trim(_MSGBUF(1))
  call multicom_main( _MSGBUF(1),i)
!
#ifdef __TIMER 
  time(1)=timer_stamp(mpe_timer)
#endif
!
#else
#ifdef __TIMER 
  time(1)=0
#endif
#endif
! qprint must be execute after the communicator is known (so that __ME is defined)
 __QPRINT
! parse input file
! *********************************************************************************************************
!
  if (__ME.le.0) then 
#ifdef __NEED_IARGC
  numarg=iargc() ! number of arguments
#else
  numarg=command_argument_count() ! number of arguments
#endif
   if (numarg.ge.1) then 
    call getarg(1, filename)
    fname=filename
   call adjustleft(fname)
    flen=len_trim(fname)
    call files_open(handle_=fid, name_=filename(1:flen), form_='FORMATTED', action_='READ')
    if (fid.lt.0) call error(whoami,'Could not open file',-1)
   else
   fid=5 ! if file name missing, read from standard input
   endif
  endif ! me
!    call parser (only the root will receive a valid file handle (see above); all nodes still call parse_file)
  call parse_file(fid _COMMA __COMM)
!
  if (__ME.le.0) call files_close(fid)
! *********************************************************************************************************
! now that the input has been parsed, we first see if output parameters changed
  if (existtag_nocase('minwarnlev',__OUTCTX))    call set_minwarnlev   (atoi(getval('minwarnlev',__OUTCTX)))
  if (existtag_nocase('minmessagelev',__OUTCTX)) call set_minmessagelev(atoi(getval('minmessagelev',__OUTCTX)))
  if (existtag_nocase('minerrorlev',__OUTCTX))   call set_minerrorlev  (atoi(getval('minerrorlev',__OUTCTX)))
!
! *********************************************************************************************************
#ifdef __TIMER 
  time(2)=timer_stamp(mpe_timer) ! parsing time
#endif
#ifdef __PARALLEL
!======= now call multicom to set up various communicators before going further
  call message(whoami, 'RUNNING MULTICOM EXECUTION STACK', __DBGLEV)
  __EXEC(multicom)
!
#ifdef __TIMER
  time(3)=timer_stamp(mpe_timer)
#endif
!
#else
  time(3)=0
#endif
! misc. initialization
!
  call message(whoami, 'INITIALIZING SIZE', __DBGLEV)
 __INIT(size)
  call message(whoami, 'INITIALIZING GRID', __DBGLEV)
 __INIT(grid)
  call message(whoami, 'INITIALIZING STATE', __DBGLEV)
 __INIT(state)
!
!====== now initialize slave codes by scanning the context list
!  call muphen_init_codes()
#ifdef __TIMER 
  time(4)=timer_stamp(mpe_timer)
#endif
!====== launch codes
  call message(whoami, 'RUNNING CHES EXECUTION STACK', __DBGLEV)
  __EXEC(ches)
!  __EXEC(eddie)
!
!
#ifdef __TIMER
  time(5)=timer_stamp(mpe_timer)
#endif

!
!====== cleanup
!  call muphen_cleanup_codes()
#ifdef __TIMER
  time(6)=timer_stamp(mpe_timer)
#endif
!


!       call state_done() ! should be done elsewhere ...
!       call grid_done()
!       call files_done() ! close all units
!       call parser_done()



#ifdef __PARALLEL
!======= now call multicom to set up various communicators before going further
  call message(whoami, 'FINALIZING MULTICOM', __DBGLEV)
  call multicom_cleanup() ! NOTE : multicom will not call mpi_finalize (will only call mpi_init if needed)
!
#ifdef __TIMER
  time(7)=timer_stamp(mpe_timer)
#endif
!
#else
  time(7)=0
#endif

!====== stop timer
#ifdef __TIMER
  call message(whoami, 'FINALIZING TIMER', __DBGLEV)
  call timer_done()
#endif
!
#ifdef __TIMER
 call message(whoami,'============= TIMING INFORMATION ==============')
#ifdef __PARALLEL
 call message(whoami,' : '//ftoa(time(1)))
#endif
 call message(whoami,' : '//ftoa(time(2)))
#ifdef __PARALLEL
 call message(whoami,' : '//ftoa(time(3)))
#endif
 call message(whoami,' : '//ftoa(time(4)))
 call message(whoami,' : '//ftoa(time(5)))
 call message(whoami,' : '//ftoa(time(6)))
 call message(whoami,'===============================================')
#endif
!
#ifdef __PARALLEL
 call message(whoami, 'FINALIZING MPI (IF NEEDED)', __DBGLEV)
 call mpi_initialized(mpiinit,i)
 if (mpiinit) call mpi_finalize(i)
#endif
!
end ! MUPHEN
