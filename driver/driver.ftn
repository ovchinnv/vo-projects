#ifdef __PARALLEL
#define __MAINCOMM PARSER
#//
#define __COMM __CONCAT(MPI_COMM_,__MAINCOMM )
#define __ME   __CONCAT(ME_,__MAINCOMM )
#define __NCPU __CONCAT(SIZE_,__MAINCOMM )
#define _COMMA ,
#else
#define __COMM
#define __ME 0
#define _COMMA
#endif
#define __QPRINT qprint=(__ME.eq.0)
#ifdef __TIMER
#define __TIMESTAMP(__DESCRIPTION) itime=itime+1; time(itime)=timer_stamp(mpe_timer) ; task(itime)=__STRING(__DESCRIPTION);
#else
#define __TIMESTAMP(__DESCRIPTION)
#endif
!
!
PROGRAM MUPHEN ! MUlti-PHysics-ENvironment
!
! 2013 Victor Ovchinnikov (ovchinnv_at_georgetown_dot_edu)
!
  __DEP_PARSER
  __DEP_OUTPUT
#ifdef __TIMER
  use timer
#endif
!
#ifdef __PARALLEL
  __DEP_MPI
  __DEP_MULTICOM
  use multicom
#endif
#ifdef __CHES
  use ches
#endif
!
  use files
  use SIZE
  use grid
  use state
!
  __IMPNONE
!======================= variables
  __IAM(MPE Manager)
  int :: i
  int :: numarg
  character(len=80) :: filename, fname
  int :: flen
  int :: fid=-1 
!
#ifdef __TIMER
  int, parameter :: ntimes=10
  int :: mpe_timer, itime=0
  float :: time(ntimes)
  character(len=vartaglen) :: task(ntimes)
#endif
#ifdef __PARALLEL
  bool :: mpiinit
  __DECLARE_MSGBUF
#endif
!
#ifdef __TIMER
  call timer_init()
  mpe_timer=timer_start()
#endif
  time=0
!
#ifdef __PARALLEL
  call mpi_initialized(mpiinit,i)
  if (.not.mpiinit) call mpi_init(i)
!
! initialize multicom; the first communicator is mpi_comm_world
  call multicom_init()      ! basic initializtion of multicom before parsing input file(s)
  _MSGBUF(1)='SET GLOBAL 1'
  i=len_trim(_MSGBUF(1))
  call multicom_main(_MSGBUF(1), i) ! set global communicator to world
!
  _MSGBUF(1)='PARSE WORLD'  ! set parser communicator to global ;  this means that every node will have the same parser list
  i=len_trim(_MSGBUF(1))
  call multicom_main( _MSGBUF(1),i)
!
#endif
!
  __TIMESTAMP(Parallel initialization time)
! qprint must be execute after the communicator is known (so that __ME is defined)
 __QPRINT
! parse input file
! *********************************************************************************************************
!
  if (__ME.le.0) then 
#ifdef __NEED_IARGC
  numarg=iargc() ! number of arguments
#else
  numarg=command_argument_count() ! number of arguments
#endif
   if (numarg.ge.1) then 
    call getarg(1, filename)
    fname=filename
   call adjustleft(fname)
    flen=len_trim(fname)
    call files_open(handle_=fid, name_=filename(1:flen), form_='FORMATTED', action_='READ')
    if (fid.lt.0) call error(whoami,'Could not open file',-1)
   else
   fid=5 ! if file name missing, read from standard input
   endif
  endif ! me
!    call parser (only the root will receive a valid file handle (see above); all nodes still call parse_file)
  call parse_file(fid _COMMA __COMM)
!
  if (__ME.le.0) call files_close(fid)
! *********************************************************************************************************
! now that the input has been parsed, we first see if output parameters changed
  if (existtag_nocase('minwarnlev',__OUTCTX))    call set_minwarnlev   (atoi(getval('minwarnlev',__OUTCTX)))
  if (existtag_nocase('minmessagelev',__OUTCTX)) call set_minmessagelev(atoi(getval('minmessagelev',__OUTCTX)))
  if (existtag_nocase('minerrorlev',__OUTCTX))   call set_minerrorlev  (atoi(getval('minerrorlev',__OUTCTX)))
!
! *********************************************************************************************************
  __TIMESTAMP(Parsing time)
!
#ifdef __PARALLEL
!======= now call multicom to set up various communicators before going further
#if __DEBUG
  call message(whoami, 'RUNNING MULTICOM EXECUTION STACK', __DBGLEV)
#endif
  __EXEC(multicom)
!
  __TIMESTAMP(Multicom execution time)
#endif
! misc. initialization
!
#if __DEBUG
  call message(whoami, 'INITIALIZING SIZE', __DBGLEV)
#endif
 __INIT(size)
#if __DEBUG
  call message(whoami, 'INITIALIZING GRID', __DBGLEV)
#endif
 __INIT(grid)
#if __DEBUG
  call message(whoami, 'INITIALIZING STATE', __DBGLEV)
#endif
 __INIT(state)
!
!====== now initialize slave codes by scanning the context list
!  call muphen_init_codes()
  __TIMESTAMP(Basic variable initialization time)
!====== launch codes
#if __DEBUG
  call message(whoami, 'RUNNING CHES EXECUTION STACK', __DBGLEV)
#endif
  __EXEC(ches)
!  __EXEC(eddie)
!
!
  __TIMESTAMP(Other code execution time)

!====== cleanup : not sure how to do this, and whether this is necessary
!  call muphen_cleanup_codes()
!#ifdef __TIMER
!  time(6)=timer_stamp(mpe_timer)
!#endif
!
!       call state_done() ! should be done elsewhere ...
!       call grid_done()
!       call files_done() ! close all units
!       call parser_done()
!

#ifdef __PARALLEL
!======= now call multicom to set up various communicators before going further
#if __DEBUG
  call message(whoami, 'FINALIZING MULTICOM', __DBGLEV)
#endif
  call multicom_cleanup() ! NOTE : multicom will not call mpi_finalize (will only call mpi_init if needed)
!
  __TIMESTAMP(Parallel finalization time)
#endif

#ifdef __TIMER
 call message(whoami,'============= TIMING INFORMATION ==============')
 do i=1, itime ; call message(whoami,trim(task(i))//char(9)//': '//ftoa(time(i))) ; enddo
 call message(whoami,'Total time'//char(9)//': '//ftoa(timer_elapsed_total(mpe_timer)));
 call message(whoami,'===============================================')
#endif
!
#ifdef __PARALLEL
#if __DEBUG
 call message(whoami, 'FINALIZING MPI (IF NEEDED)', __DBGLEV)
#endif
 call mpi_initialized(mpiinit,i)
 if (mpiinit) call mpi_finalize(i)
#endif
!====== stop timer
#ifdef __TIMER
  call message(whoami, 'FINALIZING TIMER', __DBGLEV)
  call timer_done()
#endif
!
!
end ! MUPHEN
