 implicit none						      |	 __IMPNONE
  integer, parameter :: rules_expand = 10 ! reallocation size |	  int, parameter :: rules_expand = 10 ! reallocation size inc
  integer :: num_rules=0				      |	  int :: num_rules=0
  logical :: confcons_initialized=.false., qprint=.true., qfi |	  bool :: confcons_initialized=.false., qprint=.true., qfix=.
 logical :: q						      |	 bool :: q
 integer :: i						      |	 int :: i
 integer :: i						      |	 int :: i
 use stream						      |	 __DEP_PARSER
 use string						      |	 __DEP_OUTPUT
 integer, optional :: ifile				      |	 int, optional :: ifile
 logical :: qread					      |	 bool :: qread
 integer, parameter :: maxrulelength=200		      |	 int, parameter :: maxrulelength=200
 integer :: ioerr, i, j, k, l, m, n, ii, l_bkp		      |	 int :: ioerr, i, j, k, l, m, n, ii, l_bkp
&  write(outu,'(2A,I4)') whoami, ' READING RULES FROM UNIT ', |	&  write(_MSGBUF,'(2A,I4)') whoami, ' READING RULES FROM UNIT
    call trima(line,l)					      |	    __TRIMA(line,l)
    r%resname=nexta8(line,l)				      |	    r%resname=__NEXTA(line,l)
    if (j.ge.0) then ; allocate(r%test_atoms(j)) ; do i=1,j ; |	    if (j.ge.0) then ; allocate(r%test_atoms(j)) ; do i=1,j ;
    if (j.ge.0) then ; allocate(r%orient_atoms(j)) ; do i=1,j |	    if (j.ge.0) then ; allocate(r%orient_atoms(j)) ; do i=1,j
      do i=1,j ; do m=1,k ; r%orient_atom_permutations(m,i)=n |	      do i=1,j ; do m=1,k ; r%orient_atom_permutations(m,i)=_
      do i=1,j ; do m=1,k ; r%other_atom_permutations(m,i)=ne |	      do i=1,j ; do m=1,k ; r%other_atom_permutations(m,i)=__
       call wrndie(0, whoami, 'IGNORING DUPLICATE OR CONFLICT |	       __WRN( whoami, 'IGNORING DUPLICATE OR CONFLICTING RULE
     call wrndie(0, whoami,'DETECTED ERRORS IN RULES FILE.')  |	     __WRN( whoami,'DETECTED ERRORS IN RULES FILE.')
     call wrndie(0, whoami,'SKIPPING LINE:'//line_bkp(1:l_bkp |	     __WRN( whoami,'SKIPPING LINE:'//line_bkp(1:l_bkp))
&  write(outu,'(A,I4,A,I4)') whoami, num_rules, ' RULES READ  |	&  write(_MSGBUF,'(A,I4,A,I4)') whoami, num_rules, ' RULES RE
   call trima(line,l)					      |	   __TRIMA(line,l)
   r%resname=nexta8(line,l)				      |	   r%resname=__NEXTA(line,l)
   j=nexti(line,l) ; allocate(r%test_atoms(j)) ; do i=1,j ; r |	   j=nexti(line,l) ; allocate(r%test_atoms(j)) ; do i=1,j ; r
   j=nexti(line,l) ; allocate(r%orient_atoms(j)) ; do i=1,j ; |	   j=nexti(line,l) ; allocate(r%orient_atoms(j)) ; do i=1,j ;
   do i=1,j ; do m=1,k ; r%orient_atom_permutations(m,i)=next |	   do i=1,j ; do m=1,k ; r%orient_atom_permutations(m,i)=__NE
   do i=1,j ; do m=1,k ; r%other_atom_permutations(m,i)=nexta |	   do i=1,j ; do m=1,k ; r%other_atom_permutations(m,i)=__NEX
     call wrndie(0, whoami, 'IGNORING DUPLICATE OR CONFLICTIN |	     __WRN( whoami, 'IGNORING DUPLICATE OR CONFLICTING RULE: 
 use stream						      |	 __DEP_PARSER
 use string						      |	 __DEP_OUTPUT
##IF MULTICOM						      |	__CHARMM_ONLY##IF MULTICOM
 use multicom_aux					      |	 __DEP_MULTICOM
##ENDIF							      |	__CHARMM_ONLY##ENDIF
 integer :: comlen, l, j				      |	 int :: comlen, l, j
 integer, intent(in) :: islct(:)			      |	 int, intent(in) :: islct(:)
 integer :: errnum, ifile				      |	 int :: errnum, ifile
 integer :: ngroups, npermute				      |	 int :: ngroups, npermute
 logical :: qcheck					      |	 bool :: qcheck
 if (l.le.1 .or. indxa(comlyn, comlen, 'HELP').gt.0) then     |	 if (l.le.1 .or. __INDX_RM(comlyn, comlen, 'HELP').gt.0) then
  write(outu,'(2A)') whoami, ' CONFORMATION CONSISTENCY CHECK |	  write(_MSGBUF,'(2A)') whoami, ' CONFORMATION CONSISTENCY CH
  write(outu,'(2A)') whoami, ' ______________________________ |	  write(_MSGBUF,'(2A)') whoami, ' ___________________________
  write(outu,'(2A)') whoami, ' DESCRIPTION: FIND AND ELIMINAT |	  write(_MSGBUF,'(2A)') whoami, ' DESCRIPTION: FIND AND ELIMI
  write(outu,'(2A)') whoami, ' DESCRIPTION: ATOMS IN RESIDUES |	  write(_MSGBUF,'(2A)') whoami, ' DESCRIPTION: ATOMS IN RESID
  write(outu,'(2A)') whoami, ' SYNTAX : coor confcons <COMMAN |	  write(_MSGBUF,'(2A)') whoami, ' SYNTAX : coor confcons <COM
  write(outu,'(2A)') whoami, ' COMMANDS CAN BE ONE OR MORE OF |	  write(_MSGBUF,'(2A)') whoami, ' COMMANDS CAN BE ONE OR MORE
  write(outu,'(2A)') whoami, '   INIT  - initialize/reinitial |	  write(_MSGBUF,'(2A)') whoami, '   INIT  - initialize/reinit
  write(outu,'(2A)') whoami, '   FINA  - deallocate all array |	  write(_MSGBUF,'(2A)') whoami, '   FINA  - deallocate all ar
  write(outu,'(2A)') whoami, '   CHECK - check structure'     |	  write(_MSGBUF,'(2A)') whoami, '   CHECK - check structure'
  write(outu,'(2A)') whoami, '   FIX   - check structure and  |	  write(_MSGBUF,'(2A)') whoami, '   FIX   - check structure a
  write(outu,'(2A)') whoami, '   NOFX  - do not attempt to co |	  write(_MSGBUF,'(2A)') whoami, '   NOFX  - do not attempt to
  write(outu,'(2A)') whoami, '   NOPR  - disable output'      |	  write(_MSGBUF,'(2A)') whoami, '   NOPR  - disable output'
  write(outu,'(2A)') whoami, '   PRIN  - enable output'	      |	  write(_MSGBUF,'(2A)') whoami, '   PRIN  - enable output'
  write(outu,'(2A)') whoami, '   HELP  - print this screen'   |	  write(_MSGBUF,'(2A)') whoami, '   HELP  - print this screen
  write(outu,'(2A)') whoami, '   RULE  - print rules that are |	  write(_MSGBUF,'(2A)') whoami, '   RULE  - print rules that 
  write(outu,'(2A)') whoami, '   HYDR  - include hydrogen ato |	  write(_MSGBUF,'(2A)') whoami, '   HYDR  - include hydrogen 
  write(outu,'(2A)') whoami, '   READ <UNIT> <ADD> - read rul |	  write(_MSGBUF,'(2A)') whoami, '   READ <UNIT> <ADD> - read 
  write(outu,'(2A)') whoami, '    "ADD" will append rules to  |	  write(_MSGBUF,'(2A)') whoami, '    "ADD" will append rules 
  write(outu,'(2A)') whoami, ' ATOM SELECTION IS OPTIONAL (AL |	  write(_MSGBUF,'(2A)') whoami, ' ATOM SELECTION IS OPTIONAL 
  write(outu,'(2A)') whoami, ' ______________________________ |	  write(_MSGBUF,'(2A)') whoami, ' ___________________________
 if (indxa(comlyn,comlen,'FINA').gt.0) then ; call confcons_f |	 if (__INDX_RM(comlyn,comlen,'FINA').gt.0) then ; call confco
 if ((indxa(comlyn,comlen,'INIT').gt.0).or.(.not. confcons_in |	 if ((__INDX_RM(comlyn,comlen,'INIT').gt.0).or.(.not. confcon
&        iolev.gt.0                     !##.not.ENSEMBLE !##. |	&        iolev.gt.0                     !__CHARMM_ONLY##.not.
&        (ME_LOCAL.eq.0)                !##ENSEMBLE STRINGM   |	&        (ME_LOCAL.eq.0)                !__CHARMM_ONLY##ENSEM
 if (indxa(comlyn,comlen,'NOPR').gt.0) then 		      |	 if (__INDX_RM(comlyn,comlen,'NOPR').gt.0) then 
 elseif (indxa(comlyn,comlen,'PRIN').gt.0) then		      |	 elseif (__INDX_RM(comlyn,comlen,'PRIN').gt.0) then
&        iolev.gt.0                     !##.not.ENSEMBLE !##. |	&        iolev.gt.0                     !__CHARMM_ONLY##.not.
&        (ME_LOCAL.eq.0)                !##ENSEMBLE STRINGM   |	&        (ME_LOCAL.eq.0)                !__CHARMM_ONLY##ENSEM
 if (indxa(comlyn,comlen,'HYDR').gt.0) then		      |	 if (__INDX_RM(comlyn,comlen,'HYDR').gt.0) then
  if (indxa(comlyn, comlen, 'ADD').le.0) num_rules=0 ! overwr |	  if (__INDX_RM(comlyn, comlen, 'ADD').le.0) num_rules=0 ! ov
 if (indxa(comlyn,comlen,'READ').gt.0) then		      |	 if (__INDX_RM(comlyn,comlen,'READ').gt.0) then
  ifile=gtrmi(comlyn,comlen,'UNIT',-1)			      |	  ifile=__GET_RM_I(comlyn,comlen,'UNIT',-1)
  if (indxa(comlyn, comlen, 'ADD').le.0) num_rules=0 ! overwr |	  if (__INDX_RM(comlyn, comlen, 'ADD').le.0) num_rules=0 ! ov
 if (indxa(comlyn,comlen,'RULE').gt.0) then		      |	 if (__INDX_RM(comlyn,comlen,'RULE').gt.0) then
  write(outu,'(2A)') whoami, ' ______________________________ |	  write(_MSGBUF,'(2A)') whoami, ' ___________________________
  write(outu,'(2A)') whoami, ' THE FOLLOWING RULES ARE CURREN |	  write(_MSGBUF,'(2A)') whoami, ' THE FOLLOWING RULES ARE CUR
  write(outu,'(2A)') whoami, ' ______________________________ |	  write(_MSGBUF,'(2A)') whoami, ' ___________________________
   write(outu,'(A," ",I3," : ",A)') whoami, j, r%resname      |	   write(_MSGBUF,'(A," ",I3," : ",A)') whoami, j, r%resname
    write(outu,'(A,'//itoa(npermute)//'A)') '    ORIENTATION  |	    write(_MSGBUF,'(A,'//itoa(npermute)//'A)') '    ORIENTATI
    write(outu,'(A,'//itoa(npermute)//'A,'//itoa(ngroups-1)// |	    write(_MSGBUF,'(A,'//itoa(npermute)//'A,'//itoa(ngroups-1
   if (size(r%orient_atoms).gt.0) write(outu,'(A,'//itoa(size |	   if (size(r%orient_atoms).gt.0) write(_MSGBUF,'(A,'//itoa(s
   if (size(r%orient_atoms).gt.0) write(outu,'(A,'//itoa(size |	   if (size(r%orient_atoms).gt.0) write(_MSGBUF,'(A,'//itoa(s
    write(outu,'(A,'//itoa(npermute)//'A)') '    OTHER PERMUT |	    write(_MSGBUF,'(A,'//itoa(npermute)//'A)') '    OTHER PER
    write(outu,'(A,'//itoa(npermute)//'A,'//itoa(ngroups-1)// |	    write(_MSGBUF,'(A,'//itoa(npermute)//'A,'//itoa(ngroups-1
  write(outu,'(2A)') whoami, ' ______________________________ |	  write(_MSGBUF,'(2A)') whoami, ' ___________________________
 if (indxa(comlyn,comlen,'NOFX').gt.0) then		      |	 if (__INDX_RM(comlyn,comlen,'NOFX').gt.0) then
 elseif (indxa(comlyn,comlen,'FIX').gt.0) then ! whether to m |	 elseif (__INDX_RM(comlyn,comlen,'FIX').gt.0) then ! whether 
 if ((indxa(comlyn,comlen,'CHCK').gt.0) .or. &		      |	 if ((__INDX_RM(comlyn,comlen,'CHCK').gt.0) .or. &
 &   (indxa(comlyn,comlen,'CHECK').gt.0) .or.&		      |	 &   (__INDX_RM(comlyn,comlen,'CHECK').gt.0) .or.&
 &    (indxa(comlyn,comlen,'CHEC').gt.0) .or.& 		      |	 &    (__INDX_RM(comlyn,comlen,'CHEC').gt.0) .or.& 
 &    (indxa(comlyn,comlen,'CHK').gt.0) .or. &		      |	 &    (__INDX_RM(comlyn,comlen,'CHK').gt.0) .or. &
  call trima(comlyn,comlen)				      |	  __TRIMA(comlyn,comlen)
 use stream						      |	 __DEP_PARSER
 use string						      |	 __DEP_OUTPUT
 use number, only : anum				      |	 __DEP_NUMBER, only : anum
##IF NEWBESTFIT ! VO 1.12				      |	__CHARMM_ONLY##IF NEWBESTFIT ! VO 1.12
  use bestfit						      |	  __DEP_BESTFIT
##ENDIF							      |	__CHARMM_ONLY##ENDIF
 integer :: islct(:)					      |	 int :: islct(:)
 integer :: i, j, k, l, m, errnum, ires, iseg		      |	 int :: i, j, k, l, m, errnum, ires, iseg
 integer :: itest, iorient, iorient_permute, iother_permute,  |	 int :: itest, iorient, iorient_permute, iother_permute, itot
 integer :: istart, iend				      |	 int :: istart, iend
 integer :: i0, i1					      |	 int :: i0, i1
 integer, allocatable :: ind(:)				      |	 int, allocatable :: ind(:)
 real(chm_real), allocatable :: r1(:,:), r2(:,:), ow(:)	      |	 float, allocatable :: r1(:,:), r2(:,:), ow(:)
 real(chm_real) :: u(3,3), rcom1(3), rcom2(3) ! rotation matr |	 float :: u(3,3), rcom1(3), rcom2(3) ! rotation matrix, cente
 real(chm_real) :: msd0, msd1, msd2			      |	 float :: msd0, msd1, msd2
 logical :: flagged					      |	 bool :: flagged
##IF PARALLEL						      |	__CHARMM_ONLY##IF PARALLEL
##ENDIF							      |	__CHARMM_ONLY##ENDIF
        call wrndie(0, whoami, 'SKIPPING RULE '//itoa(j)//':  |	        __WRN( whoami, 'SKIPPING RULE '//itoa(j)//': ATOM NOT
        call wrndie(0, whoami, 'SKIPPING RULE '//itoa(j)//':  |	        __WRN( whoami, 'SKIPPING RULE '//itoa(j)//': ATOM NOT
        call wrndie(0, whoami, 'SKIPPING RULE '//itoa(j)//':  |	        __WRN( whoami, 'SKIPPING RULE '//itoa(j)//': ATOM NOT
        call wrndie(0, whoami, 'SKIPPING RULE '//itoa(j)//':  |	        __WRN( whoami, 'SKIPPING RULE '//itoa(j)//': ATOM NOT
       write(outu,'(6A)') whoami, 'UNDEFINED TEST/ORIENTATION |	       write(_MSGBUF,'(6A)') whoami, 'UNDEFINED TEST/ORIENTAT
##IF NEWBESTFIT						      |	__CHARMM_ONLY##IF NEWBESTFIT
##ENDIF							      |	__CHARMM_ONLY##ENDIF
##IF NEWBESTFIT						      |	__CHARMM_ONLY##IF NEWBESTFIT
##ENDIF							      |	__CHARMM_ONLY##ENDIF
##IF NEWBESTFIT						      |	__CHARMM_ONLY##IF NEWBESTFIT
##ENDIF							      |	__CHARMM_ONLY##ENDIF
##IF NEWBESTFIT						      |	__CHARMM_ONLY##IF NEWBESTFIT
##ENDIF							      |	__CHARMM_ONLY##ENDIF
        write(outu,669) whoami, ' RESIDUE: ',resid(ires)(1:le |	        write(_MSGBUF,669) whoami, ' RESIDUE: ',resid(ires)(1
        write(outu,'(A,'//itoa(npermute)//'A)') '             |	        write(_MSGBUF,'(A,'//itoa(npermute)//'A)') '         
        write(outu,'(A,'//itoa(npermute)//'A,'//itoa(ngroups- |	        write(_MSGBUF,'(A,'//itoa(npermute)//'A,'//itoa(ngrou
!        write(outu,670) whoami, ' RESIDUE: ',resid(ires)(1:l |	!        write(_MSGBUF,670) whoami, ' RESIDUE: ',resid(ires)(
##IF PARALLEL						      |	__CHARMM_ONLY##IF PARALLEL
 call PSND8(X,natom)					      |	 __BROADCAST_LOCAL_8B(X,natom)
 call PSND8(Y,natom)					      |	 __BROADCAST_LOCAL_8B(Y,natom)
 call PSND8(Z,natom)					      |	 __BROADCAST_LOCAL_8B(Z,natom)
##ENDIF 						      |	__CHARMM_ONLY##ENDIF 
  write(outu,'(9A)') whoami,' _______________________________ |	  write(_MSGBUF,'(9A)') whoami,' ____________________________
    write(outu,'(A,I5,A)') whoami, errnum, ' INCONSISTENCY WA |	    write(_MSGBUF,'(A,I5,A)') whoami, errnum, ' INCONSISTENCY
    write(outu,'(A,I5,A)') whoami, errnum, ' INCONSISTENCIES  |	    write(_MSGBUF,'(A,I5,A)') whoami, errnum, ' INCONSISTENCI
    write(outu,'(A,I5,A)') whoami, errnum, ' INCONSISTENCY WA |	    write(_MSGBUF,'(A,I5,A)') whoami, errnum, ' INCONSISTENCY
    write(outu,'(A,I5,A)') whoami, errnum, ' INCONSISTENCIES  |	    write(_MSGBUF,'(A,I5,A)') whoami, errnum, ' INCONSISTENCI
  integer, intent(in) :: istart, iend			      |	  int, intent(in) :: istart, iend
  integer :: l,ifindc					      |	  int :: l,ifindc
  logical :: found					      |	  bool :: found
