 program bfit

 use bestfit
 use constants

! implicit none

 float :: M(3,3)
 float :: maxerr, err, TOL
 real*8 :: ERRTOL_
 real*4 :: ERRTOL4
 int :: numtest
!
 maxerr=0d0
 numtest=0
!
 if (kind(TOL).eq.kind(0d0)) then
  TOL=5d-8
 elseif (kind(TOL).eq.kind(0.)) then
  TOL=1d-1
 else
  TOL=1000*ERRTOL()
 endif
!
 ERRTOL_=ERRTOL()
 ERRTOL4=ERRTOL_
!goto 999
! ok
 M=reshape ( (/ 4.1d0, ERRTOL_, 0d0, 0d0, 1d0, 0d0, 0d0, 0d0, 3d0/),(/3,3/) )
 err=check_diag(M) ; if (err.ge.0) numtest=numtest+1 ; maxerr=max(maxerr,err)
! ok
 M=reshape ( (/ 4.1d0, ERRTOL_, ERRTOL_, 0d0, ERRTOL_, ERRTOL_, ERRTOL_, 0d0, ERRTOL_/),(/3,3/) )
 err=check_diag(M) ; if (err.ge.0) numtest=numtest+1 ; maxerr=max(maxerr,err)
! ok
 M=reshape ( (/  ERRTOL_, 1d0, 0d0, & 
                 1d0,      0d0, 3d0, & 
                 0d0,      3d0, ERRTOL_*1000/),(/3,3/) )
 err=check_diag(M) ; if (err.ge.0) numtest=numtest+1 ; maxerr=max(maxerr,err)
 666  continue
 M=reshape ( (/  ERRTOL4, 1., 0., &
                      1., 0., 3., &
                      0., 3., ERRTOL4*1000/),(/3,3/) )
 err=check_diag(M) ; if (err.ge.0) numtest=numtest+1 ; maxerr=max(maxerr,err)
 M=reshape ( (/  ERRTOL_, 1d0, 1d0, 1d0, 1d0, 1d0, 1d0, 1d0, ERRTOL_*1000/),(/3,3/) )
 err=check_diag(M) ; if (err.ge.0) numtest=numtest+1 ; maxerr=max(maxerr,err)
! goto 777
! this failed:
! in this case the eigenvalues were very close to zero (but computed as 1e-8), which lead to two 'duplicate' evectors; fixed
 M=reshape( (/ &
 0.32753820909748578016352d-01, 0.75997504774541049799019d-01, 0.76284169485594674475770d-01,&
 0.75997504774541049799019d-01, 0.17633425876849012636782d+00, 0.17699939651858714873001d+00,&
 0.76284169485594674475770d-01, 0.17699939651858714873001d+00, 0.17766704318685860863880d+00 /), (/3,3/) )
 err=check_diag(M) ; if (err.ge.0) numtest=numtest+1 ; maxerr=max(maxerr,err)
!
! this also failed:

 M=reshape( (/ &
 0.27427009764448101458711d+00, 0.10798602617951455484580d+00,-0.16209868811080687251457d-06,&
 0.10798602617951455484580d+00, 0.42516417029020051043808d-01,-0.63821733861371916309836d-07,&
-0.16209868811080687251457d-06,-0.63821733861371916309836d-07, 0.95803315464978367580174d-13 /), (/3,3/) )
 err=check_diag(M) ; if (err.ge.0) numtest=numtest+1 ; maxerr=max(maxerr,err)
!
! fixed by using the fact that eigenvectors coresponding to different EV of a symmetric matrix are orthogonal
 888 continue
 M=reshape( (/ &
 0.367410888671875E+02, 0.293145179748535E+01, -0.475931777954102E+02,&
 0.293145179748535E+01, -0.166737194061279E+02, -0.260370373725891E+01,&
-0.475931777954102E+02, -0.260370373725891E+01, -0.685383224487305E+02 /), (/3,3/) )
 err=check_diag(M) ; if (err.ge.0) numtest=numtest+1 ; maxerr=max(maxerr,err)
! goto 777
 999 continue
 M=reshape( (/ &
 0.677300186157227E+02,-0.592178153991699E+02,-0.896424102783203E+01,&
-0.592178153991699E+02,-0.689867553710938E+02,-0.241539478302002E+02,&
-0.896424102783203E+01,-0.241539478302002E+02, 0.861421356201172E+02 /), (/3,3/))
 err=check_diag(M) ; if (err.ge.0) numtest=numtest+1 ; maxerr=max(maxerr,err)
! goto 777


!*******random matrix tests*******
! these are an approximation to what actually goes on in a code
!
 do n=1,10000000
! do n=1,100000
!do n=1,0
  call random_number(M)
  M=100d0*(M+transpose(M)-1d0)
  err=check_diag(M) ; if (err.ge.0) numtest=numtest+1 ; maxerr=max(maxerr,err)
 enddo
!
 777  continue
 write(0,*) ' MAXIMUM DIAGONALIZATION ERROR: ',maxerr
 write(0,*) ' NUMBER OF TESTS: ',numtest
! end
 
 contains
  function check_diag(B)
  implicit none
  float, intent(in) :: B(3,3)
  float :: maxerr, A(3,3)
  float :: eval(3), evec(3,3)
  real*8 :: b0(3,3) ! this is a check -- do in double prec
  float :: check_diag, norm
  character(len=10) :: whoami='CHECK_DIAG'
!
! First, make sure that the matrix is symmetric
  maxerr=(maxval(abs(B-transpose(B))))
  if (maxerr.ge.TOL) then
   write(0,*) whoami,': Matrix not symmetric, aborting test.'
   write(0,*) whoami,': Details:'
   write(0,*) '-------------------------'
   write(0,*)' A-A^T :'
   write(0,'(3E22.15)') A-transpose(A)
   write(0,*) '-------------------------'
   check_diag=-1d0
   return
  endif
! Second, scale the matrix
! I find that this does not make a significant difference
!  norm=third*abs(B(1,1)+B(2,2)+B(3,3))**third ; ! use trace for normalization 
!  norm=abs(B(1,1)+B(2,2)+B(3,3))**third ; ! use trace for normalization 
!  norm=abs(B(1,1)+B(2,2)+B(3,3))**half ; ! use trace for normalization 
!  norm=abs(B(1,1)+B(2,2)+B(3,3))/27 ; ! use trace for normalization 
!  norm=third*abs(B(1,1)+B(2,2)+B(3,3)) ; ! use trace for normalization 
!  norm=abs(sum(B))/9
  norm=1;
  A=B/norm
! 
  call eig3s(A, eval, evec)
! check diagonalization directly
! rescale the eigenvalues back
  eval=eval*norm
  b0(:,1)=eval(1)*evec(:,1);b0(:,2)=eval(2)*evec(:,2);b0(:,3)=eval(3)*evec(:,3)! aa

  maxerr=(maxval(abs(matmul(b0,transpose(evec))-B)))
  if (maxerr.ge.TOL) then
   write(666,*) whoami,': Test failed, maximum error:',maxerr,TOL
   write(666,*) whoami,': Details:'
   write(666,*) '-------------------------'
   write(666,*)' A :'
   write(666,'(3E22.15)') B
   write(666,*) '-------------------------'
   write(666,*) 'EIGENVALUES: '
   write(666,'(3G22.14)') eval
   write(666,*) '---------------------------------'
   write(666,*) 'EIGENVECTORS: '
   write(666,'(3G22.14)') evec
   write(666,*) '---------------------------------'
   write(666,*)' U x U^T (should be I):'
   write(666,*) '---------------------------------'
   write(666,'(3E22.15)') matmul(evec,transpose(evec))
   write(666,*)' A - U x M x U^T (should be 0):'
   write(666,*) '---------------------------------'
   write(666,'(3E22.15)') B-matmul(b0,transpose(evec))
  endif
!
  check_diag=maxerr
!
  if (maxerr.ge.TOL) then
   write(0,*) '--**ERROR**--', check_diag ! , norm
  endif
!
  end function check_diag
 end 
 