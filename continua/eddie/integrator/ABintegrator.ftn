module ABintegrator
!
 use SIZE
 use datatypes
 use state
 use constants
 __DEP_OUTPUT
#ifdef __PARALLEL
 __DEP_MULTICOM
 __DEP_MPI
#endif
!
 __IMPNONE
!
 public ab_init
 public ab_done
! public ab_predictor
! public ab_corrector
!
!.....uab1, vab1, wab1:		RHS predictor step for Adams-Bashforth advancement
!.....uab2, vab2, wab2:		RHS corrector step (A/B)
 type(varray3df), save, pointer :: uab1_, vab1_, wab1_, uab2_, vab2_, wab2_
 float, pointer, save, dimension(:,:,:) :: uab1, vab1, wab1, uab2, vab2, wab2
!
! float :: 
!
 logical :: ab_initialized=.false.
 logical :: deltaform=.false.
!
 contains
!
       subroutine ab_init()
       __IAM(AB_INIT)
#ifdef __CTX
#undef __CTX
#endif
#ifdef __PARALLEL
! use a trick to supply communicator only in parallel mode
#define __CTX __COMM, __EDCTX
#else
#define __CTX __EDCTX
#endif
!
       nullify(uab1_, vab1_, wab1_,uab2_, vab2_, wab2_ )
       nullify(uab1, vab1, wab1, uab2, vab2, wab2)
!
       call message(whoami, 'Initializing state variables.');
!
       call state_add3df('UAB1' ,'RHS U-component (n-1)'    , __CTX, vptr=uab1_)     ; uab1=>uab1_%v
       call state_add3df('VAB1' ,'RHS V-component (n-1)'    , __CTX, vptr=vab1_)     ; vab1=>vab1_%v
       call state_add3df('WAB1' ,'RHS W-component (n-1)'    , __CTX, vptr=wab1_)     ; wab1=>wab1_%v
!
       call state_add3df('UAB2' ,'RHS U-component (n)'      , __CTX, vptr=uab2_)     ; uab2=>uab2_%v
       call state_add3df('VAB2' ,'RHS V-component (n)'      , __CTX, vptr=vab2_)     ; vab2=>vab2_%v
       call state_add3df('WAB2' ,'RHS W-component (n)'      , __CTX, vptr=wab2_)     ; wab2=>wab2_%v
!
       end subroutine ab_init
!=========================================================================
       subroutine ab_done()
! for now, all deallocation done by state, only set initialized flag here
       ab_initialized=.false.
       end subroutine ab_done
!=========================================================================
       subroutine ab_update_rhs(t_)
       use eddie_grid, only : ib, ie, jb, je, kb, ke
       float, optional :: t_
       float :: t, omt
       int :: i,j,k
       if (present(t_)) then ; t=t_ ; else ; t=1 ; endif ! not sure under what circumstances t =/= 1 !
       omt=one-t;
!      store uab2 as uab1 (i.e. typically t=1)
       do k=kb,ke  ; do j=jb,je ; do i=ib,ie
        uab1(i,j,k) = omt*uab1(i,j,k)+t*uab2(i,j,k)
        vab1(i,j,k) = omt*vab1(i,j,k)+t*vab2(i,j,k)
        wab1(i,j,k) = omt*wab1(i,j,k)+t*wab2(i,j,k)
       enddo       ; enddo      ; enddo
       end subroutine ab_update_rhs
!=========================================================================










end module ABintegrator

