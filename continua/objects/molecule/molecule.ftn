#define __CONTEXT __MOLCTX
module molecule
 use system
 __DEP_OUTPUT
 __DEP_PARSER
 __DEP_CONST
 __IMPNONE
!
 bool, private :: molecule_initialized=.false.

 float, private, allocatable :: epsatom(:) ! relative dielectric as a function of atom (not currently used)
!
!
 int, private, allocatable :: closest_pt(:,:)
 float, public, pointer :: rho(:,:,:)         ! surface 'density', the isosurfaces of which are used to assign the molecular surface
!
 float, private, parameter :: osq2=one/sqrt2
 float, private, parameter :: osq2pi=one/sqrt(twopi)
!
!************************************** DEFAULT VALUES
 __FPPARDEF(eps_solute, 2.5d0)
 __FPPARDEF(eps_solvent, 78d0)
 __FPPARDEF(kappa_solute, 0d0)
 __FPPARDEF(kappa_solvent, 0.15d0)
!
 float, private, parameter :: cutoff_stdev_default    =3d0, & ! dimensionless (see above)
&                             padding_default         =0d0, & ! units of radius
&                             stdev_default           = - 1d0 ! MEANS: determine from grid in grid_data
!
 float, private :: cutoff_eps    ! grid smoothing cutoff normalized by standard deviation of gaussian (epsilon)
 float, private :: cutoff_kappa
 float, private :: cutoff_charge
 float, private :: cutoff_surf
!
 __FPPARDEF(cutoff_eps_stdev,   cutoff_stdev_default)
 __FPPARDEF(cutoff_kappa_stdev, cutoff_stdev_default)
 __FPPARDEF(cutoff_charge_stdev,cutoff_stdev_default)
 __FPPARDEF(cutoff_surf_stdev,  cutoff_stdev_default)
!
 float, private :: oo_stdev_eps! , oo_stdev_eps2 ! std. dev. of the gaussian filter (epsilon)
 float, private :: oo_stdev_kappa! , oo_stdev_kappa2
 float, private :: oo_stdev_charge! , oo_stdev_charge2
 float, private :: oo_stdev_surf! , oo_stdev_surf2
!
 __FPPARDEF(stdev_eps,   stdev_default)
 __FPPARDEF(stdev_kappa, stdev_default)
 __FPPARDEF(stdev_charge,stdev_default)
 __FPPARDEF(stdev_surf,  stdev_default)
!
 __FPPARDEF(kappa_padding,padding_default)
 __FPPARDEF(charge_padding,padding_default)
 __FPPARDEF(eps_padding,padding_default)
 __FPPARDEF(surf_padding,padding_default)

! permittivity units conversion :
! CHARMM says :
! CCELEC is 1/ (4 pi eps ) in AKMA units, conversion from SI
! units: CCELEC = e*e*Na / (4*pi*eps*1Kcal*1A)
 __FPAR(eps_amber    , 332.0522173d0)
 __FPAR(eps_charmm   , 332.0716d0)
 __FPAR(eps_discover , 332.054d0)
 __FPAR(eps_namd     , 332.0636d0)
!
 __FPPARDEF(temperature, 298d0)
!
!CHARMM uses :     kappa2 = 8*PI*cat*e**2*beta
!    KAPPA2=2530.362733*CONC/TEMP
 __FPAR(kappa_akma , -2530.362733d0)

 __FPPARDEF(eps_scale, eps_charmm)
 __FPPARDEF(kappa_scale, kappa_akma/(four*pi*temperature_default))
!
 __FPPARDEF(charge_scale, -one) ! in the MG solver, the equation is  lap(u) = q, but we need lap(u) = -q, i.e. with a negative sign
!
!***************************** subroutines ****************
 public molecule_initialize ! initialize molecular coordinates, radii and charges
 public molecule_ok
 public molecule_read_parameters ! query parser for molecule parameters
 public molecule_center ! translate center to origin
 public molecule_align  ! align principal vectors with coordinate system
 public molecule_dimens ! translate to center
 public molecule_done ! deallocate memory
 public molecule_grid_objects ! public routine used to obtain grid values from this module
 public molecule_ndim ! return number of dimensions (inherited from system)
 public molecule_surface_pointer
!
!**********************************************************
 contains
!********************************************************************
  bool function molecule_ok(); molecule_ok=molecule_initialized;end function molecule_ok
!********************************************************************
  function molecule_surface_pointer()
  float, pointer, dimension(:,:,:) :: molecule_surface_pointer
  nullify(molecule_surface_pointer)
  if (molecule_initialized) then
   if (associated(rho)) molecule_surface_pointer=>rho
  endif
  end function molecule_surface_pointer
!********************************************************************
  subroutine molecule_read_parameters
  int :: l
  __IAM(MOLECULE_READ_PARAMETERS)
  character(len=vartaglen) :: keyword
!  character(len=7), parameter :: fmt='(F10.5)'
  character(len=15), parameter :: fmt='('//realfmt//')'
!
! query parser for parameters 
!
! temperature
#define __LEZEROERR
#define __DEFAULT
#define __VAR	temperature
#define __NAME	Temperature
#include "mol_macro1.src"
#undef __LEZEROERR
!
#define __WARNIFMISSING
#define __MINUSWRN
! solvent dielectric
#define __VAR	eps_solvent
#define __NAME	Solvent dielectric
#include "mol_macro1.src"
!
! solute dielectric
#define __VAR	eps_solute
#define __NAME	Solute dielectric
#define __BYATOM
#include "mol_macro1.src"
#undef  __BYATOM
!
! check for epsilon scaling (adapted from elec code):
#define  __VAR eps_scale
  if (existtag_nocase(__STRING(__VAR),__STRING(__CONTEXT))) then
   keyword=getval_nocase(__STRING(__VAR),__STRING(__CONTEXT))
  else
   __OUT('Dielectric permittivity scaling not specified.')
   keyword='CHARMM'
  endif
  call toupper(keyword)
  select case(keyword)
   case('CHARMM','CHM','CHRM','CHARM','CH') ; __VAR=one/(eps_charmm*four*pi)   ; __OUT('Using CHARMM AKMA permittivity scaling');
   case('NAMD','NAMD2')                     ; __VAR=one/(eps_namd*four*pi)     ; __OUT('Using NAMD AKMA permittivity scaling');
   case('AMBER','AMB','AM')                 ; __VAR=one/(eps_amber*four*pi)    ; __OUT('Using AMBER AKMA permittivity scaling');
   case('DISCOVER','DISC','DSC','DI')       ; __VAR=one/(eps_discover*four*pi) ; __OUT('Using DISCOVER AKMA permittivity scaling');
   case('NONE', 'ONE')                      ; __VAR=one                        ; __OUT('Assuming permittivity has correct units (no scaling applied)');
   case default                             ; __VAR=atof(keyword)              ; __OUT('Setting permittivity scale to ', __VAR)
  end select
#undef __VAR
!
! check for ionic strength scaling
#define  __VAR kappa_scale
  if (existtag_nocase(__STRING(__VAR),__STRING(__CONTEXT))) then
   keyword=getval_nocase(__STRING(__VAR),__STRING(__CONTEXT))
  else
   __OUT('Ionic strength scaling not specified.')
   keyword='AKMA'
  endif
  call toupper(keyword)
  select case(keyword)
   case('AKMA','CHM','CHRM','CHARM','CHARMM', 'CH') ; __VAR=kappa_akma/(temperature*four*pi) ; __OUT('Using AKMA ionic strength scaling');
   case('NONE', 'ONE')                              ; __VAR=one                              ; __OUT('Assuming ionic strength has correct units (no scaling applied)');
   case default                                     ; __VAR=atof(keyword)                    ; __OUT('Setting ionic strength scale to ', __VAR)
  end select
#ifdef __DEBUG
  __OUT('kappa_scale=',kappa_scale)
#endif
#undef __VAR
!
! charge (rhs) scaling :
#undef __WARNIFMISSING
#define __VAR	charge_scale
#define __NAME	Charge density scaling [-1 for electrostatics]
#include "mol_macro1.src"
#define __WARNIFMISSING
!
! solvent ionic strength
#define __VAR	kappa_solvent
#define __NAME	Solvent molarity
#include "mol_macro1.src"
! solute ionic strength
#define __VAR	kappa_solute
#define __NAME	Solute molarity
#include "mol_macro1.src"
!
!%%%%%%%%%%%%%%%%%%%% padding parameters for grid smoothing %%%%%%%%%%%%%%%%%%%%%%%%%%%%
! charge padding
#undef __LEZEROERR
#define __MINUSERR
#define __VAR	charge_padding
#define __NAME	Charge padding
#include "mol_macro1.src"
! kappa padding
#define __VAR	kappa_padding
#define __NAME	Ionic strength padding
#include "mol_macro1.src"
! epsilon padding
#define __VAR	eps_padding
#define __NAME	Dielectric padding
#include "mol_macro1.src"
! density padding
#define __VAR	surf_padding
#define __NAME	Density padding
#include "mol_macro1.src"
!%%%%%%%%%%%%%% cutoffs beyond which the grid values are assumed to be zero %%%%%%%%%%%%%%%%%%%%%%
! cutoff for dielectric
#define __VAR	cutoff_eps_stdev
#define __NAME	Cutoff for dielectric smoothing
#include "mol_macro1.src"
! cutoff for ionic strength
#define __VAR	cutoff_kappa_stdev
#define __NAME	Cutoff for ionic strength smoothing
#include "mol_macro1.src"
! cutoff for charge 
#define __VAR	cutoff_charge_stdev
#define __NAME	Cutoff for charge smoothing
#include "mol_macro1.src"
! cutoff for density
#define __VAR	cutoff_surf_stdev
#define __NAME	Cutoff for density smoothing
#include "mol_macro1.src"
! GAUSSIAN standard deviations for smoothing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#undef __DEFAULT
#define __COMPUTE
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#define __VAR	stdev_charge
#define __NAME	Gaussian stdev for charge smoothing
#include "mol_macro1.src"
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#define __VAR	stdev_kappa
#define __NAME	Gaussian stdev for ionic strength smoothing
#include "mol_macro1.src"
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#define __VAR	stdev_eps
#define __NAME	Gaussian stdev for dielectric smoothing
#include "mol_macro1.src"
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#define __VAR	stdev_surf
#define __NAME	Gaussian stdev for density smoothing
#include "mol_macro1.src"
!
!%%%%%%%%%%%%%%%%%%%%% compute normalized parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 oo_stdev_charge=1d0/stdev_charge;  oo_stdev_eps=1d0/stdev_eps; oo_stdev_kappa=1d0/stdev_kappa;  oo_stdev_surf=1d0/stdev_surf
! oo_stdev_charge2=oo_stdev_charge**2;oo_stdev_eps2=oo_stdev_eps**2;oo_stdev_surf2=oo_stdev_surf**2;oo_stdev_kappa2=oo_stdev_kappa**2
 cutoff_eps   =cutoff_eps_stdev*stdev_eps
 cutoff_kappa =cutoff_kappa_stdev*stdev_kappa
 cutoff_surf  =cutoff_surf_stdev*stdev_surf
 cutoff_charge=cutoff_charge_stdev*stdev_charge
!%%%%%%%%%%%%%%%%%%%%%%%%%%% done with input parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%
!
  end subroutine molecule_read_parameters
!
!**********************************************************************************
  subroutine molecule_grid_objects(xcen, ycen, zcen, dxcor, dycor, dzcor, eps, kappa, rhs, nx, ny, nz)
!DEC$ ATTRIBUTES FORCEINLINE :: erfo7
!DEC$ ATTRIBUTES FORCEINLINE :: erfo5
! to avoid circular dependencies, need to compile 'molecule' before 'grid', so pass the gridded data explicitly
! use SIZE, only: nx, ny, nz
! use grid, only : xcen, ycen, zcen, dxcor, dycor, dzcor
! use state, only: eps, kappa, rhs
! declare passed parameters (gridded data) -- see above comments
  int :: nx, ny, nz
  float, dimension(nx,ny,nz) :: eps, kappa, rhs
  float, dimension(nx), intent(in) :: xcen, dxcor
  float, dimension(ny), intent(in)  :: ycen, dycor
  float, dimension(nz), intent(in)  :: zcen, dzcor
! local vars
  __IAM(MOLECULE_GRID_OBJECTS)
  int :: l
  int :: i, j, k, ip1, jp1, kp1, im1, jm1, km1, idir, jdir, kdir

  float :: xpt, ypt, zpt,&
           dz2, dzdy2, dzdydx2,&
           d, d2, e, e2, val, qn
!
  float :: reps   , repsn,    r2epsn   , rmax2eps
  float :: rkappa , rkappan,  r2kappan , rmax2kappa
  float :: rcharge, rchargen, r2chargen, rmax2charge
  float :: rsurf  , rsurfn,   r2surfn  , rmax2surf
!
  bool :: qkappai, qkappaj, qkappak,&
          qchargei, qchargej, qchargek,&
          qepsi, qepsj, qepsk,&
          qsurfi, qsurfj, qsurfk,&
          qanyi, qanyj, qanyk
!
  float :: erfsun ! external erf function; code by Sun Microsystems
  float :: erfo7  ! approximation to within O(-7)
  float :: erfo5  ! approximation to within O(-5) [contains an exponential term]
!
  float, parameter :: TOL=1e-5
!
  if (.not.molecule_initialized) call molecule_initialize()
! make sure we have radii
  if (.not.system_radii_initialized) then
    __WRN(whoami, 'Atomic radii not initialized. Abort.')
    return
!  else
!   write(666,*) natom, size(radius), radius
  endif
!
#ifdef __DEBUG
  __OUT('Will transfer atomic parameters to grid.')
#endif
!
! if stdevs are negative, compute from grid :
  d=-1
#ifndef __GRIDSCALE
#define __GRIDSCALE 1.5d0
#endif
!
  if (any((/stdev_eps, stdev_kappa, stdev_charge, stdev_surf/).lt.zero)) d=__GRIDSCALE*min(minval(dxcor),minval(dycor),minval(dzcor))
!
#ifdef __INFO
#undef __INFO
#endif
#define __INFO(_WHAT) call message(whoami, 'COMPUTED SMALLEST '//ftoupper(__STRING(__CONCAT(stdev_,_WHAT)))//' FROM GRID := '//ftoa(d) )

  if (stdev_eps.lt.zero)  then;
   __INFO(eps)
   stdev_eps=d;  cutoff_eps=cutoff_eps_stdev*stdev_eps;  oo_stdev_eps=one/stdev_eps 
  endif
  if (stdev_kappa.lt.zero)  then;
   __INFO(kappa)
   stdev_kappa=d;  cutoff_kappa=cutoff_kappa_stdev*stdev_kappa;  oo_stdev_kappa=one/stdev_kappa
  endif
  if (stdev_charge.lt.zero) then;
   __INFO(charge)
   stdev_charge=d;  cutoff_charge=cutoff_charge_stdev*stdev_charge;  oo_stdev_charge=one/stdev_charge
  endif
  if (stdev_surf.lt.zero) then;
   __INFO(surf)
   stdev_surf=d;  cutoff_surf=cutoff_surf_stdev*stdev_surf;  oo_stdev_surf=one/stdev_surf 
  endif
!  write(0,*) 'STDEV:', oo_stdev_eps, oo_stdev_surf ! aa
!
  if (.not.associated(rho)) allocate(rho(nx,ny,nz))
! initialize all but rhs (so that we can superpose additional sources outside of this module)
  eps=zero
  kappa=zero
  rho=zero
!  do k=1,nz; do j=1, ny; do i=1,nx ;
!                                       eps(i,j,k)=zero; kappa(i,j,k)=zero; rho(i,j,k)=zero; 
!  enddo;     enddo;      enddo;

! gridding
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! 1) for each atom, find the closest gridpoint
  allocate(closest_pt(3,natom));
! begin search in the middle (in the future, can start alternatively from existing closest_pt array)
  i=nx/2; j=ny/2; k=nz/2;
!
! process grid centers (may need to do the same for corner grid to compute gradients (which will defined naturally on the corners)  
!
#ifdef __DEBUG
 __OUT('Found', natom, 'atoms.')
#endif
!
  do l=1, natom
!
   xpt=r(1,l)
   ypt=r(2,l)
   zpt=r(3,l)
#ifdef __DEBUG
 __OUT('Processing atom', l, 'with coordinates', xpt, ypt, zpt, 'charge', q(l), 'and radius', radius(l))
#endif
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% x-
   if ( xpt.gt.xcen(i) ) then 
    do
     ip1=i+1
     if (ip1.eq.nx) then
      call warning(whoami, 'MOLECULE INTERSECTS RIGHT X-GRID BOUNDARY.',-1)
      closest_pt(1,l)=i
      exit
     elseif (xpt.le.xcen(ip1)) then
      closest_pt(1,l)=i
      exit
     endif
     i=ip1
    enddo
!
   else ! xpt.le.xcen(i)
    do
     im1=i-1
     if (im1.eq.1) then
      call warning(whoami, 'MOLECULE INTERSECTS LEFT X-GRID BOUNDARY.',-1)
      closest_pt(1,l)=im1
      exit
     elseif (xpt.ge.xcen(im1)) then
      closest_pt(1,l)=im1
      exit
     endif
     i=im1
    enddo
   endif
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% y-
   if ( ypt.gt.ycen(j) ) then 
    do
     jp1=j+1
     if (jp1.eq.ny) then
      call warning(whoami, 'MOLECULE INTERSECTS RIGHT Y-GRID BOUNDARY.',0)
      closest_pt(2,l)=j
      exit
     elseif (ypt.le.ycen(jp1)) then
      closest_pt(2,l)=j
      exit
     endif
     j=jp1
    enddo
!
   else ! ypt.le.ycen(j)
    do
     jm1=j-1
     if (jm1.eq.1) then
      call warning(whoami, 'MOLECULE INTERSECTS LEFT Y-GRID BOUNDARY.',0)
      closest_pt(2,l)=jm1
      exit
     elseif (ypt.ge.ycen(jm1)) then
      closest_pt(2,l)=jm1
      exit
     endif
     j=jm1
    enddo
   endif
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% z-
   if ( zpt.gt.zcen(k) ) then 
    do
     kp1=k+1
     if (kp1.eq.nz) then
      call warning(whoami, 'MOLECULE INTERSECTS RIGHT Z-GRID BOUNDARY.',0)
      closest_pt(3,l)=k
      exit
     elseif (zpt.le.zcen(kp1)) then
      closest_pt(3,l)=k
      exit
     endif
     k=kp1
    enddo
!
   else ! zpt.le.zcen(k)
    do
     km1=k-1
     if (km1.eq.1) then
      call warning(whoami, 'MOLECULE INTERSECTS LEFT Z-GRID BOUNDARY.',0)
      closest_pt(3,l)=km1
      exit
     elseif (zpt.ge.zcen(km1)) then
      closest_pt(3,l)=km1
      exit
     endif
     k=km1
    enddo
   endif
!
#ifdef __DEBUG
  __OUT('The closest grid point to atom is', closest_pt(1,l), closest_pt(2,l), closest_pt(3,l))
#endif
  enddo ! over all atoms
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! loop over all points in the vicinity of the closest point (defined by distance) 
  do l=1, natom ! this loop should be parallelized
   xpt=r(1,l)
   ypt=r(2,l)
   zpt=r(3,l)
!
!  write(777,*) radius(l), q(l) ! aa
!  write(888,*) r(:,l), radius(l), closest_pt(:,l) ! aa; coords correct
! precomputation of parameters for the smoothed densities
   reps=   (radius(l)+eps_padding   );  repsn   =reps    * oo_stdev_eps   ! normalize by stdev
   rkappa= (radius(l)+kappa_padding );  rkappan =rkappa  * oo_stdev_kappa
   rcharge=(radius(l)+charge_padding);  rchargen=rcharge * oo_stdev_charge
   rsurf  =(radius(l)+surf_padding  );  rsurfn  =rsurf   * oo_stdev_surf
!
!   r2epsn   =repsn   **2
!   r2kappan =rkappan **2
!   r2chargen=rchargen**2
!   r2surfn  =rsurfn  **2
!
   rmax2eps   =(cutoff_eps   +reps   )**2
   rmax2kappa =(cutoff_kappa +rkappa )**2
   rmax2charge=(cutoff_charge+rcharge)**2
   rmax2surf  =(cutoff_surf  +rsurf  )**2
#ifdef __DEBUG
 __OUT('Maximum radius for gridding epsilon for atom', l, 'is', rmax2eps)
 __OUT('Maximum radius for gridding charge for atom', l, 'is', rmax2charge)
#endif
! compute nominal charge density ( nominal because it will not be accurate on the grid and will need correction )
! note that this procedure holds only if rcharge > 0 ; in the case rcharge -> 0, note that we are actually
! computing [ qn * G(r) ] below, so we can take the limit of this expression (which could also be used
! if r is infinitesimal but positive
   if ( rchargen .gt. TOL ) then ! note normalization by stdev
    qn=q(l) * three / (four * pi * rcharge **3 ) ! so that the density qn integrated over the sphere gives the charge q(l)
   else
    qn=q(l)
   endif
!
   do kdir=-1,1,2 ! directions 
    k=closest_pt(3,l)+(kdir+1)/2; ! when kdir = 1, shift to the the right relative to closest point, but not when kdir=-1
    qepsk=.true.; qkappak=.true.; qchargek=.true.; qsurfk=.true.
    do
! z-grid OOB test:
     if ((k.ge.nz).or.(k.le.1)) then 
      call warning(whoami, 'SMOOTHED MOLECULE CROSSES Z-GRID BOUNDARY.',0)
      call warning(whoami, 'ATOM #'//itoa(l)//' located at ('//trim(ftoa(xpt))//trim(ftoa(ypt))//trim(ftoa(zpt))//'); gridpoint '//itoa(k)//' of '//itoa(nz),0)
      exit
     endif
!
     dz2=(zcen(k)-zpt)**2
!     k range test:
     if (qepsk)    qepsk=(dz2.lt.rmax2eps)
     if (qkappak)  qkappak=(dz2.lt.rmax2kappa)
     if (qchargek) qchargek=(dz2.lt.rmax2charge)
     if (qsurfk)   qsurfk=(dz2.lt.rmax2surf  )
     qanyk = qepsk .or. qkappak .or. qchargek .or. qsurfk
     if (.not.( qanyk )) exit
!
     do jdir=-1,1,2 
      j=closest_pt(2,l)+(jdir+1)/2;
      qepsj=qepsk; qkappaj=qkappak; qchargej=qchargek; qsurfj=qsurfk
      do
! y-grid OOB test:
       if ((j.ge.ny).or.(j.le.1)) then 
        call warning(whoami, 'SMOOTHED MOLECULE CROSSES Y-GRID BOUNDARY.',0)
        call warning(whoami, 'ATOM #'//itoa(l)//' located at ('//trim(ftoa(xpt))//trim(ftoa(ypt))//trim(ftoa(zpt))//'); gridpoint '//itoa(j)//' of '//itoa(ny),0)
        exit
       endif
!
       dzdy2=dz2+(ycen(j)-ypt)**2
!     j range test:
       if (qepsj)    qepsj=(dzdy2.lt.rmax2eps)
       if (qkappaj)  qkappaj=(dzdy2.lt.rmax2kappa)
       if (qchargej) qchargej=(dzdy2.lt.rmax2charge)
       if (qsurfj)   qsurfj=(dzdy2.lt.rmax2surf  )
       qanyj = qepsj .or. qkappaj .or. qchargej .or. qsurfj
       if (.not.( qanyj )) exit
!
       do idir=-1,1,2 
        i=closest_pt(1,l)+(idir+1)/2;
        qepsi=qepsj; qkappai=qkappaj; qchargei=qchargej; qsurfi=qsurfj
        do
! x-grid OOB test:
         if ((i.ge.nx).or.(i.le.1)) then 
          call warning(whoami, 'SMOOTHED MOLECULE CROSSES X-GRID BOUNDARY.',0)
          call warning(whoami, 'ATOM #'//itoa(l)//' located at ('//trim(ftoa(xpt))//trim(ftoa(ypt))//trim(ftoa(zpt))//'); gridpoint '//itoa(i)//' of '//itoa(nx),0)
          exit
         endif
!
         dzdydx2=dzdy2+(xcen(i)-xpt)**2
!     i range test:
         if (qepsi)    qepsi=(dzdydx2.lt.rmax2eps)
         if (qkappai)  qkappai=(dzdydx2.lt.rmax2kappa)
         if (qchargei) qchargei=(dzdydx2.lt.rmax2charge)
         if (qsurfi)   qsurfi=(dzdydx2.lt.rmax2surf  )
         qanyi = qepsi .or. qkappai .or. qchargei .or. qsurfi
         if (.not.( qanyi )) exit
         d=sqrt(dzdydx2)
!
#ifndef __erf
#define __erf erf
#endif
#define __SMOOTH_GAUSS(__A,__B,__C)half * ( __erf (__A) - __erf (__B) ) + osq2pi*( exp(-(__A)**2) - exp(-(__B)**2 ) ) /(__C)
#ifdef __REGULARIZE
#define __SMOOTH_GAUSS_C0(__A,__B) half * ( __erf (__A) - __erf (__B) ) - osq2pi* exp( -half * ((__A)**2+(__B)**2)) \
        * osq2 * ((__A) - (__B)) * (two+third*(half * ((__A)**2-(__B)**2))**2)
#endif
#ifndef __TRUNCATEVAL
#define __TRUNCATEVAL 1.0
#endif
!#undef __TRUNCATESUMS
! grid epsilon %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         if (qepsi &
#ifdef __TRUNCATESUMS
                     .and. ( eps(i,j,k) .lt. __TRUNCATEVAL   ) &
#endif
         ) then ! do not compute if cutoff exceeded in previous iteration
! compute atomic contribution to mesh point
           d2=d*oo_stdev_eps ; e  = osq2 * (d2 + repsn) ; e2= osq2 * (d2 - repsn)
!
#ifdef __REGULARIZE
           if ( d2 .lt. TOL ) then ! Taylor expansion for exponentials
            val=__SMOOTH_GAUSS_C0(e,e2)
           else
#endif
            val=__SMOOTH_GAUSS(e,e2,d2)
#ifdef __REGULARIZE
           endif
#endif
#ifdef __DDEBUG
       __OUT('Atom', l, 'makes a contribution of', val, 'to eps array at point', i, j, k)
#endif
!
           __INCR(eps(i,j,k), val) ! scale to correct levels later
!
! this is the convolution of a normalized gaussian with stdev sigma with a function that changes across the boundary of
! a sphere of the given atomic radius (function values depend on the property: charge, surf, kappa, eps)
         endif ! epsilon
! grid kappa %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         if (qkappai &
#ifdef __TRUNCATESUMS
                     .and. ( kappa(i,j,k) .lt. __TRUNCATEVAL   ) &
#endif
         ) then ! do not compute if cutoff exceeded in previous iteration
! compute atomic contribution to mesh point
           d2=d*oo_stdev_kappa ; e  = osq2 * (d2 + rkappan) ; e2= osq2 * (d2 - rkappan)
!
#ifdef __REGULARIZE
           if ( d2 .lt. TOL ) then ! Taylor expansion for exponentials
            val=__SMOOTH_GAUSS_C0(e,e2)
           else
#endif
            val=__SMOOTH_GAUSS(e,e2,d2)
#ifdef __REGULARIZE
           endif
#endif
!
           __INCR(kappa(i,j,k), val)
         endif ! kappa
! grid charges %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         if (qchargei) then ! do not compute if cutoff exceeded in previous iteration
! compute atomic contribution to mesh point
           d2=d*oo_stdev_charge ; e  = osq2 * (d2 + rchargen) ; e2= osq2 * (d2 - rchargen)
!
           if (rchargen .gt. TOL) then
#ifdef __REGULARIZE
            if ( d2 .lt. TOL ) then ! Taylor expansion for exponentials
             val=__SMOOTH_GAUSS_C0(e,e2)
            else
#endif
             val=__SMOOTH_GAUSS(e,e2,d2)
#ifdef __REGULARIZE
        endif
#endif
           else ! Gaussian asymptote
            val =  (osq2pi*oo_stdev_charge)**3 * exp(-half*d2**2) * (one + tenth * rchargen**2 * (d2**2 - three))
           endif
#ifdef __DEBUG
       __OUT('Atom', l, 'makes a contribution of', val, 'to rhs array at point', i, j, k)
#endif
!
           __INCR(rhs(i,j,k), val * qn) ! qn is nominal charge density: q / ( 4/3pi r^3 ), or q(l) [if unit mass]
         endif ! charge
! grid surface %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         if (qsurfi &
! this is probably not a good idea if the surface derivatives are needed
!#ifdef __TRUNCATESUMS
!                     .and. ( rho(i,j,k) .lt. __TRUNCATEVAL   ) &
!#endif
         ) then ! do not compute if cutoff exceeded in previous iteration
! compute atomic contribution to mesh point
           d2=d*oo_stdev_surf ; e  = osq2 * (d2 + rsurfn) ; e2= osq2 * (d2 - rsurfn)
!
#ifdef __REGULARIZE
           if ( d2 .lt. TOL ) then ! Taylor expansion for exponentials
            val=__SMOOTH_GAUSS_C0(e,e2)
           else
#endif
            val=__SMOOTH_GAUSS(e,e2,d2)
#ifdef __REGULARIZE
           endif
#endif
!
           __INCR(rho(i,j,k), val) ! density: 1 inside sphere, 0 outside sphere
!
         endif ! surface
!
         i=i+idir
        enddo ! over i
       enddo ! idir changes from -1 to 1
!
       j=j+jdir
      enddo
     enddo ! jdir changes from -1 to 1
!
     k=k+kdir
    enddo
   enddo ! kdir changes from -1 to 1
!if (l.eq.100) exit ! aa -- grid a few atoms
  enddo ! over all atoms
!
! 3) Need to scale gridded coefficients so that they add up correctly
!    The most straightforward and, perhaps, correct way to do this is
!    to keep track of the grid points that support a given charge, and 
!    scale all of them uniformly so that the charge density integrated over this support 
!    integrates to the charge.
!    Another approach, which is adopted below, is to scale all of the 
!    grid values uniformly so that the charge density integrated over the entire domain
!    adds up to the total charge
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! scale charges uniformly
  qn=0d0  ! total grid charge
! scaling factors for kappa and eps
  d =eps_scale*(eps_solute-eps_solvent)
  e =eps_solvent*eps_scale
  d2=kappa_scale*(kappa_solute-kappa_solvent)
  e2=kappa_solvent*kappa_scale
!
  do k=2, nz-1 
   dz2=dzcor(k)
   do j=2, ny-1 
    dzdy2=dz2*dycor(j)
    do i=2, nx-1
!
     __INCR( qn , rhs(i,j,k) * dxcor(i) * dzdy2 ) ! charge integral
!
! scale rho, eps and kappa
!%%%%%%%%%%%%%%%%%%%%%%%%%
! surface
!     if (rho(i,j,k).gt.one) rho(i,j,k)=one
     rho(i,j,k)=min(rho(i,j,k),one)
! dielectric
!     if (eps(i,j,k).gt.one) eps(i,j,k)=one
      eps(i,j,k)=min(eps(i,j,k),one)
     eps(i,j,k)=eps  (i,j,k) * d  + e
! ionic strength
!     if (kappa(i,j,k).gt.one) kappa(i,j,k)=one 
     kappa(i,j,k)=min(kappa(i,j,k),one)
     kappa(i,j,k)=kappa(i,j,k) * d2 + e2
!
!%%%%%%%%%%%%%%%%%%%%%%%%%
    enddo 
    eps(1,j,k)    = eps(1,j,k)*d     + e
    eps(nx,j,k)   = eps(nx,j,k)*d    + e
    kappa(1,j,k)  = kappa(1,j,k)*d2  + e2
    kappa(nx,j,k) = kappa(nx,j,k)*d2 + e2
   enddo
!
   do i=1,nx
    eps(i,1,k)    = eps(i,1,k)*d     + e
    eps(i,ny,k)   = eps(i,ny,k)*d    + e
    kappa(i,1,k)  = kappa(i,1,k)*d2  + e2
    kappa(i,ny,k) = kappa(i,ny,k)*d2 + e2
   enddo
!
  enddo
!
  do j=1,ny ; do i=1,nx
   eps(i,j,1)   = eps(i,j,1)*d    + e;      eps(i,j,nz)   = eps(i,j,nz)*d    + e
   kappa(i,j,1) = kappa(i,j,1)*d2 + e2;     kappa(i,j,nz) = kappa(i,j,nz)*d2 + e2
  enddo     ; enddo
!
  __SCALE(rhs, charge_scale * sum(q) / qn); ! preserve total charge and apply charge scaling, if any
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

! done !

  end subroutine molecule_grid_objects
!**********************************************************************************
  subroutine molecule_initialize()
  call system_initialize() ; molecule_initialized=system_initialized
#ifdef __DEBUG
  __MESG('molecule_initialize', molecule_initialized)
#endif
  end subroutine molecule_initialize
!***********************************************************************************
  subroutine molecule_center(rcen, qmass)
  use sysmanip
  use sysinfo
  float :: dimens(ndim,3)
  float :: rcen(3)
  bool :: qmass
!
  if (.not. molecule_initialized) call molecule_initialize()
!
  dimens=sysinfo_dimens(qmass,(/iminusone/)) ! last argument is an array of length 1
  call sysmanip_translate(rcen-dimens(1:ndim,1),(/iminusone/))
!
  end subroutine molecule_center
!***********************************************************************************
  subroutine molecule_align(qmass)
  use sysmanip
  use sysinfo
  bool :: qmass
!
  if (.not. molecule_initialized) call molecule_initialize()
!
  call sysmanip_align_pc(qmass,(/iminusone/),(/iminusone/))! align the principal components of the molecule with the Cartesian vectors  
!
  end subroutine molecule_align
!***********************************************************************************
  function molecule_dimens()
  use sysinfo
  float :: molecule_dimens(ndim,3)
  float :: pad
!
  if (.not. molecule_initialized) call molecule_initialize()
!
  molecule_dimens=sysinfo_dimens(.false.,(/iminusone/)) ! last argument is an array of length 1
! increase maximum coordinate values computed above by the padding
  pad=max(eps_padding+cutoff_eps, kappa_padding+cutoff_kappa, charge_padding+cutoff_charge, surf_padding+cutoff_surf)
  molecule_dimens(:,2)=molecule_dimens(:,2)-pad;
  molecule_dimens(:,3)=molecule_dimens(:,3)+pad;
!
  end function molecule_dimens
!
!***********************************************************************************
  int function molecule_ndim()
  molecule_ndim=ndim
  end function molecule_ndim
!***********************************************************************************
  subroutine molecule_done()
  molecule_initialized=.false.
  if (allocated(closest_pt)) deallocate(closest_pt)
  if (associated(rho)) deallocate(rho)
  call system_done()
  end subroutine molecule_done
!***********************************************************************************
end module molecule
