#!/bin/bash
# use chest to compute ion solvation energies, for comparison with Honig 1985, JPC, 89, 5588.
# the parameters used here should correcpond to the matlab code in honig85
#
# write and compile postprocessing routine (once only)
tmpfile="tmp.dat"
echo -n > $tmpfile
. ./fcheck "$1" "$2" "$3" ;# execute script in the current context

nx=34; ny=34; nz=34;
nx=50; ny=50; nz=50;
#nx=66; ny=66; nz=66;
#nx=98; ny=98; nz=98;
#nx=130; ny=130; nz=130;
l=7; # box half-length
xstretch=1.0; x0=-$l; x1=$l
ystretch=1.0; y0=-$l; y1=$l
zstretch=1.0; z0=-$l; z1=$l
echo "
 implicit none
 float, dimension($nx,$ny,$nz)  :: uches, rhs
 float :: grid($nx,$ny,$nz,3)
 float :: e, totq
 integer :: i, j, k
 float, parameter :: dx=1d0*(${x1} - ${x0})/(${nx}-2)
 float, parameter :: dy=1d0*(${y1} - ${y0})/(${ny}-2)
 float, parameter :: dz=1d0*(${z1} - ${z0})/(${nz}-2)
!
 open(1,file='solution.dat',form='formatted', status='old')
 read(1,*)
 read(1,*)
 read(1,*) uches
 close(1)
 open(1,file='rhs.dat',form='formatted', status='old')
 read(1,*)
 read(1,*)
 read(1,*) rhs
 close(1)
 totq=-sum ( rhs(2:$nx-1,2:$ny-1,2:$nz-1) ) * dx * dy * dz
 e=0.5d0 * sum ( uches(2:$nx-1,2:$ny-1,2:$nz-1) * rhs(2:$nx-1,2:$ny-1,2:$nz-1)) * dx * dy * dz
 write(6,'(F25.12)') e
 write(6,'(F25.12)') totq
 end " > post.F90
#
$FC $FFLAGS $DEFS post.F90 -o post
#
radii=(1.316 1.680 2.172 2.311 2.514 1.423 1.937 2.087 2.343 1.252 1.434 1.252 1.455 1.862 2.054 2.119 1.338 1.509 1.541 1.338 1.541 1.733 1.808 1.761 1.761 1.338 1.605 2.130 1.498 1.969 1.969)
charges=(1 1 1 1 1 -1 -1 -1 -1 1 1 2 2 2 2 2 2 2 2 3 3 3 3 4 3 3 3 1 -1 -2 -1)
nq=${#radii[@]}

omega=1.44 # SOR acceleration
ein=1 ;  # scaled permittivity inside
#eout=80 ;# scaled permittivity outside
#eout=1 ;# scaled permittivity outside

s=0.4; # standard deviation
pad=1.142; # radius padding
#
# write ion parameters to pqr file
# compute center :
xc=`echo "scale=6 ; 0.5*($x0 + $x1)" | bc`
yc=`echo "scale=6 ; 0.5*($y0 + $y1)" | bc`
zc=`echo "scale=6 ; 0.5*($z0 + $z1)" | bc`
#
# prepare input file for CHES
for iq in `seq 0 $((nq-1))`; do
R=${radii[$iq]}
Q=${charges[$iq]}
echo -n "
REMARK SINGLE ION
PQR FORMAT
ATOM 1 Q ION 1 $xc $yc $zc ${Q} 0.00
" > ion.pqr
rpad=`echo "$R + $pad" | bc -l `; # padded radius
#for eout in 80 1; do # two permittivities for dg
#for eout in 1 79.9 80 80.1; do # four permittivities for dh, computed usign FD
for eout in 1 80; do # four permittivities for dh, computed usign FD
#
echo " Preparing input file..."
echo "\
!charmm
continuum {
#Size
 nx=${nx}; ny=${ny}; nz=${nz}

#Grid

 xgrid=exp; xstretch=${xstretch}; x0=${x0}; x1=${x1}
 ygrid=exp; ystretch=${ystretch}; y0=${y0}; y1=${y1}
 zgrid=exp; zstretch=${zstretch}; z0=${z0}; z1=${z1}

#Continuum output options
 output_format=plot3d
 output_mode=text
 gridoutput=xyz_test.xyz

# exec:output
}

#Communicators
multicom {
 exec:set ches 1
}

object {
 object=molecule
}

molecule {
 structype=PQR ! note : would be good to have multple ways/keywords of specifying
 structure=ion.pqr ! note that this file should have a single charge with radius 0 (unit mass)
 kappa_solute=0 ! note that could skip gaussian gridding if solute/solvent values are same
 kappa_solvent=0
 eps_solute=${ein}
 eps_solvent=${eout}
 eps_scale=charmm
# eps_scale=${eps0}
 eps_padding=${rpad} ! this is added to the radius to compute the eps array
 charge_padding=0 ! added to radius to compute smoothed right-hand-side
 stdev_eps=${s} ! might be worthwhile to be able to set a single stdev
 stdev_charge=${s}
 cutoff_eps_stdev=10 ! does not seem to make much difference
 cutoff_charge_stdev=5
}

ches {
# BC
! phi_bcx0=dirichlet; phi_bcx0_const=0
! phi_bcx1=dirichlet; phi_bcx1_const=0
! phi_bcy0=dirichlet; phi_bcy0_const=0
! phi_bcy1=dirichlet; phi_bcy1_const=0
! phi_bcz0=dirichlet; phi_bcz0_const=0
! phi_bcz1=dirichlet; phi_bcz1_const=0
 phi_bcx0=object
 phi_bcx1=object
 phi_bcy0=object
 phi_bcy1=object
 phi_bcz0=object
 phi_bcz1=object

#Initial 3D data

! note : object init gives error of ~0.005 vs 0.00004 for direct init ; using gridded eps reduces error to 0.00004 (with charge cutoff=5)
! so the problem is with eps gridding. Investigate !
! perhaps need to compare the arrays. (NOTE: increasing filtering cutoff does not help)
 epsinit=object
 kappainit=constant ; kappaconst=0.
 rhsinit=object
 phiinit=constant   ; phiconst=0. % initial solution

#Solver
 solver=multigrid

#Output
 output_format=plot3d
 output_mode=text
 phioutput=solution.dat
! epsoutput=eps.dat
 rhsoutput=rhs.dat

#Execution
 exec:init
 exec:solve
 exec:output
 exec:done
} ! ches

multigrid {
# multigrid solver parameters
 multigrid_maximum_cycles=4
# multigrid_smooth_iterations=4
# multigrid_maximum_levels=4
# multigrid_smoother=Jacobi
 multigrid_residual=1e-4 # for shorter running times
# multigrid_smoother=Jacobi-Tiled-LM
# multigrid_compute_ini_residual=no
# multigrid_skip_convergence_test=1
# multigrid_smoother_unroll=-1
 multigrid_omega=$omega
}

" > test.dat
if !([ -L ches ]); then
ln -s ../ches .
fi
echo " Running CHES..."
#echo " ********************************************************************************************"
ulimit -s unlimited
./ches < test.dat #>/dev/null
#
# compute potential energy from rhs and solution
#
j=0
for f in `./post`; do
 i[$j]=$f
 j=$(($j+1))
done
#echo " Total charge is ${i[1]} " >> $tmpfile
#echo " The electrostatic energy is ${i[0]}" >> $tmpfile
echo " Total charge is ${i[1]} "
echo -n "${i[0]} " >> $tmpfile
done # eps
echo >>$tmpfile ;#newline
f=(`cat $tmpfile`);
cat $tmpfile
echo ${f[1]} - ${f[0]} | bc -l
exit
done # ions

cat $tmpfile
#rm -f post;
