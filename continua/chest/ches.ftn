      module ches ! (Cartesian Helmholtz Equation Solver)
! 2010-2012 Victor Ovchinnikov (ovchinnv_at_georgetown_dot_edu)
! Free for academic use
! Most of the source code is distributed 
! under the GNU General Public License
! certain parts of the code are under restricted license
!
!    include other modules
      use datatypes
      use state     ! main physical variables
      __DEP_PARSER    ! parses input unit and stores input parameters
      use SIZE      ! basic size information
      use grid      ! grid module
      __DEP_OUTPUT    ! runtime output
      use object    ! objects that modify problem coefficients
!      use plot3Dio ! output in plot3D (CFD) format; compile as a library, not as a module
      use multigrid ! multigrid solver module
!      use openDXio ! output in openDX format ; not implemented yet
      __IMPNONE
!**************************************************************************************
!     routines:
      public ches_init
      public ches_done
      public ches_solve
      public ches_output
!
!     variables:
!
      bool :: ches_initialized=.false.
      character(len=16), parameter, private :: ctx=__CHESCTX
      type(varray3df), pointer :: p_, eps_, kappa_, rhs_
!
      contains
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       subroutine ches_init( &
#ifdef __PARALLEL
     &  comm )
       __DEP_MPI
#else
     &)
#endif
       use files
       use fieldbcdef
!
#ifdef __PARALLEL
       int4mpi, optional :: comm
       int4mpi :: bug
#endif
       int :: numarg 
       character(len=80) :: filename, fname, keyword
       int :: flen
       int :: fid=-1 
       bool :: qcomm
       int :: i
!
       character(len=9), parameter :: whoami='CHES_INIT'
!
#ifdef __PARALLEL
       qcomm=present(comm)
       if (qcomm) call MPI_COMM_RANK(comm, me, bug)
#else
       qcomm=.false.
#endif
! *********************************************************************************************************
! * INITIALIZATION
! *
!    check that the size module is initialized
       if (.not. size_initialized) then
        call size_initialize()
       endif
!    check that Cartesian grid and metrics are initialized
       if (.not. grid_initialized) then
        call message(whoami, 'Initializing grid variables.');
        call grid_initialize()
       endif
!    initialize state variables
       call message(whoami, 'Initializing state variables.');
!
       call state_add3df('PHI'  ,'Electrostatic Potential' , ctx, vptr=p_)
       call state_add3df('EPS'  ,'Dielectric Constant'     , ctx, vptr=eps_)
       call state_add3df('KAPPA','Ionic Strength Parameter', ctx, vptr=kappa_)
       call state_add3df('RHS'  ,'Source Density Vector'   , ctx, vptr=rhs_)
! add more variables here as needed
!
!    initialize boundary conditions
       call message(whoami, 'Initializing boundary condition variables.');
!
       call state_bc_add3df('PHI', ctx, left )   ;   call state_bc_add3df('PHI', ctx, right )
       call state_bc_add3df('PHI', ctx, bottom ) ;   call state_bc_add3df('PHI', ctx, top )
       if (.not.q2D) then
        call state_bc_add3df('PHI', ctx, front ) ;   call state_bc_add3df('PHI', ctx, back )
       endif
!
!    check whether object specified; if so, initialize
       if     (existtag('OBJECT',ctx) .or. existtag('object',ctx)) then 
!    check if the object has not yet been initialized (as could happen via grid module above); if not, initialize
        if (.not. object_initialized) then 
         call message(whoami, 'Initializing object.');
         call object_init()
        endif
       endif
!
!      at present, there are no cases in which a solution does not involve an object
!
!    object dependent properties
       if (object_initialized) then
        call message(whoami, 'Reading object parameters.');
        call object_read_parameters()
        if (.not.size_initialized) then 
         call warning(whoami, 'Size not initialized.',-1);
        elseif (.not.grid_initialized) then 
         call warning(whoami, 'Grid not initialized.',-1);
        elseif (.not.state_initialized) then
         call warning(whoami, 'State variables not initialized.',-1);
        else
         call message(whoami, 'Computing gridded parameters.');
         call object_grid_objects( xcen, ycen, zcen, dxcor, dycor, dzcor, state_get3df('EPS'), state_get3df('KAPPA'), state_get3df('RHS'), nx, ny, nz )
        endif
!
        if (qcomm) then 
#ifdef __PARALLEL
         if (fatal_warning(comm)) call terminate(whoami)
#else
/* nothing */
#endif
        else
         if (fatal_warning()) call terminate(whoami)
        endif
       endif
!
       ches_initialized=.true.
!
       end subroutine ches_init
!************************************************************************************
       subroutine ches_solve()
!
       character(len=20) :: solver
!
!    initialize multigrid solver, if requested
!
       character(len=8), parameter :: whoami='ches_SOLVE'
!
!    the proper way to terminate run if error occurs on some processors (but not all)
       if (.not. ches_initialized) call warning(whoami, 'POISSON_BOLTZMANN MODULE NOT INITIALIZED.',-1)
       if (fatal_warning(__COMM)) call terminate(whoami)
!
       if     (existtag('SOLVER',ctx)) then ; solver=getval('SOLVER',ctx); call toupper(solver);
       elseif (existtag('solver',ctx)) then ; solver=getval('solver',ctx); call toupper(solver); 
       else ; ! no solver defined
        call warning(whoami, 'No solver specified. Nothing done.',0);
        return
       endif
!
! special case: NONE - skip solution
!
       if (solver.eq.'NONE') return
!
! if still here, attempt to call solver
!
       select case(solver)
!*********************************************************************************!
#define __NM MULTIGRID
#define __ARGS p_, eps_, kappa_, rhs_
#include "macro1.def"
!*********************************************************************************!
       case default;
        call warning(whoami, 'Unknown solver '//solver(1:len_trim(solver))//' specified. Nothing done.',-1);
       end select
!
       end subroutine ches_solve
!*********************************************************************************!
       subroutine ches_output()
       use object, only : object_surface_pointer, object_initialized
       use formats
!
       character(len=9), parameter :: whoami='CHES_OUTPUT'
       int :: ifmt=plot3d
       bool :: qbin ! whether binary output is used
       float, pointer, dimension(:,:,:) :: surf, eps, kappa, rhs, p
       int :: i
!
       character(len=80) :: filename, output_format, output_mode
!
       p=>state_get3df('phi', ctx)
       eps=>state_get3df('eps', ctx)
       kappa=>state_get3df('kappa', ctx)
       rhs=>state_get3df('rhs', ctx)
!
       if (existtag_nocase('output_format', ctx)) then 
        output_format=getval_nocase_upper('output_format', ctx);
        ifmt=-999
        do i=1,num_fmt
         if (output_format.eq.format_name(i)) then 
          ifmt=i
          exit
         endif
        enddo
       endif
!
       if (ifmt.gt.0) then
        call message(whoami,format_name(ifmt)(1:len_trim(format_name(ifmt)))//' format will be used for output');
       else
        call warning(whoami,'Format "'//output_format(1:len_trim(output_format))//'" is not recognized',0)
        return
       endif
!
       if (existtag_nocase('output_mode', ctx)) then
        output_mode=getval_nocase('output_mode', ctx)
        select case(output_mode);
         case('BINARY', 'BIN', 'binary', 'bin'); 
          call message(whoami,'Using binary mode');
          qbin=.true.
         case('ASCII', 'TEXT', 'ascii', 'text'); 
          call message(whoami,'Using ASCII mode');
          qbin=.false.
         case default
          call warning(whoami,'Unknown output mode "'//output_mode(1:len_trim(output_mode))//'". Will use ASCII',0);
          qbin=.false.
        end select
       else
        call message(whoami,'Using ASCII mode');
        qbin=.false.
       endif
!
       if (existtag_nocase('epsoutput', ctx)) then
        filename=getval_nocase('epsoutput', ctx)
        call message(whoami,'Writing dielectric to file "'//filename(1:len_trim(filename))//'"');
        select case(ifmt)
         case(plot3d); call plot3Dwrite_scalar(filename,eps,nx,ny,nz,1,qbin)
        end select
       endif
!
       if (existtag_nocase('kappaoutput', ctx)) then
        filename=getval_nocase('kappaoutput', ctx)
        call message(whoami,'Writing ionic strength to file "'//filename(1:len_trim(filename))//'"');
        select case(ifmt)
         case(plot3d); call plot3Dwrite_scalar(filename,kappa,nx,ny,nz,1,qbin)
        end select
       endif
!
       if (existtag_nocase('chargeoutput', ctx)) then
        filename=getval_nocase('chargeoutput', ctx)
        call message(whoami,'Writing source density to file "'//filename(1:len_trim(filename))//'"');
        select case(ifmt)
         case(plot3d); call plot3Dwrite_scalar(filename,rhs,nx,ny,nz,1,qbin)
        end select
       endif
!
       if (existtag_nocase('potoutput', ctx)) then
        filename=getval_nocase('potoutput', ctx)
        call message(whoami,'Writing potential to file "'//filename(1:len_trim(filename))//'"');
        select case(ifmt)
         case(plot3d); call plot3Dwrite_scalar(filename,p,nx,ny,nz,1,qbin)
        end select
       endif
!
!    check for surface output options
!
       if (existtag_nocase('surfoutput', ctx).or.existtag_nocase('alloutput', ctx)) then
        nullify(surf)
        if (object_initialized) then 
         surf=>object_surface_pointer()
         if (.not.associated(surf)) then
          call warning(whoami, 'Object initialized but shape density is null. Will output zero.',0)
          allocate(surf(nx,ny,nz)); surf=0d0
         endif
        else
         call warning(whoami, 'Object not initialized. Shape density is everywhere zero.',0)
         allocate(surf(nx,ny,nz)); surf=0d0
        endif
       endif
!
       if (existtag_nocase('surfoutput', ctx)) then
        filename=getval_nocase('surfoutput', ctx)
        call message(whoami,'Writing shape density to file "'//filename(1:len_trim(filename))//'"');
        select case(ifmt)
         case(plot3d); call plot3Dwrite_scalar(filename,surf,nx,ny,nz,1,qbin)
        end select
       endif
!
!    plot five (four in 2D)  variables that correspond to the plot3D "solution"
       if (existtag_nocase('alloutput', ctx)) then
        filename=getval_nocase('alloutput', ctx)
        call message(whoami,'Writing data and solution [EPS(1),K(2),RHS(3),P(4),RHO(5)] to file "'&
&                                                       //filename(1:len_trim(filename))//'"')
        select case(ifmt)
         case(plot3d); 
          call plot3Dwrite_solution(filename,eps,kappa,rhs,p,surf,nx,ny,nz,1,qbin)
        end select
       endif
!
!    destroy surf, if needed
       if (existtag_nocase('surfoutput', ctx).or.existtag_nocase('alloutput', ctx)) then
        if (.not.object_initialized) then ; deallocate(surf)
        elseif (.not.associated(object_surface_pointer())) then ; deallocate(surf)
        endif
       endif
!
       if (existtag_nocase('gridoutput', ctx)) then
        filename=getval_nocase('gridoutput', ctx)
        call message(whoami,'Writing grid to file "'//filename(1:len_trim(filename))//'"');
        select case(ifmt)
         case(plot3d); call plot3Dwrite_grid(filename,xcen,ycen,zcen,nx,ny,nz,1,qbin)
        end select
       endif
!
       end subroutine ches_output
!*********************************************************************************!
       subroutine ches_done()
!
       character(len=7), parameter :: whoami='CHES_DONE'
       character(len=20) :: solver
!
       if (existtag('OBJECT', ctx) .or. existtag('object', ctx)) then 
        if (object_initialized) then 
         call object_done()
        endif
       endif
!
       if     (existtag('SOLVER', ctx)) then ; solver=getval('SOLVER', ctx); call toupper(solver);
       elseif (existtag('solver', ctx)) then ; solver=getval('solver', ctx); call toupper(solver); 
       else
        ches_initialized=.false.
        return
       endif
! special case: NONE -- do nothing
       if (solver.eq.'NONE') then 
        ches_initialized=.false.
        return
       endif
!
       select case(solver)
!*********************************************************************************!
#define __NM MULTIGRID
#include "macro2.def"
!*********************************************************************************!
       end select
!
       ches_initialized=.false.
!
       end subroutine ches_done
!*********************************************************************************!
       end module chesmain
