! data description from VMD :
!  
!  DX potential maps
! 
!  Format of the file is:
!  # Comments
!  .
!  .
!  .
!  object 1 class gridpositions counts xn yn zn
!  origin xorg yorg zorg
!  delta xdel 0 0
!  delta 0 ydel 0
!  delta 0 0 zdel
!  object 2 class gridconnections counts xn yn zn
!  object 3 class array type double rank 0 items { xn*yn*zn } [binary] data follows
!  f1 f2 f3
!  f4 f5 f6 f7 f8 f9
!  .
!  .
!  .
!  object "Dataset name" class field
! 
!  Where xn, yn, and zn are the number of data points along each axis;
!  xorg, yorg, and zorg is the origin of the grid, assumed to be in angstroms;
!  xdel, ydel, and zdel are the scaling factors to convert grid units to
!  angstroms.
! 
!  Grid data follows, with a single or multiple values per line (maximum 
!  allowed linelength is hardcoded into the plugin with ~2000 chars), 
!  ordered z fast, y medium, and x slow.
! 
!  Note that the ordering of grid data in VMD's VolumetricData class
!  is transposed, i.e. x changes fastest and z slowest! 
!  The file reading and writing routines perform the transpose.
! 
!  If the optional keyword 'binary' is present, the data is expected to
!  be in binary, native endian, single precision IEEE-754 floating point format.
! 
!  Note: this plugin was written to read the OpenDX files created by the
!  APBS program, and thus supports only files that are writting in this style.
!  the full OpenDX data format is extremely powerful, complex, and flexible.
!
#ifdef __PARALLEL
#define __COMM communicator
#else
#define __COMM
#endif
#define _N opendx
!
 module __CONCAT(_N,io)
!
 character(len=6), parameter :: double_format='G22.15'
 character(len=6), parameter :: single_format='G16.8 '
#ifdef __SINGLE
 character(len=6), parameter :: float_format=single_format
#else
 character(len=6), parameter :: float_format=double_format
#endif 

 contains
! routines that create datafiles compatible with the openDX format
!==============================================================
#define _NAME __NM(write_scalar)
  function _NAME(filename,x,y,z,q,nx,ny,nz,qbin &
#ifdef __PARALLEL
& , communicator &
#endif
&  ) result(ok)
#ifdef __PARALLEL
  __DEP_MPI
#endif
!
  __DEP_OUTPUT
  use files
  __DEP_PARSER
  __DEP_CONST
  __IMPNONE
!
  int, intent(in) :: nx, ny, nz
  float, dimension(*), intent(in) :: x,y,z,q
  real*4, dimension(nz,ny,nx) :: qt
  bool :: qbin, ok, qxuni, qyuni, qzuni
#ifdef __PARALLEL
  int4mpi, optional :: communicator
  int4mpi :: ierror, me ! , ncpu
#else
 int :: me
#endif
!
!  character(len=11), parameter :: fmt='UNFORMATTED'
  character(len=11), parameter :: fmt='BINARY'
  character(len=5*vartaglen) :: cbuffer
  __IAM(_NAME)
!
  bool :: q3d
!
  integer :: ioerr
!
  character(len=*) :: filename
  character(len=len(filename)) :: fname
  int :: flen, fid=-1, offset, i, j, k, ind
!
  ok=.false.
!
#ifdef __PARALLEL
   if (present(communicator)) then
    call mpi_comm_rank(communicator, me, ierror)
   else ;
    me = 0;
   endif
#else
   me=0
#endif
!
  fname=filename
  call adjustleft(fname)
  flen=len_trim(fname)
  if (flen.gt.0) then
   if (me.eq.0) then 
    call files_open(fid, name_=fname(1:flen), form_=fmt, action_='WRITE')
    if (fid.lt.0) then
     call warning(whoami, 'Cannot open output file. Abort.',-1)
    endif
   endif
!
   if (fatal_warning(__COMM)) return
!
  else ! flen > 0
   if (me.eq.0) call warning(whoami, 'File name not specified. Abort.',0)
   return
  endif
!
  q3d=(nz.gt.3)
!
  if (me.eq.0) then
!************** header *******
! check whether the grids are regular
   qxuni = ABS ( minval(x(2:nx)-x(1:nx-1)) - maxval(x(2:nx)-x(1:nx-1)) ) .le. __ERRTOL
   qyuni = ABS ( minval(y(2:ny)-y(1:ny-1)) - maxval(y(2:ny)-y(1:ny-1)) ) .le. __ERRTOL
   if (q3d) &
   qzuni = ABS ( minval(z(2:nz)-z(1:nz-1)) - maxval(z(2:nz)-z(1:nz-1)) ) .le. __ERRTOL

#define __WRITE(_FMT, ...)  write(cbuffer,_FMT, IOSTAT=ioerr) __VA_ARGS__ ; write(fid) trim(cbuffer),char(10)

    __WRITE('(A)', '#OpenDX datafile produced by the Dynamo program')
    __WRITE('(A,3I5)', 'object 1 class gridpositions counts', nx, ny, nz)
    __WRITE('(A,3'//float_format//')', 'origin', x(1), y(1), z(1))
    __WRITE('(A,3'//float_format//')', 'delta',  x(2)-x(1), zero, zero)
    __WRITE('(A,3'//float_format//')', 'delta',  zero, y(2)-y(1), zero)
    __WRITE('(A,3'//float_format//')', 'delta',  zero, zero, z(2)-z(1))
    __WRITE('(A,3I5)', 'object 2 class gridconnections counts', nx, ny, nz)
!    __WRITE(fid,'(A)', IOSTAT=ioerr) 'attribute "element type" string "cubes"'
!    __WRITE(fid,'(A)', IOSTAT=ioerr) 'attribute "ref" string "positions"'
! transpose array :
    ind=1;
    do k=1,nz; do j=1,ny; do i=1,nx;
!    qt(k,j,i)=q(i,j,k) :
     qt(k,j,i)=q(ind); __INC(ind)
    enddo ; enddo ; enddo ;
!
    if (qbin) then
    __WRITE('(A, I10, A)', 'object 3 class array type float rank 0 items', nx*ny*nz, ' binary data follows')
     write(fid) qt
    else
    __WRITE('(A, I10, A)', 'object 3 class array type float rank 0 items', nx*ny*nz, ' data follows')
     do i=1,nx ; do j=1,ny
      __WRITE('('//itoa(nz)//float_format//')', qt(:,j,i) )
     enddo ; enddo
    endif
    __WRITE('(A)', 'attribute "dep" string "positions"')
    __WRITE('(A)', 'object "regular positions regular connections" class field')
    __WRITE('(A)', 'component "positions" value 1')
    __WRITE('(A)', 'component "connections" value 2')
    __WRITE('(A)', 'component "data" value 3')
    __WRITE('(A)', 'end')
!
   if (ioerr.ne.0) then 
    call warning(whoami, 'Error encountered while writing file "'//fname(1:flen)//'. IO_ERR: '//itoa(ioerr),-1)
   else
!********* write scalar data *******
!    if (q3d) then 
!     if (qbin) then  ; write(fid, IOSTAT=ioerr) q(1:nx*ny*nz) ; else ; write(fid,'(5'//float_format//')', IOSTAT=ioerr) q(1:nx*ny*nz) ; endif
!    else
!     if (nz>1) then ; offset=nx*ny ; else ; offset=0 ; endif ! compatibility for writing 2D fields with ghostpoints
!     if (qbin) then ; write(fid, IOSTAT=ioerr) q(offset+1:offset+nx*ny) ; 
!               else ; write(fid,'(5'//float_format//')',IOSTAT=ioerr) q(offset+1:offset+nx*ny) ; endif
!    endif
    if (ioerr.ne.0) call warning(whoami, 'Error encountered while writing file "'//fname(1:flen)//'.',-1)
   endif ! ioerr
!
   call files_close(fid)
!
  endif ! me.eq.0
!
  if (.not.fatal_warning(__COMM)) then 
   if (qbin) then ; if (me.eq.0) call message(whoami, 'Binary scalar file "'//fname(1:flen)//'" written.')
   else          ; if (me.eq.0) call message(whoami, 'ASCII scalar file "'//fname(1:flen)//'" written.')
   endif
#ifdef __PARALLEL
! not yet clear what to do in parallel
#endif
!
   ok=.true.
  endif ! fatal_warning
!
  end function _NAME

 end module openDXio
