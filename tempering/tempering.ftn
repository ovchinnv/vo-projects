#define __CTX __TEMPERINGCTX
#define __RESTARTCTX __CONCAT(__TEMPERINGCTX,_RESTART)
#ifdef __ACEMD
#define __INITCTX TEMPERING_INIT
#define __DONECTX TEMPERING_DONE
#endif
#define _N TEMPERING

module _N

 __DEP_PARSER
 __DEP_OUTPUT
 __DEP_CONST
 __DEP_FILES
 __DEP_RANDOM
 __DEP_MPI
 use energy_grid

 __IMPNONE

 private

 public __NM(initialize)
! public __NM(done)
 public __NM(compute)

 bool, save :: tempering_initialized=.false.
!
! macro for parameter definition
#define __PAR(_PAR,_TYPE,_DEF) _TYPE, save :: _PAR ; _TYPE, parameter :: __CONCAT(default_,_PAR)=_DEF;

 __PAR(mintemp,float,298d0)
 __PAR(maxtemp,float,500d0)
 __PAR(temp,float,-one)       ! current temperature
 __PAR(timestep,float,1.0d-4) ! integration step
 __PAR(iteration,int,izero)   ! iteration
 __PAR(gridsize,int,1000)     ! size for (inverse) temperature grid (note that this is the number of temp. points ; number of bins would be gridsize-1 )
 __PAR(dgrid,float,(one/default_mintemp-one/default_mintemp)/(kboltz*(default_gridsize-1))) ! resolution for (inverse) temperature grid 
!                                                                                           ! ( note that it is easier to set the gridsize )
 __PAR(damping_average,float,one/ten) ! damping constant for computing averages (C_\gamma in Zhang & Ma)
!
 __PAR(inverse_dist, character(len=vartaglen), 'POWERLAW') ! prescribed distribution of inverse temperature
 __PAR(inverse_dist_exp, float, -one) ! coefficent in the distribution of inverse temperature
 __PAR(energy_interp_width, int, 10)  ! number of bins over which the linear fit of average energy is made
 __PAR(average_update_freq, int, 1)   ! frequency of updating average energy
 __PAR(temperature_update_freq, int, 1)   ! frequency of temperature evolution
 __PAR(output_file_freq, int, 1000)   ! frequency of writing tempering output file
!
 __PAR(restart_file, character(len=vartaglen), 'NONE') ! restart file
 __PAR(output_file, character(len=vartaglen), 'tempering.restart.txt') ! output file
!
 __PAR(random_seeds(4), int, (/ione, itwo, ithree, ifour/))
!
 int :: betadist ! temperature distribution type flag
 int, parameter :: constant=1, powerlaw=2
!
 int :: fid
!
! for storing random numbers
 int, parameter :: nrandmax = 10000 ! maximum random number array size (many number precomputed for speed)
 int :: nrand = 0 !actual size of random number array size
 int :: irand=0 ! pointer into random number array eta
 float :: eta(0:nrandmax-1)
 float, parameter :: ookb=one/kboltzmann
 float :: sqrt2dt  = sqrt(two * default_timestep) ! precomputed sqrt(2 x dt) for BD integrator
!
_DECL_MSGBUF
!
 contains
!====================================================================================
 __SUB(initialize) ()
 character(len=vartaglen) :: keyword, context
 int :: l
 __IAM(__NM(INITIALIZE))
!
#ifdef __ACEMD
#define __CONTEXT __STRING(__INITCTX)
#else
#define __CONTEXT __STRING(__CTX)
#endif
!
 context=__CONTEXT ;
! first, check for restart file
! if present, read it and skip initialization options
! read restart file
#define __CHAR
#define __VAR	restart_file
#define __TAG	restart_file
#define __NAME	restart file
#include "parser/parser_macro2.src"
#undef __CHAR
!
 if (existtag_nocase('restart_file', context)) then
  __MESSAGE(whoami,' READING RESTART FILE. COMMAND FILE TEMPERATURE AND GRID SIZE PARAMETERS ARE IGNORED. ')
! read and parse restart file
  fid=-1
  call files_open(fid, restart_file, 'FORMATTED', 'READ')
  call parse_file(fid, &
#ifdef __PARALLEL
 &  MPI_COMM_NULL, &
#endif
 &  quiet_=.false.)
  call files_close(fid)
! now comes a trick : change context name temporarily to process the restart file using the same calls
  context= __STRING(__RESTARTCTX)
 else ! only read below if no restart file provided

#undef __LEZEROERR
#define __VAR	damping_average
#define __TAG	average_damping_constant
#define __NAME	damping constant for weighted average
#include "parser/parser_macro2.src"

#define __LEZEROERR
#define __VAR	dgrid
#define __TAG	inverse_temperature_spacing
#define __NAME	resolution of inverse temperature grid
#include "parser/parser_macro2.src"

! warn if both dgrid and gridsize provided
  if (existtag_nocase('inverse_temperature_spacing', context).and.existtag_nocase('inverse_temperature_gridsize', context)) then
   __WRN(whoami, ' GRID SIZE AND GRID SPACING CANNOT BOTH BE SPECIFIED.')
  endif
!
 endif ! existtag
!
! check for random seeds
 if (existtag_nocase('random_seeds', context)) then ;
  random_seeds=INT(atofv(getval_nocase('random_seeds', context),4));
 else
  __WARN('RANDOM_INIT','SEEDS NOT SPECIFIED, USING [',default_random_seeds,']')
  random_seeds=default_random_seeds
 endif
!
#define __WARNIFMISSING
#define __VAR	iteration
#define __TAG	__VAR
#define __NAME	starting iteration
#include "parser/parser_macro2.src"

#define __MINUSERR
#define __INT
#define __VAR	average_update_freq
#define __TAG	__VAR
#define __NAME	frequency for updating averages
#include "parser/parser_macro2.src"
!
#define __VAR	temperature_update_freq
#define __TAG	__VAR
#define __NAME	frequency for updating temperature
#include "parser/parser_macro2.src"
#undef __MINUSERR
!
! temperature parameters (note that the temperature cannot be zero; otherwise beta=\infty
!
#undef __INT
#define __VAR	temp
#define __TAG	temperature
#define __NAME	starting temperature
#include "parser/parser_macro2.src"
!
#define __WARNIFMISSING
#define __VAR	mintemp
#define __TAG	minimum_temperature
#define __NAME	minimum temperature
#include "parser/parser_macro2.src"
!
#define __VAR	maxtemp
#define __TAG	maximum_temperature
#define __NAME	maximum temperature
#include "parser/parser_macro2.src"
!
#define __INT
#define __VAR	gridsize
#define __TAG	inverse_temperature_gridsize
#define __NAME	size of inverse temperature grid
#include "parser/parser_macro2.src"
! now read the average energy distribution

! ====== done with (possible) restart file data
 context=__CONTEXT ! reset context if changed
!
! read other parameters
! distribution parameters
#undef __INT
#define __CHAR
#define __VAR	inverse_dist
#define __TAG	inverse_temperature_distribution
#define __NAME	inverse temperature distribution
#include "parser/parser_macro2.src"
!
 call toupper(inverse_dist)
 select case(inverse_dist)
  case('CONSTANT', 'CONST','UNIFORM', 'UNIF') ; betadist=constant; 
  case('PLAW','POWER','POWERLAW') ; betadist=powerlaw;
  case default;
   __WRN(whoami, ' UNKNOWN DISTRIBUTION SPECIFIED ('//trim(inverse_dist)//')')
 end select
!
!
#undef __CHAR
#define __VAR	inverse_dist_exp
#define __TAG	inverse_temperature_distribution_exponent
#define __NAME	exponent for inverse temperature distribution
#include "parser/parser_macro2.src"
!
 if (betadist.eq.constant) then
  if (existtag_nocase('inverse_temperature_distribution_exponent', context)) then
   __WRN(whoami, ' FOR UNIFORM 1/T DISTRIBUTION EXPONENT IS SET TO ZERO.')
   inverse_dist_exp=zero
  endif
 endif
!
! output
#define __CHAR
#define __VAR	output_file
#define __TAG	output_file
#define __NAME	tempering output file
#include "parser/parser_macro2.src"
!
#undef __CHAR
#define __INT
#define __MINUSERR
#define __VAR	output_file_freq
#define __TAG	__VAR
#define __NAME	frequency for writing tempering output/restart file
#include "parser/parser_macro2.src"
!
 if (output_file_freq.le.zero) then
  __WRN(whoami, ' TEMPERING RESTART FILE WILL BE WRITTEN AT THE END ONLY')
  nrand=nrandmax ;
 else
  nrand=output_file_freq ! this is to ensure that the random deviates are a continuous sequence
 endif


! energy interpolation parameters
#define __VAR	energy_interp_width
#define __TAG	energy_interp_width
#define __NAME	number of bins for energy fitting
#include "parser/parser_macro2.src"
!
! timestep
!
#undef __INT
#define __VAR	timestep
#define __TAG	timestep
#define __NAME	integration step
#include "parser/parser_macro2.src"
!======================================
! call lower-level initialization

! initialize RNG
 call random_init(seeds=random_seeds)
 irand=0 ! make sure that we are pointing to the beginning of random number array
!======================================
 end __SUB(initialize)

!======================================
 __FUN(compute) (iteration,energy,temperature) result(new_temperature)
 int, intent(in) :: iteration
 float, intent(in) :: energy, temperature
 float :: new_temperature
 __IAM(__NM(COMPUTE))

! check initialization :
 if (.not. tempering_initialized) then
  __WRN(whoami, ' TEMPERING NOT INITIALIZED. NOTHING DONE')
  return
 endif
!
! check that iteration consistent

! check that temperature is consistent

! update averages
 if ( (mod(iteration, average_update_freq) .eq. ione) .or. average_update_freq.eq.ione) call energy_grid_update_averages(temperature,energy)

! compute new temperature
 if ( (mod(iteration, temperature_update_freq) .eq. ione) .or. temperature_update_freq.eq.ione) then
! compute average energy
! NOTE : the Langevin equation to solve is :
! dT/dt = ( E-Eavg )/kB - \alpha T + T sqrt[2] x \eta(t), where \alpha is the inverse temp distribution exponent ; \eta is Wiener process derivative
! the corresponding FPE is
! dp/dt = (T^2 V(T)'p)' + (T^2 p)'' ; where V(T)=V(\beta (T))=V(1/(kBT));
! we only need V(beta)' to solve the Langevin, which is E-Eavg(beta)-[ln(w(beta))]' = E-Eavg - kBT\alpha; for w(beta) ~ beta^\alpha
! to solve the Langevin we use the regular Brownian Dynamics integrator :
! T(n+1) = T(n) + [ (E - Eavg)/kB - \alpha T(n) ] + T sqrt[2dt]\eta(n) ; where \eta is a normal deviate

! determine whether we need to generate random numbers:
  if (irand.eq.0) call randomg_vector(eta, nrand) ! draw nrand normal deviates
! compute new temperature
  new_temperature = temp &
  &    + timestep*((energy - energy_grid_lookup_average_energy(temp))*ookb - inverse_dist_exp*temp ) & ! drift
  &    + temp*sqrt2dt*eta(irand)
!
! increment random number pointer
  irand=mod(irand+1,nrand)
!
  if (temp.gt.maxtemp) then
   temp = maxtemp
  elseif (temp.lt.mintemp) then
   temp = mintemp
  endif
!
  temp=new_temperature
!
 endif

 end __FUN(compute)
!======================================
 __SUB(done)
! a possible future modification is to process content in __DONECTX
!
! write restart file here
!
 call energy_grid_done()
 call parser_done()
 tempering_initialized=.false.
!
 end __SUB(done)
!======================================
end module _N

